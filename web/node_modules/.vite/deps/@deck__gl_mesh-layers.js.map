{
  "version": 3,
  "sources": ["../../@deck.gl/mesh-layers/src/utils/matrix.ts", "../../@deck.gl/mesh-layers/src/simple-mesh-layer/simple-mesh-layer-uniforms.ts", "../../@deck.gl/mesh-layers/src/simple-mesh-layer/simple-mesh-layer-vertex.glsl.ts", "../../@deck.gl/mesh-layers/src/simple-mesh-layer/simple-mesh-layer-fragment.glsl.ts", "../../@deck.gl/mesh-layers/src/simple-mesh-layer/simple-mesh-layer.ts", "../../@luma.gl/gltf/src/pbr/parse-pbr-material.ts", "../../@luma.gl/gltf/src/gltf/gltf-animator.ts", "../../@luma.gl/gltf/src/gltf/create-gltf-model.ts", "../../@luma.gl/gltf/src/gltf/gl-utils.ts", "../../@luma.gl/gltf/src/gltf/gltf-instantiator.ts", "../../@luma.gl/gltf/src/gltf/create-gltf-objects.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/gltf-utils.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/scenegraph-layer-uniforms.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/scenegraph-layer-vertex.glsl.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/scenegraph-layer-fragment.glsl.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/scenegraph-layer.ts"],
  "sourcesContent": ["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {COORDINATE_SYSTEM, createIterable} from '@deck.gl/core';\n\n/* eslint-disable max-statements, complexity, camelcase */\nconst RADIAN_PER_DEGREE = Math.PI / 180;\nconst modelMatrix = new Float32Array(16);\nconst valueArray = new Float32Array(12);\n\nfunction calculateTransformMatrix(targetMatrix, orientation, scale) {\n  const pitch = orientation[0] * RADIAN_PER_DEGREE;\n  const yaw = orientation[1] * RADIAN_PER_DEGREE;\n  const roll = orientation[2] * RADIAN_PER_DEGREE;\n\n  const sr = Math.sin(roll);\n  const sp = Math.sin(pitch);\n  const sw = Math.sin(yaw);\n\n  const cr = Math.cos(roll);\n  const cp = Math.cos(pitch);\n  const cw = Math.cos(yaw);\n\n  const scx = scale[0];\n  const scy = scale[1];\n  const scz = scale[2];\n\n  targetMatrix[0] = scx * cw * cp; // 0,0\n  targetMatrix[1] = scx * sw * cp; // 1,0\n  targetMatrix[2] = scx * -sp; // 2,0\n  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr); // 0,1\n  targetMatrix[4] = scy * (cw * cr + sw * sp * sr); // 1,1\n  targetMatrix[5] = scy * cp * sr; // 2,1\n  targetMatrix[6] = scz * (sw * sr + cw * sp * cr); // 0,2\n  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr); // 1,2\n  targetMatrix[8] = scz * cp * cr; // 2,2\n}\n\nfunction getExtendedMat3FromMat4(mat4) {\n  mat4[0] = mat4[0];\n  mat4[1] = mat4[1];\n  mat4[2] = mat4[2];\n  mat4[3] = mat4[4];\n  mat4[4] = mat4[5];\n  mat4[5] = mat4[6];\n  mat4[6] = mat4[8];\n  mat4[7] = mat4[9];\n  mat4[8] = mat4[10];\n  mat4[9] = mat4[12];\n  mat4[10] = mat4[13];\n  mat4[11] = mat4[14];\n\n  return mat4.subarray(0, 12);\n}\n\nexport const MATRIX_ATTRIBUTES = {\n  size: 12,\n  accessor: ['getOrientation', 'getScale', 'getTranslation', 'getTransformMatrix'],\n  shaderAttributes: {\n    instanceModelMatrixCol0: {\n      size: 3,\n      elementOffset: 0\n    },\n    instanceModelMatrixCol1: {\n      size: 3,\n      elementOffset: 3\n    },\n    instanceModelMatrixCol2: {\n      size: 3,\n      elementOffset: 6\n    },\n    instanceTranslation: {\n      size: 3,\n      elementOffset: 9\n    }\n  } as const,\n\n  update(attribute, {startRow, endRow}) {\n    // @ts-expect-error: \"this\" will be bound to a layer when this  function is called\n    const {data, getOrientation, getScale, getTranslation, getTransformMatrix} = this.props;\n\n    const arrayMatrix = Array.isArray(getTransformMatrix);\n    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;\n    const constantScale = Array.isArray(getScale);\n    const constantOrientation = Array.isArray(getOrientation);\n    const constantTranslation = Array.isArray(getTranslation);\n\n    const hasMatrix = constantMatrix || (!arrayMatrix && Boolean(getTransformMatrix(data[0])));\n\n    if (hasMatrix) {\n      attribute.constant = constantMatrix;\n    } else {\n      attribute.constant = constantOrientation && constantScale && constantTranslation;\n    }\n\n    const instanceModelMatrixData = attribute.value;\n\n    if (attribute.constant) {\n      let matrix;\n\n      if (hasMatrix) {\n        modelMatrix.set(getTransformMatrix);\n        matrix = getExtendedMat3FromMat4(modelMatrix);\n      } else {\n        matrix = valueArray;\n\n        const orientation = getOrientation;\n        const scale = getScale;\n\n        calculateTransformMatrix(matrix, orientation, scale);\n        matrix.set(getTranslation, 9);\n      }\n\n      attribute.value = new Float32Array(matrix);\n    } else {\n      let i = startRow * attribute.size;\n      const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n      for (const object of iterable) {\n        objectInfo.index++;\n        let matrix;\n\n        if (hasMatrix) {\n          modelMatrix.set(\n            constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo)\n          );\n          matrix = getExtendedMat3FromMat4(modelMatrix);\n        } else {\n          matrix = valueArray;\n\n          const orientation = constantOrientation\n            ? getOrientation\n            : getOrientation(object, objectInfo);\n          const scale = constantScale ? getScale : getScale(object, objectInfo);\n\n          calculateTransformMatrix(matrix, orientation, scale);\n          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);\n        }\n\n        instanceModelMatrixData[i++] = matrix[0];\n        instanceModelMatrixData[i++] = matrix[1];\n        instanceModelMatrixData[i++] = matrix[2];\n        instanceModelMatrixData[i++] = matrix[3];\n        instanceModelMatrixData[i++] = matrix[4];\n        instanceModelMatrixData[i++] = matrix[5];\n        instanceModelMatrixData[i++] = matrix[6];\n        instanceModelMatrixData[i++] = matrix[7];\n        instanceModelMatrixData[i++] = matrix[8];\n        instanceModelMatrixData[i++] = matrix[9];\n        instanceModelMatrixData[i++] = matrix[10];\n        instanceModelMatrixData[i++] = matrix[11];\n      }\n    }\n  }\n};\n\n// only apply composeModelMatrix when in cartesian or meter_offsets coordinate system\n// with `composeModelMatrix` enabled, the rotation part of the layer's modelMatrix will be composed to instance's transformations\n// since rotating latitude and longitude can not provide meaningful results, hence `composeModelMatrix` is disabled\n// when in LNGLAT and LNGLAT_OFFSET coordinates.\nexport function shouldComposeModelMatrix(viewport, coordinateSystem) {\n  return (\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ||\n    coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS ||\n    (coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial)\n  );\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Texture} from '@luma.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = `\\\nuniform simpleMeshUniforms {\n  float sizeScale;\n  bool composeModelMatrix;\n  bool hasTexture;\n  bool flatShading;\n} simpleMesh;\n`;\n\nexport type SimpleMeshProps = {\n  sizeScale?: number;\n  composeModelMatrix?: boolean;\n  hasTexture?: boolean;\n  flatShading?: boolean;\n  sampler?: Texture;\n};\n\nexport const simpleMeshUniforms = {\n  name: 'simpleMesh',\n  vs: uniformBlock,\n  fs: uniformBlock,\n  uniformTypes: {\n    sizeScale: 'f32',\n    composeModelMatrix: 'f32',\n    hasTexture: 'f32',\n    flatShading: 'f32'\n  }\n} as const satisfies ShaderModule<SimpleMeshProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\n\n// Primitive attributes\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\n\n// Instance attributes\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec3 instanceModelMatrixCol0;\nin vec3 instanceModelMatrixCol1;\nin vec3 instanceModelMatrixCol2;\nin vec3 instanceTranslation;\n\n// Outputs to fragment shader\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = instancePickingColors;\n\n  vTexCoord = texCoords;\n  cameraPosition = project.cameraPosition;\n  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);\n\n  mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);\n  vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale + instanceTranslation;\n\n  if (simpleMesh.composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    // using instancePositions as world coordinates\n    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth\n    // call project_normal before setting position to avoid rotation\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);\n    geometry.position = position_commonspace;\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);\n    geometry.position = position_commonspace;\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n  }\n\n  geometry.normal = normals_commonspace;\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform sampler2D sampler;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (simpleMesh.flatShading) {\n\n  normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;\n  DECKGL_FILTER_COLOR(color, geometry);\n\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a * layer.opacity);\n}\n`;\n", "// Note: This file will either be moved back to deck.gl or reformatted to web-monorepo standards\n// Disabling lint temporarily to facilitate copying code in and out of this repo\n/* eslint-disable */\n\n// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Layer, project32, picking, DefaultProps, log, LayerContext, Material} from '@deck.gl/core';\nimport {SamplerProps, Texture} from '@luma.gl/core';\nimport {Model, Geometry} from '@luma.gl/engine';\nimport {ParsedPBRMaterial} from '@luma.gl/gltf';\nimport {phongMaterial} from '@luma.gl/shadertools';\n\nimport {MATRIX_ATTRIBUTES, shouldComposeModelMatrix} from '../utils/matrix';\n\nimport {simpleMeshUniforms, SimpleMeshProps} from './simple-mesh-layer-uniforms';\nimport vs from './simple-mesh-layer-vertex.glsl';\nimport fs from './simple-mesh-layer-fragment.glsl';\n\nimport type {\n  LayerProps,\n  LayerDataSource,\n  UpdateParameters,\n  Accessor,\n  Position,\n  Color,\n  TextureSource\n} from '@deck.gl/core';\nimport type {MeshAttribute, MeshAttributes} from '@loaders.gl/schema';\nimport type {Geometry as GeometryType} from '@luma.gl/engine';\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\n\nfunction normalizeGeometryAttributes(attributes: MeshAttributes): MeshAttributes {\n  const positionAttribute = attributes.positions || attributes.POSITION;\n  log.assert(positionAttribute, 'no \"postions\" or \"POSITION\" attribute in mesh');\n\n  const vertexCount = positionAttribute.value.length / positionAttribute.size;\n  let colorAttribute = attributes.COLOR_0 || attributes.colors;\n  if (!colorAttribute) {\n    colorAttribute = {size: 3, value: new Float32Array(vertexCount * 3).fill(1)};\n  }\n  let normalAttribute = attributes.NORMAL || attributes.normals;\n  if (!normalAttribute) {\n    normalAttribute = {size: 3, value: new Float32Array(vertexCount * 3).fill(0)};\n  }\n  let texCoordAttribute = attributes.TEXCOORD_0 || attributes.texCoords;\n  if (!texCoordAttribute) {\n    texCoordAttribute = {size: 2, value: new Float32Array(vertexCount * 2).fill(0)};\n  }\n\n  return {\n    positions: positionAttribute,\n    colors: colorAttribute,\n    normals: normalAttribute,\n    texCoords: texCoordAttribute\n  };\n}\n\n/*\n * Convert mesh data into geometry\n * @returns {Geometry} geometry\n */\nfunction getGeometry(data: Mesh): Geometry {\n  if (data instanceof Geometry) {\n    // @ts-expect-error data.attributes is readonly\n    data.attributes = normalizeGeometryAttributes(data.attributes);\n    return data;\n  } else if ((data as any).attributes) {\n    return new Geometry({\n      ...data,\n      topology: 'triangle-list',\n      attributes: normalizeGeometryAttributes((data as any).attributes)\n    });\n  } else {\n    return new Geometry({\n      topology: 'triangle-list',\n      attributes: normalizeGeometryAttributes(data as MeshAttributes)\n    });\n  }\n}\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\ntype Mesh =\n  | GeometryType\n  | {\n      attributes: MeshAttributes;\n      indices?: MeshAttribute;\n    }\n  | MeshAttributes;\n\ntype _SimpleMeshLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  mesh: string | Mesh | Promise<Mesh> | null;\n  texture?: string | TextureSource | Promise<TextureSource>;\n  /** Customize the [texture parameters](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter). */\n  textureParameters?: SamplerProps | null;\n\n  /** Anchor position accessor. */\n  getPosition?: Accessor<DataT, Position>;\n  /** Color value or accessor.\n   * If `mesh` does not contain vertex colors, use this color to render each object.\n   * If `mesh` contains vertex colors, then the two colors are mixed together.\n   * Use `[255, 255, 255]` to use the original mesh colors.\n   * If `texture` is assigned, then both colors will be ignored.\n   * @default [0, 0, 0, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /**\n   * Orientation in [pitch, yaw, roll] in degrees.\n   * @see https://en.wikipedia.org/wiki/Euler_angles\n   * @default [0, 0, 0]\n   */\n  getOrientation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Scaling factor of the model along each axis.\n   * @default [1, 1, 1]\n   */\n  getScale?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Translation from the anchor point, [x, y, z] in meters.\n   * @default [0, 0, 0]\n   */\n  getTranslation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * TransformMatrix. If specified, `getOrientation`, `getScale` and `getTranslation` are ignored.\n   */\n  getTransformMatrix?: Accessor<DataT, number[]>;\n  /**\n   * Multiplier to scale each geometry by.\n   * @default 1\n   */\n  sizeScale?: number;\n\n  /**\n   * (Experimental) If rendering only one instance of the mesh, set this to false to treat mesh positions\n   * as deltas of the world coordinates of the anchor.\n   * E.g. in LNGLAT coordinates, mesh positions are interpreted as meter offsets by default.\n   * setting _instanced to false interpreted mesh positions as lnglat deltas.\n   * @default true\n   */\n  _instanced?: boolean; // TODO - formalize API\n  /**\n   * Whether to render the mesh in wireframe mode.\n   * @default false\n   */\n  wireframe?: boolean;\n  /**\n   * Material props for lighting effect.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting#constructing-a-material-instance\n   */\n  material?: Material;\n};\n\nexport type SimpleMeshLayerProps<DataT = unknown> = _SimpleMeshLayerProps<DataT> & LayerProps;\n\nconst defaultProps: DefaultProps<SimpleMeshLayerProps> = {\n  mesh: {type: 'object', value: null, async: true},\n  texture: {type: 'image', value: null, async: true},\n  sizeScale: {type: 'number', value: 1, min: 0},\n\n  // _instanced is a hack to use world position instead of meter offsets in mesh\n  // TODO - formalize API\n  _instanced: true,\n  // NOTE(Tarek): Quick and dirty wireframe. Just draws\n  // the same mesh with LINE_STRIPS. Won't follow edges\n  // of the original mesh.\n  wireframe: false,\n  // Optional material for 'lighting' shader module\n  material: true,\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  // [pitch, yaw, roll]\n  getOrientation: {type: 'accessor', value: [0, 0, 0]},\n  getScale: {type: 'accessor', value: [1, 1, 1]},\n  getTranslation: {type: 'accessor', value: [0, 0, 0]},\n  // 4x4 matrix\n  getTransformMatrix: {type: 'accessor', value: []},\n\n  textureParameters: {type: 'object', ignore: true, value: null}\n};\n\n/** Render a number of instances of an arbitrary 3D geometry. */\nexport default class SimpleMeshLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_SimpleMeshLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'SimpleMeshLayer';\n\n  state!: {\n    parsedPBRMaterial?: ParsedPBRMaterial;\n    model?: Model;\n    emptyTexture: Texture;\n    hasNormals?: boolean;\n    positionBounds?: [number[], number[]] | null;\n  };\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, phongMaterial, picking, simpleMeshUniforms]\n    });\n  }\n\n  getBounds(): [number[], number[]] | null {\n    if (this.props._instanced) {\n      return super.getBounds();\n    }\n    let result = this.state.positionBounds;\n    if (result) {\n      return result;\n    }\n    const {mesh} = this.props;\n    if (!mesh) {\n      return null;\n    }\n    // @ts-ignore Detect if mesh is generated by loaders.gl\n    result = mesh.header?.boundingBox;\n\n    if (!result) {\n      // Otherwise, calculate bounding box from positions\n      const {attributes} = getGeometry(mesh as Mesh);\n      attributes.POSITION = attributes.POSITION || attributes.positions;\n\n      //@ts-expect-error\n      result = getMeshBoundingBox(attributes);\n    }\n\n    this.state.positionBounds = result;\n    return result;\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    // attributeManager is always defined in a primitive layer\n    attributeManager!.addInstanced({\n      instancePositions: {\n        transition: true,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        size: 3,\n        accessor: 'getPosition'\n      },\n      instanceColors: {\n        type: 'unorm8',\n        transition: true,\n        size: this.props.colorFormat.length,\n        accessor: 'getColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n\n    this.setState({\n      // Avoid luma.gl's missing uniform warning\n      // TODO - add feature to luma.gl to specify ignored uniforms?\n      emptyTexture: this.context.device.createTexture({\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {\n      this.state.positionBounds = null;\n      this.state.model?.destroy();\n      if (props.mesh) {\n        this.state.model = this.getModel(props.mesh as Mesh);\n\n        const attributes = (props.mesh as any).attributes || props.mesh;\n        this.setState({\n          hasNormals: Boolean(attributes.NORMAL || attributes.normals)\n        });\n      }\n      // attributeManager is always defined in a primitive layer\n      this.getAttributeManager()!.invalidateAll();\n    }\n\n    if (props.texture !== oldProps.texture && props.texture instanceof Texture) {\n      this.setTexture(props.texture);\n    }\n\n    if (this.state.model) {\n      this.state.model.setTopology(this.props.wireframe ? 'line-strip' : 'triangle-list');\n    }\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n\n    this.state.emptyTexture.delete();\n  }\n\n  draw({uniforms}) {\n    const {model} = this.state;\n    if (!model) {\n      return;\n    }\n\n    const {viewport, renderPass} = this.context;\n    const {sizeScale, coordinateSystem, _instanced} = this.props;\n\n    const simpleMeshProps: SimpleMeshProps = {\n      sizeScale,\n      composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),\n      flatShading: !this.state.hasNormals\n    };\n    model.shaderInputs.setProps({simpleMesh: simpleMeshProps});\n    model.draw(renderPass);\n  }\n\n  get isLoaded(): boolean {\n    return Boolean(this.state?.model && super.isLoaded);\n  }\n\n  protected getModel(mesh: Mesh): Model {\n    const model = new Model(this.context.device, {\n      ...this.getShaders(),\n      id: this.props.id,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts(),\n      geometry: getGeometry(mesh),\n      isInstanced: true\n    });\n\n    const {texture} = this.props;\n    const {emptyTexture} = this.state;\n    const simpleMeshProps: SimpleMeshProps = {\n      sampler: (texture as Texture) || emptyTexture,\n      hasTexture: Boolean(texture)\n    };\n    model.shaderInputs.setProps({simpleMesh: simpleMeshProps});\n    return model;\n  }\n\n  private setTexture(texture: Texture): void {\n    const {emptyTexture, model} = this.state;\n\n    // props.mesh may not be ready at this time.\n    // The sampler will be set when `getModel` is called\n    if (model) {\n      const simpleMeshProps: SimpleMeshProps = {\n        sampler: texture || emptyTexture,\n        hasTexture: Boolean(texture)\n      };\n      model.shaderInputs.setProps({simpleMesh: simpleMeshProps});\n    }\n  }\n}\n", "import type {Device, Texture, Parameters} from '@luma.gl/core';\nimport {log} from '@luma.gl/core';\nimport {PBREnvironment} from './pbr-environment';\nimport {PBRMaterialBindings, PBRMaterialUniforms, PBRProjectionProps} from '@luma.gl/shadertools';\n\n/* eslint-disable camelcase */\n\nexport type ParsePBRMaterialOptions = {\n  /** Debug PBR shader */\n  pbrDebug?: boolean;\n  /** Enable lights */\n  lights?: any;\n  /** Use tangents */\n  useTangents?: boolean;\n  /** provide an image based (texture cube) lighting environment */\n  imageBasedLightingEnvironment?: PBREnvironment;\n};\n\nexport type ParsedPBRMaterial = {\n  readonly defines: Record<string, number | boolean>;\n  readonly bindings: Partial<PBRMaterialBindings>;\n  readonly uniforms: Partial<PBRProjectionProps & PBRMaterialUniforms>;\n  readonly parameters: Parameters;\n  readonly glParameters: Record<string, any>;\n  /** List of all generated textures, makes it easy to destroy them later */\n  readonly generatedTextures: Texture[];\n};\n\n// NOTE: Modules other than `@luma.gl/webgl` should not import `GL` from\n// `@luma.gl/constants`. Locally we use `GLEnum` instead of `GL` to avoid\n// conflicts with the `babel-plugin-inline-webgl-constants` plugin.\n// eslint-disable-next-line no-shadow\nenum GLEnum {\n  FUNC_ADD = 0x8006,\n  ONE = 1,\n  SRC_ALPHA = 0x0302,\n  ONE_MINUS_SRC_ALPHA = 0x0303,\n  TEXTURE_MIN_FILTER = 0x2801,\n  LINEAR = 0x2601,\n  LINEAR_MIPMAP_NEAREST = 0x2701,\n  UNPACK_FLIP_Y_WEBGL = 0x9240\n}\n\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n */\nexport function parsePBRMaterial(\n  device: Device,\n  material,\n  attributes: Record<string, any>,\n  options: ParsePBRMaterialOptions\n): ParsedPBRMaterial {\n  const parsedMaterial: ParsedPBRMaterial = {\n    defines: {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    },\n    bindings: {},\n    uniforms: {\n      // TODO: find better values?\n      camera: [0, 0, 0], // Model should override\n\n      metallicRoughnessValues: [1, 1] // Default is 1 and 1\n    },\n    parameters: {},\n    glParameters: {},\n    generatedTextures: []\n  };\n\n  // TODO - always available\n  parsedMaterial.defines.USE_TEX_LOD = 1;\n\n  const {imageBasedLightingEnvironment} = options;\n  if (imageBasedLightingEnvironment) {\n    parsedMaterial.bindings.pbr_diffuseEnvSampler =\n      imageBasedLightingEnvironment.diffuseEnvSampler.texture;\n    parsedMaterial.bindings.pbr_specularEnvSampler =\n      imageBasedLightingEnvironment.specularEnvSampler.texture;\n    parsedMaterial.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.brdfLutTexture.texture;\n    parsedMaterial.uniforms.scaleIBLAmbient = [1, 1];\n  }\n\n  if (options?.pbrDebug) {\n    parsedMaterial.defines.PBR_DEBUG = 1;\n    // Override final color for reference app visualization of various parameters in the lighting equation.\n    parsedMaterial.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];\n    parsedMaterial.uniforms.scaleFGDSpec = [0, 0, 0, 0];\n  }\n\n  if (attributes.NORMAL) parsedMaterial.defines.HAS_NORMALS = 1;\n  if (attributes.TANGENT && options?.useTangents) parsedMaterial.defines.HAS_TANGENTS = 1;\n  if (attributes.TEXCOORD_0) parsedMaterial.defines.HAS_UV = 1;\n\n  if (options?.imageBasedLightingEnvironment) parsedMaterial.defines.USE_IBL = 1;\n  if (options?.lights) parsedMaterial.defines.USE_LIGHTS = 1;\n\n  if (material) {\n    parseMaterial(device, material, parsedMaterial);\n  }\n\n  return parsedMaterial;\n}\n\n/** Parse GLTF material record */\nfunction parseMaterial(device: Device, material, parsedMaterial: ParsedPBRMaterial): void {\n  parsedMaterial.uniforms.unlit = Boolean(material.unlit);\n\n  if (material.pbrMetallicRoughness) {\n    parsePbrMetallicRoughness(device, material.pbrMetallicRoughness, parsedMaterial);\n  }\n  if (material.normalTexture) {\n    addTexture(\n      device,\n      material.normalTexture,\n      'pbr_normalSampler',\n      'HAS_NORMALMAP',\n      parsedMaterial\n    );\n\n    const {scale = 1} = material.normalTexture;\n    parsedMaterial.uniforms.normalScale = scale;\n  }\n  if (material.occlusionTexture) {\n    addTexture(\n      device,\n      material.occlusionTexture,\n      'pbr_occlusionSampler',\n      'HAS_OCCLUSIONMAP',\n      parsedMaterial\n    );\n\n    const {strength = 1} = material.occlusionTexture;\n    parsedMaterial.uniforms.occlusionStrength = strength;\n  }\n  if (material.emissiveTexture) {\n    addTexture(\n      device,\n      material.emissiveTexture,\n      'pbr_emissiveSampler',\n      'HAS_EMISSIVEMAP',\n      parsedMaterial\n    );\n    parsedMaterial.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];\n  }\n\n  switch (material.alphaMode) {\n    case 'MASK':\n      const {alphaCutoff = 0.5} = material;\n      parsedMaterial.defines.ALPHA_CUTOFF = 1;\n      parsedMaterial.uniforms.alphaCutoff = alphaCutoff;\n      break;\n    case 'BLEND':\n      log.warn('glTF BLEND alphaMode might not work well because it requires mesh sorting')();\n\n      // WebGPU style parameters\n      parsedMaterial.parameters.blendColorOperation = 'add';\n      parsedMaterial.parameters.blendColorSrcFactor = 'src-alpha';\n      parsedMaterial.parameters.blendColorDstFactor = 'one-minus-src-alpha';\n\n      parsedMaterial.parameters.blendAlphaOperation = 'add';\n      parsedMaterial.parameters.blendAlphaSrcFactor = 'one';\n      parsedMaterial.parameters.blendAlphaDstFactor = 'one-minus-src-alpha';\n\n      // GL parameters\n      parsedMaterial.glParameters.blend = true;\n      parsedMaterial.glParameters.blendEquation = GLEnum.FUNC_ADD;\n      parsedMaterial.glParameters.blendFunc = [\n        GLEnum.SRC_ALPHA,\n        GLEnum.ONE_MINUS_SRC_ALPHA,\n        GLEnum.ONE,\n        GLEnum.ONE_MINUS_SRC_ALPHA\n      ];\n\n      break;\n  }\n}\n\n/** Parse GLTF material sub record */\nfunction parsePbrMetallicRoughness(\n  device: Device,\n  pbrMetallicRoughness,\n  parsedMaterial: ParsedPBRMaterial\n): void {\n  if (pbrMetallicRoughness.baseColorTexture) {\n    addTexture(\n      device,\n      pbrMetallicRoughness.baseColorTexture,\n      'pbr_baseColorSampler',\n      'HAS_BASECOLORMAP',\n      parsedMaterial\n    );\n  }\n  parsedMaterial.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n  if (pbrMetallicRoughness.metallicRoughnessTexture) {\n    addTexture(\n      device,\n      pbrMetallicRoughness.metallicRoughnessTexture,\n      'pbr_metallicRoughnessSampler',\n      'HAS_METALROUGHNESSMAP',\n      parsedMaterial\n    );\n  }\n  const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n  parsedMaterial.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];\n}\n\n/** Create a texture from a glTF texture/sampler/image combo and add it to bindings */\nfunction addTexture(\n  device: Device,\n  gltfTexture,\n  uniformName: string,\n  define = null,\n  parsedMaterial: ParsedPBRMaterial\n): void {\n  const parameters = gltfTexture?.texture?.sampler?.parameters || {};\n\n  const image = gltfTexture.texture.source.image;\n  let textureOptions;\n  let specialTextureParameters = {};\n  if (image.compressed) {\n    textureOptions = image;\n    specialTextureParameters = {\n      [GLEnum.TEXTURE_MIN_FILTER]:\n        image.data.length > 1 ? GLEnum.LINEAR_MIPMAP_NEAREST : GLEnum.LINEAR\n    };\n  } else {\n    // Texture2D accepts a promise that returns an image as data (Async Textures)\n    textureOptions = {data: image};\n  }\n\n  const texture: Texture = device.createTexture({\n    id: gltfTexture.uniformName || gltfTexture.id,\n    parameters: {\n      ...parameters,\n      ...specialTextureParameters\n    },\n    pixelStore: {\n      [GLEnum.UNPACK_FLIP_Y_WEBGL]: false\n    },\n    ...textureOptions\n  });\n  parsedMaterial.bindings[uniformName] = texture;\n  if (define) parsedMaterial.defines[define] = 1;\n  parsedMaterial.generatedTextures.push(texture);\n}\n\n/*\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n *\nexport class PBRMaterialParser {\n  readonly device: Device;\n\n  readonly defines: Record<string, number | boolean>;\n  readonly bindings: Record<string, Binding>;\n  readonly uniforms: Record<string, any>;\n  readonly parameters: Record<string, any>;\n\n  /** Hold on to generated textures, we destroy them in the destroy method *\n  readonly generatedTextures: Texture[];\n\n  constructor(device: Device, props: PBRMaterialParserProps) {\n    const {attributes, material, pbrDebug, imageBasedLightingEnvironment, lights, useTangents} =\n      props;\n    this.device = device;\n\n    this.defines = {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n\n    if (this.device.features.has('glsl-texture-lod')) {\n      this.defines.USE_TEX_LOD = 1;\n    }\n\n    this.uniforms = {\n      // TODO: find better values?\n      camera: [0, 0, 0], // Model should override\n\n      metallicRoughnessValues: [1, 1] // Default is 1 and 1\n    };\n\n    this.bindings = {};\n\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.bindings.pbr_diffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.bindings.pbr_specularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.scaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      // Override final color for reference app visualization\n      // of various parameters in the lighting equation.\n      this.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.scaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  /**\n   * Destroy all generated resources to release memory.\n   *\n  destroy(): void {\n    this.generatedTextures.forEach(texture => texture.destroy());\n  }\n\n  /** Add a define if the the value is non-nullish *\n  defineIfPresent(value: unknown, name: string): void {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n\n  /** Parse GLTF material record *\n  parseMaterial(material) {\n    this.uniforms.unlit = Boolean(material.unlit);\n\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n    if (material.normalTexture) {\n      this.addTexture(material.normalTexture, 'pbr_normalSampler', 'HAS_NORMALMAP');\n\n      const {scale = 1} = material.normalTexture;\n      this.uniforms.normalScale = scale;\n    }\n    if (material.occlusionTexture) {\n      this.addTexture(material.occlusionTexture, 'pbr_occlusionSampler', 'HAS_OCCLUSIONMAP');\n\n      const {strength = 1} = material.occlusionTexture;\n      this.uniforms.occlusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n      this.addTexture(material.emissiveTexture, 'pbr_emissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    if (material.alphaMode === 'MASK') {\n      const {alphaCutoff = 0.5} = material;\n      this.defines.ALPHA_CUTOFF = 1;\n      this.uniforms.alphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: GL.FUNC_ADD,\n        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA]\n      });\n    }\n  }\n\n  /** Parse GLTF material sub record *\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.baseColorTexture,\n        'pbr_baseColorSampler',\n        'HAS_BASECOLORMAP'\n      );\n    }\n    this.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.metallicRoughnessTexture,\n        'pbr_metallicRoughnessSampler',\n        'HAS_METALROUGHNESSMAP'\n      );\n    }\n    const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n    this.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n\n  /** Create a texture from a glTF texture/sampler/image combo and add it to bindings *\n  addTexture(gltfTexture, name, define = null) {\n    const parameters = gltfTexture?.texture?.sampler?.parameters || {};\n\n    const image = gltfTexture.texture.source.image;\n    let textureOptions;\n    let specialTextureParameters = {};\n    if (image.compressed) {\n      textureOptions = image;\n      specialTextureParameters = {\n        [GL.TEXTURE_MIN_FILTER]: image.data.length > 1 ? GL.LINEAR_MIPMAP_NEAREST : GL.LINEAR\n      };\n    } else {\n      // Texture2D accepts a promise that returns an image as data (Async Textures)\n      textureOptions = {data: image};\n    }\n\n    const texture: Texture = this.device.createTexture({\n      id: gltfTexture.name || gltfTexture.id,\n      parameters: {\n        ...parameters,\n        ...specialTextureParameters\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      ...textureOptions\n    });\n    this.bindings[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n}\n*/\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log} from '@luma.gl/core';\nimport {Matrix4, Quaternion} from '@math.gl/core';\n\n// TODO: import from loaders.gl?\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\ntype GLTFAnimationProps = {\n  name: string;\n  startTime?: number;\n  playing?: boolean;\n  speed?: number;\n  channels?: any;\n};\n\nclass GLTFAnimation {\n  name: string;\n  startTime: number = 0;\n  playing: boolean = true;\n  speed: number = 1;\n  channels: any = [];\n\n  constructor(props: GLTFAnimationProps) {\n    Object.assign(this, props);\n  }\n\n  animate(timeMs: number) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n\n    this.channels.forEach(({sampler, target, path}) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n}\n\nexport class GLTFAnimator {\n  animations: GLTFAnimation[];\n\n  constructor(gltf: any) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(({input, interpolation = 'LINEAR', output}) => ({\n        input: accessorToJsArray(gltf.accessors[input]),\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      }));\n      const channels = animation.channels.map(({sampler, target}) => ({\n        sampler: samplers[sampler],\n        target: gltf.nodes[target.node],\n        path: target.path\n      }));\n      return new GLTFAnimation({name, channels});\n    });\n  }\n\n  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */\n  animate(time: number): void {\n    this.setTime(time);\n  }\n\n  setTime(time: number): void {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n}\n\n//\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {buffer, byteOffset} = accessor.bufferView.data;\n\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\n// TODO: share with GLTFInstantiator\nconst helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nconst quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    quaternion.slerp({start, target: stop, ratio});\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio: t}) {\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] =\n      (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] +\n      (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 +\n      (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] +\n      (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, {input, interpolation, output}, target, path) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  // assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n\n        cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio});\n      }\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, RenderPipelineParameters, log} from '@luma.gl/core';\nimport {pbrMaterial, ShaderModule} from '@luma.gl/shadertools';\nimport {Geometry, Model, ModelNode, ModelProps} from '@luma.gl/engine';\nimport {ParsePBRMaterialOptions, parsePBRMaterial} from '../pbr/parse-pbr-material';\n\nconst SHADER = /* WGSL */ `\nlayout(0) positions: vec4; // in vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    in vec4 normals; // in vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n@vertex\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * positions;\n  }\n\n@fragment\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n`;\n\n// TODO rename attributes to POSITION/NORMAL etc\n// See gpu-geometry.ts: getAttributeBuffersFromGeometry()\nconst vs = /* glsl */ `\\\n#version 300 es\n\n  // in vec4 POSITION;\n  in vec4 positions;\n\n  #ifdef HAS_NORMALS\n    // in vec4 NORMAL;\n    in vec4 normals;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;\n  }\n`;\n\nconst fs = /* glsl */ `\\\n#version 300 es\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n`;\n\nexport type CreateGLTFModelOptions = {\n  id?: string;\n  vertexCount?: number;\n  geometry: Geometry;\n  material: any;\n  materialOptions: ParsePBRMaterialOptions;\n  modelOptions?: Partial<ModelProps>;\n};\n\nexport function createGLTFModel(device: Device, options: CreateGLTFModelOptions): ModelNode {\n  const {id, geometry, material, vertexCount, materialOptions, modelOptions} = options;\n\n  const parsedMaterial = parsePBRMaterial(device, material, geometry.attributes, materialOptions);\n  log.info(4, 'createGLTFModel defines: ', parsedMaterial.defines)();\n\n  // Calculate managedResources\n  // TODO: Implement resource management logic that will\n  // not deallocate resources/textures/buffers that are shared\n  const managedResources = [];\n  // managedResources.push(...parsedMaterial.generatedTextures);\n  // managedResources.push(...Object.values(attributes).map((attribute) => attribute.buffer));\n\n  const parameters: RenderPipelineParameters = {\n    depthWriteEnabled: true,\n    depthCompare: 'less',\n    depthFormat: 'depth24plus',\n    cullMode: 'back'\n  };\n\n  const modelProps: ModelProps = {\n    id,\n    source: SHADER,\n    vs,\n    fs,\n    geometry,\n    topology: geometry.topology,\n    vertexCount,\n    modules: [pbrMaterial as unknown as ShaderModule],\n    ...modelOptions,\n\n    defines: {...parsedMaterial.defines, ...modelOptions.defines},\n    parameters: {...parameters, ...parsedMaterial.parameters, ...modelOptions.parameters}\n  };\n\n  const model = new Model(device, modelProps);\n\n  const {camera, ...pbrMaterialProps} = {\n    ...parsedMaterial.uniforms,\n    ...modelOptions.uniforms,\n    ...parsedMaterial.bindings,\n    ...modelOptions.bindings\n  };\n\n  model.shaderInputs.setProps({pbrMaterial: pbrMaterialProps, pbrProjection: {camera}});\n  return new ModelNode({managedResources, model});\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {PrimitiveTopology} from '@luma.gl/core';\n\n// NOTE: Modules other than `@luma.gl/webgl` should not import `GL` from\n// `@luma.gl/constants`. Locally we use `GLEnum` instead of `GL` to avoid\n// conflicts with the `babel-plugin-inline-webgl-constants` plugin.\n// eslint-disable-next-line no-shadow\nexport enum GLEnum {\n  POINTS = 0x0,\n  LINES = 0x1,\n  LINE_LOOP = 0x2,\n  LINE_STRIP = 0x3,\n  TRIANGLES = 0x4,\n  TRIANGLE_STRIP = 0x5,\n  TRIANGLE_FAN = 0x6\n}\n\nexport function convertGLDrawModeToTopology(\n  drawMode:\n    | GLEnum.POINTS\n    | GLEnum.LINES\n    | GLEnum.LINE_STRIP\n    | GLEnum.LINE_LOOP\n    | GLEnum.TRIANGLES\n    | GLEnum.TRIANGLE_STRIP\n    | GLEnum.TRIANGLE_FAN\n): PrimitiveTopology {\n  // prettier-ignore\n  switch (drawMode) {\n    case GLEnum.POINTS: return 'point-list';\n    case GLEnum.LINES: return 'line-list';\n    case GLEnum.LINE_STRIP: return 'line-strip';\n    case GLEnum.TRIANGLES: return 'triangle-list';\n    case GLEnum.TRIANGLE_STRIP: return 'triangle-strip';\n    default: throw new Error(String(drawMode));\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Buffer, PrimitiveTopology} from '@luma.gl/core';\nimport {Geometry, GeometryAttribute, GroupNode, ModelNode, ModelProps} from '@luma.gl/engine';\nimport {Matrix4} from '@math.gl/core';\n\nimport {GLTFAnimator} from './gltf-animator';\nimport {createGLTFModel} from './create-gltf-model';\nimport type {PBREnvironment} from '../pbr/pbr-environment';\nimport {convertGLDrawModeToTopology} from './gl-utils';\n\nexport type GLTFInstantiatorOptions = {\n  modelOptions?: Partial<ModelProps>;\n  pbrDebug?: boolean;\n  imageBasedLightingEnvironment?: PBREnvironment;\n  lights?: boolean;\n  useTangents?: boolean;\n};\n\nconst DEFAULT_OPTIONS: GLTFInstantiatorOptions = {\n  modelOptions: {},\n  pbrDebug: false,\n  imageBasedLightingEnvironment: null,\n  lights: true,\n  useTangents: false\n};\n\n/**\n * GLTF instantiator for luma.gl\n * Walks the parsed and resolved glTF structure and builds a luma.gl scenegraph\n */\nexport class GLTFInstantiator {\n  device: Device;\n  options: GLTFInstantiatorOptions;\n  gltf: any;\n\n  constructor(device: Device, options: GLTFInstantiatorOptions = {}) {\n    this.device = device;\n    this.options = {...DEFAULT_OPTIONS, ...options};\n  }\n\n  instantiate(gltf: any): GroupNode[] {\n    this.gltf = deepCopy(gltf);\n    const scenes = (this.gltf.scenes || []).map(scene => this.createScene(scene));\n    return scenes;\n  }\n\n  createAnimator(): GLTFAnimator {\n    if (Array.isArray(this.gltf.animations)) {\n      return new GLTFAnimator(this.gltf);\n    }\n\n    return null;\n  }\n\n  createScene(gltfScene: any): GroupNode {\n    const gltfNodes = gltfScene.nodes || [];\n    const nodes = gltfNodes.map(node => this.createNode(node));\n    const scene = new GroupNode({\n      id: gltfScene.name || gltfScene.id,\n      children: nodes\n    });\n    return scene;\n  }\n\n  createNode(gltfNode) {\n    if (!gltfNode._node) {\n      const gltfChildren = gltfNode.children || [];\n      const children = gltfChildren.map(child => this.createNode(child));\n\n      // Node can have children nodes and meshes at the same time\n      if (gltfNode.mesh) {\n        children.push(this.createMesh(gltfNode.mesh));\n      }\n\n      const node = new GroupNode({\n        id: gltfNode.name || gltfNode.id,\n        children\n      });\n\n      if (gltfNode.matrix) {\n        node.setMatrix(gltfNode.matrix);\n      } else {\n        node.matrix.identity();\n\n        if (gltfNode.translation) {\n          node.matrix.translate(gltfNode.translation);\n        }\n\n        if (gltfNode.rotation) {\n          const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);\n          node.matrix.multiplyRight(rotationMatrix);\n        }\n\n        if (gltfNode.scale) {\n          node.matrix.scale(gltfNode.scale);\n        }\n      }\n      gltfNode._node = node;\n    }\n\n    // Copy _node so that gltf-animator can access\n    const topLevelNode = this.gltf.nodes.find(node => node.id === gltfNode.id);\n    topLevelNode._node = gltfNode._node;\n\n    return gltfNode._node;\n  }\n\n  createMesh(gltfMesh): GroupNode {\n    // TODO: avoid changing the gltf\n    if (!gltfMesh._mesh) {\n      const gltfPrimitives = gltfMesh.primitives || [];\n      const primitives = gltfPrimitives.map((gltfPrimitive, i) =>\n        this.createPrimitive(gltfPrimitive, i, gltfMesh)\n      );\n      const mesh = new GroupNode({\n        id: gltfMesh.name || gltfMesh.id,\n        children: primitives\n      });\n      gltfMesh._mesh = mesh;\n    }\n\n    return gltfMesh._mesh;\n  }\n\n  createPrimitive(gltfPrimitive: any, i: number, gltfMesh): ModelNode {\n    const id = gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i}`;\n    const topology = convertGLDrawModeToTopology(gltfPrimitive.mode || 4);\n    const vertexCount = gltfPrimitive.indices\n      ? gltfPrimitive.indices.count\n      : this.getVertexCount(gltfPrimitive.attributes);\n\n    const modelNode = createGLTFModel(this.device, {\n      id,\n      geometry: this.createGeometry(id, gltfPrimitive, topology),\n      material: gltfPrimitive.material,\n      materialOptions: this.options,\n      modelOptions: this.options.modelOptions,\n      vertexCount\n    });\n\n    modelNode.bounds = [\n      gltfPrimitive.attributes.POSITION.min,\n      gltfPrimitive.attributes.POSITION.max\n    ];\n    // TODO this holds on to all the CPU side texture and attribute data\n    // modelNode.material =  gltfPrimitive.material;\n\n    return modelNode;\n  }\n\n  getVertexCount(attributes: any) {\n    throw new Error('getVertexCount not implemented');\n  }\n\n  createGeometry(id: string, gltfPrimitive: any, topology: PrimitiveTopology): Geometry {\n    const attributes = {};\n    for (const [attributeName, attribute] of Object.entries(gltfPrimitive.attributes)) {\n      const {components, size, value} = attribute as GeometryAttribute;\n\n      attributes[attributeName] = {size: size ?? components, value};\n    }\n\n    return new Geometry({\n      id,\n      topology,\n      indices: gltfPrimitive.indices.value,\n      attributes\n    });\n  }\n\n  createBuffer(attribute, usage: number): Buffer {\n    if (!attribute.bufferView) {\n      // Draco decoded files do not have a bufferView\n      attribute.bufferView = {};\n    }\n\n    const {bufferView} = attribute;\n    if (!bufferView.lumaBuffers) {\n      bufferView.lumaBuffers = {};\n    }\n\n    if (!bufferView.lumaBuffers[usage]) {\n      bufferView.lumaBuffers[usage] = this.device.createBuffer({\n        id: `from-${bufferView.id}`,\n        // Draco decoded files have attribute.value\n        data: bufferView.data || attribute.value\n      });\n    }\n\n    return bufferView.lumaBuffers[usage];\n  }\n\n  // TODO - create sampler in WebGL2\n  createSampler(gltfSampler) {\n    return gltfSampler;\n  }\n\n  // Helper methods (move to GLTFLoader.resolve...?)\n\n  needsPOT(): boolean {\n    // Has a wrapping mode (either wrapS or wrapT) equal to REPEAT or MIRRORED_REPEAT, or\n    // Has a minification filter (minFilter) that uses mipmapping\n    // (NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR,\n    // LINEAR_MIPMAP_NEAREST, or LINEAR_MIPMAP_LINEAR).\n    return false;\n  }\n}\n\n/** Deeply copies a JS data structure */\nfunction deepCopy(object: any): any {\n  // don't copy binary data\n  if (\n    ArrayBuffer.isView(object) ||\n    object instanceof ArrayBuffer ||\n    object instanceof ImageBitmap\n  ) {\n    return object;\n  }\n  if (Array.isArray(object)) {\n    return object.map(deepCopy);\n  }\n  if (object && typeof object === 'object') {\n    const result = {};\n    for (const key in object) {\n      result[key] = deepCopy(object[key]);\n    }\n    return result;\n  }\n  return object;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device} from '@luma.gl/core';\nimport {GroupNode} from '@luma.gl/engine';\nimport {GLTFInstantiator, GLTFInstantiatorOptions} from './gltf-instantiator';\nimport {GLTFAnimator} from './gltf-animator';\n\nexport function createScenegraphsFromGLTF(\n  device: Device,\n  gltf: any,\n  options?: GLTFInstantiatorOptions\n): {\n  scenes: GroupNode[];\n  animator: GLTFAnimator;\n} {\n  const instantiator = new GLTFInstantiator(device, options);\n  const scenes = instantiator.instantiate(gltf);\n  const animator = instantiator.createAnimator();\n  return {scenes, animator};\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* global requestAnimationFrame */\nimport type {GroupNode, ScenegraphNode, ModelNode} from '@luma.gl/engine';\n\nexport async function waitForGLTFAssets(gltfObjects: {scenes: GroupNode[]}): Promise<void> {\n  const remaining: any[] = [];\n\n  gltfObjects.scenes.forEach(scene => {\n    scene.traverse((modelNode: ScenegraphNode) => {\n      // TODO v9 getUnforms() was removed, hack it with props.uniforms\n      Object.values((modelNode as ModelNode).model.uniforms).forEach((uniform: any) => {\n        if (uniform.loaded === false) {\n          remaining.push(uniform);\n        }\n      });\n    });\n  });\n\n  return await waitWhileCondition(() => remaining.some(uniform => !uniform.loaded));\n}\n\nasync function waitWhileCondition(condition: () => boolean): Promise<void> {\n  while (condition()) {\n    await new Promise(resolve => requestAnimationFrame(resolve));\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Matrix4} from '@math.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = `\\\nuniform scenegraphUniforms {\n  float sizeScale;\n  float sizeMinPixels;\n  float sizeMaxPixels;\n  mat4 sceneModelMatrix;\n  bool composeModelMatrix;\n} scenegraph;\n`;\n\nexport type ScenegraphProps = {\n  sizeScale: number;\n  sizeMinPixels: number;\n  sizeMaxPixels: number;\n  sceneModelMatrix: Matrix4;\n  composeModelMatrix: boolean;\n};\n\nexport const scenegraphUniforms = {\n  name: 'scenegraph',\n  vs: uniformBlock,\n  fs: uniformBlock,\n  uniformTypes: {\n    sizeScale: 'f32',\n    sizeMinPixels: 'f32',\n    sizeMaxPixels: 'f32',\n    sceneModelMatrix: 'mat4x4<f32>',\n    composeModelMatrix: 'f32'\n  }\n} as const satisfies ShaderModule<ScenegraphProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n#version 300 es\n\n#define SHADER_NAME scenegraph-layer-vertex-shader\n\n// Instance attributes\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec3 instanceModelMatrixCol0;\nin vec3 instanceModelMatrixCol1;\nin vec3 instanceModelMatrixCol2;\nin vec3 instanceTranslation;\n\n// Primitive attributes\nin vec3 positions;\n#ifdef HAS_UV\n  in vec2 texCoords;\n#endif\n#ifdef LIGHTING_PBR\n  #ifdef HAS_NORMALS\n    in vec3 normals;\n  #endif\n#endif\n\n// Varying\nout vec4 vColor;\n\n// pbrMaterial contains all the varying definitions needed\n#ifndef LIGHTING_PBR\n  #ifdef HAS_UV\n    out vec2 vTEXCOORD_0;\n  #endif\n#endif\n\n// Main\nvoid main(void) {\n  #if defined(HAS_UV) && !defined(LIGHTING_PBR)\n    vTEXCOORD_0 = texCoords;\n    geometry.uv = texCoords;\n  #endif\n\n  geometry.worldPosition = instancePositions;\n  geometry.pickingColor = instancePickingColors;\n\n  mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);\n\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n  #ifdef LIGHTING_PBR\n    #ifdef HAS_NORMALS\n      normal = instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(normals, 0.0)).xyz;\n    #endif\n  #endif\n\n  float originalSize = project_size_to_pixel(scenegraph.sizeScale);\n  float clampedSize = clamp(originalSize, scenegraph.sizeMinPixels, scenegraph.sizeMaxPixels);\n\n  vec3 pos = (instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(positions, 1.0)).xyz) * scenegraph.sizeScale * (clampedSize / originalSize) + instanceTranslation;\n  if(scenegraph.composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    // using instancePositions as world coordinates\n    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth\n    // call project_normal before setting position to avoid rotation\n    geometry.normal = project_normal(normal);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);\n    geometry.normal = project_normal(normal);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef LIGHTING_PBR\n    // set PBR data\n    pbr_vPosition = geometry.position.xyz;\n    #ifdef HAS_NORMALS\n      pbr_vNormal = geometry.normal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = texCoords;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif\n    geometry.uv = pbr_vUV;\n  #endif\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n#version 300 es\n\n#define SHADER_NAME scenegraph-layer-fragment-shader\n\n// Varying\nin vec4 vColor;\n\nout vec4 fragColor;\n\n// pbrMaterial contains all the varying definitions needed\n#ifndef LIGHTING_PBR\n  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n    in vec2 vTEXCOORD_0;\n    uniform sampler2D pbr_baseColorSampler;\n  #endif\n#endif\n\nvoid main(void) {\n  #ifdef LIGHTING_PBR\n    fragColor = vColor * pbr_filterColor(vec4(0));\n    geometry.uv = pbr_vUV;\n  #else\n    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n      fragColor = vColor * texture(pbr_baseColorSampler, vTEXCOORD_0);\n      geometry.uv = vTEXCOORD_0;\n    #else\n      fragColor = vColor;\n    #endif\n  #endif\n\n  fragColor.a *= layer.opacity;\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Layer, project32, picking, log} from '@deck.gl/core';\nimport type {Device} from '@luma.gl/core';\nimport {pbrMaterial} from '@luma.gl/shadertools';\nimport {ScenegraphNode, GroupNode, ModelNode, Model} from '@luma.gl/engine';\nimport {GLTFAnimator, PBREnvironment, createScenegraphsFromGLTF} from '@luma.gl/gltf';\nimport {GLTFLoader, postProcessGLTF} from '@loaders.gl/gltf';\nimport {waitForGLTFAssets} from './gltf-utils';\n\nimport {MATRIX_ATTRIBUTES, shouldComposeModelMatrix} from '../utils/matrix';\n\nimport {scenegraphUniforms, ScenegraphProps} from './scenegraph-layer-uniforms';\nimport vs from './scenegraph-layer-vertex.glsl';\nimport fs from './scenegraph-layer-fragment.glsl';\n\nimport {\n  UpdateParameters,\n  LayerContext,\n  LayerProps,\n  LayerDataSource,\n  Position,\n  Color,\n  Accessor,\n  DefaultProps\n} from '@deck.gl/core';\n\ntype GLTFInstantiatorOptions = Parameters<typeof createScenegraphsFromGLTF>[2];\n\nconst DEFAULT_COLOR: [number, number, number, number] = [255, 255, 255, 255];\n\nexport type ScenegraphLayerProps<DataT = unknown> = _ScenegraphLayerProps<DataT> & LayerProps;\n\ntype _ScenegraphLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  // TODO - define in luma.gl\n  /**\n   * A url for a glTF model or scenegraph loaded via a [scenegraph loader](https://loaders.gl/docs/specifications/category-scenegraph)\n   */\n  scenegraph: any;\n  /**\n   * Create a luma.gl GroupNode from the resolved scenegraph prop\n   */\n  getScene?: (\n    scenegraph: any,\n    context: {device?: Device; layer: ScenegraphLayer<DataT>}\n  ) => GroupNode;\n  /**\n   * Create a luma.gl GLTFAnimator from the resolved scenegraph prop\n   */\n  getAnimator?: (\n    scenegraph: any,\n    context: {device?: Device; layer: ScenegraphLayer<DataT>}\n  ) => GLTFAnimator;\n  /**\n   * (Experimental) animation configurations. Requires `_animate` on deck object.\n   */\n  _animations?: {\n    [name: number | string | '*']: {\n      /** If the animation is playing */\n      playing?: boolean;\n      /** Start time of the animation, default `0` */\n      startTime?: number;\n      /** Speed multiplier of the animation, default `1` */\n      speed?: number;\n    };\n  } | null;\n  /**\n   * (Experimental) lighting mode\n   * @default 'flat'\n   */\n  _lighting?: 'flat' | 'pbr';\n  /**\n   * (Experimental) lighting environment. Requires `_lighting` to be `'pbr'`.\n   */\n  _imageBasedLightingEnvironment?:\n    | PBREnvironment\n    | ((context: {gl: WebGL2RenderingContext; layer: ScenegraphLayer<DataT>}) => PBREnvironment);\n\n  /** Anchor position accessor. */\n  getPosition?: Accessor<DataT, Position>;\n  /** Color value or accessor.\n   * @default [255, 255, 255, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /**\n   * Orientation in [pitch, yaw, roll] in degrees.\n   * @see https://en.wikipedia.org/wiki/Euler_angles\n   * @default [0, 0, 0]\n   */\n  getOrientation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Scaling factor of the model along each axis.\n   * @default [1, 1, 1]\n   */\n  getScale?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Translation from the anchor point, [x, y, z] in meters.\n   * @default [0, 0, 0]\n   */\n  getTranslation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * TransformMatrix. If specified, `getOrientation`, `getScale` and `getTranslation` are ignored.\n   */\n  getTransformMatrix?: Accessor<DataT, number[]>;\n  /**\n   * Multiplier to scale each geometry by.\n   * @default 1\n   */\n  sizeScale?: number;\n  /**\n   * The minimum size in pixels for one unit of the scene.\n   * @default 0\n   */\n  sizeMinPixels?: number;\n  /**\n   * The maximum size in pixels for one unit of the scene.\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  sizeMaxPixels?: number;\n};\n\nconst defaultProps: DefaultProps<ScenegraphLayerProps> = {\n  scenegraph: {type: 'object', value: null, async: true},\n  getScene: gltf => {\n    if (gltf && gltf.scenes) {\n      // gltf post processor replaces `gltf.scene` number with the scene `object`\n      return typeof gltf.scene === 'object' ? gltf.scene : gltf.scenes[gltf.scene || 0];\n    }\n    return gltf;\n  },\n  getAnimator: scenegraph => scenegraph && scenegraph.animator,\n  _animations: null,\n\n  sizeScale: {type: 'number', value: 1, min: 0},\n  sizeMinPixels: {type: 'number', min: 0, value: 0},\n  sizeMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER},\n\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  // flat or pbr\n  _lighting: 'flat',\n  // _lighting must be pbr for this to work\n  _imageBasedLightingEnvironment: undefined,\n\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  // [pitch, yaw, roll]\n  getOrientation: {type: 'accessor', value: [0, 0, 0]},\n  getScale: {type: 'accessor', value: [1, 1, 1]},\n  getTranslation: {type: 'accessor', value: [0, 0, 0]},\n  // 4x4 matrix\n  getTransformMatrix: {type: 'accessor', value: []},\n\n  loaders: [GLTFLoader]\n};\n\n/** Render a number of instances of a complete glTF scenegraph. */\nexport default class ScenegraphLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_ScenegraphLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'ScenegraphLayer';\n\n  state!: {\n    scenegraph: GroupNode;\n    animator: GLTFAnimator;\n    models: Model[];\n  };\n\n  getShaders() {\n    const defines: {LIGHTING_PBR?: 1} = {};\n    let pbr;\n\n    if (this.props._lighting === 'pbr') {\n      pbr = pbrMaterial;\n      defines.LIGHTING_PBR = 1;\n    } else {\n      // Dummy shader module needed to handle\n      // pbrMaterial.pbr_baseColorSampler binding\n      pbr = {name: 'pbrMaterial'};\n    }\n\n    const modules = [project32, picking, scenegraphUniforms, pbr];\n    return super.getShaders({defines, vs, fs, modules});\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    // attributeManager is always defined for primitive layers\n    attributeManager!.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        accessor: 'getPosition',\n        transition: true\n      },\n      instanceColors: {\n        type: 'unorm8',\n        size: this.props.colorFormat.length,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR,\n        transition: true\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n    const {props, oldProps} = params;\n\n    if (props.scenegraph !== oldProps.scenegraph) {\n      this._updateScenegraph();\n    } else if (props._animations !== oldProps._animations) {\n      this._applyAnimationsProp(this.state.animator, props._animations);\n    }\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n    this.state.scenegraph?.destroy();\n  }\n\n  get isLoaded(): boolean {\n    return Boolean(this.state?.scenegraph && super.isLoaded);\n  }\n\n  private _updateScenegraph(): void {\n    const props = this.props;\n    const {device} = this.context;\n    let scenegraphData: any = null;\n    if (props.scenegraph instanceof ScenegraphNode) {\n      // Signature 1: props.scenegraph is a proper luma.gl Scenegraph\n      scenegraphData = {scenes: [props.scenegraph]};\n    } else if (props.scenegraph && typeof props.scenegraph === 'object') {\n      // Converts loaders.gl gltf to luma.gl scenegraph using the undocumented @luma.gl/experimental function\n      const gltf = props.scenegraph;\n\n      // Tiles3DLoader already processes GLTF\n      const processedGLTF = gltf.json ? postProcessGLTF(gltf) : gltf;\n\n      const gltfObjects = createScenegraphsFromGLTF(device, processedGLTF, this._getModelOptions());\n      scenegraphData = {gltf: processedGLTF, ...gltfObjects};\n\n      waitForGLTFAssets(gltfObjects)\n        .then(() => {\n          this.setNeedsRedraw();\n        })\n        .catch(ex => {\n          this.raiseError(ex, 'loading glTF');\n        });\n    }\n\n    const options = {layer: this, device: this.context.device};\n    const scenegraph = props.getScene(scenegraphData, options);\n    const animator = props.getAnimator(scenegraphData, options);\n\n    if (scenegraph instanceof GroupNode) {\n      this.state.scenegraph?.destroy();\n\n      this._applyAnimationsProp(animator, props._animations);\n\n      const models: Model[] = [];\n      scenegraph.traverse(node => {\n        if (node instanceof ModelNode) {\n          models.push(node.model);\n        }\n      });\n\n      this.setState({scenegraph, animator, models});\n      this.getAttributeManager()!.invalidateAll();\n    } else if (scenegraph !== null) {\n      log.warn('invalid scenegraph:', scenegraph)();\n    }\n  }\n\n  private _applyAnimationsProp(animator: GLTFAnimator, animationsProp: any): void {\n    if (!animator || !animationsProp) {\n      return;\n    }\n\n    const animations = animator.getAnimations();\n\n    // sort() to ensure '*' comes first so that other values can override\n    Object.keys(animationsProp)\n      .sort()\n      .forEach(key => {\n        // Key can be:\n        //  - number for index number\n        //  - name for animation name\n        //  - * to affect all animations\n        const value = animationsProp[key];\n\n        if (key === '*') {\n          animations.forEach(animation => {\n            Object.assign(animation, value);\n          });\n        } else if (Number.isFinite(Number(key))) {\n          const number = Number(key);\n          if (number >= 0 && number < animations.length) {\n            Object.assign(animations[number], value);\n          } else {\n            log.warn(`animation ${key} not found`)();\n          }\n        } else {\n          const findResult = animations.find(({name}) => name === key);\n          if (findResult) {\n            Object.assign(findResult, value);\n          } else {\n            log.warn(`animation ${key} not found`)();\n          }\n        }\n      });\n  }\n\n  private _getModelOptions(): GLTFInstantiatorOptions {\n    const {_imageBasedLightingEnvironment} = this.props;\n\n    let env: PBREnvironment | undefined;\n    if (_imageBasedLightingEnvironment) {\n      if (typeof _imageBasedLightingEnvironment === 'function') {\n        env = _imageBasedLightingEnvironment({gl: this.context.gl, layer: this});\n      } else {\n        env = _imageBasedLightingEnvironment;\n      }\n    }\n\n    return {\n      imageBasedLightingEnvironment: env,\n      modelOptions: {\n        id: this.props.id,\n        isInstanced: true,\n        bufferLayout: this.getAttributeManager()!.getBufferLayouts(),\n        ...this.getShaders()\n      },\n      // tangents are not supported\n      useTangents: false\n    };\n  }\n\n  draw({context}) {\n    if (!this.state.scenegraph) return;\n\n    if (this.props._animations && this.state.animator) {\n      this.state.animator.animate(context.timeline.getTime());\n      this.setNeedsRedraw();\n    }\n\n    const {viewport, renderPass} = this.context;\n    const {sizeScale, sizeMinPixels, sizeMaxPixels, coordinateSystem} = this.props;\n\n    const numInstances = this.getNumInstances();\n    this.state.scenegraph.traverse((node, {worldMatrix}) => {\n      if (node instanceof ModelNode) {\n        const {model} = node;\n        model.setInstanceCount(numInstances);\n\n        const pbrProjectionProps = {\n          // Needed for PBR (TODO: find better way to get it)\n          camera: model.uniforms.cameraPosition as [number, number, number]\n        };\n        const scenegraphProps: ScenegraphProps = {\n          sizeScale,\n          sizeMinPixels,\n          sizeMaxPixels,\n          composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),\n          sceneModelMatrix: worldMatrix\n        };\n\n        model.shaderInputs.setProps({\n          pbrProjection: pbrProjectionProps,\n          scenegraph: scenegraphProps\n        });\n        model.draw(renderPass);\n      }\n    });\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA,IAAM,oBAAoB,KAAK,KAAK;AACpC,IAAM,cAAc,IAAI,aAAa,EAAE;AACvC,IAAM,aAAa,IAAI,aAAa,EAAE;AAEtC,SAAS,yBAAyB,cAAc,aAAa,OAAK;AAChE,QAAM,QAAQ,YAAY,CAAC,IAAI;AAC/B,QAAM,MAAM,YAAY,CAAC,IAAI;AAC7B,QAAM,OAAO,YAAY,CAAC,IAAI;AAE9B,QAAM,KAAK,KAAK,IAAI,IAAI;AACxB,QAAM,KAAK,KAAK,IAAI,KAAK;AACzB,QAAM,KAAK,KAAK,IAAI,GAAG;AAEvB,QAAM,KAAK,KAAK,IAAI,IAAI;AACxB,QAAM,KAAK,KAAK,IAAI,KAAK;AACzB,QAAM,KAAK,KAAK,IAAI,GAAG;AAEvB,QAAM,MAAM,MAAM,CAAC;AACnB,QAAM,MAAM,MAAM,CAAC;AACnB,QAAM,MAAM,MAAM,CAAC;AAEnB,eAAa,CAAC,IAAI,MAAM,KAAK;AAC7B,eAAa,CAAC,IAAI,MAAM,KAAK;AAC7B,eAAa,CAAC,IAAI,MAAM,CAAC;AACzB,eAAa,CAAC,IAAI,OAAO,CAAC,KAAK,KAAK,KAAK,KAAK;AAC9C,eAAa,CAAC,IAAI,OAAO,KAAK,KAAK,KAAK,KAAK;AAC7C,eAAa,CAAC,IAAI,MAAM,KAAK;AAC7B,eAAa,CAAC,IAAI,OAAO,KAAK,KAAK,KAAK,KAAK;AAC7C,eAAa,CAAC,IAAI,OAAO,CAAC,KAAK,KAAK,KAAK,KAAK;AAC9C,eAAa,CAAC,IAAI,MAAM,KAAK;AAC/B;AAEA,SAAS,wBAAwB,MAAI;AACnC,OAAK,CAAC,IAAI,KAAK,CAAC;AAChB,OAAK,CAAC,IAAI,KAAK,CAAC;AAChB,OAAK,CAAC,IAAI,KAAK,CAAC;AAChB,OAAK,CAAC,IAAI,KAAK,CAAC;AAChB,OAAK,CAAC,IAAI,KAAK,CAAC;AAChB,OAAK,CAAC,IAAI,KAAK,CAAC;AAChB,OAAK,CAAC,IAAI,KAAK,CAAC;AAChB,OAAK,CAAC,IAAI,KAAK,CAAC;AAChB,OAAK,CAAC,IAAI,KAAK,EAAE;AACjB,OAAK,CAAC,IAAI,KAAK,EAAE;AACjB,OAAK,EAAE,IAAI,KAAK,EAAE;AAClB,OAAK,EAAE,IAAI,KAAK,EAAE;AAElB,SAAO,KAAK,SAAS,GAAG,EAAE;AAC5B;AAEO,IAAM,oBAAoB;EAC/B,MAAM;EACN,UAAU,CAAC,kBAAkB,YAAY,kBAAkB,oBAAoB;EAC/E,kBAAkB;IAChB,yBAAyB;MACvB,MAAM;MACN,eAAe;;IAEjB,yBAAyB;MACvB,MAAM;MACN,eAAe;;IAEjB,yBAAyB;MACvB,MAAM;MACN,eAAe;;IAEjB,qBAAqB;MACnB,MAAM;MACN,eAAe;;;EAInB,OAAO,WAAW,EAAC,UAAU,OAAM,GAAC;AAElC,UAAM,EAAC,MAAM,gBAAgB,UAAU,gBAAgB,mBAAkB,IAAI,KAAK;AAElF,UAAM,cAAc,MAAM,QAAQ,kBAAkB;AACpD,UAAM,iBAAiB,eAAe,mBAAmB,WAAW;AACpE,UAAM,gBAAgB,MAAM,QAAQ,QAAQ;AAC5C,UAAM,sBAAsB,MAAM,QAAQ,cAAc;AACxD,UAAM,sBAAsB,MAAM,QAAQ,cAAc;AAExD,UAAM,YAAY,kBAAmB,CAAC,eAAe,QAAQ,mBAAmB,KAAK,CAAC,CAAC,CAAC;AAExF,QAAI,WAAW;AACb,gBAAU,WAAW;IACvB,OAAO;AACL,gBAAU,WAAW,uBAAuB,iBAAiB;IAC/D;AAEA,UAAM,0BAA0B,UAAU;AAE1C,QAAI,UAAU,UAAU;AACtB,UAAI;AAEJ,UAAI,WAAW;AACb,oBAAY,IAAI,kBAAkB;AAClC,iBAAS,wBAAwB,WAAW;MAC9C,OAAO;AACL,iBAAS;AAET,cAAM,cAAc;AACpB,cAAM,QAAQ;AAEd,iCAAyB,QAAQ,aAAa,KAAK;AACnD,eAAO,IAAI,gBAAgB,CAAC;MAC9B;AAEA,gBAAU,QAAQ,IAAI,aAAa,MAAM;IAC3C,OAAO;AACL,UAAI,IAAI,WAAW,UAAU;AAC7B,YAAM,EAAC,UAAU,WAAU,IAAI,eAAe,MAAM,UAAU,MAAM;AACpE,iBAAW,UAAU,UAAU;AAC7B,mBAAW;AACX,YAAI;AAEJ,YAAI,WAAW;AACb,sBAAY,IACV,iBAAiB,qBAAqB,mBAAmB,QAAQ,UAAU,CAAC;AAE9E,mBAAS,wBAAwB,WAAW;QAC9C,OAAO;AACL,mBAAS;AAET,gBAAM,cAAc,sBAChB,iBACA,eAAe,QAAQ,UAAU;AACrC,gBAAM,QAAQ,gBAAgB,WAAW,SAAS,QAAQ,UAAU;AAEpE,mCAAyB,QAAQ,aAAa,KAAK;AACnD,iBAAO,IAAI,sBAAsB,iBAAiB,eAAe,QAAQ,UAAU,GAAG,CAAC;QACzF;AAEA,gCAAwB,GAAG,IAAI,OAAO,CAAC;AACvC,gCAAwB,GAAG,IAAI,OAAO,CAAC;AACvC,gCAAwB,GAAG,IAAI,OAAO,CAAC;AACvC,gCAAwB,GAAG,IAAI,OAAO,CAAC;AACvC,gCAAwB,GAAG,IAAI,OAAO,CAAC;AACvC,gCAAwB,GAAG,IAAI,OAAO,CAAC;AACvC,gCAAwB,GAAG,IAAI,OAAO,CAAC;AACvC,gCAAwB,GAAG,IAAI,OAAO,CAAC;AACvC,gCAAwB,GAAG,IAAI,OAAO,CAAC;AACvC,gCAAwB,GAAG,IAAI,OAAO,CAAC;AACvC,gCAAwB,GAAG,IAAI,OAAO,EAAE;AACxC,gCAAwB,GAAG,IAAI,OAAO,EAAE;MAC1C;IACF;EACF;;AAOI,SAAU,yBAAyB,UAAU,kBAAgB;AACjE,SACE,qBAAqB,kBAAkB,aACvC,qBAAqB,kBAAkB,iBACtC,qBAAqB,kBAAkB,WAAW,CAAC,SAAS;AAEjE;;;AC/JA,IAAM,eAAe;;;;;;;AAiBd,IAAM,qBAAqB;EAChC,MAAM;EACN,IAAI;EACJ,IAAI;EACJ,cAAc;IACZ,WAAW;IACX,oBAAoB;IACpB,YAAY;IACZ,aAAa;;;;;AC5BjB,IAAA,wCAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA,IAAA,0CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AC6BA,SAAS,4BAA4B,YAA0B;AAC7D,QAAM,oBAAoB,WAAW,aAAa,WAAW;AAC7D,cAAI,OAAO,mBAAmB,+CAA+C;AAE7E,QAAM,cAAc,kBAAkB,MAAM,SAAS,kBAAkB;AACvE,MAAI,iBAAiB,WAAW,WAAW,WAAW;AACtD,MAAI,CAAC,gBAAgB;AACnB,qBAAiB,EAAC,MAAM,GAAG,OAAO,IAAI,aAAa,cAAc,CAAC,EAAE,KAAK,CAAC,EAAC;EAC7E;AACA,MAAI,kBAAkB,WAAW,UAAU,WAAW;AACtD,MAAI,CAAC,iBAAiB;AACpB,sBAAkB,EAAC,MAAM,GAAG,OAAO,IAAI,aAAa,cAAc,CAAC,EAAE,KAAK,CAAC,EAAC;EAC9E;AACA,MAAI,oBAAoB,WAAW,cAAc,WAAW;AAC5D,MAAI,CAAC,mBAAmB;AACtB,wBAAoB,EAAC,MAAM,GAAG,OAAO,IAAI,aAAa,cAAc,CAAC,EAAE,KAAK,CAAC,EAAC;EAChF;AAEA,SAAO;IACL,WAAW;IACX,QAAQ;IACR,SAAS;IACT,WAAW;;AAEf;AAMA,SAAS,YAAY,MAAU;AAC7B,MAAI,gBAAgB,UAAU;AAE5B,SAAK,aAAa,4BAA4B,KAAK,UAAU;AAC7D,WAAO;EACT,WAAY,KAAa,YAAY;AACnC,WAAO,IAAI,SAAS;MAClB,GAAG;MACH,UAAU;MACV,YAAY,4BAA6B,KAAa,UAAU;KACjE;EACH,OAAO;AACL,WAAO,IAAI,SAAS;MAClB,UAAU;MACV,YAAY,4BAA4B,IAAsB;KAC/D;EACH;AACF;AAEA,IAAM,gBAAkD,CAAC,GAAG,GAAG,GAAG,GAAG;AA6ErE,IAAM,eAAmD;EACvD,MAAM,EAAC,MAAM,UAAU,OAAO,MAAM,OAAO,KAAI;EAC/C,SAAS,EAAC,MAAM,SAAS,OAAO,MAAM,OAAO,KAAI;EACjD,WAAW,EAAC,MAAM,UAAU,OAAO,GAAG,KAAK,EAAC;;;EAI5C,YAAY;;;;EAIZ,WAAW;;EAEX,UAAU;EACV,aAAa,EAAC,MAAM,YAAY,OAAO,CAAC,MAAW,EAAE,SAAQ;EAC7D,UAAU,EAAC,MAAM,YAAY,OAAO,cAAa;;;;EAKjD,gBAAgB,EAAC,MAAM,YAAY,OAAO,CAAC,GAAG,GAAG,CAAC,EAAC;EACnD,UAAU,EAAC,MAAM,YAAY,OAAO,CAAC,GAAG,GAAG,CAAC,EAAC;EAC7C,gBAAgB,EAAC,MAAM,YAAY,OAAO,CAAC,GAAG,GAAG,CAAC,EAAC;;EAEnD,oBAAoB,EAAC,MAAM,YAAY,OAAO,CAAA,EAAE;EAEhD,mBAAmB,EAAC,MAAM,UAAU,QAAQ,MAAM,OAAO,KAAI;;AAI/D,IAAqB,kBAArB,cAAuF,cAEtF;EAYC,aAAU;AACR,WAAO,MAAM,WAAW;MACtB;MACA;MACA,SAAS,CAAC,mBAAW,eAAe,iBAAS,kBAAkB;KAChE;EACH;EAEA,YAAS;AAnNX;AAoNI,QAAI,KAAK,MAAM,YAAY;AACzB,aAAO,MAAM,UAAS;IACxB;AACA,QAAI,SAAS,KAAK,MAAM;AACxB,QAAI,QAAQ;AACV,aAAO;IACT;AACA,UAAM,EAAC,KAAI,IAAI,KAAK;AACpB,QAAI,CAAC,MAAM;AACT,aAAO;IACT;AAEA,cAAS,UAAK,WAAL,mBAAa;AAEtB,QAAI,CAAC,QAAQ;AAEX,YAAM,EAAC,WAAU,IAAI,YAAY,IAAY;AAC7C,iBAAW,WAAW,WAAW,YAAY,WAAW;AAGxD,eAAS,mBAAmB,UAAU;IACxC;AAEA,SAAK,MAAM,iBAAiB;AAC5B,WAAO;EACT;EAEA,kBAAe;AACb,UAAM,mBAAmB,KAAK,oBAAmB;AAEjD,qBAAkB,aAAa;MAC7B,mBAAmB;QACjB,YAAY;QACZ,MAAM;QACN,MAAM,KAAK,kBAAiB;QAC5B,MAAM;QACN,UAAU;;MAEZ,gBAAgB;QACd,MAAM;QACN,YAAY;QACZ,MAAM,KAAK,MAAM,YAAY;QAC7B,UAAU;QACV,cAAc,CAAC,GAAG,GAAG,GAAG,GAAG;;MAE7B,qBAAqB;KACtB;AAED,SAAK,SAAS;;;MAGZ,cAAc,KAAK,QAAQ,OAAO,cAAc;QAC9C,MAAM,IAAI,WAAW,CAAC;QACtB,OAAO;QACP,QAAQ;OACT;KACF;EACH;EAEA,YAAY,QAA8B;AA/Q5C;AAgRI,UAAM,YAAY,MAAM;AAExB,UAAM,EAAC,OAAO,UAAU,YAAW,IAAI;AACvC,QAAI,MAAM,SAAS,SAAS,QAAQ,YAAY,mBAAmB;AACjE,WAAK,MAAM,iBAAiB;AAC5B,iBAAK,MAAM,UAAX,mBAAkB;AAClB,UAAI,MAAM,MAAM;AACd,aAAK,MAAM,QAAQ,KAAK,SAAS,MAAM,IAAY;AAEnD,cAAM,aAAc,MAAM,KAAa,cAAc,MAAM;AAC3D,aAAK,SAAS;UACZ,YAAY,QAAQ,WAAW,UAAU,WAAW,OAAO;SAC5D;MACH;AAEA,WAAK,oBAAmB,EAAI,cAAa;IAC3C;AAEA,QAAI,MAAM,YAAY,SAAS,WAAW,MAAM,mBAAmB,SAAS;AAC1E,WAAK,WAAW,MAAM,OAAO;IAC/B;AAEA,QAAI,KAAK,MAAM,OAAO;AACpB,WAAK,MAAM,MAAM,YAAY,KAAK,MAAM,YAAY,eAAe,eAAe;IACpF;EACF;EAEA,cAAc,SAAqB;AACjC,UAAM,cAAc,OAAO;AAE3B,SAAK,MAAM,aAAa,OAAM;EAChC;EAEA,KAAK,EAAC,SAAQ,GAAC;AACb,UAAM,EAAC,MAAK,IAAI,KAAK;AACrB,QAAI,CAAC,OAAO;AACV;IACF;AAEA,UAAM,EAAC,UAAU,WAAU,IAAI,KAAK;AACpC,UAAM,EAAC,WAAW,kBAAkB,WAAU,IAAI,KAAK;AAEvD,UAAM,kBAAmC;MACvC;MACA,oBAAoB,CAAC,cAAc,yBAAyB,UAAU,gBAAgB;MACtF,aAAa,CAAC,KAAK,MAAM;;AAE3B,UAAM,aAAa,SAAS,EAAC,YAAY,gBAAe,CAAC;AACzD,UAAM,KAAK,UAAU;EACvB;EAEA,IAAI,WAAQ;AAnUd;AAoUI,WAAO,UAAQ,UAAK,UAAL,mBAAY,UAAS,MAAM,QAAQ;EACpD;EAEU,SAAS,MAAU;AAC3B,UAAM,QAAQ,IAAI,MAAM,KAAK,QAAQ,QAAQ;MAC3C,GAAG,KAAK,WAAU;MAClB,IAAI,KAAK,MAAM;MACf,cAAc,KAAK,oBAAmB,EAAI,iBAAgB;MAC1D,UAAU,YAAY,IAAI;MAC1B,aAAa;KACd;AAED,UAAM,EAAC,QAAO,IAAI,KAAK;AACvB,UAAM,EAAC,aAAY,IAAI,KAAK;AAC5B,UAAM,kBAAmC;MACvC,SAAU,WAAuB;MACjC,YAAY,QAAQ,OAAO;;AAE7B,UAAM,aAAa,SAAS,EAAC,YAAY,gBAAe,CAAC;AACzD,WAAO;EACT;EAEQ,WAAW,SAAgB;AACjC,UAAM,EAAC,cAAc,MAAK,IAAI,KAAK;AAInC,QAAI,OAAO;AACT,YAAM,kBAAmC;QACvC,SAAS,WAAW;QACpB,YAAY,QAAQ,OAAO;;AAE7B,YAAM,aAAa,SAAS,EAAC,YAAY,gBAAe,CAAC;IAC3D;EACF;;AAtKO,gBAAA,eAAe;AACf,gBAAA,YAAY;gCAJA;;;AC7JrB,IAAK;CAAL,SAAKA,SAAM;AACT,EAAAA,QAAAA,QAAA,UAAA,IAAA,KAAA,IAAA;AACA,EAAAA,QAAAA,QAAA,KAAA,IAAA,CAAA,IAAA;AACA,EAAAA,QAAAA,QAAA,WAAA,IAAA,GAAA,IAAA;AACA,EAAAA,QAAAA,QAAA,qBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,QAAAA,QAAA,oBAAA,IAAA,KAAA,IAAA;AACA,EAAAA,QAAAA,QAAA,QAAA,IAAA,IAAA,IAAA;AACA,EAAAA,QAAAA,QAAA,uBAAA,IAAA,IAAA,IAAA;AACA,EAAAA,QAAAA,QAAA,qBAAA,IAAA,KAAA,IAAA;AACF,GATK,WAAA,SAAM,CAAA,EAAA;AAcL,SAAU,iBACd,QACA,UACA,YACA,SAAgC;AAEhC,QAAM,iBAAoC;IACxC,SAAS;;MAEP,aAAa;MACb,yBAAyB;;IAE3B,UAAU,CAAA;IACV,UAAU;;MAER,QAAQ,CAAC,GAAG,GAAG,CAAC;;MAEhB,yBAAyB,CAAC,GAAG,CAAC;;;IAEhC,YAAY,CAAA;IACZ,cAAc,CAAA;IACd,mBAAmB,CAAA;;AAIrB,iBAAe,QAAQ,cAAc;AAErC,QAAM,EAAC,8BAA6B,IAAI;AACxC,MAAI,+BAA+B;AACjC,mBAAe,SAAS,wBACtB,8BAA8B,kBAAkB;AAClD,mBAAe,SAAS,yBACtB,8BAA8B,mBAAmB;AACnD,mBAAe,SAAS,cAAc,8BAA8B,eAAe;AACnF,mBAAe,SAAS,kBAAkB,CAAC,GAAG,CAAC;EACjD;AAEA,MAAI,mCAAS,UAAU;AACrB,mBAAe,QAAQ,YAAY;AAEnC,mBAAe,SAAS,kBAAkB,CAAC,GAAG,GAAG,GAAG,CAAC;AACrD,mBAAe,SAAS,eAAe,CAAC,GAAG,GAAG,GAAG,CAAC;EACpD;AAEA,MAAI,WAAW;AAAQ,mBAAe,QAAQ,cAAc;AAC5D,MAAI,WAAW,YAAW,mCAAS;AAAa,mBAAe,QAAQ,eAAe;AACtF,MAAI,WAAW;AAAY,mBAAe,QAAQ,SAAS;AAE3D,MAAI,mCAAS;AAA+B,mBAAe,QAAQ,UAAU;AAC7E,MAAI,mCAAS;AAAQ,mBAAe,QAAQ,aAAa;AAEzD,MAAI,UAAU;AACZ,kBAAc,QAAQ,UAAU,cAAc;EAChD;AAEA,SAAO;AACT;AAGA,SAAS,cAAc,QAAgB,UAAU,gBAAiC;AAChF,iBAAe,SAAS,QAAQ,QAAQ,SAAS,KAAK;AAEtD,MAAI,SAAS,sBAAsB;AACjC,8BAA0B,QAAQ,SAAS,sBAAsB,cAAc;EACjF;AACA,MAAI,SAAS,eAAe;AAC1B,eACE,QACA,SAAS,eACT,qBACA,iBACA,cAAc;AAGhB,UAAM,EAAC,QAAQ,EAAC,IAAI,SAAS;AAC7B,mBAAe,SAAS,cAAc;EACxC;AACA,MAAI,SAAS,kBAAkB;AAC7B,eACE,QACA,SAAS,kBACT,wBACA,oBACA,cAAc;AAGhB,UAAM,EAAC,WAAW,EAAC,IAAI,SAAS;AAChC,mBAAe,SAAS,oBAAoB;EAC9C;AACA,MAAI,SAAS,iBAAiB;AAC5B,eACE,QACA,SAAS,iBACT,uBACA,mBACA,cAAc;AAEhB,mBAAe,SAAS,iBAAiB,SAAS,kBAAkB,CAAC,GAAG,GAAG,CAAC;EAC9E;AAEA,UAAQ,SAAS,WAAW;IAC1B,KAAK;AACH,YAAM,EAAC,cAAc,IAAG,IAAI;AAC5B,qBAAe,QAAQ,eAAe;AACtC,qBAAe,SAAS,cAAc;AACtC;IACF,KAAK;AACH,UAAI,KAAK,2EAA2E,EAAC;AAGrF,qBAAe,WAAW,sBAAsB;AAChD,qBAAe,WAAW,sBAAsB;AAChD,qBAAe,WAAW,sBAAsB;AAEhD,qBAAe,WAAW,sBAAsB;AAChD,qBAAe,WAAW,sBAAsB;AAChD,qBAAe,WAAW,sBAAsB;AAGhD,qBAAe,aAAa,QAAQ;AACpC,qBAAe,aAAa,gBAAgB,OAAO;AACnD,qBAAe,aAAa,YAAY;QACtC,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;;AAGT;EACJ;AACF;AAGA,SAAS,0BACP,QACA,sBACA,gBAAiC;AAEjC,MAAI,qBAAqB,kBAAkB;AACzC,eACE,QACA,qBAAqB,kBACrB,wBACA,oBACA,cAAc;EAElB;AACA,iBAAe,SAAS,kBAAkB,qBAAqB,mBAAmB,CAAC,GAAG,GAAG,GAAG,CAAC;AAE7F,MAAI,qBAAqB,0BAA0B;AACjD,eACE,QACA,qBAAqB,0BACrB,gCACA,yBACA,cAAc;EAElB;AACA,QAAM,EAAC,iBAAiB,GAAG,kBAAkB,EAAC,IAAI;AAClD,iBAAe,SAAS,0BAA0B,CAAC,gBAAgB,eAAe;AACpF;AAGA,SAAS,WACP,QACA,aACA,aACA,SAAS,MACT,gBAAiC;AArNnC;AAuNE,QAAM,eAAa,sDAAa,YAAb,mBAAsB,YAAtB,mBAA+B,eAAc,CAAA;AAEhE,QAAM,QAAQ,YAAY,QAAQ,OAAO;AACzC,MAAI;AACJ,MAAI,2BAA2B,CAAA;AAC/B,MAAI,MAAM,YAAY;AACpB,qBAAiB;AACjB,+BAA2B;MACzB,CAAC,OAAO,kBAAkB,GACxB,MAAM,KAAK,SAAS,IAAI,OAAO,wBAAwB,OAAO;;EAEpE,OAAO;AAEL,qBAAiB,EAAC,MAAM,MAAK;EAC/B;AAEA,QAAM,UAAmB,OAAO,cAAc;IAC5C,IAAI,YAAY,eAAe,YAAY;IAC3C,YAAY;MACV,GAAG;MACH,GAAG;;IAEL,YAAY;MACV,CAAC,OAAO,mBAAmB,GAAG;;IAEhC,GAAG;GACJ;AACD,iBAAe,SAAS,WAAW,IAAI;AACvC,MAAI;AAAQ,mBAAe,QAAQ,MAAM,IAAI;AAC7C,iBAAe,kBAAkB,KAAK,OAAO;AAC/C;;;AC9OO,IAAM,+BAA+B;EAC1C,QAAQ;EACR,MAAM;EACN,MAAM;EACN,MAAM;EACN,MAAM;EACN,MAAM;EACN,MAAM;;AAGD,IAAM,oCAAoC;EAC/C,MAAM;EACN,MAAM;EACN,MAAM;EACN,MAAM;EACN,MAAM;EACN,MAAM;;AAWR,IAAM,gBAAN,MAAmB;EAOjB,YAAY,OAAyB;AANrC;AACA,qCAAoB;AACpB,mCAAmB;AACnB,iCAAgB;AAChB,oCAAgB,CAAA;AAGd,WAAO,OAAO,MAAM,KAAK;EAC3B;EAEA,QAAQ,QAAc;AACpB,QAAI,CAAC,KAAK,SAAS;AACjB;IACF;AAEA,UAAM,UAAU,SAAS;AACzB,UAAM,QAAQ,UAAU,KAAK,aAAa,KAAK;AAE/C,SAAK,SAAS,QAAQ,CAAC,EAAC,SAAS,QAAQ,KAAI,MAAK;AAChD,kBAAY,MAAM,SAAS,QAAQ,IAAI;AACvC,oCAA8B,QAAQ,OAAO,KAAK;IACpD,CAAC;EACH;;AAGI,IAAO,eAAP,MAAmB;EAGvB,YAAY,MAAS;AAFrB;AAGE,SAAK,aAAa,KAAK,WAAW,IAAI,CAAC,WAAW,UAAS;AACzD,YAAM,OAAO,UAAU,QAAQ,aAAa,KAAK;AACjD,YAAM,WAAW,UAAU,SAAS,IAAI,CAAC,EAAC,OAAO,gBAAgB,UAAU,OAAM,OAAO;QACtF,OAAO,kBAAkB,KAAK,UAAU,KAAK,CAAC;QAC9C;QACA,QAAQ,kBAAkB,KAAK,UAAU,MAAM,CAAC;QAChD;AACF,YAAM,WAAW,UAAU,SAAS,IAAI,CAAC,EAAC,SAAS,OAAM,OAAO;QAC9D,SAAS,SAAS,OAAO;QACzB,QAAQ,KAAK,MAAM,OAAO,IAAI;QAC9B,MAAM,OAAO;QACb;AACF,aAAO,IAAI,cAAc,EAAC,MAAM,SAAQ,CAAC;IAC3C,CAAC;EACH;;EAGA,QAAQ,MAAY;AAClB,SAAK,QAAQ,IAAI;EACnB;EAEA,QAAQ,MAAY;AAClB,SAAK,WAAW,QAAQ,eAAa,UAAU,QAAQ,IAAI,CAAC;EAC9D;EAEA,gBAAa;AACX,WAAO,KAAK;EACd;;AAKF,SAAS,kBAAkB,UAAQ;AACjC,MAAI,CAAC,SAAS,YAAY;AACxB,UAAM,YAAY,kCAAkC,SAAS,aAAa;AAC1E,UAAM,aAAa,6BAA6B,SAAS,IAAI;AAC7D,UAAM,SAAS,aAAa,SAAS;AACrC,UAAM,EAAC,QAAQ,WAAU,IAAI,SAAS,WAAW;AAEjD,UAAM,QAAQ,IAAI,UAAU,QAAQ,cAAc,SAAS,cAAc,IAAI,MAAM;AAEnF,QAAI,eAAe,GAAG;AACpB,eAAS,aAAa,MAAM,KAAK,KAAK;IACxC,OAAO;AAEL,YAAM,cAAc,CAAA;AACpB,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,YAAY;AACjD,oBAAY,KAAK,MAAM,KAAK,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,CAAC;MAC7D;AACA,eAAS,aAAa;IACxB;EACF;AAEA,SAAO,SAAS;AAClB;AAGA,IAAM,eAAe,IAAI,QAAO;AAChC,SAAS,8BAA8B,UAAU,MAAI;AACnD,OAAK,OAAO,SAAQ;AAEpB,MAAI,SAAS,aAAa;AACxB,SAAK,OAAO,UAAU,SAAS,WAAW;EAC5C;AAEA,MAAI,SAAS,UAAU;AACrB,UAAM,iBAAiB,aAAa,eAAe,SAAS,QAAQ;AACpE,SAAK,OAAO,cAAc,cAAc;EAC1C;AAEA,MAAI,SAAS,OAAO;AAClB,SAAK,OAAO,MAAM,SAAS,KAAK;EAClC;AACF;AAEA,IAAM,aAAa,IAAI,WAAU;AACjC,SAAS,kBAAkB,QAAQ,MAAM,OAAO,MAAM,OAAK;AACzD,MAAI,SAAS,YAAY;AAEvB,eAAW,MAAM,EAAC,OAAO,QAAQ,MAAM,MAAK,CAAC;AAC7C,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,aAAO,IAAI,EAAE,CAAC,IAAI,WAAW,CAAC;IAChC;EACF,OAAO;AAEL,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,aAAO,IAAI,EAAE,CAAC,IAAI,QAAQ,KAAK,CAAC,KAAK,IAAI,SAAS,MAAM,CAAC;IAC3D;EACF;AACF;AAEA,SAAS,uBAAuB,QAAQ,MAAM,EAAC,IAAI,aAAa,YAAY,IAAI,OAAO,OAAO,EAAC,GAAC;AAE9F,WAAS,IAAI,GAAG,IAAI,OAAO,IAAI,EAAE,QAAQ,KAAK;AAC5C,UAAM,KAAK,YAAY,CAAC,IAAI;AAC5B,UAAM,KAAK,WAAW,CAAC,IAAI;AAC3B,WAAO,IAAI,EAAE,CAAC,KACX,IAAI,KAAK,IAAI,GAAG,CAAC,IAAI,IAAI,KAAK,IAAI,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,KACnD,KAAK,IAAI,GAAG,CAAC,IAAI,IAAI,KAAK,IAAI,GAAG,CAAC,IAAI,KAAK,MAC3C,KAAK,KAAK,IAAI,GAAG,CAAC,IAAI,IAAI,KAAK,IAAI,GAAG,CAAC,KAAK,GAAG,CAAC,KAChD,KAAK,IAAI,GAAG,CAAC,IAAI,KAAK,IAAI,GAAG,CAAC,KAAK;EACxC;AACF;AAEA,SAAS,gBAAgB,QAAQ,MAAM,OAAK;AAC1C,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,WAAO,IAAI,EAAE,CAAC,IAAI,MAAM,CAAC;EAC3B;AACF;AAEA,SAAS,YAAY,MAAM,EAAC,OAAO,eAAe,OAAM,GAAG,QAAQ,MAAI;AACrE,QAAM,UAAU,MAAM,MAAM,SAAS,CAAC;AACtC,QAAM,gBAAgB,OAAO;AAE7B,QAAM,YAAY,MAAM,UAAU,OAAK,KAAK,aAAa;AACzD,QAAM,gBAAgB,KAAK,IAAI,GAAG,YAAY,CAAC;AAE/C,MAAI,CAAC,MAAM,QAAQ,OAAO,IAAI,CAAC,GAAG;AAChC,YAAQ,MAAM;MACZ,KAAK;AACH,eAAO,IAAI,IAAI,CAAC,GAAG,GAAG,CAAC;AACvB;MAEF,KAAK;AACH,eAAO,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;AAC1B;MAEF,KAAK;AACH,eAAO,IAAI,IAAI,CAAC,GAAG,GAAG,CAAC;AACvB;MAEF;AACE,YAAI,KAAK,sBAAsB,IAAI,EAAE,EAAC;IAC1C;EACF;AAGA,QAAM,eAAe,MAAM,aAAa;AACxC,QAAM,WAAW,MAAM,SAAS;AAEhC,UAAQ,eAAe;IACrB,KAAK;AACH,sBAAgB,QAAQ,MAAM,OAAO,aAAa,CAAC;AACnD;IAEF,KAAK;AACH,UAAI,WAAW,cAAc;AAC3B,cAAM,SAAS,gBAAgB,iBAAiB,WAAW;AAC3D,0BAAkB,QAAQ,MAAM,OAAO,aAAa,GAAG,OAAO,SAAS,GAAG,KAAK;MACjF;AACA;IAEF,KAAK;AACH,UAAI,WAAW,cAAc;AAC3B,cAAM,SAAS,gBAAgB,iBAAiB,WAAW;AAC3D,cAAM,QAAQ,WAAW;AAEzB,cAAM,KAAK,OAAO,IAAI,gBAAgB,CAAC;AACvC,cAAM,cAAc,OAAO,IAAI,gBAAgB,CAAC;AAChD,cAAM,aAAa,OAAO,IAAI,YAAY,CAAC;AAC3C,cAAM,KAAK,OAAO,IAAI,YAAY,CAAC;AAEnC,+BAAuB,QAAQ,MAAM,EAAC,IAAI,aAAa,YAAY,IAAI,OAAO,MAAK,CAAC;MACtF;AACA;IAEF;AACE,UAAI,KAAK,iBAAiB,aAAa,gBAAgB,EAAC;AACxD;EACJ;AACF;;;AClOA,IAAM;;EAAoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiD1B,IAAM;;EAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CtB,IAAM;;EAAgB;;;;;;;;;AAmBhB,SAAU,gBAAgB,QAAgB,SAA+B;AAC7E,QAAM,EAAC,IAAI,UAAU,UAAU,aAAa,iBAAiB,aAAY,IAAI;AAE7E,QAAM,iBAAiB,iBAAiB,QAAQ,UAAU,SAAS,YAAY,eAAe;AAC9F,MAAI,KAAK,GAAG,6BAA6B,eAAe,OAAO,EAAC;AAKhE,QAAM,mBAAmB,CAAA;AAIzB,QAAM,aAAuC;IAC3C,mBAAmB;IACnB,cAAc;IACd,aAAa;IACb,UAAU;;AAGZ,QAAM,aAAyB;IAC7B;IACA,QAAQ;IACR;IACA;IACA;IACA,UAAU,SAAS;IACnB;IACA,SAAS,CAAC,WAAsC;IAChD,GAAG;IAEH,SAAS,EAAC,GAAG,eAAe,SAAS,GAAG,aAAa,QAAO;IAC5D,YAAY,EAAC,GAAG,YAAY,GAAG,eAAe,YAAY,GAAG,aAAa,WAAU;;AAGtF,QAAM,QAAQ,IAAI,MAAM,QAAQ,UAAU;AAE1C,QAAM,EAAC,QAAQ,GAAG,iBAAgB,IAAI;IACpC,GAAG,eAAe;IAClB,GAAG,aAAa;IAChB,GAAG,eAAe;IAClB,GAAG,aAAa;;AAGlB,QAAM,aAAa,SAAS,EAAC,aAAa,kBAAkB,eAAe,EAAC,OAAM,EAAC,CAAC;AACpF,SAAO,IAAI,UAAU,EAAC,kBAAkB,MAAK,CAAC;AAChD;;;AC3JA,IAAYC;CAAZ,SAAYA,SAAM;AAChB,EAAAA,QAAAA,QAAA,QAAA,IAAA,CAAA,IAAA;AACA,EAAAA,QAAAA,QAAA,OAAA,IAAA,CAAA,IAAA;AACA,EAAAA,QAAAA,QAAA,WAAA,IAAA,CAAA,IAAA;AACA,EAAAA,QAAAA,QAAA,YAAA,IAAA,CAAA,IAAA;AACA,EAAAA,QAAAA,QAAA,WAAA,IAAA,CAAA,IAAA;AACA,EAAAA,QAAAA,QAAA,gBAAA,IAAA,CAAA,IAAA;AACA,EAAAA,QAAAA,QAAA,cAAA,IAAA,CAAA,IAAA;AACF,GARYA,YAAAA,UAAM,CAAA,EAAA;AAUZ,SAAU,4BACd,UAOuB;AAGvB,UAAQ,UAAU;IAChB,KAAKA,QAAO;AAAQ,aAAO;IAC3B,KAAKA,QAAO;AAAO,aAAO;IAC1B,KAAKA,QAAO;AAAY,aAAO;IAC/B,KAAKA,QAAO;AAAW,aAAO;IAC9B,KAAKA,QAAO;AAAgB,aAAO;IACnC;AAAS,YAAM,IAAI,MAAM,OAAO,QAAQ,CAAC;EAC3C;AACF;;;AClBA,IAAM,kBAA2C;EAC/C,cAAc,CAAA;EACd,UAAU;EACV,+BAA+B;EAC/B,QAAQ;EACR,aAAa;;AAOT,IAAO,mBAAP,MAAuB;EAK3B,YAAY,QAAgB,UAAmC,CAAA,GAAE;AAJjE;AACA;AACA;AAGE,SAAK,SAAS;AACd,SAAK,UAAU,EAAC,GAAG,iBAAiB,GAAG,QAAO;EAChD;EAEA,YAAY,MAAS;AACnB,SAAK,OAAO,SAAS,IAAI;AACzB,UAAM,UAAU,KAAK,KAAK,UAAU,CAAA,GAAI,IAAI,WAAS,KAAK,YAAY,KAAK,CAAC;AAC5E,WAAO;EACT;EAEA,iBAAc;AACZ,QAAI,MAAM,QAAQ,KAAK,KAAK,UAAU,GAAG;AACvC,aAAO,IAAI,aAAa,KAAK,IAAI;IACnC;AAEA,WAAO;EACT;EAEA,YAAY,WAAc;AACxB,UAAM,YAAY,UAAU,SAAS,CAAA;AACrC,UAAM,QAAQ,UAAU,IAAI,UAAQ,KAAK,WAAW,IAAI,CAAC;AACzD,UAAM,QAAQ,IAAI,UAAU;MAC1B,IAAI,UAAU,QAAQ,UAAU;MAChC,UAAU;KACX;AACD,WAAO;EACT;EAEA,WAAW,UAAQ;AACjB,QAAI,CAAC,SAAS,OAAO;AACnB,YAAM,eAAe,SAAS,YAAY,CAAA;AAC1C,YAAM,WAAW,aAAa,IAAI,WAAS,KAAK,WAAW,KAAK,CAAC;AAGjE,UAAI,SAAS,MAAM;AACjB,iBAAS,KAAK,KAAK,WAAW,SAAS,IAAI,CAAC;MAC9C;AAEA,YAAM,OAAO,IAAI,UAAU;QACzB,IAAI,SAAS,QAAQ,SAAS;QAC9B;OACD;AAED,UAAI,SAAS,QAAQ;AACnB,aAAK,UAAU,SAAS,MAAM;MAChC,OAAO;AACL,aAAK,OAAO,SAAQ;AAEpB,YAAI,SAAS,aAAa;AACxB,eAAK,OAAO,UAAU,SAAS,WAAW;QAC5C;AAEA,YAAI,SAAS,UAAU;AACrB,gBAAM,iBAAiB,IAAI,QAAO,EAAG,eAAe,SAAS,QAAQ;AACrE,eAAK,OAAO,cAAc,cAAc;QAC1C;AAEA,YAAI,SAAS,OAAO;AAClB,eAAK,OAAO,MAAM,SAAS,KAAK;QAClC;MACF;AACA,eAAS,QAAQ;IACnB;AAGA,UAAM,eAAe,KAAK,KAAK,MAAM,KAAK,UAAQ,KAAK,OAAO,SAAS,EAAE;AACzE,iBAAa,QAAQ,SAAS;AAE9B,WAAO,SAAS;EAClB;EAEA,WAAW,UAAQ;AAEjB,QAAI,CAAC,SAAS,OAAO;AACnB,YAAM,iBAAiB,SAAS,cAAc,CAAA;AAC9C,YAAM,aAAa,eAAe,IAAI,CAAC,eAAe,MACpD,KAAK,gBAAgB,eAAe,GAAG,QAAQ,CAAC;AAElD,YAAM,OAAO,IAAI,UAAU;QACzB,IAAI,SAAS,QAAQ,SAAS;QAC9B,UAAU;OACX;AACD,eAAS,QAAQ;IACnB;AAEA,WAAO,SAAS;EAClB;EAEA,gBAAgB,eAAoB,GAAW,UAAQ;AACrD,UAAM,KAAK,cAAc,QAAQ,GAAG,SAAS,QAAQ,SAAS,EAAE,cAAc,CAAC;AAC/E,UAAM,WAAW,4BAA4B,cAAc,QAAQ,CAAC;AACpE,UAAM,cAAc,cAAc,UAC9B,cAAc,QAAQ,QACtB,KAAK,eAAe,cAAc,UAAU;AAEhD,UAAM,YAAY,gBAAgB,KAAK,QAAQ;MAC7C;MACA,UAAU,KAAK,eAAe,IAAI,eAAe,QAAQ;MACzD,UAAU,cAAc;MACxB,iBAAiB,KAAK;MACtB,cAAc,KAAK,QAAQ;MAC3B;KACD;AAED,cAAU,SAAS;MACjB,cAAc,WAAW,SAAS;MAClC,cAAc,WAAW,SAAS;;AAKpC,WAAO;EACT;EAEA,eAAe,YAAe;AAC5B,UAAM,IAAI,MAAM,gCAAgC;EAClD;EAEA,eAAe,IAAY,eAAoB,UAA2B;AACxE,UAAM,aAAa,CAAA;AACnB,eAAW,CAAC,eAAe,SAAS,KAAK,OAAO,QAAQ,cAAc,UAAU,GAAG;AACjF,YAAM,EAAC,YAAY,MAAM,MAAK,IAAI;AAElC,iBAAW,aAAa,IAAI,EAAC,MAAM,QAAQ,YAAY,MAAK;IAC9D;AAEA,WAAO,IAAI,SAAS;MAClB;MACA;MACA,SAAS,cAAc,QAAQ;MAC/B;KACD;EACH;EAEA,aAAa,WAAW,OAAa;AACnC,QAAI,CAAC,UAAU,YAAY;AAEzB,gBAAU,aAAa,CAAA;IACzB;AAEA,UAAM,EAAC,WAAU,IAAI;AACrB,QAAI,CAAC,WAAW,aAAa;AAC3B,iBAAW,cAAc,CAAA;IAC3B;AAEA,QAAI,CAAC,WAAW,YAAY,KAAK,GAAG;AAClC,iBAAW,YAAY,KAAK,IAAI,KAAK,OAAO,aAAa;QACvD,IAAI,QAAQ,WAAW,EAAE;;QAEzB,MAAM,WAAW,QAAQ,UAAU;OACpC;IACH;AAEA,WAAO,WAAW,YAAY,KAAK;EACrC;;EAGA,cAAc,aAAW;AACvB,WAAO;EACT;;EAIA,WAAQ;AAKN,WAAO;EACT;;AAIF,SAAS,SAAS,QAAW;AAE3B,MACE,YAAY,OAAO,MAAM,KACzB,kBAAkB,eAClB,kBAAkB,aAClB;AACA,WAAO;EACT;AACA,MAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,WAAO,OAAO,IAAI,QAAQ;EAC5B;AACA,MAAI,UAAU,OAAO,WAAW,UAAU;AACxC,UAAM,SAAS,CAAA;AACf,eAAW,OAAO,QAAQ;AACxB,aAAO,GAAG,IAAI,SAAS,OAAO,GAAG,CAAC;IACpC;AACA,WAAO;EACT;AACA,SAAO;AACT;;;AC/NM,SAAU,0BACd,QACA,MACA,SAAiC;AAKjC,QAAM,eAAe,IAAI,iBAAiB,QAAQ,OAAO;AACzD,QAAM,SAAS,aAAa,YAAY,IAAI;AAC5C,QAAM,WAAW,aAAa,eAAc;AAC5C,SAAO,EAAC,QAAQ,SAAQ;AAC1B;;;ACdA,eAAsB,kBAAkB,aAAkC;AACxE,QAAM,YAAmB,CAAA;AAEzB,cAAY,OAAO,QAAQ,WAAQ;AACjC,UAAM,SAAS,CAAC,cAA6B;AAE3C,aAAO,OAAQ,UAAwB,MAAM,QAAQ,EAAE,QAAQ,CAAC,YAAgB;AAC9E,YAAI,QAAQ,WAAW,OAAO;AAC5B,oBAAU,KAAK,OAAO;QACxB;MACF,CAAC;IACH,CAAC;EACH,CAAC;AAED,SAAO,MAAM,mBAAmB,MAAM,UAAU,KAAK,aAAW,CAAC,QAAQ,MAAM,CAAC;AAClF;AAEA,eAAe,mBAAmB,WAAwB;AACxD,SAAO,UAAS,GAAI;AAClB,UAAM,IAAI,QAAQ,aAAW,sBAAsB,OAAO,CAAC;EAC7D;AACF;;;ACrBA,IAAMC,gBAAe;;;;;;;;AAkBd,IAAM,qBAAqB;EAChC,MAAM;EACN,IAAIA;EACJ,IAAIA;EACJ,cAAc;IACZ,WAAW;IACX,eAAe;IACf,eAAe;IACf,kBAAkB;IAClB,oBAAoB;;;;;AC9BxB,IAAA,uCAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA,IAAA,yCAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC2BA,IAAMC,iBAAkD,CAAC,KAAK,KAAK,KAAK,GAAG;AA6F3E,IAAMC,gBAAmD;EACvD,YAAY,EAAC,MAAM,UAAU,OAAO,MAAM,OAAO,KAAI;EACrD,UAAU,UAAO;AACf,QAAI,QAAQ,KAAK,QAAQ;AAEvB,aAAO,OAAO,KAAK,UAAU,WAAW,KAAK,QAAQ,KAAK,OAAO,KAAK,SAAS,CAAC;IAClF;AACA,WAAO;EACT;EACA,aAAa,gBAAc,cAAc,WAAW;EACpD,aAAa;EAEb,WAAW,EAAC,MAAM,UAAU,OAAO,GAAG,KAAK,EAAC;EAC5C,eAAe,EAAC,MAAM,UAAU,KAAK,GAAG,OAAO,EAAC;EAChD,eAAe,EAAC,MAAM,UAAU,KAAK,GAAG,OAAO,OAAO,iBAAgB;EAEtE,aAAa,EAAC,MAAM,YAAY,OAAO,CAAC,MAAW,EAAE,SAAQ;EAC7D,UAAU,EAAC,MAAM,YAAY,OAAOD,eAAa;;EAGjD,WAAW;;EAEX,gCAAgC;;;;EAKhC,gBAAgB,EAAC,MAAM,YAAY,OAAO,CAAC,GAAG,GAAG,CAAC,EAAC;EACnD,UAAU,EAAC,MAAM,YAAY,OAAO,CAAC,GAAG,GAAG,CAAC,EAAC;EAC7C,gBAAgB,EAAC,MAAM,YAAY,OAAO,CAAC,GAAG,GAAG,CAAC,EAAC;;EAEnD,oBAAoB,EAAC,MAAM,YAAY,OAAO,CAAA,EAAE;EAEhD,SAAS,CAAC,UAAU;;AAItB,IAAqB,kBAArB,cAAuF,cAEtF;EAUC,aAAU;AACR,UAAM,UAA8B,CAAA;AACpC,QAAI;AAEJ,QAAI,KAAK,MAAM,cAAc,OAAO;AAClC,YAAM;AACN,cAAQ,eAAe;IACzB,OAAO;AAGL,YAAM,EAAC,MAAM,cAAa;IAC5B;AAEA,UAAM,UAAU,CAAC,mBAAW,iBAAS,oBAAoB,GAAG;AAC5D,WAAO,MAAM,WAAW,EAAC,SAAS,0CAAI,4CAAI,QAAO,CAAC;EACpD;EAEA,kBAAe;AACb,UAAM,mBAAmB,KAAK,oBAAmB;AAEjD,qBAAkB,aAAa;MAC7B,mBAAmB;QACjB,MAAM;QACN,MAAM;QACN,MAAM,KAAK,kBAAiB;QAC5B,UAAU;QACV,YAAY;;MAEd,gBAAgB;QACd,MAAM;QACN,MAAM,KAAK,MAAM,YAAY;QAC7B,UAAU;QACV,cAAcA;QACd,YAAY;;MAEd,qBAAqB;KACtB;EACH;EAEA,YAAY,QAA8B;AACxC,UAAM,YAAY,MAAM;AACxB,UAAM,EAAC,OAAO,SAAQ,IAAI;AAE1B,QAAI,MAAM,eAAe,SAAS,YAAY;AAC5C,WAAK,kBAAiB;IACxB,WAAW,MAAM,gBAAgB,SAAS,aAAa;AACrD,WAAK,qBAAqB,KAAK,MAAM,UAAU,MAAM,WAAW;IAClE;EACF;EAEA,cAAc,SAAqB;AA/NrC;AAgOI,UAAM,cAAc,OAAO;AAC3B,eAAK,MAAM,eAAX,mBAAuB;EACzB;EAEA,IAAI,WAAQ;AApOd;AAqOI,WAAO,UAAQ,UAAK,UAAL,mBAAY,eAAc,MAAM,QAAQ;EACzD;EAEQ,oBAAiB;AAxO3B;AAyOI,UAAM,QAAQ,KAAK;AACnB,UAAM,EAAC,OAAM,IAAI,KAAK;AACtB,QAAI,iBAAsB;AAC1B,QAAI,MAAM,sBAAsB,gBAAgB;AAE9C,uBAAiB,EAAC,QAAQ,CAAC,MAAM,UAAU,EAAC;IAC9C,WAAW,MAAM,cAAc,OAAO,MAAM,eAAe,UAAU;AAEnE,YAAM,OAAO,MAAM;AAGnB,YAAM,gBAAgB,KAAK,OAAO,gBAAgB,IAAI,IAAI;AAE1D,YAAM,cAAc,0BAA0B,QAAQ,eAAe,KAAK,iBAAgB,CAAE;AAC5F,uBAAiB,EAAC,MAAM,eAAe,GAAG,YAAW;AAErD,wBAAkB,WAAW,EAC1B,KAAK,MAAK;AACT,aAAK,eAAc;MACrB,CAAC,EACA,MAAM,QAAK;AACV,aAAK,WAAW,IAAI,cAAc;MACpC,CAAC;IACL;AAEA,UAAM,UAAU,EAAC,OAAO,MAAM,QAAQ,KAAK,QAAQ,OAAM;AACzD,UAAM,aAAa,MAAM,SAAS,gBAAgB,OAAO;AACzD,UAAM,WAAW,MAAM,YAAY,gBAAgB,OAAO;AAE1D,QAAI,sBAAsB,WAAW;AACnC,iBAAK,MAAM,eAAX,mBAAuB;AAEvB,WAAK,qBAAqB,UAAU,MAAM,WAAW;AAErD,YAAM,SAAkB,CAAA;AACxB,iBAAW,SAAS,UAAO;AACzB,YAAI,gBAAgB,WAAW;AAC7B,iBAAO,KAAK,KAAK,KAAK;QACxB;MACF,CAAC;AAED,WAAK,SAAS,EAAC,YAAY,UAAU,OAAM,CAAC;AAC5C,WAAK,oBAAmB,EAAI,cAAa;IAC3C,WAAW,eAAe,MAAM;AAC9B,kBAAI,KAAK,uBAAuB,UAAU,EAAC;IAC7C;EACF;EAEQ,qBAAqB,UAAwB,gBAAmB;AACtE,QAAI,CAAC,YAAY,CAAC,gBAAgB;AAChC;IACF;AAEA,UAAM,aAAa,SAAS,cAAa;AAGzC,WAAO,KAAK,cAAc,EACvB,KAAI,EACJ,QAAQ,SAAM;AAKb,YAAM,QAAQ,eAAe,GAAG;AAEhC,UAAI,QAAQ,KAAK;AACf,mBAAW,QAAQ,eAAY;AAC7B,iBAAO,OAAO,WAAW,KAAK;QAChC,CAAC;MACH,WAAW,OAAO,SAAS,OAAO,GAAG,CAAC,GAAG;AACvC,cAAM,SAAS,OAAO,GAAG;AACzB,YAAI,UAAU,KAAK,SAAS,WAAW,QAAQ;AAC7C,iBAAO,OAAO,WAAW,MAAM,GAAG,KAAK;QACzC,OAAO;AACL,sBAAI,KAAK,aAAa,GAAG,YAAY,EAAC;QACxC;MACF,OAAO;AACL,cAAM,aAAa,WAAW,KAAK,CAAC,EAAC,KAAI,MAAM,SAAS,GAAG;AAC3D,YAAI,YAAY;AACd,iBAAO,OAAO,YAAY,KAAK;QACjC,OAAO;AACL,sBAAI,KAAK,aAAa,GAAG,YAAY,EAAC;QACxC;MACF;IACF,CAAC;EACL;EAEQ,mBAAgB;AACtB,UAAM,EAAC,+BAA8B,IAAI,KAAK;AAE9C,QAAI;AACJ,QAAI,gCAAgC;AAClC,UAAI,OAAO,mCAAmC,YAAY;AACxD,cAAM,+BAA+B,EAAC,IAAI,KAAK,QAAQ,IAAI,OAAO,KAAI,CAAC;MACzE,OAAO;AACL,cAAM;MACR;IACF;AAEA,WAAO;MACL,+BAA+B;MAC/B,cAAc;QACZ,IAAI,KAAK,MAAM;QACf,aAAa;QACb,cAAc,KAAK,oBAAmB,EAAI,iBAAgB;QAC1D,GAAG,KAAK,WAAU;;;MAGpB,aAAa;;EAEjB;EAEA,KAAK,EAAC,QAAO,GAAC;AACZ,QAAI,CAAC,KAAK,MAAM;AAAY;AAE5B,QAAI,KAAK,MAAM,eAAe,KAAK,MAAM,UAAU;AACjD,WAAK,MAAM,SAAS,QAAQ,QAAQ,SAAS,QAAO,CAAE;AACtD,WAAK,eAAc;IACrB;AAEA,UAAM,EAAC,UAAU,WAAU,IAAI,KAAK;AACpC,UAAM,EAAC,WAAW,eAAe,eAAe,iBAAgB,IAAI,KAAK;AAEzE,UAAM,eAAe,KAAK,gBAAe;AACzC,SAAK,MAAM,WAAW,SAAS,CAAC,MAAM,EAAC,YAAW,MAAK;AACrD,UAAI,gBAAgB,WAAW;AAC7B,cAAM,EAAC,MAAK,IAAI;AAChB,cAAM,iBAAiB,YAAY;AAEnC,cAAM,qBAAqB;;UAEzB,QAAQ,MAAM,SAAS;;AAEzB,cAAM,kBAAmC;UACvC;UACA;UACA;UACA,oBAAoB,yBAAyB,UAAU,gBAAgB;UACvE,kBAAkB;;AAGpB,cAAM,aAAa,SAAS;UAC1B,eAAe;UACf,YAAY;SACb;AACD,cAAM,KAAK,UAAU;MACvB;IACF,CAAC;EACH;;AAzNO,gBAAA,eAAeC;AACf,gBAAA,YAAY;+BAJA;",
  "names": ["GLEnum", "GLEnum", "uniformBlock", "DEFAULT_COLOR", "defaultProps"]
}
