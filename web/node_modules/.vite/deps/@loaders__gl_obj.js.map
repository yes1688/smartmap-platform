{
  "version": 3,
  "sources": ["../../@loaders.gl/obj/dist/lib/parse-obj-meshes.js", "../../@loaders.gl/obj/dist/lib/get-obj-schema.js", "../../@loaders.gl/obj/dist/lib/parse-obj.js", "../../@loaders.gl/obj/dist/obj-loader.js", "../../@loaders.gl/obj/dist/lib/parse-mtl.js", "../../@loaders.gl/obj/dist/mtl-loader.js", "../../@loaders.gl/obj/dist/index.js"],
  "sourcesContent": ["// OBJ Loader, adapted from THREE.js (MIT license)\n//\n// Attributions per original THREE.js source file:\n//\n// @author mrdoob / http://mrdoob.com/\n// @ts-nocheck\n// o object_name | g group_name\nconst OBJECT_RE = /^[og]\\s*(.+)?/;\n// mtllib file_reference\nconst MATERIAL_RE = /^mtllib /;\n// usemtl material_name\nconst MATERIAL_USE_RE = /^usemtl /;\nclass MeshMaterial {\n    constructor({ index, name = '', mtllib, smooth, groupStart }) {\n        this.index = index;\n        this.name = name;\n        this.mtllib = mtllib;\n        this.smooth = smooth;\n        this.groupStart = groupStart;\n        this.groupEnd = -1;\n        this.groupCount = -1;\n        this.inherited = false;\n    }\n    clone(index = this.index) {\n        return new MeshMaterial({\n            index,\n            name: this.name,\n            mtllib: this.mtllib,\n            smooth: this.smooth,\n            groupStart: 0\n        });\n    }\n}\nclass MeshObject {\n    constructor(name = '') {\n        this.name = name;\n        this.geometry = {\n            vertices: [],\n            normals: [],\n            colors: [],\n            uvs: []\n        };\n        this.materials = [];\n        this.smooth = true;\n        this.fromDeclaration = null;\n    }\n    startMaterial(name, libraries) {\n        const previous = this._finalize(false);\n        // New usemtl declaration overwrites an inherited material, except if faces were declared\n        // after the material, then it must be preserved for proper MultiMaterial continuation.\n        if (previous && (previous.inherited || previous.groupCount <= 0)) {\n            this.materials.splice(previous.index, 1);\n        }\n        const material = new MeshMaterial({\n            index: this.materials.length,\n            name,\n            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n            smooth: previous !== undefined ? previous.smooth : this.smooth,\n            groupStart: previous !== undefined ? previous.groupEnd : 0\n        });\n        this.materials.push(material);\n        return material;\n    }\n    currentMaterial() {\n        if (this.materials.length > 0) {\n            return this.materials[this.materials.length - 1];\n        }\n        return undefined;\n    }\n    _finalize(end) {\n        const lastMultiMaterial = this.currentMaterial();\n        if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n            lastMultiMaterial.inherited = false;\n        }\n        // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n        if (end && this.materials.length > 1) {\n            for (let mi = this.materials.length - 1; mi >= 0; mi--) {\n                if (this.materials[mi].groupCount <= 0) {\n                    this.materials.splice(mi, 1);\n                }\n            }\n        }\n        // Guarantee at least one empty material, this makes the creation later more straight forward.\n        if (end && this.materials.length === 0) {\n            this.materials.push({\n                name: '',\n                smooth: this.smooth\n            });\n        }\n        return lastMultiMaterial;\n    }\n}\nclass ParserState {\n    constructor() {\n        this.objects = [];\n        this.object = null;\n        this.vertices = [];\n        this.normals = [];\n        this.colors = [];\n        this.uvs = [];\n        this.materialLibraries = [];\n        this.startObject('', false);\n    }\n    startObject(name, fromDeclaration = true) {\n        // If the current object (initial from reset) is not from a g/o declaration in the parsed\n        // file. We need to use it for the first parsed g/o to keep things in sync.\n        if (this.object && !this.object.fromDeclaration) {\n            this.object.name = name;\n            this.object.fromDeclaration = fromDeclaration;\n            return;\n        }\n        const previousMaterial = this.object && typeof this.object.currentMaterial === 'function'\n            ? this.object.currentMaterial()\n            : undefined;\n        if (this.object && typeof this.object._finalize === 'function') {\n            this.object._finalize(true);\n        }\n        this.object = new MeshObject(name);\n        this.object.fromDeclaration = fromDeclaration;\n        // Inherit previous objects material.\n        // Spec tells us that a declared material must be set to all objects until a new material is declared.\n        // If a usemtl declaration is encountered while this new object is being parsed, it will\n        // overwrite the inherited material. Exception being that there was already face declarations\n        // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n        if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n            const declared = previousMaterial.clone(0);\n            declared.inherited = true;\n            this.object.materials.push(declared);\n        }\n        this.objects.push(this.object);\n    }\n    finalize() {\n        if (this.object && typeof this.object._finalize === 'function') {\n            this.object._finalize(true);\n        }\n    }\n    parseVertexIndex(value, len) {\n        const index = parseInt(value);\n        return (index >= 0 ? index - 1 : index + len / 3) * 3;\n    }\n    parseNormalIndex(value, len) {\n        const index = parseInt(value);\n        return (index >= 0 ? index - 1 : index + len / 3) * 3;\n    }\n    parseUVIndex(value, len) {\n        const index = parseInt(value);\n        return (index >= 0 ? index - 1 : index + len / 2) * 2;\n    }\n    addVertex(a, b, c) {\n        const src = this.vertices;\n        const dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    }\n    addVertexPoint(a) {\n        const src = this.vertices;\n        const dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    }\n    addVertexLine(a) {\n        const src = this.vertices;\n        const dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    }\n    addNormal(a, b, c) {\n        const src = this.normals;\n        const dst = this.object.geometry.normals;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    }\n    addColor(a, b, c) {\n        const src = this.colors;\n        const dst = this.object.geometry.colors;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    }\n    addUV(a, b, c) {\n        const src = this.uvs;\n        const dst = this.object.geometry.uvs;\n        dst.push(src[a + 0], src[a + 1]);\n        dst.push(src[b + 0], src[b + 1]);\n        dst.push(src[c + 0], src[c + 1]);\n    }\n    addUVLine(a) {\n        const src = this.uvs;\n        const dst = this.object.geometry.uvs;\n        dst.push(src[a + 0], src[a + 1]);\n    }\n    // eslint-disable-next-line max-params\n    addFace(a, b, c, ua, ub, uc, na, nb, nc) {\n        const vLen = this.vertices.length;\n        let ia = this.parseVertexIndex(a, vLen);\n        let ib = this.parseVertexIndex(b, vLen);\n        let ic = this.parseVertexIndex(c, vLen);\n        this.addVertex(ia, ib, ic);\n        if (ua !== undefined && ua !== '') {\n            const uvLen = this.uvs.length;\n            ia = this.parseUVIndex(ua, uvLen);\n            ib = this.parseUVIndex(ub, uvLen);\n            ic = this.parseUVIndex(uc, uvLen);\n            this.addUV(ia, ib, ic);\n        }\n        if (na !== undefined && na !== '') {\n            // Normals are many times the same. If so, skip function call and parseInt.\n            const nLen = this.normals.length;\n            ia = this.parseNormalIndex(na, nLen);\n            ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);\n            ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);\n            this.addNormal(ia, ib, ic);\n        }\n        if (this.colors.length > 0) {\n            this.addColor(ia, ib, ic);\n        }\n    }\n    addPointGeometry(vertices) {\n        this.object.geometry.type = 'Points';\n        const vLen = this.vertices.length;\n        for (const vertex of vertices) {\n            this.addVertexPoint(this.parseVertexIndex(vertex, vLen));\n        }\n    }\n    addLineGeometry(vertices, uvs) {\n        this.object.geometry.type = 'Line';\n        const vLen = this.vertices.length;\n        const uvLen = this.uvs.length;\n        for (const vertex of vertices) {\n            this.addVertexLine(this.parseVertexIndex(vertex, vLen));\n        }\n        for (const uv of uvs) {\n            this.addUVLine(this.parseUVIndex(uv, uvLen));\n        }\n    }\n}\n// eslint-disable-next-line max-statements, complexity\nexport function parseOBJMeshes(text) {\n    const state = new ParserState();\n    if (text.indexOf('\\r\\n') !== -1) {\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n    }\n    if (text.indexOf('\\\\\\n') !== -1) {\n        // join lines separated by a line continuation character (\\)\n        text = text.replace(/\\\\\\n/g, '');\n    }\n    const lines = text.split('\\n');\n    let line = '';\n    let lineFirstChar = '';\n    let lineLength = 0;\n    let result = [];\n    // Faster to just trim left side of the line. Use if available.\n    const trimLeft = typeof ''.trimLeft === 'function';\n    /* eslint-disable no-continue, max-depth */\n    for (let i = 0, l = lines.length; i < l; i++) {\n        line = lines[i];\n        line = trimLeft ? line.trimLeft() : line.trim();\n        lineLength = line.length;\n        if (lineLength === 0)\n            continue;\n        lineFirstChar = line.charAt(0);\n        // @todo invoke passed in handler if any\n        if (lineFirstChar === '#')\n            continue;\n        if (lineFirstChar === 'v') {\n            const data = line.split(/\\s+/);\n            switch (data[0]) {\n                case 'v':\n                    state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n                    if (data.length >= 7) {\n                        state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n                    }\n                    break;\n                case 'vn':\n                    state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n                    break;\n                case 'vt':\n                    state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n                    break;\n                default:\n            }\n        }\n        else if (lineFirstChar === 'f') {\n            const lineData = line.substr(1).trim();\n            const vertexData = lineData.split(/\\s+/);\n            const faceVertices = [];\n            // Parse the face vertex data into an easy to work with format\n            for (let j = 0, jl = vertexData.length; j < jl; j++) {\n                const vertex = vertexData[j];\n                if (vertex.length > 0) {\n                    const vertexParts = vertex.split('/');\n                    faceVertices.push(vertexParts);\n                }\n            }\n            // Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n            const v1 = faceVertices[0];\n            for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n                const v2 = faceVertices[j];\n                const v3 = faceVertices[j + 1];\n                state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n            }\n        }\n        else if (lineFirstChar === 'l') {\n            const lineParts = line.substring(1).trim().split(' ');\n            let lineVertices;\n            const lineUVs = [];\n            if (line.indexOf('/') === -1) {\n                lineVertices = lineParts;\n            }\n            else {\n                lineVertices = [];\n                for (let li = 0, llen = lineParts.length; li < llen; li++) {\n                    const parts = lineParts[li].split('/');\n                    if (parts[0] !== '')\n                        lineVertices.push(parts[0]);\n                    if (parts[1] !== '')\n                        lineUVs.push(parts[1]);\n                }\n            }\n            state.addLineGeometry(lineVertices, lineUVs);\n        }\n        else if (lineFirstChar === 'p') {\n            const lineData = line.substr(1).trim();\n            const pointData = lineData.split(' ');\n            state.addPointGeometry(pointData);\n        }\n        else if ((result = OBJECT_RE.exec(line)) !== null) {\n            // o object_name\n            // or\n            // g group_name\n            // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n            // var name = result[ 0 ].substr( 1 ).trim();\n            const name = (' ' + result[0].substr(1).trim()).substr(1); // eslint-disable-line\n            state.startObject(name);\n        }\n        else if (MATERIAL_USE_RE.test(line)) {\n            // material\n            state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n        }\n        else if (MATERIAL_RE.test(line)) {\n            // mtl file\n            state.materialLibraries.push(line.substring(7).trim());\n        }\n        else if (lineFirstChar === 's') {\n            result = line.split(' ');\n            // smooth shading\n            // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n            // but does not define a usemtl for each face set.\n            // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n            // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n            // where explicit usemtl defines geometry groups.\n            // Example asset: examples/models/obj/cerberus/Cerberus.obj\n            /*\n             * http://paulbourke.net/dataformats/obj/\n             * or\n             * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n             *\n             * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n             * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n             * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n             * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n             * than 0.\"\n             */\n            if (result.length > 1) {\n                const value = result[1].trim().toLowerCase();\n                state.object.smooth = value !== '0' && value !== 'off';\n            }\n            else {\n                // ZBrush can produce \"s\" lines #11707\n                state.object.smooth = true;\n            }\n            const material = state.object.currentMaterial();\n            if (material)\n                material.smooth = state.object.smooth;\n        }\n        else {\n            // Handle null terminated files without exception\n            if (line === '\\0')\n                continue;\n            throw new Error(`Unexpected line: \"${line}\"`);\n        }\n    }\n    state.finalize();\n    const meshes = [];\n    const materials = [];\n    for (const object of state.objects) {\n        const { geometry } = object;\n        // Skip o/g line declarations that did not follow with any faces\n        if (geometry.vertices.length === 0)\n            continue;\n        const mesh = {\n            header: {\n                vertexCount: geometry.vertices.length / 3\n            },\n            attributes: {}\n        };\n        switch (geometry.type) {\n            case 'Points':\n                mesh.mode = 0; // GL.POINTS\n                break;\n            case 'Line':\n                mesh.mode = 1; // GL.LINES\n                break;\n            default:\n                mesh.mode = 4; // GL.TRIANGLES\n                break;\n        }\n        mesh.attributes.POSITION = { value: new Float32Array(geometry.vertices), size: 3 };\n        if (geometry.normals.length > 0) {\n            mesh.attributes.NORMAL = { value: new Float32Array(geometry.normals), size: 3 };\n        }\n        if (geometry.colors.length > 0) {\n            mesh.attributes.COLOR_0 = { value: new Float32Array(geometry.colors), size: 3 };\n        }\n        if (geometry.uvs.length > 0) {\n            mesh.attributes.TEXCOORD_0 = { value: new Float32Array(geometry.uvs), size: 2 };\n        }\n        // Create materials\n        mesh.materials = [];\n        for (const sourceMaterial of object.materials) {\n            // TODO - support full spec\n            const _material = {\n                name: sourceMaterial.name,\n                flatShading: !sourceMaterial.smooth\n            };\n            mesh.materials.push(_material);\n            materials.push(_material);\n        }\n        mesh.name = object.name;\n        meshes.push(mesh);\n    }\n    return { meshes, materials };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getDataTypeFromArray } from '@loaders.gl/schema';\n/** Get Mesh Schema */\nexport function getOBJSchema(attributes, metadata = {}) {\n    const stringMetadata = {};\n    for (const key in metadata) {\n        if (key !== 'value') {\n            stringMetadata[key] = JSON.stringify(metadata[key]);\n        }\n    }\n    const fields = [];\n    for (const attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        const field = getFieldFromAttribute(attributeName, attribute);\n        fields.push(field);\n    }\n    return { fields, metadata: stringMetadata };\n}\n/** Get a Field describing the column from an OBJ attribute */\nfunction getFieldFromAttribute(name, attribute) {\n    const metadata = {};\n    for (const key in attribute) {\n        if (key !== 'value') {\n            metadata[key] = JSON.stringify(attribute[key]);\n        }\n    }\n    let { type } = getDataTypeFromArray(attribute.value);\n    const isSingleValue = attribute.size === 1 || attribute.size === undefined;\n    if (!isSingleValue) {\n        type = { type: 'fixed-size-list', listSize: attribute.size, children: [{ name: 'values', type }] };\n    }\n    return { name, type, nullable: false, metadata };\n}\n", "import { getMeshBoundingBox } from '@loaders.gl/schema';\nimport { parseOBJMeshes } from \"./parse-obj-meshes.js\";\nimport { getOBJSchema } from \"./get-obj-schema.js\";\nexport function parseOBJ(text, options) {\n    const { meshes } = parseOBJMeshes(text);\n    // @ts-expect-error\n    const vertexCount = meshes.reduce((s, mesh) => s + mesh.header.vertexCount, 0);\n    // TODO - render objects separately\n    const attributes = mergeAttributes(meshes, vertexCount);\n    const header = {\n        vertexCount,\n        // @ts-ignore Need to export Attributes type\n        boundingBox: getMeshBoundingBox(attributes)\n    };\n    const schema = getOBJSchema(attributes, {\n        mode: 4,\n        boundingBox: header.boundingBox\n    });\n    return {\n        // Data return by this loader implementation\n        loaderData: {\n            header: {}\n        },\n        // Normalised data\n        schema,\n        header,\n        mode: 4, // TRIANGLES\n        topology: 'point-list',\n        attributes\n    };\n}\n// eslint-disable-next-line max-statements\nfunction mergeAttributes(meshes, vertexCount) {\n    const positions = new Float32Array(vertexCount * 3);\n    let normals;\n    let colors;\n    let uvs;\n    let i = 0;\n    for (const mesh of meshes) {\n        const { POSITION, NORMAL, COLOR_0, TEXCOORD_0 } = mesh.attributes;\n        positions.set(POSITION.value, i * 3);\n        if (NORMAL) {\n            normals = normals || new Float32Array(vertexCount * 3);\n            normals.set(NORMAL.value, i * 3);\n        }\n        if (COLOR_0) {\n            colors = colors || new Float32Array(vertexCount * 3);\n            colors.set(COLOR_0.value, i * 3);\n        }\n        if (TEXCOORD_0) {\n            uvs = uvs || new Float32Array(vertexCount * 2);\n            uvs.set(TEXCOORD_0.value, i * 2);\n        }\n        i += POSITION.value.length / 3;\n    }\n    const attributes = {};\n    attributes.POSITION = { value: positions, size: 3 };\n    if (normals) {\n        attributes.NORMAL = { value: normals, size: 3 };\n    }\n    if (colors) {\n        attributes.COLOR_0 = { value: colors, size: 3 };\n    }\n    if (uvs) {\n        attributes.TEXCOORD_0 = { value: uvs, size: 2 };\n    }\n    return attributes;\n}\n", "// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n/**\n * Worker loader for the OBJ geometry format\n */\nexport const OBJLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'OBJ',\n    id: 'obj',\n    module: 'obj',\n    version: VERSION,\n    worker: true,\n    extensions: ['obj'],\n    mimeTypes: ['text/plain'],\n    testText: testOBJFile,\n    options: {\n        obj: {}\n    }\n};\nfunction testOBJFile(text) {\n    // TODO - There could be comment line first\n    return text[0] === 'v';\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from THREE.js under MIT license\n// https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/MTLLoader.js\nconst DELIMITER_PATTERN = /\\s+/;\n/**\n * Parses a MTL file.\n * Parses a Wavefront .mtl file specifying materials\n * http://paulbourke.net/dataformats/mtl/\n * https://www.loc.gov/preservation/digital/formats/fdd/fdd000508.shtml\n *\n * @param  text - Content of MTL file\n */\n// eslint-disable-next-line complexity\nexport function parseMTL(text, options) {\n    // const materialsInfo: Record<string, MTLMaterial> = {};\n    const materials = [];\n    let currentMaterial = { name: 'placeholder' };\n    const lines = text.split('\\n');\n    for (let line of lines) {\n        line = line.trim();\n        if (line.length === 0 || line.charAt(0) === '#') {\n            // Blank line or comment ignore\n            continue; // eslint-disable-line no-continue\n        }\n        const pos = line.indexOf(' ');\n        let key = pos >= 0 ? line.substring(0, pos) : line;\n        key = key.toLowerCase();\n        let value = pos >= 0 ? line.substring(pos + 1) : '';\n        value = value.trim();\n        switch (key) {\n            case 'newmtl':\n                // New material\n                currentMaterial = { name: value };\n                // insert into map\n                materials.push(currentMaterial);\n                break;\n            case 'ka': // Ka\n                currentMaterial.ambientColor = parseColor(value);\n                break;\n            case 'kd':\n                // Kd: Diffuse color (color under white light) using RGB values\n                currentMaterial.diffuseColor = parseColor(value);\n                break;\n            case 'map_kd':\n                // Diffuse texture map\n                currentMaterial.diffuseTextureUrl = value;\n                //         setMapForType('map', value);\n                break;\n            case 'ks':\n                // Specular color (color when light is reflected from shiny surface) using RGB values\n                currentMaterial.specularColor = parseColor(value);\n                break;\n            case 'map_ks':\n                // Specular map\n                currentMaterial.specularTextureUrl = value;\n                // setMapForType('specularMap', value);\n                break;\n            case 'ke':\n                // Emissive using RGB values\n                currentMaterial.emissiveColor = parseColor(value);\n                break;\n            case 'map_ke':\n                // Emissive map\n                currentMaterial.emissiveTextureUrl = value;\n                // setMapForType('emissiveMap', value);\n                break;\n            case 'ns':\n                // Ns is material specular exponent (defines the focus of the specular highlight)\n                // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n                currentMaterial.shininess = parseFloat(value);\n                break;\n            case 'map_ns':\n                // Ns is material specular exponent\n                // TODO?\n                // currentMaterial.shininessMap = parseFloat(value);\n                break;\n            case 'ni':\n                currentMaterial.refraction = parseFloat(value);\n                break;\n            case 'illum':\n                currentMaterial.illumination = parseFloat(value);\n                break;\n            default:\n                // log unknown message?\n                break;\n            /*\n            case 'norm':\n              setMapForType('normalMap', value);\n              break;\n      \n            case 'map_bump':\n            case 'bump':\n              // Bump texture map\n              setMapForType('bumpMap', value);\n              break;\n      \n            case 'd':\n              n = parseFloat(value);\n              if (n < 1) {\n                params.opacity = n;\n                params.transparent = true;\n              }\n              break;\n      \n            case 'map_d':\n              // Alpha map\n              setMapForType('alphaMap', value);\n              params.transparent = true;\n              break;\n      \n            case 'tr':\n              n = parseFloat(value);\n              if (this.options && this.options.invertTrProperty) n = 1 - n;\n              if (n > 0) {\n                params.opacity = 1 - n;\n                params.transparent = true;\n              }\n            */\n        }\n    }\n    return materials;\n}\nfunction parseColor(value, options) {\n    const rgb = value.split(DELIMITER_PATTERN, 3);\n    const color = [\n        parseFloat(rgb[0]),\n        parseFloat(rgb[1]),\n        parseFloat(rgb[2])\n    ];\n    // TODO auto detect big values?\n    // if (this.options && this.options.normalizeRGB) {\n    //   value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n    // }\n    // if (this.options && this.options.ignoreZeroRGBs) {\n    //   if (value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0) {\n    //     // ignore\n    //     save = false;\n    //   }\n    // }\n    return color;\n}\n/* TODO parse url options\nfunction parseTexture(value, matParams) {\n  const texParams = {\n    scale: new Vector2(1, 1),\n    offset: new Vector2(0, 0)\n  };\n\n  const items = value.split(/\\s+/);\n  let pos;\n\n  pos = items.indexOf('-bm');\n  if (pos >= 0) {\n    matParams.bumpScale = parseFloat(items[ pos + 1 ]);\n    items.splice(pos, 2);\n  }\n\n  pos = items.indexOf('-s');\n  if (pos >= 0) {\n    texParams.scale.set(parseFloat(items[ pos + 1 ]), parseFloat(items[ pos + 2 ]));\n    items.splice(pos, 4); // we expect 3 parameters here!\n\n  }\n\n  pos = items.indexOf('-o');\n\n  if (pos >= 0) {\n    texParams.offset.set(parseFloat(items[ pos + 1 ]), parseFloat(items[ pos + 2 ]));\n    items.splice(pos, 4); // we expect 3 parameters here!\n  }\n\n  texParams.url = items.join(' ').trim();\n  return texParams;\n}\n\n *function resolveURL(baseUrl, url) {\n * baseUrl?: string;\n    // Absolute URL\n    if (/^https?:\\/\\//i.test(url)) return url;\n    return baseUrl + url;\n  }\n\n  function setMapForType(mapType, value) {\n    if (params[ mapType ]) return; // Keep the first encountered texture\n\n    const texParams = scope.getTextureParams(value, params);\n    const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n\n    map.repeat.copy(texParams.scale);\n    map.offset.copy(texParams.offset);\n\n    map.wrapS = scope.wrap;\n    map.wrapT = scope.wrap;\n\n    params[ mapType ] = map;\n  }\n*/\n", "// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n/**\n * Loader for the MTL material format\n * Parses a Wavefront .mtl file specifying materials\n */\nexport const MTLLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'MTL',\n    id: 'mtl',\n    module: 'mtl',\n    version: VERSION,\n    worker: true,\n    extensions: ['mtl'],\n    mimeTypes: ['text/plain'],\n    testText: (text) => text.includes('newmtl'),\n    options: {\n        mtl: {}\n    }\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { parseOBJ } from \"./lib/parse-obj.js\";\nimport { OBJLoader as OBJWorkerLoader } from \"./obj-loader.js\";\nimport { parseMTL } from \"./lib/parse-mtl.js\";\nimport { MTLLoader as MTLWorkerLoader } from \"./mtl-loader.js\";\nexport { OBJWorkerLoader };\n/**\n * Loader for the OBJ geometry format\n */\nexport const OBJLoader = {\n    ...OBJWorkerLoader,\n    parse: async (arrayBuffer, options) => parseOBJ(new TextDecoder().decode(arrayBuffer), options),\n    parseTextSync: (text, options) => parseOBJ(text, options)\n};\n// MTLLoader\n/**\n * Loader for the MTL material format\n */\nexport const MTLLoader = {\n    ...MTLWorkerLoader,\n    parse: async (arrayBuffer, options) => parseMTL(new TextDecoder().decode(arrayBuffer), options?.mtl),\n    parseTextSync: (text, options) => parseMTL(text, options?.mtl)\n};\n"],
  "mappings": "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",
  "names": ["VERSION", "OBJLoader", "MTLLoader"]
}
