// node_modules/@loaders.gl/schema/dist/lib/table/simple-table/table-accessors.js
function isTable(table) {
  var _a;
  const shape = typeof table === "object" && (table == null ? void 0 : table.shape);
  switch (shape) {
    case "array-row-table":
    case "object-row-table":
      return Array.isArray(table.data);
    case "geojson-table":
      return Array.isArray(table.features);
    case "columnar-table":
      return table.data && typeof table.data === "object";
    case "arrow-table":
      return Boolean(((_a = table == null ? void 0 : table.data) == null ? void 0 : _a.numRows) !== void 0);
    default:
      return false;
  }
}
function getTableLength(table) {
  switch (table.shape) {
    case "array-row-table":
    case "object-row-table":
      return table.data.length;
    case "geojson-table":
      return table.features.length;
    case "arrow-table":
      const arrowTable = table.data;
      return arrowTable.numRows;
    case "columnar-table":
      for (const column of Object.values(table.data)) {
        return column.length || 0;
      }
      return 0;
    default:
      throw new Error("table");
  }
}

// node_modules/@loaders.gl/schema/dist/lib/table/simple-table/make-table-from-batches.js
function makeBatchFromTable(table) {
  return { ...table, length: getTableLength(table), batchType: "data" };
}

// node_modules/@loaders.gl/schema/dist/lib/mesh/mesh-utils.js
function getMeshBoundingBox(attributes) {
  let minX = Infinity;
  let minY = Infinity;
  let minZ = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let maxZ = -Infinity;
  const positions = attributes.POSITION ? attributes.POSITION.value : [];
  const len = positions && positions.length;
  for (let i = 0; i < len; i += 3) {
    const x = positions[i];
    const y = positions[i + 1];
    const z = positions[i + 2];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    minZ = z < minZ ? z : minZ;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    maxZ = z > maxZ ? z : maxZ;
  }
  return [
    [minX, minY, minZ],
    [maxX, maxY, maxZ]
  ];
}

// node_modules/@loaders.gl/schema/dist/lib/table/simple-table/data-type.js
function getDataTypeFromValue(value, defaultNumberType = "float32") {
  if (value instanceof Date) {
    return "date-millisecond";
  }
  if (value instanceof Number) {
    return defaultNumberType;
  }
  if (typeof value === "string") {
    return "utf8";
  }
  if (value === null || value === "undefined") {
    return "null";
  }
  return "null";
}
function getDataTypeFromArray(array) {
  let type = getDataTypeFromTypedArray(array);
  if (type !== "null") {
    return { type, nullable: false };
  }
  if (array.length > 0) {
    type = getDataTypeFromValue(array[0]);
    return { type, nullable: true };
  }
  return { type: "null", nullable: true };
}
function getDataTypeFromTypedArray(array) {
  switch (array.constructor) {
    case Int8Array:
      return "int8";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int16Array:
      return "int16";
    case Uint16Array:
      return "uint16";
    case Int32Array:
      return "int32";
    case Uint32Array:
      return "uint32";
    case Float32Array:
      return "float32";
    case Float64Array:
      return "float64";
    default:
      return "null";
  }
}

// node_modules/@loaders.gl/schema/dist/lib/mesh/deduce-mesh-schema.js
function deduceMeshField(name, attribute, optionalMetadata) {
  const type = getDataTypeFromTypedArray(attribute.value);
  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);
  return {
    name,
    type: { type: "fixed-size-list", listSize: attribute.size, children: [{ name: "value", type }] },
    nullable: false,
    metadata
  };
}
function makeMeshAttributeMetadata(attribute) {
  const result = {};
  if ("byteOffset" in attribute) {
    result.byteOffset = attribute.byteOffset.toString(10);
  }
  if ("byteStride" in attribute) {
    result.byteStride = attribute.byteStride.toString(10);
  }
  if ("normalized" in attribute) {
    result.normalized = attribute.normalized.toString();
  }
  return result;
}

// node_modules/@loaders.gl/schema/dist/lib/table/arrow-api/enum.js
var Type;
(function(Type2) {
  Type2[Type2["NONE"] = 0] = "NONE";
  Type2[Type2["Null"] = 1] = "Null";
  Type2[Type2["Int"] = 2] = "Int";
  Type2[Type2["Float"] = 3] = "Float";
  Type2[Type2["Binary"] = 4] = "Binary";
  Type2[Type2["Utf8"] = 5] = "Utf8";
  Type2[Type2["Bool"] = 6] = "Bool";
  Type2[Type2["Decimal"] = 7] = "Decimal";
  Type2[Type2["Date"] = 8] = "Date";
  Type2[Type2["Time"] = 9] = "Time";
  Type2[Type2["Timestamp"] = 10] = "Timestamp";
  Type2[Type2["Interval"] = 11] = "Interval";
  Type2[Type2["List"] = 12] = "List";
  Type2[Type2["Struct"] = 13] = "Struct";
  Type2[Type2["Union"] = 14] = "Union";
  Type2[Type2["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type2[Type2["FixedSizeList"] = 16] = "FixedSizeList";
  Type2[Type2["Map"] = 17] = "Map";
  Type2[Type2["Dictionary"] = -1] = "Dictionary";
  Type2[Type2["Int8"] = -2] = "Int8";
  Type2[Type2["Int16"] = -3] = "Int16";
  Type2[Type2["Int32"] = -4] = "Int32";
  Type2[Type2["Int64"] = -5] = "Int64";
  Type2[Type2["Uint8"] = -6] = "Uint8";
  Type2[Type2["Uint16"] = -7] = "Uint16";
  Type2[Type2["Uint32"] = -8] = "Uint32";
  Type2[Type2["Uint64"] = -9] = "Uint64";
  Type2[Type2["Float16"] = -10] = "Float16";
  Type2[Type2["Float32"] = -11] = "Float32";
  Type2[Type2["Float64"] = -12] = "Float64";
  Type2[Type2["DateDay"] = -13] = "DateDay";
  Type2[Type2["DateMillisecond"] = -14] = "DateMillisecond";
  Type2[Type2["TimestampSecond"] = -15] = "TimestampSecond";
  Type2[Type2["TimestampMillisecond"] = -16] = "TimestampMillisecond";
  Type2[Type2["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
  Type2[Type2["TimestampNanosecond"] = -18] = "TimestampNanosecond";
  Type2[Type2["TimeSecond"] = -19] = "TimeSecond";
  Type2[Type2["TimeMillisecond"] = -20] = "TimeMillisecond";
  Type2[Type2["TimeMicrosecond"] = -21] = "TimeMicrosecond";
  Type2[Type2["TimeNanosecond"] = -22] = "TimeNanosecond";
  Type2[Type2["DenseUnion"] = -23] = "DenseUnion";
  Type2[Type2["SparseUnion"] = -24] = "SparseUnion";
  Type2[Type2["IntervalDayTime"] = -25] = "IntervalDayTime";
  Type2[Type2["IntervalYearMonth"] = -26] = "IntervalYearMonth";
})(Type || (Type = {}));

export {
  getDataTypeFromArray,
  isTable,
  makeBatchFromTable,
  getMeshBoundingBox,
  deduceMeshField
};
//# sourceMappingURL=chunk-EHZSQIWE.js.map
