{
  "version": 3,
  "sources": ["../../@loaders.gl/schema/dist/lib/table/simple-table/table-accessors.js", "../../@loaders.gl/schema/dist/lib/table/simple-table/make-table-from-batches.js", "../../@loaders.gl/schema/dist/lib/mesh/mesh-utils.js", "../../@loaders.gl/schema/dist/lib/table/simple-table/data-type.js", "../../@loaders.gl/schema/dist/lib/mesh/deduce-mesh-schema.js", "../../@loaders.gl/schema/dist/lib/table/arrow-api/enum.js"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport function isTable(table) {\n    const shape = typeof table === 'object' && table?.shape;\n    switch (shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return Array.isArray(table.data);\n        case 'geojson-table':\n            return Array.isArray(table.features);\n        case 'columnar-table':\n            return table.data && typeof table.data === 'object';\n        case 'arrow-table':\n            return Boolean(table?.data?.numRows !== undefined);\n        default:\n            return false;\n    }\n}\n/**\n * Returns the length of the table (i.e. the number of rows)\n */\nexport function getTableLength(table) {\n    switch (table.shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return table.data.length;\n        case 'geojson-table':\n            return table.features.length;\n        case 'arrow-table':\n            const arrowTable = table.data;\n            return arrowTable.numRows;\n        case 'columnar-table':\n            for (const column of Object.values(table.data)) {\n                return column.length || 0;\n            }\n            return 0;\n        default:\n            throw new Error('table');\n    }\n}\n/**\n * Returns the number of columns in the table\n * @throws Fails to deduce number of columns if the table has no schema and is empty\n */\nexport function getTableNumCols(table) {\n    if (table.schema) {\n        return table.schema.fields.length;\n    }\n    if (getTableLength(table) === 0) {\n        throw new Error('empty table');\n    }\n    switch (table.shape) {\n        case 'array-row-table':\n            return table.data[0].length;\n        case 'object-row-table':\n            return Object.keys(table.data[0]).length;\n        case 'geojson-table':\n            return Object.keys(table.features[0]).length;\n        case 'columnar-table':\n            return Object.keys(table.data).length;\n        case 'arrow-table':\n            const arrowTable = table.data;\n            return arrowTable.numCols;\n        default:\n            throw new Error('table');\n    }\n}\n/** Get a table cell value at row index and column name */\nexport function getTableCell(table, rowIndex, columnName) {\n    switch (table.shape) {\n        case 'array-row-table':\n            const columnIndex = getTableColumnIndex(table, columnName);\n            return table.data[rowIndex][columnIndex];\n        case 'object-row-table':\n            return table.data[rowIndex][columnName];\n        case 'geojson-table':\n            return table.features[rowIndex][columnName];\n        case 'columnar-table':\n            const column = table.data[columnName];\n            return column[rowIndex];\n        case 'arrow-table':\n            const arrowTable = table.data;\n            const arrowColumnIndex = arrowTable.schema.fields.findIndex((field) => field.name === columnName);\n            return arrowTable.getChildAt(arrowColumnIndex)?.get(rowIndex);\n        default:\n            throw new Error('todo');\n    }\n}\n/** Get a table cell value at row index and column name */\nexport function getTableCellAt(table, rowIndex, columnIndex) {\n    switch (table.shape) {\n        case 'array-row-table':\n            return table.data[rowIndex][columnIndex];\n        case 'object-row-table':\n            const columnName1 = getTableColumnName(table, columnIndex);\n            return table.data[rowIndex][columnName1];\n        case 'geojson-table':\n            const columnName2 = getTableColumnName(table, columnIndex);\n            return table.features[rowIndex][columnName2];\n        case 'columnar-table':\n            const columnName3 = getTableColumnName(table, columnIndex);\n            const column = table.data[columnName3];\n            return column[rowIndex];\n        case 'arrow-table':\n            const arrowTable = table.data;\n            return arrowTable.getChildAt(columnIndex)?.get(rowIndex);\n        default:\n            throw new Error('todo');\n    }\n}\n/** Deduce the table row shape */\nexport function getTableRowShape(table) {\n    switch (table.shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return table.shape;\n        case 'geojson-table':\n            // TODO - this is not correct, geojson-table is not a row table\n            return 'object-row-table';\n        case 'columnar-table':\n        default:\n            throw new Error('Not a row table');\n    }\n}\n/** Get the index of a named table column. Requires the table to have a schema */\nexport function getTableColumnIndex(table, columnName) {\n    const columnIndex = table.schema?.fields.findIndex((field) => field.name === columnName);\n    if (columnIndex === undefined) {\n        throw new Error(columnName);\n    }\n    return columnIndex;\n}\n/** Get the name of a table column by index. Requires the table to have a schema */\nexport function getTableColumnName(table, columnIndex) {\n    const columnName = table.schema?.fields[columnIndex]?.name;\n    if (!columnName) {\n        throw new Error(`${columnIndex}`);\n    }\n    return columnName;\n}\n/**\n * Returns one row of the table in object format.\n * @param target Optional parameter will be used if needed to store the row. Can be reused between calls to improve performance\n * @returns an array representing the row. May be the original array in the row, a new object, or the target parameter\n */\n// eslint-disable-next-line complexity\nexport function getTableRowAsObject(table, rowIndex, target, copy) {\n    switch (table.shape) {\n        case 'object-row-table':\n            return copy ? Object.fromEntries(Object.entries(table.data[rowIndex])) : table.data[rowIndex];\n        case 'array-row-table':\n            if (table.schema) {\n                const objectRow = target || {};\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    objectRow[table.schema.fields[i].name] = table.data[rowIndex][i];\n                }\n                return objectRow;\n            }\n            throw new Error('no schema');\n        case 'geojson-table':\n            if (table.schema) {\n                const objectRow = target || {};\n                // TODO - should lift properties to top level\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    objectRow[table.schema.fields[i].name] = table.features[rowIndex][i];\n                }\n                return objectRow;\n            }\n            throw new Error('no schema');\n        case 'columnar-table':\n            if (table.schema) {\n                const objectRow = target || {};\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    objectRow[table.schema.fields[i].name] =\n                        table.data[table.schema.fields[i].name][rowIndex];\n                }\n                return objectRow;\n            }\n            else {\n                // eslint-disable-line no-else-return\n                const objectRow = target || {};\n                for (const [name, column] of Object.entries(table.data)) {\n                    objectRow[name] = column[rowIndex];\n                }\n                return objectRow;\n            }\n        case 'arrow-table':\n            const arrowTable = table.data;\n            const objectRow = target || {};\n            const row = arrowTable.get(rowIndex);\n            const schema = arrowTable.schema;\n            for (let i = 0; i < schema.fields.length; i++) {\n                objectRow[schema.fields[i].name] = row?.[schema.fields[i].name];\n            }\n            return objectRow;\n        default:\n            throw new Error('shape');\n    }\n}\n/**\n * Returns one row of the table in array format.\n * @param target Optional parameter will be used if needed to store the row. Can be reused between calls to improve performance.\n * @returns an array representing the row. May be the original array in the row, a new object, or the target parameter\n */\n// eslint-disable-next-line complexity\nexport function getTableRowAsArray(table, rowIndex, target, copy) {\n    switch (table.shape) {\n        case 'array-row-table':\n            return copy ? Array.from(table.data[rowIndex]) : table.data[rowIndex];\n        case 'object-row-table':\n            if (table.schema) {\n                const arrayRow = target || [];\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    arrayRow[i] = table.data[rowIndex][table.schema.fields[i].name];\n                }\n                return arrayRow;\n            }\n            // Warning: just slap on the values, this risks mismatches between rows\n            return Object.values(table.data[rowIndex]);\n        case 'geojson-table':\n            if (table.schema) {\n                const arrayRow = target || [];\n                // TODO - should lift properties to top level\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    arrayRow[i] = table.features[rowIndex][table.schema.fields[i].name];\n                }\n                return arrayRow;\n            }\n            // Warning: just slap on the values, this risks mismatches between rows\n            return Object.values(table.features[rowIndex]);\n        case 'columnar-table':\n            if (table.schema) {\n                const arrayRow = target || [];\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    arrayRow[i] = table.data[table.schema.fields[i].name][rowIndex];\n                }\n                return arrayRow;\n            }\n            else {\n                // eslint-disable-line no-else-return\n                const arrayRow = target || [];\n                let i = 0;\n                for (const column of Object.values(table.data)) {\n                    arrayRow[i] = column[rowIndex];\n                    i++;\n                }\n                return arrayRow;\n            }\n        case 'arrow-table':\n            const arrowTable = table.data;\n            const arrayRow = target || [];\n            const row = arrowTable.get(rowIndex);\n            const schema = arrowTable.schema;\n            for (let i = 0; i < schema.fields.length; i++) {\n                arrayRow[i] = row?.[schema.fields[i].name];\n            }\n            return arrayRow;\n        default:\n            throw new Error('shape');\n    }\n}\n/** Convert any table into array row format */\nexport function makeArrayRowTable(table) {\n    if (table.shape === 'array-row-table') {\n        return table;\n    }\n    const length = getTableLength(table);\n    const data = new Array(length);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        data[rowIndex] = getTableRowAsArray(table, rowIndex);\n    }\n    return {\n        shape: 'array-row-table',\n        schema: table.schema,\n        data\n    };\n}\n/** Convert any table into object row format */\nexport function makeObjectRowTable(table) {\n    if (table.shape === 'object-row-table') {\n        return table;\n    }\n    const length = getTableLength(table);\n    const data = new Array(length);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        data[rowIndex] = getTableRowAsObject(table, rowIndex);\n    }\n    return {\n        shape: 'object-row-table',\n        schema: table.schema,\n        data\n    };\n}\n/** Convert any table into object row format */\nexport function makeColumnarTable(table) {\n    if (table.shape === 'object-row-table') {\n        return table;\n    }\n    const length = getTableLength(table);\n    const data = new Array(length);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        data[rowIndex] = getTableRowAsObject(table, rowIndex);\n    }\n    return {\n        shape: 'object-row-table',\n        schema: table.schema,\n        data\n    };\n}\n// Row Iterators\n/**\n * Iterate over table rows\n * @param table\n * @param shape\n */\nexport function* makeRowIterator(table, shape) {\n    switch (shape) {\n        case 'array-row-table':\n            yield* makeArrayRowIterator(table);\n            break;\n        case 'object-row-table':\n            yield* makeObjectRowIterator(table);\n            break;\n        default:\n            throw new Error(`Unknown row type ${shape}`);\n    }\n}\n/**\n * Streaming processing: Iterate over table, yielding array rows\n * @param table\n * @param shape\n */\nexport function* makeArrayRowIterator(table, target = []) {\n    const length = getTableLength(table);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        yield getTableRowAsArray(table, rowIndex, target);\n    }\n}\n/**\n * Streaming processing: Iterate over table, yielding object rows\n * @param table\n * @param shape\n */\nexport function* makeObjectRowIterator(table, target = {}) {\n    const length = getTableLength(table);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        yield getTableRowAsObject(table, rowIndex, target);\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getTableLength } from \"./table-accessors.js\";\n/**\n * Returns an iterator that yields a single table as a sequence of batches.\n * @note Currently only a single batch is yielded.\n * @note All batches will have the same shape and schema as the original table.\n * @returns\n */\nexport function* makeBatchesFromTable(table) {\n    yield makeBatchFromTable(table);\n}\n/**\n * Returns a table packaged as a single table batch\n * @note The batch will have the same shape and schema as the original table.\n * @returns `null` if no batches are yielded by the async iterator\n */\nexport function makeBatchFromTable(table) {\n    return { ...table, length: getTableLength(table), batchType: 'data' };\n}\n/**\n * Assembles all batches from an async iterator into a single table.\n * @note All batches must have the same shape and schema\n * @param batchIterator\n * @returns `null` if no batches are yielded by the async iterator\n */\n// eslint-disable-next-line complexity\nexport async function makeTableFromBatches(batchIterator) {\n    let arrayRows;\n    let objectRows;\n    let features;\n    let shape = null;\n    let schema;\n    for await (const batch of batchIterator) {\n        shape = shape || batch.shape;\n        schema = schema || batch.schema;\n        switch (batch.shape) {\n            case 'array-row-table':\n                arrayRows = arrayRows || [];\n                for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n                    const row = batch.data[rowIndex];\n                    arrayRows.push(row);\n                }\n                break;\n            case 'object-row-table':\n                objectRows = objectRows || [];\n                for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n                    const row = batch.data[rowIndex];\n                    objectRows.push(row);\n                }\n                break;\n            case 'geojson-table':\n                features = features || [];\n                for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n                    const row = batch.features[rowIndex];\n                    features.push(row);\n                }\n                break;\n            case 'columnar-table':\n            case 'arrow-table':\n            default:\n                throw new Error('shape');\n        }\n    }\n    if (!shape) {\n        return null;\n    }\n    switch (shape) {\n        case 'array-row-table':\n            return { shape: 'array-row-table', data: arrayRows, schema };\n        case 'object-row-table':\n            return { shape: 'object-row-table', data: objectRows, schema };\n        case 'geojson-table':\n            return { shape: 'geojson-table', type: 'FeatureCollection', features: features, schema };\n        default:\n            return null;\n    }\n}\n", "/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes) {\n    let size = 0;\n    for (const attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        if (ArrayBuffer.isView(attribute)) {\n            // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n            size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n        }\n    }\n    return size;\n}\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes) {\n    let minX = Infinity;\n    let minY = Infinity;\n    let minZ = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let maxZ = -Infinity;\n    const positions = attributes.POSITION ? attributes.POSITION.value : [];\n    const len = positions && positions.length;\n    for (let i = 0; i < len; i += 3) {\n        const x = positions[i];\n        const y = positions[i + 1];\n        const z = positions[i + 2];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        minZ = z < minZ ? z : minZ;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n        maxZ = z > maxZ ? z : maxZ;\n    }\n    return [\n        [minX, minY, minZ],\n        [maxX, maxY, maxZ]\n    ];\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Deduce column types from values */\nexport function getDataTypeFromValue(value, defaultNumberType = 'float32') {\n    if (value instanceof Date) {\n        return 'date-millisecond';\n    }\n    if (value instanceof Number) {\n        return defaultNumberType;\n    }\n    if (typeof value === 'string') {\n        return 'utf8';\n    }\n    if (value === null || value === 'undefined') {\n        return 'null';\n    }\n    return 'null';\n}\n/**\n * Deduces a simple data type \"descriptor from a typed array instance\n */\nexport function getDataTypeFromArray(array) {\n    let type = getDataTypeFromTypedArray(array);\n    if (type !== 'null') {\n        return { type, nullable: false };\n    }\n    if (array.length > 0) {\n        type = getDataTypeFromValue(array[0]);\n        return { type, nullable: true };\n    }\n    return { type: 'null', nullable: true };\n}\n/**\n * Deduces a simple data type \"descriptor from a typed array instance\n */\nexport function getDataTypeFromTypedArray(array) {\n    switch (array.constructor) {\n        case Int8Array:\n            return 'int8';\n        case Uint8Array:\n        case Uint8ClampedArray:\n            return 'uint8';\n        case Int16Array:\n            return 'int16';\n        case Uint16Array:\n            return 'uint16';\n        case Int32Array:\n            return 'int32';\n        case Uint32Array:\n            return 'uint32';\n        case Float32Array:\n            return 'float32';\n        case Float64Array:\n            return 'float64';\n        default:\n            return 'null';\n    }\n}\nexport function getArrayTypeFromDataType(type, nullable) {\n    if (!nullable) {\n        switch (type) {\n            case 'int8':\n                return Int8Array;\n            case 'uint8':\n                return Uint8Array;\n            case 'int16':\n                return Int16Array;\n            case 'uint16':\n                return Uint16Array;\n            case 'int32':\n                return Int32Array;\n            case 'uint32':\n                return Uint32Array;\n            case 'float32':\n                return Float32Array;\n            case 'float64':\n                return Float64Array;\n            default:\n                break;\n        }\n    }\n    // if (typeof BigInt64Array !== 'undefined') {\n    //   TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n    //   TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n    // }\n    return Array;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getDataTypeFromTypedArray } from \"../table/simple-table/data-type.js\";\n/**\n * Create a schema for mesh attributes data\n * @param attributes\n * @param metadata\n * @returns\n */\nexport function deduceMeshSchema(attributes, metadata = {}) {\n    const fields = deduceMeshFields(attributes);\n    return { fields, metadata };\n}\n/**\n * Create arrow-like schema field for mesh attribute\n * @param attributeName\n * @param attribute\n * @param optionalMetadata\n * @returns\n */\nexport function deduceMeshField(name, attribute, optionalMetadata) {\n    const type = getDataTypeFromTypedArray(attribute.value);\n    const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n    return {\n        name,\n        type: { type: 'fixed-size-list', listSize: attribute.size, children: [{ name: 'value', type }] },\n        nullable: false,\n        metadata\n    };\n}\n/**\n * Create fields array for mesh attributes\n * @param attributes\n * @returns\n */\nfunction deduceMeshFields(attributes) {\n    const fields = [];\n    for (const attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        fields.push(deduceMeshField(attributeName, attribute));\n    }\n    return fields;\n}\n/**\n * Make metadata by mesh attribute properties\n * @param attribute\n * @returns\n */\nexport function makeMeshAttributeMetadata(attribute) {\n    const result = {};\n    if ('byteOffset' in attribute) {\n        result.byteOffset = attribute.byteOffset.toString(10);\n    }\n    if ('byteStride' in attribute) {\n        result.byteStride = attribute.byteStride.toString(10);\n    }\n    if ('normalized' in attribute) {\n        result.normalized = attribute.normalized.toString();\n    }\n    return result;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n/**\n * Main data type enumeration.\n *\n * Data types in this library are all *logical*. They can be expressed as\n * either a primitive physical type (bytes or bits of some fixed size), a\n * nested type consisting of other data types, or another data type (e.g. a\n * timestamp encoded as an int64).\n *\n * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow\n * IPC payload.\n *\n * The rest of the values are specified here so TypeScript can narrow the type\n * signatures further beyond the base Arrow Types. The Arrow DataTypes include\n * metadata like `bitWidth` that impact the type signatures of the values we\n * accept and return.\n *\n * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an\n * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`\n * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the\n * underlying `Int32Array`.\n *\n * Library consumers benefit by knowing the narrowest type, since we can ensure\n * the types across all public methods are propagated, and never bail to `any`.\n * These values are _never_ used at runtime, and they will _never_ be written\n * to the flatbuffers metadata of serialized Arrow IPC payloads.\n */\nexport var Type;\n(function (Type) {\n    /** The default placeholder type */\n    Type[Type[\"NONE\"] = 0] = \"NONE\";\n    /** A NULL type having no physical storage */\n    Type[Type[\"Null\"] = 1] = \"Null\";\n    /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */\n    Type[Type[\"Int\"] = 2] = \"Int\";\n    /** 2, 4, or 8-byte floating point value */\n    Type[Type[\"Float\"] = 3] = \"Float\";\n    /** Variable-length bytes (no guarantee of UTF8-ness) */\n    Type[Type[\"Binary\"] = 4] = \"Binary\";\n    /** UTF8 variable-length string as List<Char> */\n    Type[Type[\"Utf8\"] = 5] = \"Utf8\";\n    /** Boolean as 1 bit, LSB bit-packed ordering */\n    Type[Type[\"Bool\"] = 6] = \"Bool\";\n    /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */\n    Type[Type[\"Decimal\"] = 7] = \"Decimal\";\n    /** int32_t days or int64_t milliseconds since the UNIX epoch */\n    Type[Type[\"Date\"] = 8] = \"Date\";\n    /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */\n    Type[Type[\"Time\"] = 9] = \"Time\";\n    /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */\n    Type[Type[\"Timestamp\"] = 10] = \"Timestamp\";\n    /** YEAR_MONTH or DAY_TIME interval in SQL style */\n    Type[Type[\"Interval\"] = 11] = \"Interval\";\n    /** A list of some logical data type */\n    Type[Type[\"List\"] = 12] = \"List\";\n    /** Struct of logical types */\n    Type[Type[\"Struct\"] = 13] = \"Struct\";\n    /** Union of logical types */\n    Type[Type[\"Union\"] = 14] = \"Union\";\n    /** Fixed-size binary. Each value occupies the same number of bytes */\n    Type[Type[\"FixedSizeBinary\"] = 15] = \"FixedSizeBinary\";\n    /** Fixed-size list. Each value occupies the same number of bytes */\n    Type[Type[\"FixedSizeList\"] = 16] = \"FixedSizeList\";\n    /** Map of named logical types */\n    Type[Type[\"Map\"] = 17] = \"Map\";\n    /** Dictionary aka Category type */\n    Type[Type[\"Dictionary\"] = -1] = \"Dictionary\";\n    Type[Type[\"Int8\"] = -2] = \"Int8\";\n    Type[Type[\"Int16\"] = -3] = \"Int16\";\n    Type[Type[\"Int32\"] = -4] = \"Int32\";\n    Type[Type[\"Int64\"] = -5] = \"Int64\";\n    Type[Type[\"Uint8\"] = -6] = \"Uint8\";\n    Type[Type[\"Uint16\"] = -7] = \"Uint16\";\n    Type[Type[\"Uint32\"] = -8] = \"Uint32\";\n    Type[Type[\"Uint64\"] = -9] = \"Uint64\";\n    Type[Type[\"Float16\"] = -10] = \"Float16\";\n    Type[Type[\"Float32\"] = -11] = \"Float32\";\n    Type[Type[\"Float64\"] = -12] = \"Float64\";\n    Type[Type[\"DateDay\"] = -13] = \"DateDay\";\n    Type[Type[\"DateMillisecond\"] = -14] = \"DateMillisecond\";\n    Type[Type[\"TimestampSecond\"] = -15] = \"TimestampSecond\";\n    Type[Type[\"TimestampMillisecond\"] = -16] = \"TimestampMillisecond\";\n    Type[Type[\"TimestampMicrosecond\"] = -17] = \"TimestampMicrosecond\";\n    Type[Type[\"TimestampNanosecond\"] = -18] = \"TimestampNanosecond\";\n    Type[Type[\"TimeSecond\"] = -19] = \"TimeSecond\";\n    Type[Type[\"TimeMillisecond\"] = -20] = \"TimeMillisecond\";\n    Type[Type[\"TimeMicrosecond\"] = -21] = \"TimeMicrosecond\";\n    Type[Type[\"TimeNanosecond\"] = -22] = \"TimeNanosecond\";\n    Type[Type[\"DenseUnion\"] = -23] = \"DenseUnion\";\n    Type[Type[\"SparseUnion\"] = -24] = \"SparseUnion\";\n    Type[Type[\"IntervalDayTime\"] = -25] = \"IntervalDayTime\";\n    Type[Type[\"IntervalYearMonth\"] = -26] = \"IntervalYearMonth\";\n})(Type || (Type = {}));\n"],
  "mappings": ";AAGO,SAAS,QAAQ,OAAO;AAH/B;AAII,QAAM,QAAQ,OAAO,UAAU,aAAY,+BAAO;AAClD,UAAQ,OAAO;AAAA,IACX,KAAK;AAAA,IACL,KAAK;AACD,aAAO,MAAM,QAAQ,MAAM,IAAI;AAAA,IACnC,KAAK;AACD,aAAO,MAAM,QAAQ,MAAM,QAAQ;AAAA,IACvC,KAAK;AACD,aAAO,MAAM,QAAQ,OAAO,MAAM,SAAS;AAAA,IAC/C,KAAK;AACD,aAAO,UAAQ,oCAAO,SAAP,mBAAa,aAAY,MAAS;AAAA,IACrD;AACI,aAAO;AAAA,EACf;AACJ;AAIO,SAAS,eAAe,OAAO;AAClC,UAAQ,MAAM,OAAO;AAAA,IACjB,KAAK;AAAA,IACL,KAAK;AACD,aAAO,MAAM,KAAK;AAAA,IACtB,KAAK;AACD,aAAO,MAAM,SAAS;AAAA,IAC1B,KAAK;AACD,YAAM,aAAa,MAAM;AACzB,aAAO,WAAW;AAAA,IACtB,KAAK;AACD,iBAAW,UAAU,OAAO,OAAO,MAAM,IAAI,GAAG;AAC5C,eAAO,OAAO,UAAU;AAAA,MAC5B;AACA,aAAO;AAAA,IACX;AACI,YAAM,IAAI,MAAM,OAAO;AAAA,EAC/B;AACJ;;;ACtBO,SAAS,mBAAmB,OAAO;AACtC,SAAO,EAAE,GAAG,OAAO,QAAQ,eAAe,KAAK,GAAG,WAAW,OAAO;AACxE;;;ACCO,SAAS,mBAAmB,YAAY;AAC3C,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAI,OAAO;AACX,QAAM,YAAY,WAAW,WAAW,WAAW,SAAS,QAAQ,CAAC;AACrE,QAAM,MAAM,aAAa,UAAU;AACnC,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK,GAAG;AAC7B,UAAM,IAAI,UAAU,CAAC;AACrB,UAAM,IAAI,UAAU,IAAI,CAAC;AACzB,UAAM,IAAI,UAAU,IAAI,CAAC;AACzB,WAAO,IAAI,OAAO,IAAI;AACtB,WAAO,IAAI,OAAO,IAAI;AACtB,WAAO,IAAI,OAAO,IAAI;AACtB,WAAO,IAAI,OAAO,IAAI;AACtB,WAAO,IAAI,OAAO,IAAI;AACtB,WAAO,IAAI,OAAO,IAAI;AAAA,EAC1B;AACA,SAAO;AAAA,IACH,CAAC,MAAM,MAAM,IAAI;AAAA,IACjB,CAAC,MAAM,MAAM,IAAI;AAAA,EACrB;AACJ;;;ACzCO,SAAS,qBAAqB,OAAO,oBAAoB,WAAW;AACvE,MAAI,iBAAiB,MAAM;AACvB,WAAO;AAAA,EACX;AACA,MAAI,iBAAiB,QAAQ;AACzB,WAAO;AAAA,EACX;AACA,MAAI,OAAO,UAAU,UAAU;AAC3B,WAAO;AAAA,EACX;AACA,MAAI,UAAU,QAAQ,UAAU,aAAa;AACzC,WAAO;AAAA,EACX;AACA,SAAO;AACX;AAIO,SAAS,qBAAqB,OAAO;AACxC,MAAI,OAAO,0BAA0B,KAAK;AAC1C,MAAI,SAAS,QAAQ;AACjB,WAAO,EAAE,MAAM,UAAU,MAAM;AAAA,EACnC;AACA,MAAI,MAAM,SAAS,GAAG;AAClB,WAAO,qBAAqB,MAAM,CAAC,CAAC;AACpC,WAAO,EAAE,MAAM,UAAU,KAAK;AAAA,EAClC;AACA,SAAO,EAAE,MAAM,QAAQ,UAAU,KAAK;AAC1C;AAIO,SAAS,0BAA0B,OAAO;AAC7C,UAAQ,MAAM,aAAa;AAAA,IACvB,KAAK;AACD,aAAO;AAAA,IACX,KAAK;AAAA,IACL,KAAK;AACD,aAAO;AAAA,IACX,KAAK;AACD,aAAO;AAAA,IACX,KAAK;AACD,aAAO;AAAA,IACX,KAAK;AACD,aAAO;AAAA,IACX,KAAK;AACD,aAAO;AAAA,IACX,KAAK;AACD,aAAO;AAAA,IACX,KAAK;AACD,aAAO;AAAA,IACX;AACI,aAAO;AAAA,EACf;AACJ;;;ACrCO,SAAS,gBAAgB,MAAM,WAAW,kBAAkB;AAC/D,QAAM,OAAO,0BAA0B,UAAU,KAAK;AACtD,QAAM,WAAW,mBAAmB,mBAAmB,0BAA0B,SAAS;AAC1F,SAAO;AAAA,IACH;AAAA,IACA,MAAM,EAAE,MAAM,mBAAmB,UAAU,UAAU,MAAM,UAAU,CAAC,EAAE,MAAM,SAAS,KAAK,CAAC,EAAE;AAAA,IAC/F,UAAU;AAAA,IACV;AAAA,EACJ;AACJ;AAmBO,SAAS,0BAA0B,WAAW;AACjD,QAAM,SAAS,CAAC;AAChB,MAAI,gBAAgB,WAAW;AAC3B,WAAO,aAAa,UAAU,WAAW,SAAS,EAAE;AAAA,EACxD;AACA,MAAI,gBAAgB,WAAW;AAC3B,WAAO,aAAa,UAAU,WAAW,SAAS,EAAE;AAAA,EACxD;AACA,MAAI,gBAAgB,WAAW;AAC3B,WAAO,aAAa,UAAU,WAAW,SAAS;AAAA,EACtD;AACA,SAAO;AACX;;;AC9BO,IAAI;AAAA,CACV,SAAUA,OAAM;AAEb,EAAAA,MAAKA,MAAK,MAAM,IAAI,CAAC,IAAI;AAEzB,EAAAA,MAAKA,MAAK,MAAM,IAAI,CAAC,IAAI;AAEzB,EAAAA,MAAKA,MAAK,KAAK,IAAI,CAAC,IAAI;AAExB,EAAAA,MAAKA,MAAK,OAAO,IAAI,CAAC,IAAI;AAE1B,EAAAA,MAAKA,MAAK,QAAQ,IAAI,CAAC,IAAI;AAE3B,EAAAA,MAAKA,MAAK,MAAM,IAAI,CAAC,IAAI;AAEzB,EAAAA,MAAKA,MAAK,MAAM,IAAI,CAAC,IAAI;AAEzB,EAAAA,MAAKA,MAAK,SAAS,IAAI,CAAC,IAAI;AAE5B,EAAAA,MAAKA,MAAK,MAAM,IAAI,CAAC,IAAI;AAEzB,EAAAA,MAAKA,MAAK,MAAM,IAAI,CAAC,IAAI;AAEzB,EAAAA,MAAKA,MAAK,WAAW,IAAI,EAAE,IAAI;AAE/B,EAAAA,MAAKA,MAAK,UAAU,IAAI,EAAE,IAAI;AAE9B,EAAAA,MAAKA,MAAK,MAAM,IAAI,EAAE,IAAI;AAE1B,EAAAA,MAAKA,MAAK,QAAQ,IAAI,EAAE,IAAI;AAE5B,EAAAA,MAAKA,MAAK,OAAO,IAAI,EAAE,IAAI;AAE3B,EAAAA,MAAKA,MAAK,iBAAiB,IAAI,EAAE,IAAI;AAErC,EAAAA,MAAKA,MAAK,eAAe,IAAI,EAAE,IAAI;AAEnC,EAAAA,MAAKA,MAAK,KAAK,IAAI,EAAE,IAAI;AAEzB,EAAAA,MAAKA,MAAK,YAAY,IAAI,EAAE,IAAI;AAChC,EAAAA,MAAKA,MAAK,MAAM,IAAI,EAAE,IAAI;AAC1B,EAAAA,MAAKA,MAAK,OAAO,IAAI,EAAE,IAAI;AAC3B,EAAAA,MAAKA,MAAK,OAAO,IAAI,EAAE,IAAI;AAC3B,EAAAA,MAAKA,MAAK,OAAO,IAAI,EAAE,IAAI;AAC3B,EAAAA,MAAKA,MAAK,OAAO,IAAI,EAAE,IAAI;AAC3B,EAAAA,MAAKA,MAAK,QAAQ,IAAI,EAAE,IAAI;AAC5B,EAAAA,MAAKA,MAAK,QAAQ,IAAI,EAAE,IAAI;AAC5B,EAAAA,MAAKA,MAAK,QAAQ,IAAI,EAAE,IAAI;AAC5B,EAAAA,MAAKA,MAAK,SAAS,IAAI,GAAG,IAAI;AAC9B,EAAAA,MAAKA,MAAK,SAAS,IAAI,GAAG,IAAI;AAC9B,EAAAA,MAAKA,MAAK,SAAS,IAAI,GAAG,IAAI;AAC9B,EAAAA,MAAKA,MAAK,SAAS,IAAI,GAAG,IAAI;AAC9B,EAAAA,MAAKA,MAAK,iBAAiB,IAAI,GAAG,IAAI;AACtC,EAAAA,MAAKA,MAAK,iBAAiB,IAAI,GAAG,IAAI;AACtC,EAAAA,MAAKA,MAAK,sBAAsB,IAAI,GAAG,IAAI;AAC3C,EAAAA,MAAKA,MAAK,sBAAsB,IAAI,GAAG,IAAI;AAC3C,EAAAA,MAAKA,MAAK,qBAAqB,IAAI,GAAG,IAAI;AAC1C,EAAAA,MAAKA,MAAK,YAAY,IAAI,GAAG,IAAI;AACjC,EAAAA,MAAKA,MAAK,iBAAiB,IAAI,GAAG,IAAI;AACtC,EAAAA,MAAKA,MAAK,iBAAiB,IAAI,GAAG,IAAI;AACtC,EAAAA,MAAKA,MAAK,gBAAgB,IAAI,GAAG,IAAI;AACrC,EAAAA,MAAKA,MAAK,YAAY,IAAI,GAAG,IAAI;AACjC,EAAAA,MAAKA,MAAK,aAAa,IAAI,GAAG,IAAI;AAClC,EAAAA,MAAKA,MAAK,iBAAiB,IAAI,GAAG,IAAI;AACtC,EAAAA,MAAKA,MAAK,mBAAmB,IAAI,GAAG,IAAI;AAC5C,GAAG,SAAS,OAAO,CAAC,EAAE;",
  "names": ["Type"]
}
