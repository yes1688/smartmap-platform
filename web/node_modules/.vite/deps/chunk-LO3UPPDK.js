import {
  Log,
  Stats
} from "./chunk-5S5NFWAX.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-DC5AMYBS.js";

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "loader assertion failed.");
  }
}

// node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js
var globals = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_ = globals.self || globals.window || globals.global || {};
var window_ = globals.window || globals.self || globals.global || {};
var global_ = globals.global || globals.self || globals.window || {};
var document_ = globals.document || {};
var isBrowser = (
  // @ts-ignore process does not exist on browser
  Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser)
);
var isWorker = typeof importScripts === "function";
var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion = matches && parseFloat(matches[1]) || 0;

// node_modules/@loaders.gl/loader-utils/dist/lib/iterators/text-iterators.js
async function* makeTextDecoderIterator(arrayBufferIterator, options = {}) {
  const textDecoder = new TextDecoder(void 0, options);
  for await (const arrayBuffer of arrayBufferIterator) {
    yield typeof arrayBuffer === "string" ? arrayBuffer : textDecoder.decode(arrayBuffer, { stream: true });
  }
}
async function* makeTextEncoderIterator(textIterator) {
  const textEncoder = new TextEncoder();
  for await (const text of textIterator) {
    yield typeof text === "string" ? textEncoder.encode(text) : text;
  }
}
async function* makeLineIterator(textIterator) {
  let previous = "";
  for await (const textChunk of textIterator) {
    previous += textChunk;
    let eolIndex;
    while ((eolIndex = previous.indexOf("\n")) >= 0) {
      const line = previous.slice(0, eolIndex + 1);
      previous = previous.slice(eolIndex + 1);
      yield line;
    }
  }
  if (previous.length > 0) {
    yield previous;
  }
}
async function* makeNumberedLineIterator(lineIterator) {
  let counter = 1;
  for await (const line of lineIterator) {
    yield { counter, line };
    counter++;
  }
}

// node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function concatenateArrayBuffers(...sources) {
  return concatenateArrayBuffersFromArray(sources);
}
function concatenateArrayBuffersFromArray(sources) {
  const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }
  return result.buffer;
}
function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  const subArray = byteLength !== void 0 ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
  const arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js
async function forEach(iterator, visitor) {
  while (true) {
    const { done, value } = await iterator.next();
    if (done) {
      iterator.return();
      return;
    }
    const cancel = visitor(value);
    if (cancel) {
      return;
    }
  }
}
async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];
  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }
  return concatenateArrayBuffers(...arrayBuffers);
}

// node_modules/@loaders.gl/loader-utils/dist/lib/request-utils/request-scheduler.js
var STAT_QUEUED_REQUESTS = "Queued Requests";
var STAT_ACTIVE_REQUESTS = "Active Requests";
var STAT_CANCELLED_REQUESTS = "Cancelled Requests";
var STAT_QUEUED_REQUESTS_EVER = "Queued Requests Ever";
var STAT_ACTIVE_REQUESTS_EVER = "Active Requests Ever";
var DEFAULT_PROPS = {
  id: "request-scheduler",
  /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */
  throttleRequests: true,
  /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */
  maxRequests: 6,
  /**
   * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have
   * been added to the queue for this amount of time.
   */
  debounceTime: 0
};
var RequestScheduler = class {
  constructor(props = {}) {
    __publicField(this, "props");
    __publicField(this, "stats");
    __publicField(this, "activeRequestCount", 0);
    /** Tracks the number of active requests and prioritizes/cancels queued requests. */
    __publicField(this, "requestQueue", []);
    __publicField(this, "requestMap", /* @__PURE__ */ new Map());
    __publicField(this, "updateTimer", null);
    this.props = { ...DEFAULT_PROPS, ...props };
    this.stats = new Stats({ id: this.props.id });
    this.stats.get(STAT_QUEUED_REQUESTS);
    this.stats.get(STAT_ACTIVE_REQUESTS);
    this.stats.get(STAT_CANCELLED_REQUESTS);
    this.stats.get(STAT_QUEUED_REQUESTS_EVER);
    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
  }
  /**
   * Called by an application that wants to issue a request, without having it deeply queued by the browser
   *
   * When the returned promise resolved, it is OK for the application to issue a request.
   * The promise resolves to an object that contains a `done` method.
   * When the application's request has completed (or failed), the application must call the `done` function
   *
   * @param handle
   * @param getPriority will be called when request "slots" open up,
   *    allowing the caller to update priority or cancel the request
   *    Highest priority executes first, priority < 0 cancels the request
   * @returns a promise
   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,
   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).
   *     In this case the application should not issue the request
   */
  scheduleRequest(handle, getPriority = () => 0) {
    if (!this.props.throttleRequests) {
      return Promise.resolve({ done: () => {
      } });
    }
    if (this.requestMap.has(handle)) {
      return this.requestMap.get(handle);
    }
    const request = { handle, priority: 0, getPriority };
    const promise = new Promise((resolve2) => {
      request.resolve = resolve2;
      return request;
    });
    this.requestQueue.push(request);
    this.requestMap.set(handle, promise);
    this._issueNewRequests();
    return promise;
  }
  // PRIVATE
  _issueRequest(request) {
    const { handle, resolve: resolve2 } = request;
    let isDone = false;
    const done = () => {
      if (!isDone) {
        isDone = true;
        this.requestMap.delete(handle);
        this.activeRequestCount--;
        this._issueNewRequests();
      }
    };
    this.activeRequestCount++;
    return resolve2 ? resolve2({ done }) : Promise.resolve({ done });
  }
  /** We check requests asynchronously, to prevent multiple updates */
  _issueNewRequests() {
    if (this.updateTimer !== null) {
      clearTimeout(this.updateTimer);
    }
    this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);
  }
  /** Refresh all requests  */
  _issueNewRequestsAsync() {
    if (this.updateTimer !== null) {
      clearTimeout(this.updateTimer);
    }
    this.updateTimer = null;
    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (freeSlots === 0) {
      return;
    }
    this._updateAllRequests();
    for (let i = 0; i < freeSlots; ++i) {
      const request = this.requestQueue.shift();
      if (request) {
        this._issueRequest(request);
      }
    }
  }
  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */
  _updateAllRequests() {
    const requestQueue = this.requestQueue;
    for (let i = 0; i < requestQueue.length; ++i) {
      const request = requestQueue[i];
      if (!this._updateRequest(request)) {
        requestQueue.splice(i, 1);
        this.requestMap.delete(request.handle);
        i--;
      }
    }
    requestQueue.sort((a, b) => a.priority - b.priority);
  }
  /** Update a single request by calling the callback */
  _updateRequest(request) {
    request.priority = request.getPriority(request.handle);
    if (request.priority < 0) {
      request.resolve(null);
      return false;
    }
    return true;
  }
};

// node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js
var pathPrefix = "";
var fileAliases = {};
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}
function getPathPrefix() {
  return pathPrefix;
}
function resolvePath(filename2) {
  for (const alias in fileAliases) {
    if (filename2.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename2 = filename2.replace(alias, replacement);
    }
  }
  if (!filename2.startsWith("http://") && !filename2.startsWith("https://")) {
    filename2 = `${pathPrefix}${filename2}`;
  }
  return filename2;
}

// node_modules/@loaders.gl/loader-utils/dist/json-loader.js
var VERSION = true ? "4.3.3" : "latest";
var JSONLoader = {
  dataType: null,
  batchType: null,
  name: "JSON",
  id: "json",
  module: "json",
  version: VERSION,
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json"],
  category: "json",
  text: true,
  parseTextSync,
  parse: async (arrayBuffer) => parseTextSync(new TextDecoder().decode(arrayBuffer)),
  options: {}
};
function parseTextSync(text) {
  return JSON.parse(text);
}

// node_modules/@loaders.gl/loader-utils/dist/loader-types.js
async function parseFromContext(data, loaders, options, context) {
  return context._parse(data, loaders, options, context);
}

// node_modules/@loaders.gl/loader-utils/dist/lib/log-utils/log.js
var VERSION2 = true ? "4.3.3" : "latest";
var version = VERSION2[0] >= "0" && VERSION2[0] <= "9" ? `v${VERSION2}` : "";
function createLog() {
  const log2 = new Log({ id: "loaders.gl" });
  globalThis.loaders = globalThis.loaders || {};
  globalThis.loaders.log = log2;
  globalThis.loaders.version = version;
  globalThis.probe = globalThis.probe || {};
  globalThis.probe.loaders = log2;
  return log2;
}
var log = createLog();

// node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js
function mergeLoaderOptions(baseOptions, newOptions) {
  return mergeOptionsRecursively(baseOptions || {}, newOptions);
}
function mergeOptionsRecursively(baseOptions, newOptions, level = 0) {
  if (level > 3) {
    return newOptions;
  }
  const options = { ...baseOptions };
  for (const [key, newValue] of Object.entries(newOptions)) {
    if (newValue && typeof newValue === "object" && !Array.isArray(newValue)) {
      options[key] = mergeOptionsRecursively(options[key] || {}, newOptions[key], level + 1);
    } else {
      options[key] = newOptions[key];
    }
  }
  return options;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/module-utils/js-module-utils.js
function registerJSModules(modules) {
  var _a;
  globalThis.loaders || (globalThis.loaders = {});
  (_a = globalThis.loaders).modules || (_a.modules = {});
  Object.assign(globalThis.loaders.modules, modules);
}
function getJSModuleOrNull(name) {
  var _a, _b;
  const module = (_b = (_a = globalThis.loaders) == null ? void 0 : _a.modules) == null ? void 0 : _b[name];
  return module || null;
}

// node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js
var NPM_TAG = "latest";
function getVersion() {
  var _a;
  if (!((_a = globalThis._loadersgl_) == null ? void 0 : _a.version)) {
    globalThis._loadersgl_ = globalThis._loadersgl_ || {};
    if (false) {
      console.warn("loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.");
      globalThis._loadersgl_.version = NPM_TAG;
    } else {
      globalThis._loadersgl_.version = "4.3.3";
    }
  }
  return globalThis._loadersgl_.version;
}
var VERSION3 = getVersion();

// node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "loaders.gl assertion failed.");
  }
}

// node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js
var globals2 = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_2 = globals2.self || globals2.window || globals2.global || {};
var window_2 = globals2.window || globals2.self || globals2.global || {};
var global_2 = globals2.global || globals2.self || globals2.window || {};
var document_2 = globals2.document || {};
var isBrowser2 = (
  // @ts-ignore process.browser
  typeof process !== "object" || String(process) !== "[object process]" || process.browser
);
var isWorker2 = typeof importScripts === "function";
var isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
var matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js
var WorkerJob = class {
  constructor(jobName, workerThread) {
    __publicField(this, "name");
    __publicField(this, "workerThread");
    __publicField(this, "isRunning", true);
    /** Promise that resolves when Job is done */
    __publicField(this, "result");
    __publicField(this, "_resolve", () => {
    });
    __publicField(this, "_reject", () => {
    });
    this.name = jobName;
    this.workerThread = workerThread;
    this.result = new Promise((resolve2, reject) => {
      this._resolve = resolve2;
      this._reject = reject;
    });
  }
  /**
   * Send a message to the job's worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   */
  postMessage(type, payload) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      // Lets worker ignore unrelated messages
      type,
      payload
    });
  }
  /**
   * Call to resolve the `result` Promise with the supplied value
   */
  done(value) {
    assert2(this.isRunning);
    this.isRunning = false;
    this._resolve(value);
  }
  /**
   * Call to reject the `result` Promise with the supplied error
   */
  error(error) {
    assert2(this.isRunning);
    this.isRunning = false;
    this._reject(error);
  }
};

// node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js
var NodeWorker = class {
  terminate() {
  }
};

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js
var workerURLCache = /* @__PURE__ */ new Map();
function getLoadableWorkerURL(props) {
  assert2(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);
  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }
    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }
  assert2(workerURL);
  return workerURL;
}
function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith("http")) {
    return url;
  }
  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}
function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function buildScriptSource(workerUrl) {
  return `try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js
function getTransferList(object, recursive = true, transfers) {
  const transfersSet = transfers || /* @__PURE__ */ new Set();
  if (!object) {
  } else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {
  } else if (recursive && typeof object === "object") {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === void 0 ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}
function getTransferListForWriter(object) {
  if (object === null) {
    return {};
  }
  const clone = Object.assign({}, object);
  Object.keys(clone).forEach((key) => {
    if (typeof object[key] === "object" && !ArrayBuffer.isView(object[key]) && !(object[key] instanceof Array)) {
      clone[key] = getTransferListForWriter(object[key]);
    } else if (typeof clone[key] === "function" || clone[key] instanceof RegExp) {
      clone[key] = {};
    } else {
      clone[key] = object[key];
    }
  });
  return clone;
}

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js
var NOOP = () => {
};
var WorkerThread = class {
  constructor(props) {
    __publicField(this, "name");
    __publicField(this, "source");
    __publicField(this, "url");
    __publicField(this, "terminated", false);
    __publicField(this, "worker");
    __publicField(this, "onMessage");
    __publicField(this, "onError");
    __publicField(this, "_loadableURL", "");
    const { name, source, url } = props;
    assert2(source || url);
    this.name = name;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP;
    this.onError = (error) => console.log(error);
    this.worker = isBrowser2 ? this._createBrowserWorker() : this._createNodeWorker();
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return typeof Worker !== "undefined" && isBrowser2 || typeof NodeWorker !== "undefined" && !isBrowser2;
  }
  /**
   * Terminate this worker thread
   * @note Can free up significant memory
   */
  destroy() {
    this.onMessage = NOOP;
    this.onError = NOOP;
    this.worker.terminate();
    this.terminated = true;
  }
  get isRunning() {
    return Boolean(this.onMessage);
  }
  /**
   * Send a message to this worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   * @param transferList If not supplied, calculated automatically by traversing data
   */
  postMessage(data, transferList) {
    transferList = transferList || getTransferList(data);
    this.worker.postMessage(data, transferList);
  }
  // PRIVATE
  /**
   * Generate a standard Error from an ErrorEvent
   * @param event
   */
  _getErrorFromErrorEvent(event) {
    let message = "Failed to load ";
    message += `worker ${this.name} from ${this.url}. `;
    if (event.message) {
      message += `${event.message} in `;
    }
    if (event.lineno) {
      message += `:${event.lineno}:${event.colno}`;
    }
    return new Error(message);
  }
  /**
   * Creates a worker thread on the browser
   */
  _createBrowserWorker() {
    this._loadableURL = getLoadableWorkerURL({ source: this.source, url: this.url });
    const worker = new Worker(this._loadableURL, { name: this.name });
    worker.onmessage = (event) => {
      if (!event.data) {
        this.onError(new Error("No data received"));
      } else {
        this.onMessage(event.data);
      }
    };
    worker.onerror = (error) => {
      this.onError(this._getErrorFromErrorEvent(error));
      this.terminated = true;
    };
    worker.onmessageerror = (event) => console.error(event);
    return worker;
  }
  /**
   * Creates a worker thread in node.js
   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
   */
  _createNodeWorker() {
    let worker;
    if (this.url) {
      const absolute = this.url.includes(":/") || this.url.startsWith("/");
      const url = absolute ? this.url : `./${this.url}`;
      worker = new NodeWorker(url, { eval: false });
    } else if (this.source) {
      worker = new NodeWorker(this.source, { eval: true });
    } else {
      throw new Error("no worker");
    }
    worker.on("message", (data) => {
      this.onMessage(data);
    });
    worker.on("error", (error) => {
      this.onError(error);
    });
    worker.on("exit", (code) => {
    });
    return worker;
  }
};

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js
var WorkerPool = class {
  /**
   * @param processor - worker function
   * @param maxConcurrency - max count of workers
   */
  constructor(props) {
    __publicField(this, "name", "unnamed");
    __publicField(this, "source");
    // | Function;
    __publicField(this, "url");
    __publicField(this, "maxConcurrency", 1);
    __publicField(this, "maxMobileConcurrency", 1);
    __publicField(this, "onDebug", () => {
    });
    __publicField(this, "reuseWorkers", true);
    __publicField(this, "props", {});
    __publicField(this, "jobQueue", []);
    __publicField(this, "idleQueue", []);
    __publicField(this, "count", 0);
    __publicField(this, "isDestroyed", false);
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return WorkerThread.isSupported();
  }
  /**
   * Terminates all workers in the pool
   * @note Can free up significant memory
   */
  destroy() {
    this.idleQueue.forEach((worker) => worker.destroy());
    this.isDestroyed = true;
  }
  setProps(props) {
    this.props = { ...this.props, ...props };
    if (props.name !== void 0) {
      this.name = props.name;
    }
    if (props.maxConcurrency !== void 0) {
      this.maxConcurrency = props.maxConcurrency;
    }
    if (props.maxMobileConcurrency !== void 0) {
      this.maxMobileConcurrency = props.maxMobileConcurrency;
    }
    if (props.reuseWorkers !== void 0) {
      this.reuseWorkers = props.reuseWorkers;
    }
    if (props.onDebug !== void 0) {
      this.onDebug = props.onDebug;
    }
  }
  async startJob(name, onMessage3 = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {
    const startPromise = new Promise((onStart) => {
      this.jobQueue.push({ name, onMessage: onMessage3, onError, onStart });
      return this;
    });
    this._startQueuedJob();
    return await startPromise;
  }
  // PRIVATE
  /**
   * Starts first queued job if worker is available or can be created
   * Called when job is started and whenever a worker returns to the idleQueue
   */
  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const workerThread = this._getAvailableWorker();
    if (!workerThread) {
      return;
    }
    const queuedJob = this.jobQueue.shift();
    if (queuedJob) {
      this.onDebug({
        message: "Starting job",
        name: queuedJob.name,
        workerThread,
        backlog: this.jobQueue.length
      });
      const job = new WorkerJob(queuedJob.name, workerThread);
      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
      workerThread.onError = (error) => queuedJob.onError(job, error);
      queuedJob.onStart(job);
      try {
        await job.result;
      } catch (error) {
        console.error(`Worker exception: ${error}`);
      } finally {
        this.returnWorkerToQueue(workerThread);
      }
    }
  }
  /**
   * Returns a worker to the idle queue
   * Destroys the worker if
   *  - pool is destroyed
   *  - if this pool doesn't reuse workers
   *  - if maxConcurrency has been lowered
   * @param worker
   */
  returnWorkerToQueue(worker) {
    const shouldDestroyWorker = (
      // Workers on Node.js prevent the process from exiting.
      // Until we figure out how to close them before exit, we always destroy them
      !isBrowser2 || // If the pool is destroyed, there is no reason to keep the worker around
      this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
      !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
      this.count > this._getMaxConcurrency()
    );
    if (shouldDestroyWorker) {
      worker.destroy();
      this.count--;
    } else {
      this.idleQueue.push(worker);
    }
    if (!this.isDestroyed) {
      this._startQueuedJob();
    }
  }
  /**
   * Returns idle worker or creates new worker if maxConcurrency has not been reached
   */
  _getAvailableWorker() {
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift() || null;
    }
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new WorkerThread({ name, source: this.source, url: this.url });
    }
    return null;
  }
  _getMaxConcurrency() {
    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
  }
};

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js
var DEFAULT_PROPS2 = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  onDebug: () => {
  }
};
var _WorkerFarm = class _WorkerFarm {
  /** get global instance with WorkerFarm.getWorkerFarm() */
  constructor(props) {
    __publicField(this, "props");
    __publicField(this, "workerPools", /* @__PURE__ */ new Map());
    this.props = { ...DEFAULT_PROPS2 };
    this.setProps(props);
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return WorkerThread.isSupported();
  }
  /** Get the singleton instance of the global worker farm */
  static getWorkerFarm(props = {}) {
    _WorkerFarm._workerFarm = _WorkerFarm._workerFarm || new _WorkerFarm({});
    _WorkerFarm._workerFarm.setProps(props);
    return _WorkerFarm._workerFarm;
  }
  /**
   * Terminate all workers in the farm
   * @note Can free up significant memory
   */
  destroy() {
    for (const workerPool of this.workerPools.values()) {
      workerPool.destroy();
    }
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Set props used when initializing worker pools
   * @param props
   */
  setProps(props) {
    this.props = { ...this.props, ...props };
    for (const workerPool of this.workerPools.values()) {
      workerPool.setProps(this._getWorkerPoolProps());
    }
  }
  /**
   * Returns a worker pool for the specified worker
   * @param options - only used first time for a specific worker name
   * @param options.name - the name of the worker - used to identify worker pool
   * @param options.url -
   * @param options.source -
   * @example
   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
   */
  getWorkerPool(options) {
    const { name, source, url } = options;
    let workerPool = this.workerPools.get(name);
    if (!workerPool) {
      workerPool = new WorkerPool({
        name,
        source,
        url
      });
      workerPool.setProps(this._getWorkerPoolProps());
      this.workerPools.set(name, workerPool);
    }
    return workerPool;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
};
// singleton
__publicField(_WorkerFarm, "_workerFarm");
var WorkerFarm = _WorkerFarm;

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js
function getWorkerName(worker) {
  const warning = worker.version !== VERSION3 ? ` (worker-utils@${VERSION3})` : "";
  return `${worker.name}@${worker.version}${warning}`;
}
function getWorkerURL(worker, options = {}) {
  const workerOptions = options[worker.id] || {};
  const workerFile = isBrowser2 ? `${worker.id}-worker.js` : `${worker.id}-worker-node.js`;
  let url = workerOptions.workerUrl;
  if (!url && worker.id === "compression") {
    url = options.workerUrl;
  }
  if (options._workerType === "test") {
    if (isBrowser2) {
      url = `modules/${worker.module}/dist/${workerFile}`;
    } else {
      url = `modules/${worker.module}/src/workers/${worker.id}-worker-node.ts`;
    }
  }
  if (!url) {
    let version2 = worker.version;
    if (version2 === "latest") {
      version2 = NPM_TAG;
    }
    const versionTag = version2 ? `@${version2}` : "";
    url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;
  }
  assert2(url);
  return url;
}

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/process-on-worker.js
async function processOnWorker(worker, data, options = {}, context = {}) {
  const name = getWorkerName(worker);
  const workerFarm = WorkerFarm.getWorkerFarm(options);
  const { source } = options;
  const workerPoolProps = { name, source };
  if (!source) {
    workerPoolProps.url = getWorkerURL(worker, options);
  }
  const workerPool = workerFarm.getWorkerPool(workerPoolProps);
  const jobName = options.jobName || worker.name;
  const job = await workerPool.startJob(
    jobName,
    // eslint-disable-next-line
    onMessage.bind(null, context)
  );
  const transferableOptions = getTransferListForWriter(options);
  job.postMessage("process", { input: data, options: transferableOptions });
  const result = await job.result;
  return result.result;
}
async function onMessage(context, job, type, payload) {
  switch (type) {
    case "done":
      job.done(payload);
      break;
    case "error":
      job.error(new Error(payload.error));
      break;
    case "process":
      const { id, input, options } = payload;
      try {
        if (!context.process) {
          job.postMessage("error", { id, error: "Worker not set up to process on main thread" });
          return;
        }
        const result = await context.process(input, options);
        job.postMessage("done", { id, result });
      } catch (error) {
        const message = error instanceof Error ? error.message : "unknown error";
        job.postMessage("error", { id, error: message });
      }
      break;
    default:
      console.warn(`process-on-worker: unknown message ${type}`);
  }
}

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js
function validateWorkerVersion(worker, coreVersion = VERSION3) {
  assert2(worker, "no worker provided");
  const workerVersion = worker.version;
  if (!coreVersion || !workerVersion) {
    return false;
  }
  return true;
}

// node_modules/@loaders.gl/worker-utils/dist/lib/library-utils/library-utils.js
var loadLibraryPromises = {};
async function loadLibrary(libraryUrl, moduleName = null, options = {}, libraryName = null) {
  if (moduleName) {
    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options, libraryName);
  }
  loadLibraryPromises[libraryUrl] = // eslint-disable-next-line @typescript-eslint/no-misused-promises
  loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
  return await loadLibraryPromises[libraryUrl];
}
function getLibraryUrl(library, moduleName, options = {}, libraryName = null) {
  if (!options.useLocalLibraries && library.startsWith("http")) {
    return library;
  }
  libraryName = libraryName || library;
  const modules = options.modules || {};
  if (modules[libraryName]) {
    return modules[libraryName];
  }
  if (!isBrowser2) {
    return `modules/${moduleName}/dist/libs/${libraryName}`;
  }
  if (options.CDN) {
    assert2(options.CDN.startsWith("http"));
    return `${options.CDN}/${moduleName}@${VERSION3}/dist/libs/${libraryName}`;
  }
  if (isWorker2) {
    return `../src/libs/${libraryName}`;
  }
  return `modules/${moduleName}/src/libs/${libraryName}`;
}
async function loadLibraryFromFile(libraryUrl) {
  if (libraryUrl.endsWith("wasm")) {
    return await loadAsArrayBuffer(libraryUrl);
  }
  if (!isBrowser2) {
    try {
      const { requireFromFile } = globalThis.loaders || {};
      return await (requireFromFile == null ? void 0 : requireFromFile(libraryUrl));
    } catch (error) {
      console.error(error);
      return null;
    }
  }
  if (isWorker2) {
    return importScripts(libraryUrl);
  }
  const scriptSource = await loadAsText(libraryUrl);
  return loadLibraryFromString(scriptSource, libraryUrl);
}
function loadLibraryFromString(scriptSource, id) {
  if (!isBrowser2) {
    const { requireFromString } = globalThis.loaders || {};
    return requireFromString == null ? void 0 : requireFromString(scriptSource, id);
  }
  if (isWorker2) {
    eval.call(globalThis, scriptSource);
    return null;
  }
  const script = document.createElement("script");
  script.id = id;
  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }
  document.body.appendChild(script);
  return null;
}
async function loadAsArrayBuffer(url) {
  const { readFileAsArrayBuffer } = globalThis.loaders || {};
  if (isBrowser2 || !readFileAsArrayBuffer || url.startsWith("http")) {
    const response = await fetch(url);
    return await response.arrayBuffer();
  }
  return await readFileAsArrayBuffer(url);
}
async function loadAsText(url) {
  const { readFileAsText } = globalThis.loaders || {};
  if (isBrowser2 || !readFileAsText || url.startsWith("http")) {
    const response = await fetch(url);
    return await response.text();
  }
  return await readFileAsText(url);
}

// node_modules/@loaders.gl/worker-utils/dist/lib/process-utils/child-process-proxy.js
var ChildProcess2 = __toESM(require_child_process(), 1);

// node_modules/@loaders.gl/worker-utils/dist/lib/process-utils/process-utils.js
var import_child_process = __toESM(require_child_process(), 1);

// node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js
function canParseWithWorker(loader, options) {
  if (!WorkerFarm.isSupported()) {
    return false;
  }
  if (!isBrowser2 && !(options == null ? void 0 : options._nodeWorkers)) {
    return false;
  }
  return loader.worker && (options == null ? void 0 : options.worker);
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
  const name = loader.id;
  const url = getWorkerURL(loader, options);
  const workerFarm = WorkerFarm.getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({ name, url });
  options = JSON.parse(JSON.stringify(options));
  context = JSON.parse(JSON.stringify(context || {}));
  const job = await workerPool.startJob(
    "process-on-worker",
    // @ts-expect-error
    onMessage2.bind(null, parseOnMainThread)
    // eslint-disable-line @typescript-eslint/no-misused-promises
  );
  job.postMessage("process", {
    // @ts-ignore
    input: data,
    options,
    context
  });
  const result = await job.result;
  return await result.result;
}
async function onMessage2(parseOnMainThread, job, type, payload) {
  switch (type) {
    case "done":
      job.done(payload);
      break;
    case "error":
      job.error(new Error(payload.error));
      break;
    case "process":
      const { id, input, options } = payload;
      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage("done", { id, result });
      } catch (error) {
        const message = error instanceof Error ? error.message : "unknown error";
        job.postMessage("error", { id, error: message });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${type}`);
  }
}

// node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/encode-with-worker.js
function canEncodeWithWorker(writer, options) {
  if (!WorkerFarm.isSupported()) {
    return false;
  }
  if (!isBrowser && !(options == null ? void 0 : options._nodeWorkers)) {
    return false;
  }
  return writer.worker && (options == null ? void 0 : options.worker);
}

// node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/get-first-characters.js
function getFirstCharacters(data, length = 5) {
  if (typeof data === "string") {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return "";
}
function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return "";
  }
  const dataView = new DataView(arrayBuffer);
  let magic = "";
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/parser-utils/parse-json.js
function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error(`Failed to parse JSON from data starting with "${getFirstCharacters(string)}"`);
  }
}

// node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-copy-utils.js
function padToNBytes(byteLength, padding) {
  assert(byteLength >= 0);
  assert(padding > 0);
  return byteLength + (padding - 1) & ~(padding - 1);
}
function copyToArray(source, target, targetOffset) {
  let sourceArray;
  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
  }
  target.set(sourceArray, targetOffset);
  return targetOffset + padToNBytes(sourceArray.byteLength, 4);
}

// node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/dataview-copy-utils.js
function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {
  const paddedLength = padToNBytes(sourceBuffer.byteLength, padding);
  const padLength = paddedLength - sourceBuffer.byteLength;
  if (dataView) {
    const targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);
    const sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);
    for (let i = 0; i < padLength; ++i) {
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 32);
    }
  }
  byteOffset += paddedLength;
  return byteOffset;
}
function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {
  const textEncoder = new TextEncoder();
  const stringBuffer = textEncoder.encode(string);
  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);
  return byteOffset;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js
function toArrayBuffer(buffer) {
  return buffer;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js
function isBuffer(value) {
  return value && typeof value === "object" && value.isBuffer;
}
function toArrayBuffer2(data) {
  if (isBuffer(data)) {
    return toArrayBuffer(data);
  }
  if (data instanceof ArrayBuffer) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
  if (typeof data === "string") {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data && typeof data === "object" && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }
  throw new Error("toArrayBuffer");
}

// node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
var path_exports = {};
__export(path_exports, {
  dirname: () => dirname,
  filename: () => filename,
  join: () => join,
  resolve: () => resolve
});

// node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js
function getCWD() {
  var _a;
  if (typeof process !== "undefined" && typeof process.cwd !== "undefined") {
    return process.cwd();
  }
  const pathname = (_a = window.location) == null ? void 0 : _a.pathname;
  return (pathname == null ? void 0 : pathname.slice(0, pathname.lastIndexOf("/") + 1)) || "";
}

// node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
function filename(url) {
  const slashIndex = url ? url.lastIndexOf("/") : -1;
  return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
}
function dirname(url) {
  const slashIndex = url ? url.lastIndexOf("/") : -1;
  return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
}
function join(...parts) {
  const separator = "/";
  parts = parts.map((part, index) => {
    if (index) {
      part = part.replace(new RegExp(`^${separator}`), "");
    }
    if (index !== parts.length - 1) {
      part = part.replace(new RegExp(`${separator}$`), "");
    }
    return part;
  });
  return parts.join(separator);
}
function resolve(...components) {
  const paths = [];
  for (let _i = 0; _i < components.length; _i++) {
    paths[_i] = components[_i];
  }
  let resolvedPath = "";
  let resolvedAbsolute = false;
  let cwd;
  for (let i = paths.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) {
      path = paths[i];
    } else {
      if (cwd === void 0) {
        cwd = getCWD();
      }
      path = cwd;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = path.charCodeAt(0) === SLASH;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    return `/${resolvedPath}`;
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  }
  return ".";
}
var SLASH = 47;
var DOT = 46;
function normalizeStringPosix(path, allowAboveRoot) {
  let res = "";
  let lastSlash = -1;
  let dots = 0;
  let code;
  let isAboveRoot = false;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (code === SLASH) {
      break;
    } else {
      code = SLASH;
    }
    if (code === SLASH) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
          if (res.length > 2) {
            const start = res.length - 1;
            let j = start;
            for (; j >= 0; --j) {
              if (res.charCodeAt(j) === SLASH) {
                break;
              }
            }
            if (j !== start) {
              res = j === -1 ? "" : res.slice(0, j);
              lastSlash = i;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSlash = i;
            dots = 0;
            isAboveRoot = false;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          isAboveRoot = true;
        }
      } else {
        const slice = path.slice(lastSlash + 1, i);
        if (res.length > 0) {
          res += `/${slice}`;
        } else {
          res = slice;
        }
        isAboveRoot = false;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/files/blob-file.js
var BlobFile = class {
  constructor(blob) {
    __publicField(this, "handle");
    __publicField(this, "size");
    __publicField(this, "bigsize");
    __publicField(this, "url");
    this.handle = blob instanceof ArrayBuffer ? new Blob([blob]) : blob;
    this.size = blob instanceof ArrayBuffer ? blob.byteLength : blob.size;
    this.bigsize = BigInt(this.size);
    this.url = blob instanceof File ? blob.name : "";
  }
  async close() {
  }
  async stat() {
    return {
      size: this.handle.size,
      bigsize: BigInt(this.handle.size),
      isDirectory: false
    };
  }
  async read(start, length) {
    const arrayBuffer = await this.handle.slice(Number(start), Number(start) + Number(length)).arrayBuffer();
    return arrayBuffer;
  }
};

// node_modules/@loaders.gl/loader-utils/dist/lib/files/node-file-facade.js
var NOT_IMPLEMENTED = new Error("Not implemented");
var NodeFileFacade = class {
  constructor(url, flags, mode) {
    __publicField(this, "handle");
    __publicField(this, "size", 0);
    __publicField(this, "bigsize", 0n);
    __publicField(this, "url", "");
    var _a;
    if ((_a = globalThis.loaders) == null ? void 0 : _a.NodeFile) {
      return new globalThis.loaders.NodeFile(url, flags, mode);
    }
    if (isBrowser) {
      throw new Error("Can't instantiate NodeFile in browser.");
    }
    throw new Error("Can't instantiate NodeFile. Make sure to import @loaders.gl/polyfills first.");
  }
  /** Read data */
  async read(start, length) {
    throw NOT_IMPLEMENTED;
  }
  /** Write to file. The number of bytes written will be returned */
  async write(arrayBuffer, offset, length) {
    throw NOT_IMPLEMENTED;
  }
  /** Get information about file */
  async stat() {
    throw NOT_IMPLEMENTED;
  }
  /** Truncates the file descriptor. Only available on NodeFile. */
  async truncate(length) {
    throw NOT_IMPLEMENTED;
  }
  /** Append data to a file. Only available on NodeFile. */
  async append(data) {
    throw NOT_IMPLEMENTED;
  }
  /** Close the file */
  async close() {
  }
};

// node_modules/@loaders.gl/loader-utils/dist/lib/filesystems/node-filesystem-facade.js
var NOT_IMPLEMENTED2 = new Error("Not implemented");

export {
  parseFromContext,
  assert,
  self_,
  window_,
  global_,
  document_,
  isBrowser,
  isWorker,
  log,
  mergeLoaderOptions,
  registerJSModules,
  getJSModuleOrNull,
  assert2,
  processOnWorker,
  validateWorkerVersion,
  loadLibrary,
  canParseWithWorker,
  parseWithWorker,
  canEncodeWithWorker,
  parseJSON,
  compareArrayBuffers,
  concatenateArrayBuffers,
  sliceArrayBuffer,
  padToNBytes,
  copyToArray,
  copyPaddedArrayBufferToDataView,
  copyPaddedStringToDataView,
  makeTextDecoderIterator,
  makeTextEncoderIterator,
  makeLineIterator,
  makeNumberedLineIterator,
  forEach,
  concatenateArrayBuffersAsync,
  RequestScheduler,
  setPathPrefix,
  getPathPrefix,
  resolvePath,
  JSONLoader,
  toArrayBuffer2 as toArrayBuffer,
  path_exports,
  BlobFile,
  NodeFileFacade
};
//# sourceMappingURL=chunk-LO3UPPDK.js.map
