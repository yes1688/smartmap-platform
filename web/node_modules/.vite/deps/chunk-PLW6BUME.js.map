{
  "version": 3,
  "sources": ["../../@luma.gl/engine/src/animation/timeline.ts", "../../@luma.gl/engine/src/animation/key-frames.ts", "../../@luma.gl/engine/src/animation-loop/animation-loop-template.ts", "../../@luma.gl/core/src/utils/stats-manager.ts", "../../@luma.gl/core/src/utils/log.ts", "../../@luma.gl/core/src/utils/uid.ts", "../../@luma.gl/core/src/adapter/resources/resource.ts", "../../@luma.gl/core/src/adapter/resources/buffer.ts", "../../@luma.gl/core/src/gpu-type-utils/decode-data-type.ts", "../../@luma.gl/core/src/gpu-type-utils/texture-format-table.ts", "../../@luma.gl/core/src/gpu-type-utils/decode-texture-format.ts", "../../@luma.gl/core/src/gpu-type-utils/texture-format-capabilities.ts", "../../@luma.gl/core/src/adapter/device.ts", "../../@luma.gl/core/src/adapter/luma.ts", "../../@luma.gl/core/src/adapter/adapter.ts", "../../@luma.gl/core/src/adapter/canvas-context.ts", "../../@luma.gl/core/src/adapter/resources/texture.ts", "../../@luma.gl/core/src/adapter/resources/texture-view.ts", "../../@luma.gl/core/src/adapter/resources/external-texture.ts", "../../@luma.gl/core/src/adapter-utils/format-compiler-log.ts", "../../@luma.gl/core/src/adapter/resources/shader.ts", "../../@luma.gl/core/src/adapter/resources/sampler.ts", "../../@luma.gl/core/src/adapter/resources/framebuffer.ts", "../../@luma.gl/core/src/adapter/resources/render-pipeline.ts", "../../@luma.gl/core/src/adapter/resources/render-pass.ts", "../../@luma.gl/core/src/adapter/resources/compute-pipeline.ts", "../../@luma.gl/core/src/adapter/resources/compute-pass.ts", "../../@luma.gl/core/src/adapter/resources/command-encoder.ts", "../../@luma.gl/core/src/adapter/resources/command-buffer.ts", "../../@luma.gl/core/src/gpu-type-utils/decode-attribute-type.ts", "../../@luma.gl/core/src/gpu-type-utils/decode-vertex-format.ts", "../../@luma.gl/core/src/adapter-utils/get-attribute-from-layouts.ts", "../../@luma.gl/core/src/adapter/resources/vertex-array.ts", "../../@luma.gl/core/src/adapter/resources/transform-feedback.ts", "../../@luma.gl/core/src/adapter/resources/query-set.ts", "../../@luma.gl/core/src/adapter/resources/pipeline-layout.ts", "../../@luma.gl/core/src/gpu-type-utils/decode-shader-types.ts", "../../@luma.gl/core/src/utils/array-utils-flat.ts", "../../@luma.gl/core/src/utils/is-array.ts", "../../@luma.gl/core/src/portable/uniform-buffer-layout.ts", "../../@luma.gl/core/src/utils/array-equal.ts", "../../@luma.gl/core/src/portable/uniform-block.ts", "../../@luma.gl/core/src/portable/uniform-store.ts", "../../@luma.gl/core/src/gpu-type-utils/vertex-format-from-attribute.ts", "../../@luma.gl/core/src/adapter-utils/buffer-layout-helper.ts", "../../@luma.gl/core/src/adapter-utils/buffer-layout-order.ts", "../../@luma.gl/engine/src/animation-loop/request-animation-frame.ts", "../../@luma.gl/engine/src/animation-loop/animation-loop.ts", "../../@luma.gl/engine/src/animation-loop/make-animation-loop.ts", "../../@luma.gl/shadertools/src/lib/utils/assert.ts", "../../@luma.gl/shadertools/src/lib/filters/prop-types.ts", "../../@luma.gl/shadertools/src/module-injectors.ts", "../../@luma.gl/shadertools/src/lib/shader-assembly/shader-injections.ts", "../../@luma.gl/shadertools/src/lib/shader-module/shader-module.ts", "../../@luma.gl/shadertools/src/lib/shader-module/shader-module-dependencies.ts", "../../@luma.gl/shadertools/src/lib/shader-assembly/platform-defines.ts", "../../@luma.gl/shadertools/src/lib/shader-transpiler/transpile-glsl-shader.ts", "../../@luma.gl/shadertools/src/lib/shader-assembly/shader-hooks.ts", "../../@luma.gl/shadertools/src/lib/glsl-utils/get-shader-info.ts", "../../@luma.gl/shadertools/src/lib/shader-assembly/assemble-shaders.ts", "../../@luma.gl/shadertools/src/lib/preprocessor/preprocessor.ts", "../../@luma.gl/shadertools/src/lib/shader-assembler.ts", "../../@luma.gl/shadertools/src/lib/glsl-utils/shader-utils.ts", "../../wgsl_reflect/src/reflect/info.ts", "../../wgsl_reflect/src/utils/float.ts", "../../wgsl_reflect/src/utils/texture_sample.ts", "../../wgsl_reflect/src/utils/texture_format_info.ts", "../../wgsl_reflect/src/wgsl_ast.ts", "../../wgsl_reflect/src/wgsl_scanner.ts", "../../wgsl_reflect/src/utils/cast.ts", "../../wgsl_reflect/src/reflect/reflect.ts", "../../wgsl_reflect/src/exec/exec_context.ts", "../../wgsl_reflect/src/exec/exec_interface.ts", "../../wgsl_reflect/src/exec/builtin_functions.ts", "../../wgsl_reflect/src/utils/matrix.ts", "../../wgsl_reflect/src/wgsl_exec.ts", "../../wgsl_reflect/src/ast/parse_context.ts", "../../wgsl_reflect/src/wgsl_parser.ts", "../../wgsl_reflect/src/wgsl_reflect.ts", "../../wgsl_reflect/src/exec/command.ts", "../../wgsl_reflect/src/exec/stack_frame.ts", "../../wgsl_reflect/src/exec/exec_stack.ts", "../../wgsl_reflect/src/wgsl_debug.ts", "../../@luma.gl/shadertools/src/lib/wgsl/get-shader-layout-wgsl.ts", "../../@luma.gl/shadertools/src/modules/math/fp16/fp16-utils.ts", "../../@luma.gl/shadertools/src/modules/math/fp64/fp64-utils.ts", "../../@luma.gl/shadertools/src/modules/math/fp32/fp32.ts", "../../@luma.gl/shadertools/src/modules/math/fp64/fp64-arithmetic-glsl.ts", "../../@luma.gl/shadertools/src/modules/math/fp64/fp64.ts", "../../@luma.gl/shadertools/src/modules/engine/picking/picking.ts", "../../@luma.gl/shadertools/src/modules/lighting/lights/lighting-uniforms-glsl.ts", "../../@luma.gl/shadertools/src/modules/lighting/lights/lighting-uniforms-wgsl.ts", "../../@luma.gl/shadertools/src/modules/lighting/lights/lighting.ts", "../../@luma.gl/shadertools/src/modules/lighting/phong-material/phong-shaders-glsl.ts", "../../@luma.gl/shadertools/src/modules/lighting/phong-material/phong-shaders-wgsl.ts", "../../@luma.gl/shadertools/src/modules/lighting/gouraud-material/gouraud-material.ts", "../../@luma.gl/shadertools/src/modules/lighting/phong-material/phong-material.ts", "../../@luma.gl/shadertools/src/modules/lighting/pbr-material/pbr-vertex-glsl.ts", "../../@luma.gl/shadertools/src/modules/lighting/pbr-material/pbr-fragment-glsl.ts", "../../@luma.gl/shadertools/src/modules/lighting/pbr-material/pbr-projection.ts", "../../@luma.gl/shadertools/src/modules/lighting/pbr-material/pbr-material.ts", "../../@luma.gl/shadertools/src/modules-webgl1/project/project.ts", "../../@luma.gl/shadertools/src/modules-webgl1/lighting/dirlight/dirlight.ts", "../../@luma.gl/engine/src/utils/uid.ts", "../../@luma.gl/engine/src/geometry/gpu-geometry.ts", "../../@luma.gl/engine/src/factories/pipeline-factory.ts", "../../@luma.gl/engine/src/factories/shader-factory.ts", "../../@luma.gl/engine/src/debug/debug-shader-layout.ts", "../../@luma.gl/engine/src/debug/debug-framebuffer.ts", "../../@luma.gl/engine/src/utils/deep-equal.ts", "../../@math.gl/types/src/is-array.ts", "../../@luma.gl/engine/src/model/split-uniforms-and-bindings.ts", "../../@luma.gl/engine/src/shader-inputs.ts", "../../@luma.gl/engine/src/application-utils/load-file.ts", "../../@luma.gl/engine/src/async-texture/async-texture.ts", "../../@luma.gl/engine/src/model/model.ts", "../../@luma.gl/engine/src/compute/buffer-transform.ts", "../../@luma.gl/engine/src/compute/texture-transform.ts", "../../@luma.gl/engine/src/geometry/geometry.ts", "../../@luma.gl/engine/src/models/clip-space.ts", "../../@luma.gl/engine/src/models/billboard-texture-model.ts", "../../@luma.gl/engine/src/scenegraph/scenegraph-node.ts", "../../@luma.gl/engine/src/scenegraph/group-node.ts", "../../@luma.gl/engine/src/scenegraph/model-node.ts", "../../@luma.gl/engine/src/geometries/truncated-cone-geometry.ts", "../../@luma.gl/engine/src/geometries/cone-geometry.ts", "../../@luma.gl/engine/src/geometries/cube-geometry.ts", "../../@luma.gl/engine/src/geometries/cylinder-geometry.ts", "../../@luma.gl/engine/src/geometries/ico-sphere-geometry.ts", "../../@luma.gl/engine/src/geometry/geometry-utils.ts", "../../@luma.gl/engine/src/geometries/plane-geometry.ts", "../../@luma.gl/engine/src/geometries/sphere-geometry.ts", "../../@luma.gl/engine/src/application-utils/random.ts", "../../@luma.gl/engine/src/compute/swap.ts", "../../@luma.gl/engine/src/passes/get-fragment-shader.ts", "../../@luma.gl/engine/src/passes/shader-pass-renderer.ts", "../../@luma.gl/engine/src/compute/computation.ts", "../../@luma.gl/engine/src/modules/picking/picking-uniforms.ts", "../../@luma.gl/engine/src/modules/picking/picking-manager.ts", "../../@luma.gl/engine/src/modules/picking/index-picking.ts", "../../@luma.gl/engine/src/modules/picking/color-picking.ts", "../../@luma.gl/engine/src/modules/picking/legacy-picking-manager.ts"],
  "sourcesContent": ["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/**\n * Timeline channel properties\n * @param delay = 0;\n * @param duration = Number.POSITIVE_INFINITY;\n * @param rate = 1\n * @param repeat = 1\n */\nexport type ChannelOptions = {\n  delay?: number;\n  duration?: number;\n  rate?: number;\n  repeat?: number;\n};\n\nexport type AnimationOptions = {\n  setTime: (time: number) => void;\n};\n\ntype Channel = {\n  time: number;\n  delay: number;\n  duration: number;\n  rate: number;\n  repeat: number;\n};\n\ntype Animation = {\n  channel?: number;\n  animation: {\n    setTime: (time: number) => void;\n  };\n};\n\nlet channelHandles = 1;\nlet animationHandles = 1;\n\nexport class Timeline {\n  time: number = 0;\n  channels = new Map<number, Channel>();\n  animations = new Map<number, Animation>();\n  playing: boolean = false;\n  lastEngineTime: number = -1;\n\n  constructor() {}\n\n  addChannel(props: ChannelOptions): number {\n    const {delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1} = props;\n\n    const channelId = channelHandles++;\n    const channel: Channel = {\n      time: 0,\n      delay,\n      duration,\n      rate,\n      repeat\n    };\n    this._setChannelTime(channel, this.time);\n    this.channels.set(channelId, channel);\n\n    return channelId;\n  }\n\n  removeChannel(channelId: number): void {\n    this.channels.delete(channelId);\n\n    for (const [animationHandle, animation] of this.animations) {\n      if (animation.channel === channelId) {\n        this.detachAnimation(animationHandle);\n      }\n    }\n  }\n\n  isFinished(channelId: number): boolean {\n    const channel = this.channels.get(channelId);\n    if (channel === undefined) {\n      return false;\n    }\n\n    return this.time >= channel.delay + channel.duration * channel.repeat;\n  }\n\n  getTime(channelId?: number): number {\n    if (channelId === undefined) {\n      return this.time;\n    }\n\n    const channel = this.channels.get(channelId);\n\n    if (channel === undefined) {\n      return -1;\n    }\n\n    return channel.time;\n  }\n\n  setTime(time: number): void {\n    this.time = Math.max(0, time);\n\n    const channels = this.channels.values();\n    for (const channel of channels) {\n      this._setChannelTime(channel, this.time);\n    }\n\n    const animations = this.animations.values();\n    for (const animationData of animations) {\n      const {animation, channel} = animationData;\n      animation.setTime(this.getTime(channel));\n    }\n  }\n\n  play(): void {\n    this.playing = true;\n  }\n\n  pause(): void {\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  reset(): void {\n    this.setTime(0);\n  }\n\n  attachAnimation(animation: AnimationOptions, channelHandle?: number): number {\n    const animationHandle = animationHandles++;\n\n    this.animations.set(animationHandle, {\n      animation,\n      channel: channelHandle\n    });\n\n    animation.setTime(this.getTime(channelHandle));\n\n    return animationHandle;\n  }\n\n  detachAnimation(channelId: number): void {\n    this.animations.delete(channelId);\n  }\n\n  update(engineTime: number): void {\n    if (this.playing) {\n      if (this.lastEngineTime === -1) {\n        this.lastEngineTime = engineTime;\n      }\n      this.setTime(this.time + (engineTime - this.lastEngineTime));\n      this.lastEngineTime = engineTime;\n    }\n  }\n\n  _setChannelTime(channel: Channel, time: number): void {\n    const offsetTime = time - channel.delay;\n    const totalDuration = channel.duration * channel.repeat;\n    // Note(Tarek): Don't loop on final repeat.\n    if (offsetTime >= totalDuration) {\n      channel.time = channel.duration * channel.rate;\n    } else {\n      channel.time = Math.max(0, offsetTime) % channel.duration;\n      channel.time *= channel.rate;\n    }\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// keyframes\nexport type KeyFrame<T> = [number, T];\n\n/** Holds a list of key frames (timestamped values) */\nexport class KeyFrames<T = number> {\n  startIndex: number = -1;\n  endIndex: number = -1;\n  factor: number = 0;\n  times: number[] = [];\n  values: T[] = [];\n  private _lastTime = -1;\n\n  constructor(keyFrames: KeyFrame<T>[]) {\n    this.setKeyFrames(keyFrames);\n    this.setTime(0);\n  }\n\n  setKeyFrames(keyFrames: KeyFrame<T>[]): void {\n    const numKeys = keyFrames.length;\n    this.times.length = numKeys;\n    this.values.length = numKeys;\n\n    for (let i = 0; i < numKeys; ++i) {\n      this.times[i] = keyFrames[i][0];\n      this.values[i] = keyFrames[i][1];\n    }\n\n    this._calculateKeys(this._lastTime);\n  }\n\n  setTime(time: number): void {\n    time = Math.max(0, time);\n\n    if (time !== this._lastTime) {\n      this._calculateKeys(time);\n      this._lastTime = time;\n    }\n  }\n\n  getStartTime(): number {\n    return this.times[this.startIndex];\n  }\n\n  getEndTime(): number {\n    return this.times[this.endIndex];\n  }\n\n  getStartData(): T {\n    return this.values[this.startIndex];\n  }\n\n  getEndData(): T {\n    return this.values[this.endIndex];\n  }\n\n  _calculateKeys(time: number): void {\n    let index = 0;\n    const numKeys = this.times.length;\n\n    for (index = 0; index < numKeys - 2; ++index) {\n      if (this.times[index + 1] > time) {\n        break;\n      }\n    }\n\n    this.startIndex = index;\n    this.endIndex = index + 1;\n\n    const startTime = this.times[this.startIndex];\n    const endTime = this.times[this.endIndex];\n    this.factor = Math.min(Math.max(0, (time - startTime) / (endTime - startTime)), 1);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {AnimationProps} from './animation-props';\n\n/**\n * Minimal class that represents a \"componentized\" rendering life cycle\n * (resource construction, repeated rendering, resource destruction)\n *\n * @note A motivation for this class compared to the raw animation loop is\n * that it simplifies TypeScript code by allowing resources to be typed unconditionally\n * since they are allocated in the constructor rather than in onInitialized\n *\n * @note Introduced in luma.gl v9\n *\n * @example AnimationLoopTemplate is intended to be subclassed,\n * but the subclass should not be instantiated directly. Instead the subclass\n * (i.e. the constructor of the subclass) should be used\n * as an argument to create an AnimationLoop.\n */\nexport abstract class AnimationLoopTemplate {\n  constructor(animationProps?: AnimationProps) {}\n  async onInitialize(animationProps: AnimationProps): Promise<unknown> {\n    return null;\n  }\n  abstract onRender(animationProps: AnimationProps): unknown;\n  abstract onFinalize(animationProps: AnimationProps): void;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Stats} from '@probe.gl/stats';\n\n/**\n * Helper class managing a collection of probe.gl stats objects\n */\nexport class StatsManager {\n  stats = new Map();\n\n  getStats(name: string): Stats {\n    return this.get(name);\n  }\n\n  get(name: string): Stats {\n    if (!this.stats.has(name)) {\n      this.stats.set(name, new Stats({id: name}));\n    }\n\n    return this.stats.get(name);\n  }\n}\n\n/** Global stats for all luma.gl devices */\nexport const lumaStats: StatsManager = new StatsManager();\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Log} from '@probe.gl/log';\n\n/** Global log instance */\nexport const log: Log = new Log({id: 'luma.gl'});\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nconst uidCounters: Record<string, number> = {};\n\n/**\n * Returns a UID.\n * @param id= - Identifier base name\n * @return uid\n **/\nexport function uid(id: string = 'id'): string {\n  uidCounters[id] = uidCounters[id] || 1;\n  const count = uidCounters[id]++;\n  return `${id}-${count}`;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {uid} from '../../utils/uid';\n\nexport type ResourceProps = {\n  /** Name of resource, mainly for debugging purposes. A unique name will be assigned if not provided */\n  id?: string;\n  /** Handle for the underlying resources (WebGL object or WebGPU handle) */\n  handle?: any;\n  /** User provided data stored on this resource  */\n  userData?: {[key: string]: any};\n};\n\n/**\n * Base class for GPU (WebGPU/WebGL) Resources\n */\nexport abstract class Resource<Props extends ResourceProps> {\n  /** Default properties for resource */\n  static defaultProps: Required<ResourceProps> = {\n    id: 'undefined',\n    handle: undefined,\n    userData: undefined!\n  };\n\n  abstract get [Symbol.toStringTag](): string;\n\n  toString(): string {\n    return `${this[Symbol.toStringTag] || this.constructor.name}:\"${this.id}\"`;\n  }\n\n  /** props.id, for debugging. */\n  id: string;\n  readonly props: Required<Props>;\n  readonly userData: Record<string, unknown> = {};\n  abstract readonly device: Device;\n  private _device: Device;\n\n  /** Whether this resource has been destroyed */\n  destroyed: boolean = false;\n  /** For resources that allocate GPU memory */\n  private allocatedBytes: number = 0;\n  /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created \"sub\" resources. */\n  private _attachedResources = new Set<Resource<ResourceProps>>();\n\n  /**\n   * Create a new Resource. Called from Subclass\n   */\n  constructor(device: Device, props: Props, defaultProps: Required<Props>) {\n    if (!device) {\n      throw new Error('no device');\n    }\n    this._device = device;\n    this.props = selectivelyMerge<Props>(props, defaultProps);\n\n    const id =\n      this.props.id !== 'undefined' ? (this.props.id as string) : uid(this[Symbol.toStringTag]);\n    this.props.id = id;\n    this.id = id;\n    this.userData = this.props.userData || {};\n\n    this.addStats();\n  }\n\n  /**\n   * destroy can be called on any resource to release it before it is garbage collected.\n   */\n  destroy(): void {\n    this.destroyResource();\n  }\n\n  /** @deprecated Use destroy() */\n  delete(): this {\n    this.destroy();\n    return this;\n  }\n\n  /**\n   * Combines a map of user props and default props, only including props from defaultProps\n   * @returns returns a map of overridden default props\n   */\n  getProps(): object {\n    return this.props;\n  }\n\n  // ATTACHED RESOURCES\n\n  /**\n   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed\n   * Called automatically when sub resources are auto created but can be called by application\n   */\n  attachResource(resource: Resource<ResourceProps>): void {\n    this._attachedResources.add(resource);\n  }\n\n  /**\n   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.\n   */\n  detachResource(resource: Resource<ResourceProps>): void {\n    this._attachedResources.delete(resource);\n  }\n\n  /**\n   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.\n   */\n  destroyAttachedResource(resource: Resource<ResourceProps>): void {\n    if (this._attachedResources.delete(resource)) {\n      resource.destroy();\n    }\n  }\n\n  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */\n  destroyAttachedResources(): void {\n    for (const resource of Object.values(this._attachedResources)) {\n      resource.destroy();\n    }\n    // don't remove while we are iterating\n    this._attachedResources = new Set<Resource<ResourceProps>>();\n  }\n\n  // PROTECTED METHODS\n\n  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */\n  protected destroyResource(): void {\n    this.destroyAttachedResources();\n    this.removeStats();\n    this.destroyed = true;\n  }\n\n  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */\n  protected removeStats(): void {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    const name = this[Symbol.toStringTag];\n    stats.get(`${name}s Active`).decrementCount();\n  }\n\n  /** Called by subclass to track memory allocations */\n  protected trackAllocatedMemory(bytes: number, name = this[Symbol.toStringTag]): void {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    stats.get('GPU Memory').addCount(bytes);\n    stats.get(`${name} Memory`).addCount(bytes);\n    this.allocatedBytes = bytes;\n  }\n\n  /** Called by subclass to track memory deallocations */\n  protected trackDeallocatedMemory(name = this[Symbol.toStringTag]): void {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    stats.get('GPU Memory').subtractCount(this.allocatedBytes);\n    stats.get(`${name} Memory`).subtractCount(this.allocatedBytes);\n    this.allocatedBytes = 0;\n  }\n\n  /** Called by resource constructor to track object creation */\n  private addStats(): void {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    const name = this[Symbol.toStringTag];\n    stats.get('Resources Created').incrementCount();\n    stats.get(`${name}s Created`).incrementCount();\n    stats.get(`${name}s Active`).incrementCount();\n  }\n}\n\n/**\n * Combines a map of user props and default props, only including props from defaultProps\n * @param props\n * @param defaultProps\n * @returns returns a map of overridden default props\n */\nfunction selectivelyMerge<Props>(props: Props, defaultProps: Required<Props>): Required<Props> {\n  const mergedProps = {...defaultProps};\n  for (const key in props) {\n    if (props[key] !== undefined) {\n      mergedProps[key] = props[key];\n    }\n  }\n  return mergedProps;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n\nexport type BufferProps = ResourceProps & {\n  /** Supply a handle to connect to an existing device-specific buffer */\n  handle?: WebGLBuffer;\n  /** Specifies how this buffer can be used */\n  usage?: number;\n  /** Length in bytes of memory to be allocated. If not specified, `byteLength` of  `props.data` will be used. */\n  byteLength?: number;\n  /** Data to initialize the buffer with. */\n  data?: ArrayBuffer | ArrayBufferView | null;\n  /** Byte offset into the newly created Buffer to store data at */\n  byteOffset?: number;\n  /** If props.usage includes Buffer.INDEX */\n  indexType?: 'uint16' | 'uint32';\n\n  // TBD\n  mappedAtCreation?: boolean;\n};\n\n/** Abstract GPU buffer */\nexport abstract class Buffer extends Resource<BufferProps> {\n  static override defaultProps: Required<BufferProps> = {\n    ...Resource.defaultProps,\n    usage: 0, // Buffer.COPY_DST | Buffer.COPY_SRC\n    byteLength: 0,\n    byteOffset: 0,\n    data: null,\n    indexType: 'uint16',\n    mappedAtCreation: false\n  };\n\n  // Usage Flags\n  static MAP_READ = 0x01;\n  static MAP_WRITE = 0x02;\n  static COPY_SRC = 0x0004;\n  static COPY_DST = 0x0008;\n  /** Index buffer */\n  static INDEX = 0x0010;\n  /** Vertex buffer */\n  static VERTEX = 0x0020;\n  /** Uniform buffer */\n  static UNIFORM = 0x0040;\n  /** Storage buffer */\n  static STORAGE = 0x0080;\n  static INDIRECT = 0x0100;\n  static QUERY_RESOLVE = 0x0200;\n\n  override get [Symbol.toStringTag](): string {\n    return 'Buffer';\n  }\n\n  /** The usage with which this buffer was created */\n  readonly usage: number;\n  /** For index buffers, whether indices are 16 or 32 bit */\n  readonly indexType?: 'uint16' | 'uint32';\n  /** Length of buffer in bytes */\n  abstract byteLength: number;\n  /** \"Time\" of last update, can be used to check if redraw is needed */\n  updateTimestamp: number;\n\n  constructor(device: Device, props: BufferProps) {\n    const deducedProps = {...props};\n\n    // Deduce indexType\n    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {\n      if (props.data instanceof Uint32Array) {\n        deducedProps.indexType = 'uint32';\n      } else if (props.data instanceof Uint16Array) {\n        deducedProps.indexType = 'uint16';\n      }\n    }\n\n    // Remove data from props before storing, we don't want to hold on to a big chunk of memory\n    delete deducedProps.data;\n\n    super(device, deducedProps, Buffer.defaultProps);\n\n    this.usage = deducedProps.usage || 0;\n    this.indexType = deducedProps.indexType;\n\n    // TODO - perhaps this should be set on async write completion?\n    this.updateTimestamp = device.incrementTimestamp();\n  }\n\n  /**\n   * Create a copy of this Buffer with new byteLength, with same props but of the specified size.\n   * @note Does not copy contents of the cloned Buffer.\n   */\n  clone(props: {byteLength: number}): Buffer {\n    return this.device.createBuffer({...this.props, ...props});\n  }\n\n  /** Write data to buffer */\n  abstract write(data: ArrayBufferView, byteOffset?: number): void;\n\n  /** Read data asynchronously */\n  abstract readAsync(byteOffset?: number, byteLength?: number): Promise<Uint8Array>;\n\n  /** Read data synchronously. @note WebGL2 only */\n  readSyncWebGL(byteOffset?: number, byteLength?: number): Uint8Array {\n    throw new Error('not implemented');\n  }\n\n  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)\n\n  /** Max amount of debug data saved. Two vec4's */\n  static DEBUG_DATA_MAX_LENGTH = 32;\n\n  /** A partial CPU-side copy of the data in this buffer, for debugging purposes */\n  debugData: ArrayBuffer = new ArrayBuffer(0);\n\n  /** This doesn't handle partial non-zero offset updates correctly */\n  protected _setDebugData(\n    data: ArrayBufferView | ArrayBuffer | null,\n    byteOffset: number,\n    byteLength: number\n  ): void {\n    const arrayBuffer: ArrayBuffer | null = ArrayBuffer.isView(data) ? data.buffer : data;\n    const debugDataLength = Math.min(\n      data ? data.byteLength : byteLength,\n      Buffer.DEBUG_DATA_MAX_LENGTH\n    );\n    if (arrayBuffer === null) {\n      this.debugData = new ArrayBuffer(debugDataLength);\n    } else if (byteOffset === 0 && byteLength === arrayBuffer.byteLength) {\n      this.debugData = arrayBuffer.slice(0, debugDataLength);\n    } else {\n      this.debugData = arrayBuffer.slice(byteOffset, byteOffset + debugDataLength);\n    }\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {DataType, NormalizedDataType} from './vertex-formats';\n\nexport type DecodedVertexType = {\n  /** WebGPU data type */\n  dataType: DataType;\n  /** Length in bytes of the data for one vertex */\n  byteLength: number;\n  /** Whether this is for integer or float vert */\n  integer: boolean;\n  /** Whether this data type is signed */\n  signed: boolean;\n  /** Whether this is a normalized integer (that must be used as float) */\n  normalized: boolean;\n};\n\n/** Decodes a vertex type, returning byte length and flags (integer, signed, normalized) */\nexport function decodeVertexType(type: NormalizedDataType): DecodedVertexType {\n  const dataType = TYPE_MAP[type];\n  const bytes = getDataTypeBytes(dataType);\n  const normalized: boolean = type.includes('norm');\n  const integer: boolean = !normalized && !type.startsWith('float');\n  const signed: boolean = type.startsWith('s');\n  return {\n    dataType: TYPE_MAP[type],\n    byteLength: bytes,\n    integer,\n    signed,\n    normalized\n  };\n}\n\nfunction getDataTypeBytes(type: DataType): number {\n  const bytes = TYPE_SIZES[type];\n  // assert(bytes);\n  return bytes;\n}\n\nconst TYPE_MAP: Record<NormalizedDataType, DataType> = {\n  uint8: 'uint8',\n  sint8: 'sint8',\n  unorm8: 'uint8',\n  snorm8: 'sint8',\n  uint16: 'uint16',\n  sint16: 'sint16',\n  unorm16: 'uint16',\n  snorm16: 'sint16',\n  float16: 'float16',\n  float32: 'float32',\n  uint32: 'uint32',\n  sint32: 'sint32'\n};\n\nconst TYPE_SIZES: Record<DataType, number> = {\n  uint8: 1,\n  sint8: 1,\n  uint16: 2,\n  sint16: 2,\n  float16: 2,\n  float32: 4,\n  uint32: 4,\n  sint32: 4\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TextureFormat} from './texture-formats';\nimport {TextureFeature} from './texture-features';\nimport {TextureFormatInfo} from './texture-format-info';\n\n/* eslint-disable camelcase */\n\n// Define local device feature strings to optimize minification\nconst texture_compression_bc: TextureFeature = 'texture-compression-bc';\nconst texture_compression_astc: TextureFeature = 'texture-compression-astc';\nconst texture_compression_etc2: TextureFeature = 'texture-compression-etc2';\nconst texture_compression_etc1_webgl: TextureFeature = 'texture-compression-etc1-webgl';\nconst texture_compression_pvrtc_webgl: TextureFeature = 'texture-compression-pvrtc-webgl';\nconst texture_compression_atc_webgl: TextureFeature = 'texture-compression-atc-webgl';\n\nconst float32_renderable: TextureFeature = 'float32-renderable-webgl';\nconst float16_renderable: TextureFeature = 'float16-renderable-webgl';\nconst rgb9e5ufloat_renderable: TextureFeature = 'rgb9e5ufloat-renderable-webgl';\nconst snorm8_renderable: TextureFeature = 'snorm8-renderable-webgl';\nconst norm16_renderable: TextureFeature = 'norm16-renderable-webgl';\nconst snorm16_renderable: TextureFeature = 'snorm16-renderable-webgl';\n\nconst float32_filterable: TextureFeature = 'float32-filterable';\nconst float16_filterable: TextureFeature = 'float16-filterable-webgl';\n\n/** https://www.w3.org/TR/webgpu/#texture-format-caps */\n\n/** Internal type representing texture capabilities */\ntype TextureFormatDefinition = Partial<TextureFormatInfo> & {\n  /** for compressed texture formats */\n  f?: TextureFeature;\n  /** renderable if feature is present. false means the spec does not support this format */\n  render?: TextureFeature | false;\n  /** filterable if feature is present. false means the spec does not support this format */\n  filter?: TextureFeature | false;\n  blend?: TextureFeature | false;\n  store?: TextureFeature | false;\n\n  /** (bytes per pixel), for memory usage calculations. */\n  b?: number;\n  /** channels */\n  c?: number;\n  bpp?: number;\n  /** packed */\n  p?: number;\n\n  /** If not supported on WebGPU */\n  wgpu?: false;\n};\n\nexport function getTextureFormatDefinition(format: TextureFormat): TextureFormatDefinition {\n  const info = TEXTURE_FORMAT_TABLE[format];\n  if (!info) {\n    throw new Error(`Unsupported texture format ${format}`);\n  }\n  return info;\n}\n\nexport function getTextureFormatTable(): Readonly<Record<TextureFormat, TextureFormatDefinition>> {\n  return TEXTURE_FORMAT_TABLE;\n}\n\n// prettier-ignore\nconst TEXTURE_FORMAT_TABLE: Readonly<Record<TextureFormat, TextureFormatDefinition>> = {\n  // 8-bit formats\n  'r8unorm': {},\n  'r8snorm': {render: snorm8_renderable},\n  'r8uint': {},\n  'r8sint': {},\n\n  // 16-bit formats\n  'rg8unorm': {},\n  'rg8snorm': {render: snorm8_renderable},\n  'rg8uint': {},\n  'rg8sint': {},\n\n  'r16uint': {},\n  'r16sint': {},\n  'r16float': {render: float16_renderable, filter: 'float16-filterable-webgl'},\n  'r16unorm-webgl': {f: norm16_renderable},\n  'r16snorm-webgl': {f: snorm16_renderable},\n\n  // Packed 16-bit formats\n  'rgba4unorm-webgl': {channels: 'rgba', bitsPerChannel: [4, 4, 4, 4], packed: true},\n  'rgb565unorm-webgl': {channels: 'rgb', bitsPerChannel: [5, 6, 5, 0], packed: true},\n  'rgb5a1unorm-webgl': {channels: 'rgba', bitsPerChannel: [5, 5, 5, 1], packed: true},\n\n  // 24-bit formats\n  'rgb8unorm-webgl': {},\n  'rgb8snorm-webgl': {},\n\n  // 32-bit formats  \n  'rgba8unorm': {},\n  'rgba8unorm-srgb': {},\n  'rgba8snorm': {render: snorm8_renderable},\n  'rgba8uint': {},\n  'rgba8sint': {},\n\n  // 32-bit, reverse colors, webgpu only\n  'bgra8unorm': {},\n  'bgra8unorm-srgb': {},\n\n  'rg16uint': {},\n  'rg16sint': {},\n  'rg16float': {render: float16_renderable, filter: float16_filterable},\n  'rg16unorm-webgl': {render: norm16_renderable},\n  'rg16snorm-webgl': {render: snorm16_renderable},\n\n  'r32uint': {},\n  'r32sint': {},\n  'r32float': {render: float32_renderable, filter: float32_filterable},\n\n  // Packed 32 bit formats\n  'rgb9e5ufloat': {channels: 'rgb', packed: true, render: rgb9e5ufloat_renderable}, // , filter: true},\n  'rg11b10ufloat': {channels: 'rgb', bitsPerChannel: [11, 11, 10, 0], packed: true, p: 1,render: float32_renderable},\n  'rgb10a2unorm': {channels: 'rgba',  bitsPerChannel: [10, 10, 10, 2], packed: true, p: 1},\n  'rgb10a2uint-webgl': {channels: 'rgba', bitsPerChannel: [10, 10, 10, 2], packed: true, p: 1, wgpu: false},\n\n  // 48-bit formats\n  'rgb16unorm-webgl': {f: norm16_renderable}, // rgb not renderable\n  'rgb16snorm-webgl': {f: norm16_renderable}, // rgb not renderable\n\n  // 64-bit formats\n  'rg32uint': {},\n  'rg32sint': {},\n  'rg32float': {render: false, filter: float32_filterable},\n  'rgba16uint': {},\n  'rgba16sint': {},\n  'rgba16float': {render: float16_renderable, filter: float16_filterable},\n  'rgba16unorm-webgl': {render: norm16_renderable},\n  'rgba16snorm-webgl': {render: snorm16_renderable},\n\n  // 96-bit formats (deprecated!)\n  'rgb32float-webgl': {render: float32_renderable, filter: float32_filterable},\n  \n  // 128-bit formats\n  'rgba32uint': {},\n  'rgba32sint': {},\n  'rgba32float': {render: float32_renderable, filter: float32_filterable},\n\n  // Depth/stencil\n  \n  // Depth and stencil formats\n  stencil8: {attachment: 'stencil', bitsPerChannel: [8, 0, 0, 0], dataType: 'uint8'},\n  'depth16unorm': {attachment: 'depth',  bitsPerChannel: [16, 0, 0, 0], dataType: 'uint16'},\n  'depth24plus': {attachment: 'depth', bitsPerChannel: [24, 0, 0, 0], dataType: 'uint32'},\n  'depth32float': {attachment: 'depth', bitsPerChannel: [32, 0, 0, 0], dataType: 'float32'},\n  // The depth component of the \"depth24plus\" and \"depth24plus-stencil8\" formats may be implemented as either a 24-bit depth value or a \"depth32float\" value.\n  'depth24plus-stencil8': {attachment: 'depth-stencil', bitsPerChannel: [24, 8, 0, 0], packed: true},\n  // \"depth32float-stencil8\" feature\n  'depth32float-stencil8': {attachment: 'depth-stencil', bitsPerChannel: [32, 8, 0, 0], packed: true},\n\n  // BC compressed formats: check device.features.has(\"texture-compression-bc\");\n\n  'bc1-rgb-unorm-webgl': {f: texture_compression_bc},\n  'bc1-rgb-unorm-srgb-webgl': {f: texture_compression_bc},\n\n  'bc1-rgba-unorm': {f: texture_compression_bc},\n  'bc1-rgba-unorm-srgb': {f: texture_compression_bc},\n  'bc2-rgba-unorm': {f: texture_compression_bc},\n  'bc2-rgba-unorm-srgb': {f: texture_compression_bc},\n  'bc3-rgba-unorm': {f: texture_compression_bc},\n  'bc3-rgba-unorm-srgb': {f: texture_compression_bc},\n  'bc4-r-unorm': {f: texture_compression_bc},\n  'bc4-r-snorm': {f: texture_compression_bc},\n  'bc5-rg-unorm': {f: texture_compression_bc},\n  'bc5-rg-snorm': {f: texture_compression_bc},\n  'bc6h-rgb-ufloat': {f: texture_compression_bc},\n  'bc6h-rgb-float': {f: texture_compression_bc},\n  'bc7-rgba-unorm': {f: texture_compression_bc},\n  'bc7-rgba-unorm-srgb': {f: texture_compression_bc},\n\n  // WEBGL_compressed_texture_etc: device.features.has(\"texture-compression-etc2\")\n  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression\n\n  'etc2-rgb8unorm': {f: texture_compression_etc2},\n  'etc2-rgb8unorm-srgb': {f: texture_compression_etc2},\n  'etc2-rgb8a1unorm': {f: texture_compression_etc2},\n  'etc2-rgb8a1unorm-srgb': {f: texture_compression_etc2},\n  'etc2-rgba8unorm': {f: texture_compression_etc2},\n  'etc2-rgba8unorm-srgb': {f: texture_compression_etc2},\n\n  'eac-r11unorm': {f: texture_compression_etc2},\n  'eac-r11snorm': {f: texture_compression_etc2},\n  'eac-rg11unorm': {f: texture_compression_etc2},\n  'eac-rg11snorm': {f: texture_compression_etc2},\n\n  // X_ASTC compressed formats: device.features.has(\"texture-compression-astc\")\n\n  'astc-4x4-unorm': {f: texture_compression_astc},\n  'astc-4x4-unorm-srgb': {f: texture_compression_astc},\n  'astc-5x4-unorm': {f: texture_compression_astc},\n  'astc-5x4-unorm-srgb': {f: texture_compression_astc},\n  'astc-5x5-unorm': {f: texture_compression_astc},\n  'astc-5x5-unorm-srgb': {f: texture_compression_astc},\n  'astc-6x5-unorm': {f: texture_compression_astc},\n  'astc-6x5-unorm-srgb': {f: texture_compression_astc},\n  'astc-6x6-unorm': {f: texture_compression_astc},\n  'astc-6x6-unorm-srgb': {f: texture_compression_astc},\n  'astc-8x5-unorm': {f: texture_compression_astc},\n  'astc-8x5-unorm-srgb': {f: texture_compression_astc},\n  'astc-8x6-unorm': {f: texture_compression_astc},\n  'astc-8x6-unorm-srgb': {f: texture_compression_astc},\n  'astc-8x8-unorm': {f: texture_compression_astc},\n  'astc-8x8-unorm-srgb': {f: texture_compression_astc},\n  'astc-10x5-unorm': {f: texture_compression_astc},\n  'astc-10x5-unorm-srgb': {f: texture_compression_astc},\n  'astc-10x6-unorm': {f: texture_compression_astc},\n  'astc-10x6-unorm-srgb': {f: texture_compression_astc},\n  'astc-10x8-unorm': {f: texture_compression_astc},\n  'astc-10x8-unorm-srgb': {f: texture_compression_astc},\n  'astc-10x10-unorm': {f: texture_compression_astc},\n  'astc-10x10-unorm-srgb': {f: texture_compression_astc},\n  'astc-12x10-unorm': {f: texture_compression_astc},\n  'astc-12x10-unorm-srgb': {f: texture_compression_astc},\n  'astc-12x12-unorm': {f: texture_compression_astc},\n  'astc-12x12-unorm-srgb': {f: texture_compression_astc},\n\n  // WEBGL_compressed_texture_pvrtc\n\n  'pvrtc-rgb4unorm-webgl': {f: texture_compression_pvrtc_webgl},\n  'pvrtc-rgba4unorm-webgl': {f: texture_compression_pvrtc_webgl},\n  'pvrtc-rbg2unorm-webgl': {f: texture_compression_pvrtc_webgl},\n  'pvrtc-rgba2unorm-webgl': {f: texture_compression_pvrtc_webgl},\n\n  // WEBGL_compressed_texture_etc1\n\n  'etc1-rbg-unorm-webgl': {f: texture_compression_etc1_webgl},\n\n  // WEBGL_compressed_texture_atc\n\n  'atc-rgb-unorm-webgl': {f: texture_compression_atc_webgl},\n  'atc-rgba-unorm-webgl': {f: texture_compression_atc_webgl},\n  'atc-rgbai-unorm-webgl': {f: texture_compression_atc_webgl}\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TextureFormat, CompressedTextureFormat} from './texture-formats';\nimport {VertexType} from './vertex-formats';\nimport {decodeVertexType} from './decode-data-type';\nimport {TextureFormatInfo} from './texture-format-info';\n\nimport {getTextureFormatDefinition} from './texture-format-table';\n\n// prettier-ignore\nconst COMPRESSED_TEXTURE_FORMAT_PREFIXES = [\n  'bc1', 'bc2', 'bc3', 'bc4', 'bc5', 'bc6', 'bc7', 'etc1', 'etc2', 'eac', 'atc', 'astc', 'pvrtc'\n];\n\nconst RGB_FORMAT_REGEX = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;\n\n/**\n * Returns true if a texture format is GPU compressed\n */\nexport function isTextureFormatCompressed(\n  format: TextureFormat\n): format is CompressedTextureFormat {\n  return COMPRESSED_TEXTURE_FORMAT_PREFIXES.some(prefix => (format as string).startsWith(prefix));\n}\n\n/**\n * Decodes a texture format, returning e.g. attatchment type, components, byte length and flags (integer, signed, normalized)\n */\nexport function decodeTextureFormat(format: TextureFormat): TextureFormatInfo {\n  let formatInfo: TextureFormatInfo = decodeTextureFormatUsingTable(format);\n\n  if (isTextureFormatCompressed(format)) {\n    formatInfo.channels = 'rgb';\n    formatInfo.components = 3;\n    formatInfo.bytesPerPixel = 1;\n    formatInfo.srgb = false;\n    formatInfo.compressed = true;\n\n    const blockSize = getCompressedTextureBlockSize(format);\n    if (blockSize) {\n      formatInfo.blockWidth = blockSize.blockWidth;\n      formatInfo.blockHeight = blockSize.blockHeight;\n    }\n  }\n\n  // Fill in missing information that can be derived from the format string\n  const matches = RGB_FORMAT_REGEX.exec(format as string);\n  if (matches) {\n    const [, channels, length, type, srgb, suffix] = matches;\n    const dataType = `${type}${length}` as VertexType;\n    const decodedType = decodeVertexType(dataType);\n    const bits = decodedType.byteLength * 8;\n    const components = channels.length as 1 | 2 | 3 | 4;\n    const bitsPerChannel: [number, number, number, number] = [\n      bits,\n      components >= 2 ? bits : 0,\n      components >= 3 ? bits : 0,\n      components >= 4 ? bits : 0\n    ];\n\n    formatInfo = {\n      format,\n      attachment: formatInfo.attachment,\n      dataType: decodedType.dataType,\n      components,\n      channels: channels as 'r' | 'rg' | 'rgb' | 'rgba',\n      integer: decodedType.integer,\n      signed: decodedType.signed,\n      normalized: decodedType.normalized,\n      bitsPerChannel,\n      bytesPerPixel: decodedType.byteLength * channels.length,\n      packed: formatInfo.packed,\n      srgb: formatInfo.srgb\n    };\n\n    if (suffix === '-webgl') {\n      formatInfo.webgl = true;\n    }\n    // dataType - overwritten by decodedType\n    if (srgb === '-srgb') {\n      formatInfo.srgb = true;\n    }\n  }\n\n  if (format.endsWith('-webgl')) {\n    formatInfo.webgl = true;\n  }\n  if (format.endsWith('-srgb')) {\n    formatInfo.srgb = true;\n  }\n\n  return formatInfo;\n}\n\n/** Decode texture format info from the table */\nfunction decodeTextureFormatUsingTable(format: TextureFormat): TextureFormatInfo {\n  const info = getTextureFormatDefinition(format);\n\n  const bytesPerPixel = info.bytesPerPixel || 1;\n  const bitsPerChannel = info.bitsPerChannel || [8, 8, 8, 8];\n  delete info.bitsPerChannel;\n  delete info.bytesPerPixel;\n  delete info.f;\n  delete info.render;\n  delete info.filter;\n  delete info.blend;\n  delete info.store;\n\n  const formatInfo: TextureFormatInfo = {\n    ...info,\n    format,\n    attachment: info.attachment || 'color',\n    channels: info.channels || 'r',\n    components: (info.components || info.channels?.length || 1) as 1 | 2 | 3 | 4,\n    bytesPerPixel,\n    bitsPerChannel,\n    dataType: info.dataType || 'uint8',\n    srgb: info.srgb ?? false,\n    packed: info.packed ?? false,\n    webgl: info.webgl ?? false,\n    integer: info.integer ?? false,\n    signed: info.signed ?? false,\n    normalized: info.normalized ?? false,\n    compressed: info.compressed ?? false\n  };\n\n  return formatInfo;\n}\n\n/** Parses ASTC block widths from format string */\nfunction getCompressedTextureBlockSize(\n  format: CompressedTextureFormat\n): {blockWidth: number; blockHeight: number} | null {\n  const REGEX = /.*-(\\d+)x(\\d+)-.*/;\n  const matches = REGEX.exec(format as string);\n  if (matches) {\n    const [, blockWidth, blockHeight] = matches;\n    return {blockWidth: Number(blockWidth), blockHeight: Number(blockHeight)};\n  }\n  return null;\n}\n\n/*\n'r8unorm':\t{s: \"float\"}, // \t✓\t✓\t✓\t},\n'r8snorm':\t{s: \"float\"}, // \t\t✓\t\t},\n'r8uint':\t{s: \"uint\"}, // \t✓\t✓\t\t},\n'r8sint':\t{s: \"sint\"}, // \t✓\t✓\t\t},\n'rg8unorm':\t{s: \"float\"}, // \t✓\t✓\t✓\t},\n'rg8snorm':\t{s: \"float\"}, // \t\t✓\t\t},\n'rg8uint':\t{s: \"uint\"}, // \t✓\t✓\t\t},\n'rg8sint':\t{s: \"sint\"}, // \t✓\t✓\t\t},\n'rgba8unorm':\t{s: \"float\"}, // \t✓\t✓\t✓\t✓},\n'rgba8unorm-srgb': {s: \"float\"}, // \t✓\t✓\t✓\t},\n'rgba8snorm':\t{s: \"float\"}, // \t\t✓\t\t✓},\n'rgba8uint':\t{s: \"uint\"}, // \t✓\t✓\t\t✓},\n'rgba8sint':\t{s: \"sint\"}, // \t✓\t✓\t\t✓},\n'bgra8unorm':\t{s: \"float\"}, // \t✓\t✓\t✓\t},\n'bgra8unorm-srgb': {s: \"float\"}, // \t✓\t✓\t✓\t},\n// 16-bit per component\t\t\t\t\t\n'r16uint': {s: \"uint\"}, // \t✓\t✓\t\t},\n'r16sint': {s: \"sint\"}, // \t✓\t✓\t\t},\n'r16float': {s: \"float\"}, // \t✓\t✓\t✓\t},\n'rg16uint': {s: \"uint\"}, // \t✓\t✓\t\t},\n'rg16sint': {s: \"sint\"}, // \t✓\t✓\t\t},\n'rg16float': {s: \"float\"}, // \t✓\t✓\t✓\t},\n'rgba16uint': {s: \"uint\"}, // \t✓\t✓\t\t✓},\n'rgba16sint': {s: \"sint\"}, // \t✓\t✓\t\t✓},\n'rgba16float': {s: \"float\"}, // \t✓\t✓\t✓\t✓},\n// 32-bit per component\t\t\t\t\t\n'r32uint': {s: \"uint\"}, // \t✓\t\t\t✓},\n'r32sint': {s: \"sint\"}, // \t✓\t\t\t✓},\n'r32float': {\"unfilterable-float\"\t✓\t✓\t\t✓},\n'rg32uint': {s: \"uint\"}, // \t✓\t\t\t✓},\n'rg32sint': {s: \"sint\"}, // \t✓\t\t\t✓},\n'rg32float': {\"unfilterable-float\"\t✓\t\t\t✓},\n'rgba32uint': {s: \"uint\"}, // \t✓\t\t\t✓},\n'rgba32sint': {s: \"sint\"}, // \t✓\t\t\t✓},\n'rgba32float': {\"unfilterable-float\"\t✓\t\t\t✓},\n// mixed component width\t\t\t\t\t\n'rgb10a2unorm': {s: \"float\"}, // \t✓\t✓\t✓\t}\n'rg11b10ufloat': {s: \"float\"}, // \t\t✓\t\t}\n// Format\tBytes per texel\tAspect\tGPUTextureSampleType\tValid image copy source\tValid image copy destination\n'stencil8': {1 − 4\tstencil\t\"uint\"\t✓}\n'depth16unorm': {2\tdepth\t\"depth\"\t✓}\n'depth24plus': {4\tdepth\t\"depth\"\t✗}\n'depth24plus': {stencil8\t4 − 8\tdepth\t\"depth\"\t✗}\n'stencil': {s: \"uint\"}, // \t✓}\n'depth32float': {4\tdepth\t\"depth\"\t✓\t✗}\n'depth24unorm': {stencil8\t4\tdepth\t\"depth\"\t✗}\n'stencil': {s: \"uint\"}, // \t✓}\n'depth32float': {stencil8}\n\n// Format\tBytes per block\tGPUTextureSampleType\tBlock Size\tFeature\n'rgb9e5ufloat': {c: 4, s: \"float\",\tbpp: 4/(1*1)},\n\n'bc1-rgba-unorm': {c: 4. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc1-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc2-rgba-unorm': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc2-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc3-rgba-unorm': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc3-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc4-r-unorm': {c: 1. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc4-r-snorm': {c: 1. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc5-rg-unorm': {c: 2. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc5-rg-snorm': { },\n'bc6h-rgb-ufloat': {\t16 },\n'bc6h-rgb-float': { },\n'bc7-rgba-unorm': {\t16 },\n'bc7-rgba-unorm-srgb': { },\n\n'etc2-rgb8unorm': {\t8\t\"float\"\t4 × 4\ttexture-compression-etc2 },\n'etc2-rgb8unorm-srgb': { },\n'etc2-rgb8a1unorm': {\t8 },\n'etc2-rgb8a1unorm-srgb': { },\n'etc2-rgba8unorm': {\t16 },\n'etc2-rgba8unorm-srgb': { },\n\n'eac-r11unorm': {\t8 },\n'eac-r11snorm': { },\n'eac-rg11unorm': {\t16 },\n'eac-rg11snorm': { },\n\n'astc-4x4-unorm': {\t16\t\"float\"\t4 × 4\ttexture-compression-astc },\n'astc-4x4-unorm-srgb': { },\n'astc-5x4-unorm': {\t16\t5 × 4 },\n'astc-5x4-unorm-srgb': { },\n'astc-5x5-unorm': {\t16\t5 × 5 },\n'astc-5x5-unorm-srgb': { },\n'astc-6x5-unorm': {\t16\t6 × 5 },\n'astc-6x5-unorm-srgb': { },\n'astc-6x6-unorm': {\t16\t6 × 6 },\n'astc-6x6-unorm-srgb': { },\n'astc-8x5-unorm': {\t16\t8 × 5 },\n'astc-8x5-unorm-srgb': { },\n'astc-8x6-unorm': {\t16\t8 × 6 },\n'astc-8x6-unorm-srgb': { },\n'astc-8x8-unorm': {\t16\t8 × 8 },\n'astc-8x8-unorm-srgb': { },\n'astc-10x5-unorm': {\t16\t10 × 5 },\n'astc-10x5-unorm-srgb': { },\n'astc-10x6-unorm': {\t16\t10 × 6 },\n'astc-10x6-unorm-srgb': { },\n'astc-10x8-unorm': {\t16\t10 × 8 },\n'astc-10x8-unorm-srgb': { },\n'astc-10x10-unorm': {\t16\t10 × 10 },\n'astc-10x10-unorm-srgb': { },\n'astc-12x10-unorm': {\t16\t12 × 10 },\n'astc-12x10-unorm-srgb': { },\n'astc-12x12-unorm': {\t16 },\n*/\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TextureFormat} from './texture-formats';\nimport type {TextureFeature} from './texture-features';\nimport {decodeTextureFormat} from './decode-texture-format';\n\nimport {getTextureFormatDefinition} from './texture-format-table';\n\n/**\n * Texture format capabilities.\n * @note Not directly usable. Can contain TextureFeature strings that need to be checked against a specific device.\n */\nexport type TextureFormatCapabilities = {\n  format: TextureFormat;\n  /** Can the format be created */\n  create: TextureFeature | boolean;\n  /** If a feature string, the specified device feature determines if format is renderable. */\n  render: TextureFeature | boolean;\n  /** If a feature string, the specified device feature determines if format is filterable. */\n  filter: TextureFeature | boolean;\n  /** If a feature string, the specified device feature determines if format is blendable. */\n  blend: TextureFeature | boolean;\n  /** If a feature string, the specified device feature determines if format is storeable. */\n  store: TextureFeature | boolean;\n};\n\nexport function getTextureFormatCapabilities(format: TextureFormat): TextureFormatCapabilities {\n  const info = getTextureFormatDefinition(format);\n\n  const formatCapabilities: Required<TextureFormatCapabilities> = {\n    format,\n    create: info.f ?? true,\n    render: info.render ?? true,\n    filter: info.filter ?? true,\n    blend: info.blend ?? true,\n    store: info.store ?? true\n  };\n\n  const formatInfo = decodeTextureFormat(format);\n  const isDepthStencil = format.startsWith('depth') || format.startsWith('stencil');\n  const isSigned = formatInfo?.signed;\n  const isInteger = formatInfo?.integer;\n  const isWebGLSpecific = formatInfo?.webgl;\n\n  // signed formats are not renderable\n  formatCapabilities.render &&= !isSigned;\n  // signed and integer formats are not filterable\n  formatCapabilities.filter &&= !isDepthStencil && !isSigned && !isInteger && !isWebGLSpecific;\n\n  return formatCapabilities;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {StatsManager, lumaStats} from '../utils/stats-manager';\nimport {log} from '../utils/log';\nimport {uid} from '../utils/uid';\nimport type {TextureFormat} from '../gpu-type-utils/texture-formats';\nimport type {TextureFormatCapabilities} from '../gpu-type-utils/texture-format-capabilities';\nimport type {CanvasContext, CanvasContextProps} from './canvas-context';\nimport type {BufferProps} from './resources/buffer';\nimport {Buffer} from './resources/buffer';\nimport type {RenderPipeline, RenderPipelineProps} from './resources/render-pipeline';\nimport type {ComputePipeline, ComputePipelineProps} from './resources/compute-pipeline';\nimport type {Sampler, SamplerProps} from './resources/sampler';\nimport type {Shader, ShaderProps} from './resources/shader';\nimport type {Texture, TextureProps} from './resources/texture';\nimport type {ExternalTexture, ExternalTextureProps} from './resources/external-texture';\nimport type {Framebuffer, FramebufferProps} from './resources/framebuffer';\nimport type {RenderPass, RenderPassProps} from './resources/render-pass';\nimport type {ComputePass, ComputePassProps} from './resources/compute-pass';\nimport type {CommandEncoder, CommandEncoderProps} from './resources/command-encoder';\nimport type {VertexArray, VertexArrayProps} from './resources/vertex-array';\nimport type {TransformFeedback, TransformFeedbackProps} from './resources/transform-feedback';\nimport type {QuerySet, QuerySetProps} from './resources/query-set';\n\nimport {isTextureFormatCompressed} from '../gpu-type-utils/decode-texture-format';\nimport {getTextureFormatCapabilities} from '../gpu-type-utils/texture-format-capabilities';\n\n/**\n * Identifies the GPU vendor and driver.\n * @note Chrome WebGPU does not provide much information, though more can be enabled with\n * @see https://developer.chrome.com/blog/new-in-webgpu-120#adapter_information_updates\n * chrome://flags/#enable-webgpu-developer-features\n */\nexport type DeviceInfo = {\n  /** Type of device */\n  type: 'webgl' | 'webgpu' | 'unknown';\n  /** Vendor (name of GPU vendor, Apple, nVidia etc */\n  vendor: string;\n  /** Renderer (usually driver name) */\n  renderer: string;\n  /** version of driver */\n  version: string;\n  /** family of GPU */\n  gpu: 'nvidia' | 'amd' | 'intel' | 'apple' | 'software' | 'unknown';\n  /** Type of GPU () */\n  gpuType: 'discrete' | 'integrated' | 'cpu' | 'unknown';\n  /** GPU architecture */\n  gpuArchitecture?: string; // 'common-3' on Apple\n  /** GPU driver backend. Can sometimes be sniffed */\n  gpuBackend?: 'opengl' | 'opengles' | 'metal' | 'd3d11' | 'd3d12' | 'vulkan' | 'unknown';\n  /** If this is a fallback adapter */\n  fallback?: boolean;\n  /** Shader language supported by device.createShader() */\n  shadingLanguage: 'wgsl' | 'glsl';\n  /** Highest supported shader language version: GLSL 3.00 = 300, WGSL 1.00 = 100 */\n  shadingLanguageVersion: number;\n};\n\n/** Limits for a device (max supported sizes of resources, max number of bindings etc) */\nexport abstract class DeviceLimits {\n  /** max number of TextureDimension1D */\n  abstract maxTextureDimension1D: number;\n  /** max number of TextureDimension2D */\n  abstract maxTextureDimension2D: number;\n  /** max number of TextureDimension3D */\n  abstract maxTextureDimension3D: number;\n  /** max number of TextureArrayLayers */\n  abstract maxTextureArrayLayers: number;\n  /** max number of BindGroups */\n  abstract maxBindGroups: number;\n  /** max number of DynamicUniformBuffers per PipelineLayout */\n  abstract maxDynamicUniformBuffersPerPipelineLayout: number;\n  /** max number of DynamicStorageBuffers per PipelineLayout */\n  abstract maxDynamicStorageBuffersPerPipelineLayout: number;\n  /** max number of SampledTextures per ShaderStage */\n  abstract maxSampledTexturesPerShaderStage: number;\n  /** max number of Samplers per ShaderStage */\n  abstract maxSamplersPerShaderStage: number;\n  /** max number of StorageBuffers per ShaderStage */\n  abstract maxStorageBuffersPerShaderStage: number;\n  /** max number of StorageTextures per ShaderStage */\n  abstract maxStorageTexturesPerShaderStage: number;\n  /** max number of UniformBuffers per ShaderStage */\n  abstract maxUniformBuffersPerShaderStage: number;\n  /** max number of UniformBufferBindingSize */\n  abstract maxUniformBufferBindingSize: number;\n  /** max number of StorageBufferBindingSize */\n  abstract maxStorageBufferBindingSize: number;\n  /** min UniformBufferOffsetAlignment */\n  abstract minUniformBufferOffsetAlignment: number;\n  /** min StorageBufferOffsetAlignment */\n  abstract minStorageBufferOffsetAlignment: number;\n  /** max number of VertexBuffers */\n  abstract maxVertexBuffers: number;\n  /** max number of VertexAttributes */\n  abstract maxVertexAttributes: number;\n  /** max number of VertexBufferArrayStride */\n  abstract maxVertexBufferArrayStride: number;\n  /** max number of InterStageShaderComponents */\n  abstract maxInterStageShaderComponents: number;\n  /** max number of ComputeWorkgroupStorageSize */\n  abstract maxComputeWorkgroupStorageSize: number;\n  /** max number of ComputeInvocations per Workgroup */\n  abstract maxComputeInvocationsPerWorkgroup: number;\n  /** max ComputeWorkgroupSizeX */\n  abstract maxComputeWorkgroupSizeX: number;\n  /** max ComputeWorkgroupSizeY */\n  abstract maxComputeWorkgroupSizeY: number;\n  /** max ComputeWorkgroupSizeZ */\n  abstract maxComputeWorkgroupSizeZ: number;\n  /** max ComputeWorkgroupsPerDimension */\n  abstract maxComputeWorkgroupsPerDimension: number;\n}\n\n/** Set-like class for features (lets apps check for WebGL / WebGPU extensions) */\nexport class DeviceFeatures {\n  protected features: Set<DeviceFeature>;\n  protected disabledFeatures?: Partial<Record<DeviceFeature, boolean>>;\n\n  constructor(\n    features: DeviceFeature[] = [],\n    disabledFeatures: Partial<Record<DeviceFeature, boolean>>\n  ) {\n    this.features = new Set<DeviceFeature>(features);\n    this.disabledFeatures = disabledFeatures || {};\n  }\n\n  *[Symbol.iterator](): IterableIterator<DeviceFeature> {\n    yield* this.features;\n  }\n\n  has(feature: DeviceFeature): boolean {\n    return !this.disabledFeatures?.[feature] && this.features.has(feature);\n  }\n}\n\n/** Device feature names */\nexport type DeviceFeature =\n  | WebGPUDeviceFeature\n  | WebGLDeviceFeature\n  | WebGLCompressedTextureFeatures;\n\nexport type WebGPUDeviceFeature =\n  | 'depth-clip-control'\n  | 'indirect-first-instance'\n  | 'timestamp-query'\n  | 'shader-f16'\n  | 'depth32float-stencil8'\n  | 'rg11b10ufloat-renderable' // Is the rg11b10ufloat texture format renderable?\n  | 'float32-filterable' // Is the float32 format filterable?\n  | 'bgra8unorm-storage' // Can the bgra8unorm texture format be used in storage buffers?\n  | 'texture-compression-bc'\n  | 'texture-compression-etc2'\n  | 'texture-compression-astc';\n// | 'depth-clamping' // removed from the WebGPU spec...\n// | 'pipeline-statistics-query' // removed from the WebGPU spec...\n\nexport type WebGLDeviceFeature =\n  // webgl extension features\n  | 'timer-query-webgl' // unify with WebGPU timestamp-query?\n  | 'compilation-status-async-webgl' // Non-blocking shader compile/link status query available\n  | 'provoking-vertex-webgl' // parameters.provokingVertex\n  | 'polygon-mode-webgl' // parameters.polygonMode and parameters.polygonOffsetLine\n\n  // GLSL extension features\n  | 'shader-noperspective-interpolation-webgl' // Vertex outputs & fragment inputs can have a `noperspective` interpolation qualifier.\n  | 'shader-conservative-depth-webgl' // GLSL `gl_FragDepth` qualifiers `depth_unchanged` etc can enable early depth test\n  | 'shader-clip-cull-distance-webgl' // Makes gl_ClipDistance and gl_CullDistance available in shaders\n\n  // texture rendering\n  | 'float32-renderable-webgl'\n  | 'float16-renderable-webgl'\n  | 'rgb9e5ufloat-renderable-webgl'\n  | 'snorm8-renderable-webgl'\n  | 'norm16-renderable-webgl'\n  | 'snorm16-renderable-webgl'\n\n  // texture filtering\n  | 'float16-filterable-webgl'\n  | 'texture-filterable-anisotropic-webgl'\n\n  // texture storage bindings\n  | 'bgra8unorm-storage'\n\n  // texture blending\n  | 'texture-blend-float-webgl';\n\ntype WebGLCompressedTextureFeatures =\n  | 'texture-compression-bc5-webgl'\n  | 'texture-compression-bc7-webgl'\n  | 'texture-compression-etc1-webgl'\n  | 'texture-compression-pvrtc-webgl'\n  | 'texture-compression-atc-webgl';\n\n/** Texture format capabilities that have been checked against a specific device */\nexport type DeviceTextureFormatCapabilities = {\n  format: TextureFormat;\n  /** Can the format be created */\n  create: boolean;\n  /** If a feature string, the specified device feature determines if format is renderable. */\n  render: boolean;\n  /** If a feature string, the specified device feature determines if format is filterable. */\n  filter: boolean;\n  /** If a feature string, the specified device feature determines if format is blendable. */\n  blend: boolean;\n  /** If a feature string, the specified device feature determines if format is storeable. */\n  store: boolean;\n};\n\n/** Device properties */\nexport type DeviceProps = {\n  /** string id for debugging. Stored on the object, used in logging and set on underlying GPU objects when feasible. */\n  id?: string;\n  /** Properties for creating a default canvas context */\n  createCanvasContext?: CanvasContextProps | true;\n  /** Control which type of GPU is preferred on systems with both integrated and discrete GPU. Defaults to \"high-performance\" / discrete GPU. */\n  powerPreference?: 'default' | 'high-performance' | 'low-power';\n  /** Hints that device creation should fail if no hardware GPU is available (if the system performance is \"low\"). */\n  failIfMajorPerformanceCaveat?: boolean;\n  /** Error handling */\n  onError?: (error: Error) => unknown;\n\n  /** WebGL specific: Properties passed through to WebGL2RenderingContext creation: `canvas.getContext('webgl2', props.webgl)` */\n  webgl?: WebGLContextProps;\n\n  // DEBUG SETTINGS\n\n  /** Turn on implementation defined checks that slow down execution but help break where errors occur */\n  debug?: boolean;\n  /** Show shader source in browser? The default is`'error'`, meaning that logs are shown when shader compilation has errors */\n  debugShaders?: 'never' | 'errors' | 'warnings' | 'always';\n  /** Renders a small version of updated Framebuffers into the primary canvas context. Can be set in console luma.log.set('debug-framebuffers', true) */\n  debugFramebuffers?: boolean;\n  /** WebGL specific - Trace WebGL calls (instruments WebGL2RenderingContext at the expense of performance). Can be set in console luma.log.set('debug-webgl', true)  */\n  debugWebGL?: boolean;\n  /** WebGL specific - Initialize the SpectorJS WebGL debugger. Can be set in console luma.log.set('debug-spectorjs', true)  */\n  debugSpectorJS?: boolean;\n  /** WebGL specific - SpectorJS URL. Override if CDN is down or different SpectorJS version is desired. */\n  debugSpectorJSUrl?: string;\n\n  // EXPERIMENTAL SETTINGS - subject to change\n\n  /** adapter.create() returns the existing Device if the provided canvas' WebGL context is already associated with a Device.  */\n  _reuseDevices?: boolean;\n  /** WebGPU specific - Request a Device with the highest limits supported by platform. On WebGPU devices can be created with minimal limits. */\n  _requestMaxLimits?: boolean;\n  /** Disable specific features */\n  _disabledFeatures?: Partial<Record<DeviceFeature, boolean>>;\n  /** WebGL specific - Initialize all features on startup */\n  _initializeFeatures?: boolean;\n  /** Never destroy cached shaders and pipelines */\n  _factoryDestroyPolicy?: 'unused' | 'never';\n  /** Resource default overrides */\n  _resourceDefaults?: {\n    texture?: Partial<TextureProps>;\n    sampler?: Partial<SamplerProps>;\n    renderPass?: Partial<RenderPassProps>;\n  };\n\n  /** @deprecated Internal, Do not use directly! Use `luma.attachDevice()` to attach to pre-created contexts/devices. */\n  _handle?: unknown; // WebGL2RenderingContext | GPUDevice | null;\n};\n\n/** WebGL independent copy of WebGLContextAttributes */\ntype WebGLContextProps = {\n  alpha?: boolean; // indicates if the canvas contains an alpha buffer.\n  desynchronized?: boolean; // hints the user agent to reduce the latency by desynchronizing the canvas paint cycle from the event loop\n  antialias?: boolean; // indicates whether or not to perform anti-aliasing.\n  depth?: boolean; // indicates that the drawing buffer has a depth buffer of at least 16 bits.\n  failIfMajorPerformanceCaveat?: boolean; // indicates if a context will be created if the system performance is low or if no hardware GPU is available.\n  powerPreference?: 'default' | 'high-performance' | 'low-power';\n  premultipliedAlpha?: boolean; // page compositor will assume the drawing buffer contains colors with pre-multiplied alpha.\n  preserveDrawingBuffer?: boolean; // buffers will not be cleared and will preserve their values until cleared or overwritten by the author.\n};\n\n/**\n * Create and attach devices for a specific backend. Currently static methods on each device\n */\nexport interface DeviceFactory {\n  // new (props: DeviceProps): Device; Constructor isn't used\n  type: string;\n  isSupported(): boolean;\n  create(props: DeviceProps): Promise<Device>;\n  attach?(handle: unknown): Device;\n}\n\n/**\n * WebGPU Device/WebGL context abstraction\n */\nexport abstract class Device {\n  static defaultProps: Required<DeviceProps> = {\n    id: null!,\n    powerPreference: 'high-performance',\n    failIfMajorPerformanceCaveat: false,\n    createCanvasContext: undefined!,\n\n    // Callbacks\n    onError: (error: Error) => log.error(error.message)(),\n\n    // Experimental\n    _reuseDevices: false,\n    _requestMaxLimits: true,\n    _factoryDestroyPolicy: 'unused',\n    // TODO - Change these after confirming things work as expected\n    _initializeFeatures: true,\n    _disabledFeatures: {\n      'compilation-status-async-webgl': true\n    },\n    _resourceDefaults: {},\n\n    // WebGL specific\n    webgl: {},\n\n    debug: log.get('debug') || undefined!,\n    debugShaders: log.get('debug-shaders') || undefined!,\n    debugFramebuffers: Boolean(log.get('debug-framebuffers')),\n    debugWebGL: Boolean(log.get('debug-webgl')),\n    debugSpectorJS: undefined!, // Note: log setting is queried by the spector.js code\n    debugSpectorJSUrl: undefined!,\n\n    // INTERNAL\n    _handle: undefined!\n  };\n\n  get [Symbol.toStringTag](): string {\n    return 'Device';\n  }\n\n  constructor(props: DeviceProps) {\n    this.props = {...Device.defaultProps, ...props};\n    this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());\n  }\n\n  /** id of this device, primarily for debugging */\n  readonly id: string;\n  /** type of this device */\n  abstract readonly type: 'webgl' | 'webgpu' | 'unknown';\n  /** A copy of the device props  */\n  readonly props: Required<DeviceProps>;\n  /** Available for the application to store data on the device */\n  userData: {[key: string]: unknown} = {};\n  /** stats */\n  readonly statsManager: StatsManager = lumaStats;\n  /** An abstract timestamp used for change tracking */\n  timestamp: number = 0;\n\n  /** True if this device has been reused during device creation (app has multiple references) */\n  _reused: boolean = false;\n  /** Used by other luma.gl modules to store data on the device */\n  _lumaData: {[key: string]: unknown} = {};\n\n  abstract destroy(): void;\n\n  // Capabilities\n\n  /** Information about the device (vendor, versions etc) */\n  abstract info: DeviceInfo;\n  /** Optional capability discovery */\n  abstract features: DeviceFeatures;\n  /** WebGPU style device limits */\n  abstract get limits(): DeviceLimits;\n\n  /** Determines what operations are supported on a texture format, checking against supported device features */\n  getTextureFormatCapabilities(format: TextureFormat): DeviceTextureFormatCapabilities {\n    const genericCapabilities = getTextureFormatCapabilities(format);\n\n    // Check standard features\n    const checkFeature = (featureOrBoolean: DeviceFeature | boolean | undefined) =>\n      (typeof featureOrBoolean === 'string'\n        ? this.features.has(featureOrBoolean)\n        : featureOrBoolean) ?? true;\n\n    const supported = checkFeature(genericCapabilities.create);\n\n    const deviceCapabilities: DeviceTextureFormatCapabilities = {\n      format,\n      create: supported,\n      render: supported && checkFeature(genericCapabilities.render),\n      filter: supported && checkFeature(genericCapabilities.filter),\n      blend: supported && checkFeature(genericCapabilities.blend),\n      store: supported && checkFeature(genericCapabilities.store)\n    };\n\n    return this._getDeviceSpecificTextureFormatCapabilities(deviceCapabilities);\n  }\n\n  /** Check if device supports a specific texture format (creation and `nearest` sampling) */\n  isTextureFormatSupported(\n    format: TextureFormat,\n    capabilities: Partial<TextureFormatCapabilities>\n  ): boolean {\n    return this.getTextureFormatCapabilities(format).create;\n  }\n\n  /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */\n  isTextureFormatFilterable(format: TextureFormat): boolean {\n    return this.getTextureFormatCapabilities(format).filter;\n  }\n\n  /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */\n  isTextureFormatRenderable(format: TextureFormat): boolean {\n    return this.getTextureFormatCapabilities(format).render;\n  }\n\n  /** Check if a specific texture format is GPU compressed */\n  isTextureFormatCompressed(format: TextureFormat): boolean {\n    return isTextureFormatCompressed(format);\n  }\n\n  // Device loss\n\n  /** `true` if device is already lost */\n  abstract get isLost(): boolean;\n\n  /** Promise that resolves when device is lost */\n  abstract readonly lost: Promise<{reason: 'destroyed'; message: string}>;\n\n  /**\n   * Trigger device loss.\n   * @returns `true` if context loss could actually be triggered.\n   * @note primarily intended for testing how application reacts to device loss\n   */\n  loseDevice(): boolean {\n    return false;\n  }\n\n  /** Report error (normally called for unhandled device errors) */\n  reportError(error: Error): void {\n    this.props.onError(error);\n  }\n\n  // Canvas context\n\n  /** Default / primary canvas context. Can be null as WebGPU devices can be created without a CanvasContext */\n  abstract canvasContext: CanvasContext | null;\n\n  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */\n  getDefaultCanvasContext(): CanvasContext {\n    if (!this.canvasContext) {\n      throw new Error('Device has no default CanvasContext. See props.createCanvasContext');\n    }\n    return this.canvasContext;\n  }\n\n  /** Creates a new CanvasContext (WebGPU only) */\n  abstract createCanvasContext(props?: CanvasContextProps): CanvasContext;\n\n  /** Call after rendering a frame (necessary e.g. on WebGL OffscreenCanvas) */\n  abstract submit(): void;\n\n  // Resource creation\n\n  /** Create a buffer */\n  abstract createBuffer(props: BufferProps | ArrayBuffer | ArrayBufferView): Buffer;\n\n  /** Create a texture */\n  abstract createTexture(props: TextureProps): Texture;\n\n  /** Create a temporary texture view of a video source */\n  abstract createExternalTexture(props: ExternalTextureProps): ExternalTexture;\n\n  /** Create a sampler */\n  abstract createSampler(props: SamplerProps): Sampler;\n\n  /** Create a Framebuffer. Must have at least one attachment. */\n  abstract createFramebuffer(props: FramebufferProps): Framebuffer;\n\n  /** Create a shader */\n  abstract createShader(props: ShaderProps): Shader;\n\n  /** Create a render pipeline (aka program) */\n  abstract createRenderPipeline(props: RenderPipelineProps): RenderPipeline;\n\n  /** Create a compute pipeline (aka program). WebGPU only. */\n  abstract createComputePipeline(props: ComputePipelineProps): ComputePipeline;\n\n  /** Create a vertex array */\n  abstract createVertexArray(props: VertexArrayProps): VertexArray;\n\n  /** Create a RenderPass */\n  abstract beginRenderPass(props?: RenderPassProps): RenderPass;\n\n  /** Create a ComputePass */\n  abstract beginComputePass(props?: ComputePassProps): ComputePass;\n\n  /** Create a transform feedback (immutable set of output buffer bindings). WebGL only. */\n  abstract createTransformFeedback(props: TransformFeedbackProps): TransformFeedback;\n\n  abstract createQuerySet(props: QuerySetProps): QuerySet;\n\n  createCommandEncoder(props: CommandEncoderProps = {}): CommandEncoder {\n    throw new Error('not implemented');\n  }\n\n  /** A monotonic counter for tracking buffer and texture updates */\n  incrementTimestamp(): number {\n    return this.timestamp++;\n  }\n\n  // Error Handling\n\n  /** Report unhandled device errors */\n  onError(error: Error) {\n    this.props.onError(error);\n  }\n\n  // DEPRECATED METHODS\n\n  /** @deprecated Use getDefaultCanvasContext() */\n  getCanvasContext(): CanvasContext {\n    return this.getDefaultCanvasContext();\n  }\n\n  // WebGL specific HACKS - enables app to remove webgl import\n  // Use until we have a better way to handle these\n\n  /** @deprecated - will be removed - should use command encoder */\n  readPixelsToArrayWebGL(\n    source: Framebuffer | Texture,\n    options?: {\n      sourceX?: number;\n      sourceY?: number;\n      sourceFormat?: number;\n      sourceAttachment?: number;\n      target?: Uint8Array | Uint16Array | Float32Array;\n      // following parameters are auto deduced if not provided\n      sourceWidth?: number;\n      sourceHeight?: number;\n      sourceType?: number;\n    }\n  ): Uint8Array | Uint16Array | Float32Array {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use command encoder */\n  readPixelsToBufferWebGL(\n    source: Framebuffer | Texture,\n    options?: {\n      sourceX?: number;\n      sourceY?: number;\n      sourceFormat?: number;\n      target?: Buffer; // A new Buffer object is created when not provided.\n      targetByteOffset?: number; // byte offset in buffer object\n      // following parameters are auto deduced if not provided\n      sourceWidth?: number;\n      sourceHeight?: number;\n      sourceType?: number;\n    }\n  ): Buffer {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  setParametersWebGL(parameters: any): void {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  getParametersWebGL(parameters: any): void {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  withParametersWebGL(parameters: any, func: any): any {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use clear arguments in RenderPass */\n  clearWebGL(options?: {framebuffer?: Framebuffer; color?: any; depth?: any; stencil?: any}): void {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use for debugging only */\n  resetWebGL(): void {\n    throw new Error('not implemented');\n  }\n\n  // IMPLEMENTATION\n\n  /** Helper to get the canvas context props */\n  static _getCanvasContextProps(props: DeviceProps): CanvasContextProps | undefined {\n    return props.createCanvasContext === true ? {} : props.createCanvasContext;\n  }\n\n  /**\n   * Determines what operations are supported on a texture format, checking against supported device features\n   * Subclasses override to apply additional checks\n   */\n  protected abstract _getDeviceSpecificTextureFormatCapabilities(\n    format: DeviceTextureFormatCapabilities\n  ): DeviceTextureFormatCapabilities;\n\n  /** Subclasses use this to support .createBuffer() overloads */\n  protected _normalizeBufferProps(props: BufferProps | ArrayBuffer | ArrayBufferView): BufferProps {\n    if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {\n      props = {data: props};\n    }\n\n    // TODO - fragile, as this is done before we merge with default options\n    // inside the Buffer constructor\n\n    const newProps = {...props};\n    // Deduce indexType\n    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {\n      if (props.data instanceof Uint32Array) {\n        newProps.indexType = 'uint32';\n      } else if (props.data instanceof Uint16Array) {\n        newProps.indexType = 'uint16';\n      } else {\n        log.warn('indices buffer content must be of integer type')();\n      }\n    }\n    return newProps;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Log} from '@probe.gl/log';\nimport {isBrowser} from '@probe.gl/env';\nimport type {DeviceProps} from './device';\nimport {Device} from './device';\nimport {Adapter} from './adapter';\nimport {StatsManager, lumaStats} from '../utils/stats-manager';\nimport {log} from '../utils/log';\n\nconst isPage: boolean = isBrowser() && typeof document !== 'undefined';\nconst isPageLoaded: () => boolean = () => isPage && document.readyState === 'complete';\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var luma: Luma;\n}\n\nconst STARTUP_MESSAGE = 'set luma.log.level=1 (or higher) to trace rendering';\n\nconst ERROR_MESSAGE =\n  'No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.';\n\n/** Properties for creating a new device */\nexport type CreateDeviceProps = {\n  /** Selects the type of device. `best-available` uses webgpu if available, then webgl. */\n  type?: 'webgl' | 'webgpu' | 'unknown' | 'best-available';\n  /** List of adapters. Will also search any pre-registered adapters */\n  adapters?: Adapter[];\n  /** Whether to wait for page to be loaded */\n  waitForPageLoad?: boolean;\n} & DeviceProps;\n\n/** Properties for attaching an existing WebGL context or WebGPU device to a new luma Device */\nexport type AttachDeviceProps = {\n  type?: 'webgl' | 'webgpu' | 'unknown' | 'best-available';\n  /** Externally created WebGL context or WebGPU device */\n  handle: unknown; // WebGL2RenderingContext | GPUDevice | null;\n  /** List of adapters. Will also search any pre-registered adapters */\n  adapters?: Adapter[];\n} & DeviceProps;\n\n/**\n * Entry point to the luma.gl GPU abstraction\n * Register WebGPU and/or WebGL adapters (controls application bundle size)\n * Run-time selection of the first available Device\n */\nexport class Luma {\n  static defaultProps: Required<CreateDeviceProps> = {\n    ...Device.defaultProps,\n    type: 'best-available',\n    adapters: undefined!,\n    waitForPageLoad: true\n  };\n\n  /**\n   * Page load promise\n   * Get a 'lazy' promise that resolves when the DOM is loaded.\n   * @note Since there may be limitations on number of `load` event listeners,\n   * it is recommended avoid calling this function until actually needed.\n   * I.e. don't call it until you know that you will be looking up a string in the DOM.\n   */\n  static pageLoaded: Promise<void> = getPageLoadPromise().then(() => {\n    log.probe(2, 'DOM is loaded')();\n  });\n\n  /** Global stats for all devices */\n  readonly stats: StatsManager = lumaStats;\n\n  /**\n   * Global log\n   *\n   * Assign luma.log.level in console to control logging: \\\n   * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs\n   * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;\n   */\n  readonly log: Log = log;\n\n  /** Version of luma.gl */\n  readonly VERSION: string =\n    // Version detection using build plugin\n    // @ts-expect-error no-undef\n    typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'running from source';\n\n  spector: unknown;\n\n  protected preregisteredAdapters = new Map<string, Adapter>();\n\n  constructor() {\n    if (globalThis.luma) {\n      if (globalThis.luma.VERSION !== this.VERSION) {\n        log.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)();\n        log.error(`'yarn why @luma.gl/core' can help identify the source of the conflict`)();\n        throw new Error(`luma.gl - multiple versions detected: see console log`);\n      }\n\n      log.error('This version of luma.gl has already been initialized')();\n    }\n\n    log.log(1, `${this.VERSION} - ${STARTUP_MESSAGE}`)();\n\n    globalThis.luma = this;\n  }\n\n  registerAdapters(adapters: Adapter[]): void {\n    for (const deviceClass of adapters) {\n      this.preregisteredAdapters.set(deviceClass.type, deviceClass);\n    }\n  }\n\n  /** Get type strings for supported Devices */\n  getSupportedAdapters(adapters: Adapter[] = []): string[] {\n    const adapterMap = this.getAdapterMap(adapters);\n    return Array.from(adapterMap)\n      .map(([, adapter]) => adapter)\n      .filter(adapter => adapter.isSupported?.())\n      .map(adapter => adapter.type);\n  }\n\n  /** Get type strings for best available Device */\n  getBestAvailableAdapter(adapters: Adapter[] = []): 'webgpu' | 'webgl' | null {\n    const adapterMap = this.getAdapterMap(adapters);\n    if (adapterMap.get('webgpu')?.isSupported?.()) {\n      return 'webgpu';\n    }\n    if (adapterMap.get('webgl')?.isSupported?.()) {\n      return 'webgl';\n    }\n    return null;\n  }\n\n  setDefaultDeviceProps(props: CreateDeviceProps): void {\n    Object.assign(Luma.defaultProps, props);\n  }\n\n  /** Creates a device. Asynchronously. */\n  async createDevice(props: CreateDeviceProps = {}): Promise<Device> {\n    props = {...Luma.defaultProps, ...props};\n\n    if (props.waitForPageLoad) {\n      // || props.createCanvasContext) {\n      await Luma.pageLoaded;\n    }\n\n    const adapterMap = this.getAdapterMap(props.adapters);\n\n    let type: string = props.type || '';\n    if (type === 'best-available') {\n      type = this.getBestAvailableAdapter(props.adapters) || type;\n    }\n\n    const adapters = this.getAdapterMap(props.adapters) || adapterMap;\n\n    const adapter = adapters.get(type);\n    const device = await adapter?.create?.(props);\n    if (device) {\n      return device;\n    }\n\n    throw new Error(ERROR_MESSAGE);\n  }\n\n  /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */\n  async attachDevice(props: AttachDeviceProps): Promise<Device> {\n    const adapters = this.getAdapterMap(props.adapters);\n\n    // WebGL\n    let type = '';\n    if (props.handle instanceof WebGL2RenderingContext) {\n      type = 'webgl';\n    }\n\n    if (props.createCanvasContext) {\n      await Luma.pageLoaded;\n    }\n\n    // TODO - WebGPU does not yet have a stable API\n    // if (props.handle instanceof GPUDevice) {\n    //   const WebGPUDevice = adapters.get('webgpu') as any;\n    //   if (WebGPUDevice) {\n    //     return (await WebGPUDevice.attach(props.handle)) as Device;\n    //   }\n    // }\n\n    // null\n    if (props.handle === null) {\n      type = 'unknown';\n    }\n\n    const adapter = adapters.get(type);\n    const device = await adapter?.attach?.(null);\n    if (device) {\n      return device;\n    }\n\n    throw new Error(ERROR_MESSAGE);\n  }\n\n  /**\n   * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.\n   * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.\n   */\n  enforceWebGL2(enforce: boolean = true, adapters: Adapter[] = []): void {\n    const adapterMap = this.getAdapterMap(adapters);\n    const webgl2Adapter = adapterMap.get('webgl');\n    if (!webgl2Adapter) {\n      log.warn('enforceWebGL2: webgl adapter not found')();\n    }\n    (webgl2Adapter as any)?.enforceWebGL2?.(enforce);\n  }\n\n  /** Convert a list of adapters to a map */\n  protected getAdapterMap(adapters: Adapter[] = []): Map<string, Adapter> {\n    const map = new Map(this.preregisteredAdapters);\n    for (const adapter of adapters) {\n      map.set(adapter.type, adapter);\n    }\n    return map;\n  }\n\n  // DEPRECATED\n\n  /** @deprecated Use registerAdapters */\n  registerDevices(deviceClasses: any[]): void {\n    log.warn('luma.registerDevices() is deprecated, use luma.registerAdapters() instead');\n    for (const deviceClass of deviceClasses) {\n      const adapter = deviceClass.adapter as Adapter;\n      if (adapter) {\n        this.preregisteredAdapters.set(adapter.type, adapter);\n      }\n    }\n  }\n}\n\n/**\n * Entry point to the luma.gl GPU abstraction\n * Register WebGPU and/or WebGL adapters (controls application bundle size)\n * Run-time selection of the first available Device\n */\nexport const luma = new Luma();\n\n// HELPER FUNCTIONS\n\n/** Returns a promise that resolves when the page is loaded */\nfunction getPageLoadPromise(): Promise<void> {\n  if (isPageLoaded() || typeof window === 'undefined') {\n    return Promise.resolve();\n  }\n  return new Promise(resolve => {\n    window.addEventListener('load', () => resolve());\n  });\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, DeviceProps} from './device';\n\n/**\n * Create and attach devices for a specific backend.\n */\nexport abstract class Adapter {\n  // new (props: DeviceProps): Device; Constructor isn't used\n  abstract type: string;\n  abstract isSupported(): boolean;\n  abstract create(props: DeviceProps): Promise<Device>;\n  abstract attach?(handle: unknown): Promise<Device>;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {isBrowser} from '@probe.gl/env';\nimport type {Device} from './device';\nimport type {Framebuffer} from './resources/framebuffer';\nimport {log} from '../utils/log';\nimport {uid} from '../utils/uid';\nimport type {TextureFormat} from '../gpu-type-utils/texture-formats';\n\n/** Properties for a CanvasContext */\nexport type CanvasContextProps = {\n  /** If a canvas not supplied, one will be created and added to the DOM. If a string, a canvas with that id will be looked up in the DOM */\n  canvas?: HTMLCanvasElement | OffscreenCanvas | string | null;\n  /** If new canvas is created, it will be created in the specified container, otherwise is appended as a child of document.body */\n  container?: HTMLElement | string | null;\n  /** Width in pixels of the canvas - used when creating a new canvas */\n  width?: number;\n  /** Height in pixels of the canvas - used when creating a new canvas */\n  height?: number;\n  /** Visibility (only used if new canvas is created). */\n  visible?: boolean;\n  /** Whether to apply a device pixels scale factor (`true` uses browser DPI) */\n  useDevicePixels?: boolean | number;\n  /** Whether to track window resizes */\n  autoResize?: boolean;\n  /** https://developer.mozilla.org/en-US/docs/Web/API/GPUCanvasContext/configure#alphamode */\n  alphaMode?: 'opaque' | 'premultiplied';\n  /** https://developer.mozilla.org/en-US/docs/Web/API/GPUCanvasContext/configure#colorspace */\n  colorSpace?: 'srgb'; // GPUPredefinedColorSpace\n};\n\n/**\n * Manages a canvas. Supports both HTML or offscreen canvas\n * - Creates a new canvas or looks up a canvas from the DOM\n * - Provides check for DOM loaded\n * @todo commit(): https://github.com/w3ctag/design-reviews/issues/288\n * @todo transferControlToOffscreen: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/transferControlToOffscreen\n */\nexport abstract class CanvasContext {\n  static defaultProps: Required<CanvasContextProps> = {\n    canvas: null,\n    width: 800, // width are height are only used by headless gl\n    height: 600,\n    useDevicePixels: true,\n    autoResize: true,\n    container: null,\n    visible: true,\n    alphaMode: 'opaque',\n    colorSpace: 'srgb'\n  };\n\n  abstract readonly device: Device;\n  readonly id: string;\n  readonly props: Required<CanvasContextProps>;\n  readonly canvas: HTMLCanvasElement | OffscreenCanvas;\n  readonly htmlCanvas?: HTMLCanvasElement;\n  readonly offscreenCanvas?: OffscreenCanvas;\n  readonly type: 'html-canvas' | 'offscreen-canvas' | 'node';\n\n  /** Format of returned textures: \"bgra8unorm\", \"rgba8unorm\" */\n  abstract readonly format: TextureFormat;\n  /** Default stencil format for depth textures */\n  abstract readonly depthStencilFormat: TextureFormat;\n\n  width: number = 1;\n  height: number = 1;\n\n  readonly resizeObserver: ResizeObserver | undefined;\n\n  /** State used by luma.gl classes: TODO - move to canvasContext*/\n  readonly _canvasSizeInfo = {clientWidth: 0, clientHeight: 0, devicePixelRatio: 1};\n\n  abstract get [Symbol.toStringTag](): string;\n\n  toString(): string {\n    return `${this[Symbol.toStringTag]}(${this.id})`;\n  }\n\n  constructor(props?: CanvasContextProps) {\n    this.props = {...CanvasContext.defaultProps, ...props};\n    props = this.props;\n\n    if (!isBrowser()) {\n      this.id = 'node-canvas-context';\n      this.type = 'node';\n      this.width = this.props.width;\n      this.height = this.props.height;\n      // TODO - does this prevent app from using jsdom style polyfills?\n      this.canvas = null!;\n      return;\n    }\n\n    if (!props.canvas) {\n      const canvas = createCanvas(props);\n      const container = getContainer(props?.container || null);\n      container.insertBefore(canvas, container.firstChild);\n\n      this.canvas = canvas;\n\n      if (!props?.visible) {\n        this.canvas.style.visibility = 'hidden';\n      }\n    } else if (typeof props.canvas === 'string') {\n      this.canvas = getCanvasFromDOM(props.canvas);\n    } else {\n      this.canvas = props.canvas;\n    }\n\n    if (this.canvas instanceof HTMLCanvasElement) {\n      this.id = this.canvas.id;\n      this.type = 'html-canvas';\n      this.htmlCanvas = this.canvas;\n    } else {\n      this.id = 'offscreen-canvas';\n      this.type = 'offscreen-canvas';\n      this.offscreenCanvas = this.canvas;\n    }\n\n    // React to size changes\n    if (this.canvas instanceof HTMLCanvasElement && props.autoResize) {\n      this.resizeObserver = new ResizeObserver(entries => {\n        for (const entry of entries) {\n          if (entry.target === this.canvas) {\n            this.update();\n          }\n        }\n      });\n      this.resizeObserver.observe(this.canvas);\n    }\n  }\n\n  /** Returns a framebuffer with properly resized current 'swap chain' textures */\n  abstract getCurrentFramebuffer(): Framebuffer;\n\n  /**\n   * Returns the current DPR, if props.useDevicePixels is true\n   * Device refers to physical\n   */\n  getDevicePixelRatio(useDevicePixels?: boolean | number): number {\n    if (typeof OffscreenCanvas !== 'undefined' && this.canvas instanceof OffscreenCanvas) {\n      return 1;\n    }\n\n    useDevicePixels = useDevicePixels === undefined ? this.props.useDevicePixels : useDevicePixels;\n\n    if (!useDevicePixels || (useDevicePixels as number) <= 0) {\n      return 1;\n    }\n\n    // The param was mainly provide to support the test cases, could be removed\n    if (useDevicePixels === true) {\n      const dpr = typeof window !== 'undefined' && window.devicePixelRatio;\n      return dpr || 1;\n    }\n\n    return useDevicePixels;\n  }\n\n  /**\n   * Returns the size of drawing buffer in device pixels.\n   * @note This can be different from the 'CSS' size of a canvas, and also from the\n   * canvas' internal drawing buffer size (.width, .height).\n   * This is the size required to cover the canvas, adjusted for DPR\n   */\n  getPixelSize(): [number, number] {\n    switch (this.type) {\n      case 'node':\n        return [this.width, this.height];\n      case 'offscreen-canvas':\n        return [this.canvas.width, this.canvas.height];\n      case 'html-canvas':\n        const dpr = this.getDevicePixelRatio();\n        const canvas = this.canvas as HTMLCanvasElement;\n        // If not attached to DOM client size can be 0\n        return canvas.parentElement\n          ? [canvas.clientWidth * dpr, canvas.clientHeight * dpr]\n          : [this.canvas.width, this.canvas.height];\n      default:\n        throw new Error(this.type);\n    }\n  }\n\n  getAspect(): number {\n    const [width, height] = this.getPixelSize();\n    return width / height;\n  }\n\n  /**\n   * Returns multiplier need to convert CSS size to Device size\n   */\n  cssToDeviceRatio(): number {\n    try {\n      // For headless gl we might have used custom width and height\n      // hence use cached clientWidth\n      const [drawingBufferWidth] = this.getDrawingBufferSize();\n      // _canvasSizeInfo may not be populated if `setDevicePixelRatio` is never called\n      const clientWidth = this._canvasSizeInfo.clientWidth || this.htmlCanvas?.clientWidth;\n      return clientWidth ? drawingBufferWidth / clientWidth : 1;\n    } catch {\n      return 1;\n    }\n  }\n\n  /**\n   * Maps CSS pixel position to device pixel position\n   */\n  cssToDevicePixels(\n    cssPixel: number[],\n    yInvert: boolean = true\n  ): {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  } {\n    const ratio = this.cssToDeviceRatio();\n    const [width, height] = this.getDrawingBufferSize();\n    return scalePixels(cssPixel, ratio, width, height, yInvert);\n  }\n\n  /**\n   * Use devicePixelRatio to set canvas width and height\n   * @note this is a raw port of luma.gl v8 code. Might be worth a review\n   */\n  setDevicePixelRatio(\n    devicePixelRatio: number,\n    options: {width?: number; height?: number} = {}\n  ): void {\n    if (!this.htmlCanvas) {\n      return;\n    }\n\n    // NOTE: if options.width and options.height not used remove in v8\n    let clientWidth = 'width' in options ? options.width : this.htmlCanvas.clientWidth;\n    let clientHeight = 'height' in options ? options.height : this.htmlCanvas.clientHeight;\n\n    if (!clientWidth || !clientHeight) {\n      log.log(1, 'Canvas clientWidth/clientHeight is 0')();\n      // by forcing devicePixel ratio to 1, we do not scale canvas.width and height in each frame.\n      devicePixelRatio = 1;\n      clientWidth = this.htmlCanvas.width || 1;\n      clientHeight = this.htmlCanvas.height || 1;\n    }\n\n    const cachedSize = this._canvasSizeInfo;\n    // Check if canvas needs to be resized\n    if (\n      cachedSize.clientWidth !== clientWidth ||\n      cachedSize.clientHeight !== clientHeight ||\n      cachedSize.devicePixelRatio !== devicePixelRatio\n    ) {\n      let clampedPixelRatio = devicePixelRatio;\n\n      const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);\n      const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);\n      this.htmlCanvas.width = canvasWidth;\n      this.htmlCanvas.height = canvasHeight;\n\n      // @ts-expect-error This only works for WebGL\n      const gl = this.device.gl;\n      if (gl) {\n        // Note: when devicePixelRatio is too high, it is possible we might hit system limit for\n        // drawing buffer width and hight, in those cases they get clamped and resulting aspect ration may not be maintained\n        // for those cases, reduce devicePixelRatio.\n        const [drawingBufferWidth, drawingBufferHeight] = this.getDrawingBufferSize();\n\n        if (drawingBufferWidth !== canvasWidth || drawingBufferHeight !== canvasHeight) {\n          clampedPixelRatio = Math.min(\n            drawingBufferWidth / clientWidth,\n            drawingBufferHeight / clientHeight\n          );\n\n          this.htmlCanvas.width = Math.floor(clientWidth * clampedPixelRatio);\n          this.htmlCanvas.height = Math.floor(clientHeight * clampedPixelRatio);\n\n          log.warn('Device pixel ratio clamped')();\n        }\n\n        this._canvasSizeInfo.clientWidth = clientWidth;\n        this._canvasSizeInfo.clientHeight = clientHeight;\n        this._canvasSizeInfo.devicePixelRatio = devicePixelRatio;\n      }\n    }\n  }\n\n  // PRIVATE\n\n  /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */\n  getDrawingBufferSize(): [number, number] {\n    // @ts-expect-error This only works for WebGL\n    const gl = this.device.gl;\n    if (!gl) {\n      // use default device pixel ratio\n      return this.getPixelSize();\n    }\n    return [gl.drawingBufferWidth, gl.drawingBufferHeight];\n  }\n\n  abstract resize(options?: {\n    width?: number;\n    height?: number;\n    useDevicePixels?: boolean | number;\n  }): void;\n\n  /** Perform platform specific updates (WebGPU vs WebGL) */\n  protected abstract update(): void;\n\n  /**\n   * Allows subclass constructor to override the canvas id for auto created canvases.\n   * This can really help when debugging DOM in apps that create multiple devices\n   */\n  protected _setAutoCreatedCanvasId(id: string) {\n    if (this.htmlCanvas?.id === 'lumagl-auto-created-canvas') {\n      this.htmlCanvas.id = id;\n    }\n  }\n}\n\n// HELPER FUNCTIONS\n\nfunction getContainer(container: HTMLElement | string | null): HTMLElement {\n  if (typeof container === 'string') {\n    const element = document.getElementById(container);\n    if (!element) {\n      throw new Error(`${container} is not an HTML element`);\n    }\n    return element;\n  } else if (container) {\n    return container;\n  }\n  return document.body;\n}\n\n/** Get a Canvas element from DOM id */\nfunction getCanvasFromDOM(canvasId: string): HTMLCanvasElement {\n  const canvas = document.getElementById(canvasId);\n  if (!(canvas instanceof HTMLCanvasElement)) {\n    throw new Error('Object is not a canvas element');\n  }\n  return canvas;\n}\n\n/** Create a new canvas */\nfunction createCanvas(props: CanvasContextProps) {\n  const {width, height} = props;\n  const targetCanvas = document.createElement('canvas');\n  targetCanvas.id = uid('lumagl-auto-created-canvas');\n  targetCanvas.width = width || 1;\n  targetCanvas.height = height || 1;\n  targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';\n  targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';\n  return targetCanvas;\n}\n\n/**\n *\n * @param pixel\n * @param ratio\n * @param width\n * @param height\n * @param yInvert\n * @returns\n */\nfunction scalePixels(\n  pixel: number[],\n  ratio: number,\n  width: number,\n  height: number,\n  yInvert: boolean\n): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n} {\n  const point = pixel as [number, number];\n\n  const x = scaleX(point[0], ratio, width);\n  let y = scaleY(point[1], ratio, height, yInvert);\n\n  // Find boundaries of next pixel to provide valid range of device pixel locations\n\n  let t = scaleX(point[0] + 1, ratio, width);\n  // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary\n  const xHigh = t === width - 1 ? t : t - 1;\n\n  t = scaleY(point[1] + 1, ratio, height, yInvert);\n  let yHigh;\n  if (yInvert) {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    t = t === 0 ? t : t + 1;\n    // swap y and yHigh\n    yHigh = y;\n    y = t;\n  } else {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    yHigh = t === height - 1 ? t : t - 1;\n    // y remains same\n  }\n  return {\n    x,\n    y,\n    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\n\nfunction scaleX(x: number, ratio: number, width: number): number {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\n\nfunction scaleY(y: number, ratio: number, height: number, yInvert: boolean): number {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  return yInvert\n    ? Math.max(0, height - 1 - Math.round(y * ratio))\n    : Math.min(Math.round(y * ratio), height - 1);\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport type {TypedArray} from '../../types';\nimport type {TextureFormat} from '../../gpu-type-utils/texture-formats';\nimport type {TextureView, TextureViewProps} from './texture-view';\nimport {Resource, ResourceProps} from './resource';\nimport {Sampler, SamplerProps} from './sampler';\n\n/**\n * These represent the main compressed texture formats\n * Each format typically has a number of more specific subformats\n */\nexport type TextureCompressionFormat =\n  | 'dxt'\n  | 'dxt-srgb'\n  | 'etc1'\n  | 'etc2'\n  | 'pvrtc'\n  | 'atc'\n  | 'astc'\n  | 'rgtc';\n\n/** Names of cube texture faces */\nexport type TextureCubeFace = '+X' | '-X' | '+Y' | '-Y' | '+Z' | '-Z';\n\n/**\n * One mip level\n * Basic data structure is similar to `ImageData`\n * additional optional fields can describe compressed texture data.\n */\nexport type TextureLevelData = {\n  /** WebGPU style format string. Defaults to 'rgba8unorm' */\n  format?: TextureFormat;\n  data: TypedArray;\n  width: number;\n  height: number;\n\n  compressed?: boolean;\n  byteLength?: number;\n  hasAlpha?: boolean;\n};\n\n/**\n * Built-in data types that can be used to initialize textures\n * @note ImageData can be used for 8 bit data via Uint8ClampedArray\n */\nexport type ExternalImage =\n  | ImageBitmap\n  | ImageData\n  | HTMLImageElement\n  | HTMLVideoElement\n  | VideoFrame\n  | HTMLCanvasElement\n  | OffscreenCanvas;\n\nexport type TextureLevelSource = TextureLevelData | ExternalImage;\n\n/** Texture data can be one or more mip levels */\nexport type TextureData = TextureLevelData | ExternalImage | (TextureLevelData | ExternalImage)[];\n\n/** @todo - define what data type is supported for 1D textures */\nexport type Texture1DData = TypedArray | TextureLevelData;\n\n/** Texture data can be one or more mip levels */\nexport type Texture2DData =\n  | TypedArray\n  | TextureLevelData\n  | ExternalImage\n  | (TextureLevelData | ExternalImage)[];\n\n/** Array of textures */\nexport type Texture3DData = TypedArray | TextureData[];\n\n/** 6 face textures */\nexport type TextureCubeData = Record<TextureCubeFace, Texture2DData>;\n\n/** Array of textures */\nexport type TextureArrayData = TextureData[];\n\n/** Array of 6 face textures */\nexport type TextureCubeArrayData = Record<TextureCubeFace, TextureData>[];\n\nexport type TextureDataProps =\n  | Texture1DProps\n  | Texture2DProps\n  | Texture3DProps\n  | TextureArrayProps\n  | TextureCubeProps\n  | TextureCubeArrayProps;\n\nexport type Texture1DProps = {dimension: '1d'; data?: Texture1DData | null};\nexport type Texture2DProps = {dimension?: '2d'; data?: Texture2DData | null};\nexport type Texture3DProps = {dimension: '3d'; data?: Texture3DData | null};\nexport type TextureArrayProps = {dimension: '2d-array'; data?: TextureArrayData | null};\nexport type TextureCubeProps = {dimension: 'cube'; data?: TextureCubeData | null};\nexport type TextureCubeArrayProps = {dimension: 'cube-array'; data: TextureCubeArrayData | null};\n\n/** Texture properties */\nexport type TextureProps = ResourceProps &\n  TextureDataProps & {\n    format?: TextureFormat;\n    width?: number | undefined;\n    height?: number | undefined;\n    depth?: number;\n    usage?: number;\n\n    /** How many mip levels */\n    mipLevels?: number | 'pyramid';\n    /** Multi sampling */\n    samples?: number;\n\n    /** Specifying mipmaps will default mipLevels to 'pyramid' and attempt to generate mipmaps */\n    mipmaps?: boolean;\n\n    /** Sampler (or SamplerProps) for the default sampler for this texture. Used if no sampler provided. Note that other samplers can still be used. */\n    sampler?: Sampler | SamplerProps;\n    /** Props for the default TextureView for this texture. Note that other views can still be created and used. */\n    view?: TextureViewProps;\n\n    /** Whether to flip the image vertically. Used if texture is initialized with an image. */\n    flipY?: boolean;\n\n    /** @deprecated - this is implicit from format */\n    compressed?: boolean;\n  };\n\n/** Options for Texture.copyExternalImage */\nexport type CopyExternalImageOptions = {\n  /** Image */\n  image: ExternalImage;\n  /** Copy from image x offset (default 0) */\n  sourceX?: number;\n  /** Copy from image y offset (default 0) */\n  sourceY?: number;\n  /** Copy area width (default 1) */\n  width?: number;\n  /** Copy area height (default 1) */\n  height?: number;\n  /** Copy depth (default 1) */\n  depth?: number;\n  /** Which mip-level to copy into (default 0) */\n  mipLevel?: number;\n  /** Start copying into offset x (default 0) */\n  x?: number;\n  /** Start copying into offset y (default 0) */\n  y?: number;\n  /** Start copying from depth layer z (default 0) */\n  z?: number;\n  /** When copying into depth stencil textures (default 'all') */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n  /** Specific color space of image data */\n  colorSpace?: 'srgb';\n  /** load as premultiplied alpha  */\n  premultipliedAlpha?: boolean;\n  /** Whether to flip the image vertically */\n  flipY?: boolean;\n};\n\n/**\n * Abstract Texture interface\n * Texture Object\n * https://gpuweb.github.io/gpuweb/#gputexture\n */\nexport abstract class Texture extends Resource<TextureProps> {\n  static COPY_SRC = 0x01;\n  static COPY_DST = 0x02;\n  static TEXTURE = 0x04;\n  static STORAGE = 0x08;\n  static RENDER_ATTACHMENT = 0x10;\n\n  static CubeFaces: TextureCubeFace[] = ['+X', '-X', '+Y', '-Y', '+Z', '-Z'];\n\n  static override defaultProps: Required<TextureProps> = {\n    ...Resource.defaultProps,\n    data: null,\n    dimension: '2d',\n    format: 'rgba8unorm',\n    width: undefined!,\n    height: undefined!,\n    depth: 1,\n    mipmaps: false,\n    compressed: false,\n    usage: 0,\n    mipLevels: undefined!,\n    samples: undefined!,\n    sampler: {},\n    view: undefined!,\n    flipY: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'Texture';\n  }\n\n  override toString(): string {\n    return `Texture(${this.id},${this.format},${this.width}x${this.height})`;\n  }\n\n  /** dimension of this texture */\n  readonly dimension: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d';\n  /** format of this texture */\n  readonly format: TextureFormat;\n  /** width in pixels of this texture */\n  width: number;\n  /** height in pixels of this texture */\n  height: number;\n  /** depth of this texture */\n  depth: number;\n  /** mip levels in this texture */\n  mipLevels: number;\n\n  /** Default sampler for this texture */\n  abstract sampler: Sampler;\n  /** Default view for this texture */\n  abstract view: TextureView;\n\n  /** \"Time\" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */\n  updateTimestamp: number;\n\n  /** Do not use directly. Create with device.createTexture() */\n  constructor(device: Device, props: TextureProps) {\n    props = Texture.normalizeProps(device, props);\n    super(device, props, Texture.defaultProps);\n    this.dimension = this.props.dimension;\n    this.format = this.props.format;\n\n    // Size\n    this.width = this.props.width;\n    this.height = this.props.height;\n    this.depth = this.props.depth;\n\n    // Calculate size, if not provided\n    if (this.props.width === undefined || this.props.height === undefined) {\n      // @ts-ignore\n      const size = Texture.getTextureDataSize(this.props.data);\n      this.width = size?.width || 1;\n      this.height = size?.height || 1;\n    }\n\n    // mipLevels\n\n    // If mipmap generation is requested and mipLevels is not provided, initialize a full pyramid\n    if (this.props.mipmaps && this.props.mipLevels === undefined) {\n      this.props.mipLevels = 'pyramid';\n    }\n\n    // Auto-calculate the number of mip levels as a convenience\n    // TODO - Should we clamp to 1-getMipLevelCount?\n    this.mipLevels =\n      this.props.mipLevels === 'pyramid'\n        ? Texture.getMipLevelCount(this.width, this.height)\n        : this.props.mipLevels || 1;\n\n    // TODO - perhaps this should be set on async write completion?\n    this.updateTimestamp = device.incrementTimestamp();\n  }\n\n  /** Create a texture view for this texture */\n  abstract createView(props: TextureViewProps): TextureView;\n\n  /** Set sampler props associated with this texture */\n  abstract setSampler(sampler?: Sampler | SamplerProps): void;\n\n  /** Copy external image data into the texture */\n  abstract copyExternalImage(options: CopyExternalImageOptions): {width: number; height: number};\n\n  /**\n   * Create a new texture with the same parameters and optionally, a different size\n   * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.\n   * @note Does not copy contents of the texture\n   */\n  clone(size?: {width: number; height: number}): Texture {\n    return this.device.createTexture({...this.props, ...size});\n  }\n\n  /** Check if data is an external image */\n  static isExternalImage(data: unknown): data is ExternalImage {\n    return (\n      (typeof ImageData !== 'undefined' && data instanceof ImageData) ||\n      (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) ||\n      (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) ||\n      (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) ||\n      (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) ||\n      (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) ||\n      (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)\n    );\n  }\n\n  /** Determine size (width and height) of provided image data */\n  static getExternalImageSize(data: ExternalImage): {width: number; height: number} {\n    if (\n      (typeof ImageData !== 'undefined' && data instanceof ImageData) ||\n      (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) ||\n      (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) ||\n      (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)\n    ) {\n      return {width: data.width, height: data.height};\n    }\n    if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n      return {width: data.naturalWidth, height: data.naturalHeight};\n    }\n    if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n      return {width: data.videoWidth, height: data.videoHeight};\n    }\n    if (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) {\n      // TODO: is this the right choice for width and height?\n      return {width: data.displayWidth, height: data.displayHeight};\n    }\n    throw new Error('Unknown image type');\n  }\n\n  /** Check if texture data is a typed array */\n  static isTextureLevelData(data: TextureData): data is TextureLevelData {\n    const typedArray = (data as TextureLevelData)?.data;\n    return ArrayBuffer.isView(typedArray);\n  }\n\n  /** Get the size of the texture described by the provided TextureData */\n  static getTextureDataSize(\n    data: TextureData | TextureCubeData | TextureArrayData | TextureCubeArrayData | TypedArray\n  ): {width: number; height: number} | null {\n    if (!data) {\n      return null;\n    }\n    if (ArrayBuffer.isView(data)) {\n      return null;\n    }\n    // Recurse into arrays (array of miplevels)\n    if (Array.isArray(data)) {\n      return Texture.getTextureDataSize(data[0]);\n    }\n    if (Texture.isExternalImage(data)) {\n      return Texture.getExternalImageSize(data);\n    }\n    if (data && typeof data === 'object' && data.constructor === Object) {\n      const textureDataArray = Object.values(data) as Texture2DData[];\n      const untypedData = textureDataArray[0] as any;\n      return {width: untypedData.width, height: untypedData.height};\n    }\n    throw new Error('texture size deduction failed');\n  }\n\n  /**\n   * Normalize TextureData to an array of TextureLevelData / ExternalImages\n   * @param data\n   * @param options\n   * @returns array of TextureLevelData / ExternalImages\n   */\n  static normalizeTextureData(\n    data: Texture2DData,\n    options: {width: number; height: number; depth: number}\n  ): (TextureLevelData | ExternalImage)[] {\n    let lodArray: (TextureLevelData | ExternalImage)[];\n    if (ArrayBuffer.isView(data)) {\n      lodArray = [\n        {\n          // ts-expect-error does data really need to be Uint8ClampedArray?\n          data,\n          width: options.width,\n          height: options.height\n          // depth: options.depth\n        }\n      ];\n    } else if (!Array.isArray(data)) {\n      lodArray = [data];\n    } else {\n      lodArray = data;\n    }\n    return lodArray;\n  }\n\n  /** Calculate the number of mip levels for a texture of width and height */\n  static getMipLevelCount(width: number, height: number): number {\n    return Math.floor(Math.log2(Math.max(width, height))) + 1;\n  }\n\n  /** Convert luma.gl cubemap face constants to depth index */\n  static getCubeFaceDepth(face: TextureCubeFace): number {\n    // prettier-ignore\n    switch (face) {\n        case '+X': return  0;\n        case '-X': return  1;\n        case '+Y': return  2;\n        case '-Y': return  3;\n        case '+Z': return  4;\n        case '-Z': return  5;\n        default: throw new Error(face);\n      }\n  }\n\n  /** Default options */\n  protected static defaultCopyExternalImageOptions: Required<CopyExternalImageOptions> = {\n    image: undefined!,\n    sourceX: 0,\n    sourceY: 0,\n    width: undefined!,\n    height: undefined!,\n    depth: 1,\n    mipLevel: 0,\n    x: 0,\n    y: 0,\n    z: 0,\n    aspect: 'all',\n    colorSpace: 'srgb',\n    premultipliedAlpha: false,\n    flipY: false\n  };\n\n  /** Ensure we have integer coordinates */\n  protected static normalizeProps(device: Device, props: TextureProps): TextureProps {\n    const newProps = {...props};\n\n    // Allow device to override props (e.g. props.mipmaps)\n    const overriddenDefaultProps: Partial<TextureProps> =\n      device?.props?._resourceDefaults?.texture || {};\n    // TODO - Type issue with props.data circumvented with Object.assign\n    Object.assign(newProps, overriddenDefaultProps);\n\n    // Ensure we have integer coordinates\n    const {width, height} = newProps;\n    if (typeof width === 'number') {\n      newProps.width = Math.max(1, Math.ceil(width));\n    }\n    if (typeof height === 'number') {\n      newProps.height = Math.max(1, Math.ceil(height));\n    }\n    return newProps;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport type {Texture} from './texture';\nimport type {TextureFormat} from '../../gpu-type-utils/texture-formats';\nimport {Resource, ResourceProps} from './resource';\n\n/** Properties for initializing a texture view */\nexport type TextureViewProps = ResourceProps & {\n  /** The format of the texture view. Must be either the format of the texture or one of the viewFormats specified during its creation. */\n  format?: TextureFormat;\n  /** The dimension to view the texture as. */\n  dimension?: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d';\n  /** Which aspect(s) of the texture are accessible to the texture view. default \"all\"*/\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n  /** The first (most detailed) mipmap level accessible to the texture view.  default 0*/\n  baseMipLevel?: number;\n  /** How many mipmap levels, starting with baseMipLevel, are accessible to the texture view. */\n  mipLevelCount: number;\n  /** The index of the first array layer accessible to the texture view. default 0 */\n  baseArrayLayer?: number;\n  /** How many array layers, starting with baseArrayLayer, are accessible to the texture view. */\n  arrayLayerCount: number;\n};\n\n/** Immutable TextureView object */\nexport abstract class TextureView extends Resource<TextureViewProps> {\n  static override defaultProps: Required<TextureViewProps> = {\n    ...Resource.defaultProps,\n    format: undefined!,\n    dimension: undefined!,\n    aspect: 'all',\n    baseMipLevel: 0,\n    mipLevelCount: undefined!,\n    baseArrayLayer: 0,\n    arrayLayerCount: undefined!\n  };\n\n  abstract texture: Texture;\n\n  override get [Symbol.toStringTag](): string {\n    return 'TextureView';\n  }\n\n  /** Should not be constructed directly. Use `texture.createView(props)` */\n  constructor(device: Device, props: TextureViewProps & {texture: Texture}) {\n    super(device, props, TextureView.defaultProps);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n\nexport type ExternalTextureProps = ResourceProps & {\n  source: HTMLVideoElement; //  | null;\n  colorSpace?: 'srgb';\n};\nexport abstract class ExternalTexture extends Resource<ExternalTextureProps> {\n  static override defaultProps: Required<ExternalTextureProps> = {\n    ...Resource.defaultProps,\n    source: undefined!,\n    colorSpace: 'srgb'\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'ExternalTexture';\n  }\n\n  constructor(device: Device, props: ExternalTextureProps) {\n    super(device, props, ExternalTexture.defaultProps);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {CompilerMessage} from '../adapter/types/compiler-message';\n\n/** @returns annotated errors or warnings */\nexport function formatCompilerLog(\n  shaderLog: readonly CompilerMessage[],\n  source: string,\n  options?: {\n    /** Include source code in the log. Either just the lines before issues or all source code */\n    showSourceCode?: 'no' | 'issues' | 'all';\n    html?: boolean;\n  }\n): string {\n  let formattedLog = '';\n  const lines = source.split(/\\r?\\n/);\n  const log = shaderLog.slice().sort((a, b) => a.lineNum - b.lineNum);\n\n  switch (options?.showSourceCode || 'no') {\n    case 'all':\n      // Parse the error - note: browser and driver dependent\n      let currentMessage = 0;\n      for (let lineNum = 1; lineNum <= lines.length; lineNum++) {\n        formattedLog += getNumberedLine(lines[lineNum - 1], lineNum, options);\n        while (log.length > currentMessage && log[currentMessage].lineNum === lineNum) {\n          const message = log[currentMessage++];\n          formattedLog += formatCompilerMessage(message, lines, message.lineNum, {\n            ...options,\n            inlineSource: false\n          });\n        }\n      }\n      return formattedLog;\n\n    case 'issues':\n    case 'no':\n      // Parse the error - note: browser and driver dependent\n      for (const message of shaderLog) {\n        formattedLog += formatCompilerMessage(message, lines, message.lineNum, {\n          inlineSource: options?.showSourceCode !== 'no'\n        });\n      }\n      return formattedLog;\n  }\n}\n\n// Helpers\n\n/** Format one message */\nfunction formatCompilerMessage(\n  message: CompilerMessage,\n  lines: readonly string[],\n  lineNum: number,\n  options: {\n    inlineSource?: boolean;\n    html?: boolean;\n  }\n): string {\n  if (options?.inlineSource) {\n    const numberedLines = getNumberedLines(lines, lineNum);\n    // If we got error position on line add a `^^^` indicator on next line\n    const positionIndicator = message.linePos > 0 ? `${' '.repeat(message.linePos + 5)}^^^\\n` : '';\n    return `\n${numberedLines}${positionIndicator}${message.type.toUpperCase()}: ${message.message}\n\n`;\n  }\n  const color = message.type === 'error' ? 'red' : '#8B4000'; // dark orange\n  return options?.html\n    ? `<div class='luma-compiler-log-error' style=\"color:${color};\"><b> ${message.type.toUpperCase()}: ${\n        message.message\n      }</b></div>`\n    : `${message.type.toUpperCase()}: ${message.message}`;\n}\n\nfunction getNumberedLines(\n  lines: readonly string[],\n  lineNum: number,\n  options?: {html?: boolean}\n): string {\n  let numberedLines = '';\n  for (let lineIndex = lineNum - 2; lineIndex <= lineNum; lineIndex++) {\n    const sourceLine = lines[lineIndex - 1];\n    if (sourceLine !== undefined) {\n      numberedLines += getNumberedLine(sourceLine, lineNum, options);\n    }\n  }\n  return numberedLines;\n}\n\nfunction getNumberedLine(line: string, lineNum: number, options?: {html?: boolean}): string {\n  const escapedLine = options?.html ? escapeHTML(line) : line;\n  return `${padLeft(String(lineNum), 4)}: ${escapedLine}${options?.html ? '<br/>' : '\\n'}`;\n}\n\n/**\n * Pads a string with a number of spaces (space characters) to the left\n * @param {String} string - string to pad\n * @param {Number} digits - number of spaces to add\n * @return {String} string - The padded string\n */\nfunction padLeft(string: string, paddedLength: number): string {\n  let result = '';\n  for (let i = string.length; i < paddedLength; ++i) {\n    result += ' ';\n  }\n  return result + string;\n}\n\nfunction escapeHTML(unsafe: string): string {\n  return unsafe\n    .replaceAll('&', '&amp;')\n    .replaceAll('<', '&lt;')\n    .replaceAll('>', '&gt;')\n    .replaceAll('\"', '&quot;')\n    .replaceAll(\"'\", '&#039;');\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n// import { log } from '../../utils/log';\nimport {uid} from '../../utils/uid';\nimport {CompilerMessage} from '../types/compiler-message';\nimport {formatCompilerLog} from '../../adapter-utils/format-compiler-log';\n\n/**\n * Properties for a Shader\n */\nexport type ShaderProps = ResourceProps & {\n  /** Shader language (defaults to auto) */\n  language?: 'glsl' | 'wgsl' | 'auto';\n  /** Which stage are we compiling? Required for GLSL. Ignored for WGSL. */\n  stage?: 'vertex' | 'fragment' | 'compute';\n  /** Shader source code */\n  source: string;\n  /** Optional shader source map (WebGPU only) */\n  sourceMap?: string | null;\n  /** Optional shader entry point (WebGPU only) */\n  entryPoint?: string;\n  /** Show shader source in browser? Overrides the device.props.debugShaders setting */\n  debugShaders?: 'never' | 'errors' | 'warnings' | 'always';\n};\n\n/**\n * Immutable Shader object\n * In WebGPU the handle can be copied between threads\n */\nexport abstract class Shader extends Resource<ShaderProps> {\n  static override defaultProps: Required<ShaderProps> = {\n    ...Resource.defaultProps,\n    language: 'auto',\n    stage: undefined!,\n    source: '',\n    sourceMap: null,\n    entryPoint: 'main',\n    debugShaders: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'Shader';\n  }\n\n  /** The stage of this shader */\n  readonly stage: 'vertex' | 'fragment' | 'compute';\n  /** The source code of this shader */\n  readonly source: string;\n  /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */\n  compilationStatus: 'pending' | 'success' | 'error' = 'pending';\n\n  /** Create a new Shader instance */\n  constructor(device: Device, props: ShaderProps) {\n    props = {...props, debugShaders: props.debugShaders || device.props.debugShaders || 'errors'};\n    super(device, {id: getShaderIdFromProps(props), ...props}, Shader.defaultProps);\n    this.stage = this.props.stage;\n    this.source = this.props.source;\n  }\n\n  abstract get asyncCompilationStatus(): Promise<'pending' | 'success' | 'error'>;\n\n  /** Get compiler log asynchronously */\n  abstract getCompilationInfo(): Promise<readonly CompilerMessage[]>;\n\n  /** Get compiler log synchronously (WebGL only) */\n  getCompilationInfoSync(): readonly CompilerMessage[] | null {\n    return null;\n  }\n\n  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */\n  getTranslatedSource(): string | null {\n    return null;\n  }\n\n  // PORTABLE HELPERS\n\n  /** In browser logging of errors */\n  async debugShader(): Promise<void> {\n    const trigger = this.props.debugShaders;\n    switch (trigger) {\n      case 'never':\n        return;\n      case 'errors':\n        // On WebGL - Don't extract the log unless errors\n        if (this.compilationStatus === 'success') {\n          return;\n        }\n        break;\n      case 'warnings':\n      case 'always':\n        break;\n    }\n\n    const messages = await this.getCompilationInfo();\n    if (trigger === 'warnings' && messages?.length === 0) {\n      return;\n    }\n    this._displayShaderLog(messages);\n  }\n\n  // PRIVATE\n\n  /**\n   * In-browser UI logging of errors\n   * TODO - this HTML formatting code should not be in Device, should be pluggable\n   */\n  protected _displayShaderLog(messages: readonly CompilerMessage[]): void {\n    // Return if under Node.js / incomplete `document` polyfills\n    if (typeof document === 'undefined' || !document?.createElement) {\n      return;\n    }\n\n    const shaderName: string = getShaderName(this.source);\n    const shaderTitle: string = `${this.stage} ${shaderName}`;\n    let htmlLog = formatCompilerLog(messages, this.source, {showSourceCode: 'all', html: true});\n    // Show translated source if available\n    const translatedSource = this.getTranslatedSource();\n    if (translatedSource) {\n      htmlLog += `<br /><br /><h1>Translated Source</h1><br /><br /><code style=\"user-select:text;\"><pre>${translatedSource}</pre></code>`;\n    }\n    // Make it clickable so we can copy to clipboard\n    const button = document.createElement('Button');\n    button.innerHTML = `\n<h1>Shader Compilation Error in ${shaderTitle}</h1><br /><br />\n<code style=\"user-select:text;\"><pre>\n${htmlLog}\n</pre></code>`;\n    button.style.top = '10px';\n    button.style.left = '10px';\n    button.style.position = 'absolute';\n    button.style.zIndex = '9999';\n    button.style.width = '100%';\n    button.style.textAlign = 'left';\n    document.body.appendChild(button);\n\n    const errors = document.getElementsByClassName('luma-compiler-log-error');\n    errors[0]?.scrollIntoView();\n\n    // TODO - add a small embedded copy button (instead of main button)\n    button.onclick = () => {\n      // const source = this.source.replaceAll('\\n', '<br />');\n      const dataURI = `data:text/plain,${encodeURIComponent(this.source)}`;\n      navigator.clipboard.writeText(dataURI);\n    };\n\n    // TODO - add a small embedded close button\n  }\n}\n\n// HELPERS\n\n/** Deduce an id, from shader source, or supplied id, or shader type */\nfunction getShaderIdFromProps(props: ShaderProps): string {\n  return getShaderName(props.source) || props.id || uid(`unnamed ${props.stage}-shader`);\n}\n\n/** Extracts GLSLIFY style naming of shaders: `#define SHADER_NAME ...` */\nfunction getShaderName(shader: string, defaultName: string = 'unnamed'): string {\n  const SHADER_NAME_REGEXP = /#define[\\s*]SHADER_NAME[\\s*]([A-Za-z0-9_-]+)[\\s*]/;\n  const match = SHADER_NAME_REGEXP.exec(shader);\n  return match ? match[1] : defaultName;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {CompareFunction} from '../types/parameters';\nimport {Resource, ResourceProps} from './resource';\n\n/** Edge values sampling mode */\nexport type SamplerAddressMode = 'clamp-to-edge' | 'repeat' | 'mirror-repeat';\n\n/** Sampler filtering mode */\nexport type SamplerFilterMode = 'nearest' | 'linear';\n\n/**\n * Properties for initializing a sampler\n */\nexport type SamplerProps = ResourceProps & {\n  /** Comparison / shadow samplers are used with depth textures. See the `Sampler.compare` field */\n  type?: 'color-sampler' | 'comparison-sampler';\n  /** Edge value sampling in X direction */\n  addressModeU?: 'clamp-to-edge' | 'repeat' | 'mirror-repeat';\n  /** Edge value sampling in Y direction */\n  addressModeV?: 'clamp-to-edge' | 'repeat' | 'mirror-repeat';\n  /** Edge value sampling in Z direction */\n  addressModeW?: 'clamp-to-edge' | 'repeat' | 'mirror-repeat';\n\n  /** Magnification: the area of the fragment in texture space is smaller than a texel */\n  magFilter?: 'nearest' | 'linear';\n  /** Minification: the area of the fragment in texture space is larger than a texel */\n  minFilter?: 'nearest' | 'linear';\n  /** mipmapping: select between multiple mipmaps based on angle and size of the texture relative to the screen. */\n  mipmapFilter?: 'none' | 'nearest' | 'linear';\n  /** Affects the mipmap image selection */\n  lodMinClamp?: number;\n  /** Affects the mipmap image selection */\n  lodMaxClamp?: number;\n  /** Maximum number of samples that can be taken of the texture during any one texture fetch */\n  maxAnisotropy?: number;\n  /** How to compare reference values provided in shader shadow sampler calls with those pulled from the texture */\n  compare?: CompareFunction;\n};\n\nexport type SamplerParameters = Omit<SamplerProps, keyof ResourceProps>;\n\n/** Immutable Sampler object */\nexport abstract class Sampler extends Resource<SamplerProps> {\n  static override defaultProps: Required<SamplerProps> = {\n    ...Resource.defaultProps,\n    type: 'color-sampler',\n    addressModeU: 'clamp-to-edge',\n    addressModeV: 'clamp-to-edge',\n    addressModeW: 'clamp-to-edge',\n    magFilter: 'nearest',\n    minFilter: 'nearest',\n    mipmapFilter: 'none',\n    lodMinClamp: 0,\n    lodMaxClamp: 32, // Per WebGPU spec\n    compare: 'less-equal',\n    maxAnisotropy: 1\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'Sampler';\n  }\n\n  constructor(device: Device, props: SamplerProps) {\n    props = Sampler.normalizeProps(device, props);\n    super(device, props, Sampler.defaultProps);\n  }\n\n  protected static normalizeProps(device: Device, props: SamplerProps): SamplerProps {\n    const overriddenDefaultProps: Partial<SamplerProps> =\n      device?.props?._resourceDefaults?.sampler || {};\n    const newProps = {...props, ...overriddenDefaultProps};\n    return newProps;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {\n  ColorTextureFormat,\n  DepthStencilTextureFormat,\n  TextureFormat\n} from '../../gpu-type-utils/texture-formats';\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\nimport {Texture} from './texture';\nimport {TextureView} from './texture-view';\nimport {log} from '../../utils/log';\n\nexport type FramebufferProps = ResourceProps & {\n  width?: number;\n  height?: number;\n  colorAttachments?: (TextureView | Texture | ColorTextureFormat)[];\n  depthStencilAttachment?: (TextureView | Texture | DepthStencilTextureFormat) | null;\n};\n\n/**\n * Create new textures with correct size for all attachments.\n * @note resize() destroys existing textures (if size has changed).\n */\nexport abstract class Framebuffer extends Resource<FramebufferProps> {\n  static override defaultProps: Required<FramebufferProps> = {\n    ...Resource.defaultProps,\n    width: 1,\n    height: 1,\n    colorAttachments: [], // ['rgba8unorm'],\n    depthStencilAttachment: null // 'depth24plus-stencil8'\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'Framebuffer';\n  }\n\n  /** Width of all attachments in this framebuffer */\n  width: number;\n  /** Height of all attachments in this framebuffer */\n  height: number;\n  /** Color attachments */\n  abstract colorAttachments: TextureView[];\n  /** Depth-stencil attachment, if provided */\n  abstract depthStencilAttachment: TextureView | null;\n\n  constructor(device: Device, props: FramebufferProps = {}) {\n    super(device, props, Framebuffer.defaultProps);\n    this.width = this.props.width;\n    this.height = this.props.height;\n  }\n\n  /**\n   * Create a copy of this framebuffer with new attached textures, with same props but of the specified size.\n   * @note Does not copy contents of the attached textures.\n   */\n  clone(size?: {width: number; height: number}): Framebuffer {\n    const colorAttachments = this.colorAttachments.map(colorAttachment =>\n      colorAttachment.texture.clone(size)\n    );\n\n    const depthStencilAttachment =\n      this.depthStencilAttachment && this.depthStencilAttachment.texture.clone(size);\n\n    return this.device.createFramebuffer({...this.props, colorAttachments, depthStencilAttachment});\n  }\n\n  /**\n   * Resizes all attachments\n   * @note resize() destroys existing textures (if size has changed).\n   * @deprecated Use framebuffer.clone()\n   */\n  resize(size: {width: number; height: number}): void;\n  resize(size: [width: number, height: number]): void;\n  resize(): void;\n  resize(size?: {width: number; height: number} | [width: number, height: number]): void {\n    let updateSize: boolean = !size;\n    if (size) {\n      const [width, height] = Array.isArray(size) ? size : [size.width, size.height];\n      updateSize = updateSize || height !== this.height || width !== this.width;\n      this.width = width;\n      this.height = height;\n    }\n    if (updateSize) {\n      log.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)();\n      this.resizeAttachments(this.width, this.height);\n    }\n  }\n\n  /** Auto creates any textures */\n  protected autoCreateAttachmentTextures(): void {\n    if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment) {\n      throw new Error('Framebuffer has noattachments');\n    }\n\n    this.colorAttachments = this.props.colorAttachments.map((attachment, index) => {\n      if (typeof attachment === 'string') {\n        const texture = this.createColorTexture(attachment, index);\n        this.attachResource(texture);\n        return texture.view;\n      }\n      if (attachment instanceof Texture) {\n        return attachment.view;\n      }\n      return attachment;\n    });\n\n    const attachment = this.props.depthStencilAttachment;\n    if (attachment) {\n      if (typeof attachment === 'string') {\n        const texture = this.createDepthStencilTexture(attachment);\n        this.attachResource(texture);\n        this.depthStencilAttachment = texture.view;\n      } else if (attachment instanceof Texture) {\n        this.depthStencilAttachment = attachment.view;\n      } else {\n        this.depthStencilAttachment = attachment;\n      }\n    }\n  }\n\n  /** Create a color texture */\n  protected createColorTexture(format: TextureFormat, index: number): Texture {\n    return this.device.createTexture({\n      id: `${this.id}-color-attachment-${index}`,\n      usage: Texture.RENDER_ATTACHMENT,\n      format,\n      width: this.width,\n      height: this.height,\n      // TODO deprecated? - luma.gl v8 compatibility\n      sampler: {\n        magFilter: 'linear',\n        minFilter: 'linear'\n      }\n    });\n  }\n\n  /** Create depth stencil texture */\n  protected createDepthStencilTexture(format: TextureFormat): Texture {\n    return this.device.createTexture({\n      id: `${this.id}-depth-stencil-attachment`,\n      usage: Texture.RENDER_ATTACHMENT,\n      format,\n      width: this.width,\n      height: this.height,\n      mipmaps: false\n    });\n  }\n\n  /**\n   * Default implementation of resize\n   * Creates new textures with correct size for all attachments.\n   * and destroys existing textures if owned\n   */\n  protected resizeAttachments(width: number, height: number): void {\n    for (let i = 0; i < this.colorAttachments.length; ++i) {\n      if (this.colorAttachments[i]) {\n        const resizedTexture = this.colorAttachments[i].texture.clone({\n          width,\n          height\n        });\n        this.destroyAttachedResource(this.colorAttachments[i]);\n        this.colorAttachments[i] = resizedTexture.view;\n        this.attachResource(resizedTexture.view);\n      }\n    }\n\n    if (this.depthStencilAttachment) {\n      const resizedTexture = this.depthStencilAttachment.texture.clone({\n        width,\n        height\n      });\n      this.destroyAttachedResource(this.depthStencilAttachment);\n      this.depthStencilAttachment = resizedTexture.view;\n      this.attachResource(resizedTexture);\n    }\n\n    this.updateAttachments();\n  }\n\n  /** Implementation is expected to update any underlying binding (WebGL framebuffer attachment) */\n  protected abstract updateAttachments(): void;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport type {UniformValue} from '../types/uniforms';\nimport type {PrimitiveTopology, RenderPipelineParameters} from '../types/parameters';\nimport type {ShaderLayout, Binding} from '../types/shader-layout';\nimport type {BufferLayout} from '../types/buffer-layout';\n// import {normalizeAttributeMap} from '../helpers/attribute-bindings';\nimport {Resource, ResourceProps} from './resource';\nimport type {Shader} from './shader';\nimport type {RenderPass} from './render-pass';\nimport {VertexArray} from './vertex-array';\nimport {TransformFeedback} from './transform-feedback';\n\nexport type RenderPipelineProps = ResourceProps & {\n  // Shaders and shader layout\n\n  /** Compiled vertex shader */\n  vs?: Shader | null;\n  /** Name of vertex shader stage main function (defaults to 'main'). WGSL only */\n  vertexEntryPoint?: string; //\n  /** Constant values to apply to compiled vertex shader. Do not require re-compilation. (WGSL only) */\n  vsConstants?: Record<string, number>; // WGSL only\n  /** Compiled fragment shader */\n  fs?: Shader | null;\n  /** Name of fragment shader stage main function (defaults to 'main'). WGSL only */\n  fragmentEntryPoint?: string; // WGSL only\n  /** Constant values to apply to compiled fragment shader. Do not require re-compilation. (WGSL only) */\n  fsConstants?: Record<string, number>;\n\n  /** Describes the attributes and bindings exposed by the pipeline shader(s). */\n  shaderLayout?: ShaderLayout | null;\n  /** Describes the buffers accepted by this pipeline and how they are mapped to shader attributes. */\n  bufferLayout?: BufferLayout[]; // Record<string, Omit<BufferLayout, 'name'>\n\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology?: PrimitiveTopology;\n  /** Parameters that are controlled by pipeline */\n  parameters?: RenderPipelineParameters;\n\n  // /** Use instanced rendering? */\n  // isInstanced?: boolean;\n  // /** Number of instances */\n  // instanceCount?: number;\n  // /** Number of vertices */\n  // vertexCount?: number;\n\n  /** Buffers, Textures, Samplers for the shader bindings */\n  bindings?: Record<string, Binding>;\n  /** @deprecated uniforms (WebGL only) */\n  uniforms?: Record<string, UniformValue>;\n};\n\n/**\n * A compiled and linked shader program\n */\nexport abstract class RenderPipeline extends Resource<RenderPipelineProps> {\n  static override defaultProps: Required<RenderPipelineProps> = {\n    ...Resource.defaultProps,\n\n    vs: null,\n    vertexEntryPoint: 'vertexMain',\n    vsConstants: {},\n\n    fs: null,\n    fragmentEntryPoint: 'fragmentMain',\n    fsConstants: {},\n\n    shaderLayout: null,\n    bufferLayout: [],\n    topology: 'triangle-list',\n    parameters: {},\n\n    // isInstanced: false,\n    // instanceCount: 0,\n    // vertexCount: 0,\n\n    bindings: {},\n    uniforms: {}\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'RenderPipeline';\n  }\n\n  abstract readonly vs: Shader;\n  abstract readonly fs: Shader | null;\n\n  /** The merged layout */\n  shaderLayout: ShaderLayout;\n  /** Buffer map describing buffer interleaving etc */\n  readonly bufferLayout: BufferLayout[];\n  /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */\n  linkStatus: 'pending' | 'success' | 'error' = 'pending';\n  /** The hash of the pipeline */\n  hash: string = '';\n\n  constructor(device: Device, props: RenderPipelineProps) {\n    super(device, props, RenderPipeline.defaultProps);\n    this.shaderLayout = this.props.shaderLayout!;\n    this.bufferLayout = this.props.bufferLayout || [];\n  }\n\n  /** Set bindings (stored on pipeline and set before each call) */\n  abstract setBindings(\n    bindings: Record<string, Binding>,\n    options?: {disableWarnings?: boolean}\n  ): void;\n\n  /** Draw call. Returns false if the draw call was aborted (due to resources still initializing) */\n  abstract draw(options: {\n    /** Render pass to draw into (targeting screen or framebuffer) */\n    renderPass?: RenderPass;\n    /** Parameters to be set during draw call. Note that most parameters can only be overridden in WebGL. */\n    parameters?: RenderPipelineParameters;\n    /** Topology. Note can only be overridden in WebGL. */\n    topology?: PrimitiveTopology;\n    /** vertex attributes */\n    vertexArray: VertexArray;\n    /** Use instanced rendering? */\n    isInstanced?: boolean;\n    /** Number of \"rows\" in 'instance' buffers */\n    instanceCount?: number;\n    /** Number of \"rows\" in 'vertex' buffers */\n    vertexCount?: number;\n    /** Number of \"rows\" in index buffer */\n    indexCount?: number;\n    /** First vertex to draw from */\n    firstVertex?: number;\n    /** First index to draw from */\n    firstIndex?: number;\n    /** First instance to draw from */\n    firstInstance?: number;\n    baseVertex?: number;\n    /** Transform feedback. WebGL only. */\n    transformFeedback?: TransformFeedback;\n  }): boolean;\n\n  // DEPRECATED METHODS\n\n  /**\n   * Uniforms\n   * @deprecated Use uniforms buffers\n   * @note textures, samplers and uniform buffers should be set via `setBindings()`, these are not considered uniforms.\n   * @note In WebGL uniforms have a performance penalty, they are reset before each call to enable pipeline sharing.\n   */\n  setUniformsWebGL(uniforms: Record<string, UniformValue>): void {\n    throw new Error('Use uniform blocks');\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumberArray4, TypedArray} from '@math.gl/types';\nimport type {Device} from '../device';\nimport type {RenderPassParameters} from '../types/parameters';\n// import {Binding} from '../types/shader-layout';\nimport {Resource, ResourceProps} from './resource';\nimport {Framebuffer} from './framebuffer';\nimport {QuerySet} from './query-set';\n\n/**\n * Properties for a RenderPass instance is a required parameter to all draw calls.\n */\nexport type RenderPassProps = ResourceProps & {\n  /** Framebuffer specifies which textures to render into. Default gets framebuffer from canvas context. */\n  framebuffer?: Framebuffer | null;\n  /** Control viewport, scissor rect, blend constant and stencil ref */\n  parameters?: RenderPassParameters;\n\n  // TODO - API needs to be able to control multiple render targets\n\n  /** Clear value for color attachment, or false to preserve the previous value */\n  clearColor?: NumberArray4 | TypedArray | false;\n  /** Experimental: Clear color values for multiple color attachments. Must specify typed arrays. props.clearColor will be ignored. */\n  clearColors?: (TypedArray | false)[];\n  /** Clear value for depth attachment (true === `1`), or false to preserve the previous value. Must be between 0.0 (near) and 1.0 (far), inclusive. */\n  clearDepth?: number | false;\n  /** Clear value for stencil attachment (true === `0`), or false to preserve the previous value. Converted to the type and number of LSBs as the number of bits in the stencil aspect */\n  clearStencil?: number | false;\n\n  /** Indicates that the depth component is read only. */\n  depthReadOnly?: boolean;\n  /** Indicates that the stencil component is read only. */\n  stencilReadOnly?: boolean;\n\n  /** Whether to disable / discard the output of the rasterizer */\n  discard?: boolean;\n\n  /** QuerySet to write begin/end timestamps to */\n  occlusionQuerySet?: QuerySet;\n  /** QuerySet to write begin/end timestamps to */\n  timestampQuerySet?: QuerySet;\n  /** QuerySet index to write begin timestamp to. No timestamp is written if not provided. */\n  beginTimestampIndex?: number;\n  /** QuerySet index to write end timestamp to. No timestamp is written if not provided. */\n  endTimestampIndex?: number;\n};\n\n/**\n * A RenderPass instance is a required parameter to all draw calls.\n *\n * It holds a combination of\n * - render targets (specified via a framebuffer)\n * - clear colors, read/write, discard information for the framebuffer attachments\n * - a couple of mutable parameters ()\n */\nexport abstract class RenderPass extends Resource<RenderPassProps> {\n  /** TODO - should be [0, 0, 0, 0], update once deck.gl tests run clean */\n  static defaultClearColor: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth 1.0 represents the far plance */\n  static defaultClearDepth = 1;\n  /** Clears all stencil bits */\n  static defaultClearStencil = 0;\n\n  /** Default properties for RenderPass */\n  static override defaultProps: Required<RenderPassProps> = {\n    ...Resource.defaultProps,\n    framebuffer: null,\n    parameters: undefined!,\n    clearColor: RenderPass.defaultClearColor,\n    clearColors: undefined!,\n    clearDepth: RenderPass.defaultClearDepth,\n    clearStencil: RenderPass.defaultClearStencil,\n    depthReadOnly: false,\n    stencilReadOnly: false,\n    discard: false,\n\n    occlusionQuerySet: undefined!,\n    timestampQuerySet: undefined!,\n    beginTimestampIndex: undefined!,\n    endTimestampIndex: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'RenderPass';\n  }\n\n  constructor(device: Device, props: RenderPassProps) {\n    props = RenderPass.normalizeProps(device, props);\n    super(device, props, RenderPass.defaultProps);\n  }\n\n  /** Call when rendering is done in this pass. */\n  abstract end(): void;\n\n  /** A few parameters can be changed at any time (viewport, scissorRect, blendColor, stencilReference) */\n  abstract setParameters(parameters: RenderPassParameters): void;\n\n  // executeBundles(bundles: Iterable<GPURenderBundle>): void;\n\n  /** Being an occlusion query. Value will be stored in the occlusionQuerySet at the index. Occlusion queries cannot be nested. */\n  abstract beginOcclusionQuery(queryIndex: number): void;\n  /** End an occlusion query. Stores result in the index specified in beginOcclusionQuery. */\n  abstract endOcclusionQuery(): void;\n\n  /** Begins a labeled debug group containing subsequent commands */\n  abstract pushDebugGroup(groupLabel: string): void;\n  /** Ends the labeled debug group most recently started by pushDebugGroup() */\n  abstract popDebugGroup(): void;\n  /** Marks a point in a stream of commands with a label */\n  abstract insertDebugMarker(markerLabel: string): void;\n\n  protected static normalizeProps(device: Device, props: RenderPassProps): RenderPassProps {\n    // Intended to override e.g. set default clear values to true\n    const overriddenDefaultProps = device.props._resourceDefaults?.renderPass;\n    const newProps = {...overriddenDefaultProps, ...props};\n    return newProps;\n  }\n}\n\n// TODO - Can we align WebGL implementation with WebGPU API?\n// In WebGPU the following methods are on the renderpass instead of the renderpipeline\n// luma.gl keeps them on the pipeline for now, but that has some issues.\n\n// abstract setPipeline(pipeline: RenderPipeline): void {}\n// abstract setIndexBuffer()\n// abstract setVertexBuffer(slot: number, buffer: Buffer, offset: number): void;\n// abstract setBindings(bindings: Record<string, Binding>): void;\n// abstract setParameters(parameters: RenderPassParameters);\n// abstract draw(options: {\n// abstract drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): void;\n// abstract drawIndexedIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): void;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Resource, ResourceProps} from './resource';\nimport type {ComputeShaderLayout, Binding} from '../types/shader-layout';\nimport type {Device} from '../device';\nimport type {Shader} from './shader';\n\n/**\n * Properties for a compute pipeline\n */\nexport type ComputePipelineProps = ResourceProps & {\n  handle?: unknown;\n  /** Compiled shader object */\n  shader: Shader;\n  /** The entry point, defaults to main */\n  entryPoint?: string;\n  /** These are WGSL constant values - different from GLSL defines in that shader does not need to be recompiled */\n  constants?: Record<string, number>;\n  /** Describes the attributes and bindings exposed by the pipeline shader(s). */\n  shaderLayout?: ComputeShaderLayout | null;\n};\n\n/**\n * A compiled and linked shader program for compute\n */\nexport abstract class ComputePipeline extends Resource<ComputePipelineProps> {\n  static override defaultProps: Required<ComputePipelineProps> = {\n    ...Resource.defaultProps,\n    shader: undefined!,\n    entryPoint: undefined!,\n    constants: {},\n    shaderLayout: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'ComputePipeline';\n  }\n\n  hash: string = '';\n  /** The merged shader layout */\n  shaderLayout: ComputeShaderLayout;\n\n  constructor(device: Device, props: ComputePipelineProps) {\n    super(device, props, ComputePipeline.defaultProps);\n    this.shaderLayout = props.shaderLayout!;\n  }\n\n  /**\n   * @todo Use renderpass.setBindings() ?\n   * @todo Do we want to expose BindGroups in the API and remove this?\n   */\n  abstract setBindings(bindings: Record<string, Binding>): void;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Resource, ResourceProps} from './resource';\nimport {ComputePipeline} from './compute-pipeline';\nimport type {Device} from '../device';\nimport {Buffer} from './buffer';\nimport {QuerySet} from './query-set';\n\nexport type ComputePassProps = ResourceProps & {\n  /** QuerySet to write beging/end timestamps to */\n  timestampQuerySet?: QuerySet;\n  /** QuerySet index to write begin timestamp to. No timestamp is written if not provided. */\n  beginTimestampIndex?: number;\n  /** QuerySet index to write end timestamp to. No timestamp is written if not provided. */\n  endTimestampIndex?: number;\n};\n\nexport abstract class ComputePass extends Resource<ComputePassProps> {\n  static override defaultProps: Required<ComputePassProps> = {\n    ...Resource.defaultProps,\n    timestampQuerySet: undefined!,\n    beginTimestampIndex: undefined!,\n    endTimestampIndex: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'ComputePass';\n  }\n\n  constructor(device: Device, props: ComputePassProps) {\n    super(device, props, ComputePass.defaultProps);\n  }\n\n  abstract override destroy(): void;\n\n  abstract end(): void;\n\n  abstract setPipeline(pipeline: ComputePipeline): void;\n\n  /** Sets an array of bindings (uniform buffers, samplers, textures, ...) */\n  // abstract setBindings(bindings: Binding[]): void;\n\n  /**\n   * Dispatch work to be performed with the current ComputePipeline.\n   * @param x X dimension of the grid of workgroups to dispatch.\n   * @param y Y dimension of the grid of workgroups to dispatch.\n   * @param z Z dimension of the grid of workgroups to dispatch.\n   */\n  abstract dispatch(x: number, y?: number, z?: number): void;\n\n  /**\n   * Dispatch work to be performed with the current ComputePipeline.\n   * @param indirectBuffer buffer must be a tightly packed block of three 32-bit unsigned integer values (12 bytes total), given in the same order as the arguments for dispatch()\n   * @param indirectOffset\n   */\n  abstract dispatchIndirect(indirectBuffer: Buffer, indirectOffset?: number): void;\n\n  /** Begins a labeled debug group containing subsequent commands */\n  abstract pushDebugGroup(groupLabel: string): void;\n  /** Ends the labeled debug group most recently started by pushDebugGroup() */\n  abstract popDebugGroup(): void;\n  /** Marks a point in a stream of commands with a label */\n  abstract insertDebugMarker(markerLabel: string): void;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// import type {TypedArray} from '@math.gl/types';\nimport {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\nimport {Buffer} from './buffer';\nimport {Texture} from './texture';\nimport {QuerySet} from './query-set';\n\n// WEBGPU COMMAND ENCODER OPERATIONS\n\nexport type CopyBufferToBufferOptions = {\n  sourceBuffer: Buffer;\n  sourceOffset?: number;\n  destinationBuffer: Buffer;\n  destinationOffset?: number;\n  size: number;\n};\n\nexport type CopyBufferToTextureOptions = {\n  sourceBuffer: Buffer;\n  byteOffset?: number;\n  destinationTexture: Texture;\n  mipLevel?: number; //  = 0;\n  origin?: [number, number, number] | number[];\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n  bytesPerRow: number;\n  rowsPerImage: number;\n  size: [number, number, number] | number[];\n};\n\nexport type CopyTextureToBufferOptions = {\n  /** Texture to copy to/from. */\n  sourceTexture: Texture;\n  /**  Mip-map level of the texture to copy to/from. (Default 0) */\n  mipLevel?: number;\n  /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from.\n   * Together with `copySize`, defines the full copy sub-region.\n   */\n  /** Defines which aspects of the texture to copy to/from. */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n\n  /** Width to copy */\n  width?: number;\n  height?: number;\n  depthOrArrayLayers?: number;\n  origin?: number[];\n\n  /** Destination buffer */\n  destinationBuffer: Buffer;\n  /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */\n  byteOffset?: number;\n  /**\n   * The stride, in bytes, between the beginning of each block row and the subsequent block row.\n   * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).\n   */\n  bytesPerRow?: number;\n  /**\n   * Number of block rows per single image of the texture.\n   * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.\n   * Required if there are multiple images (i.e. the copy depth is more than one).\n   */\n  rowsPerImage?: number;\n};\n\nexport type CopyTextureToTextureOptions = {\n  /** Texture to copy to/from. */\n  sourceTexture: Texture;\n  /**  Mip-map level of the texture to copy to/from. (Default 0) */\n  mipLevel?: number;\n  /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */\n  origin?: number[];\n  /** Defines which aspects of the {@link GPUImageCopyTexture#texture} to copy to/from. */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n\n  /** Texture to copy to/from. */\n  destinationTexture: Texture;\n  /**  Mip-map level of the texture to copy to/from. (Default 0) */\n  destinationMipLevel?: number;\n  /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */\n  destinationOrigin?: number[];\n  /** Defines which aspects of the {@link GPUImageCopyTexture#texture} to copy to/from. */\n  destinationAspect?: 'all' | 'stencil-only' | 'depth-only';\n\n  /** Width to copy */\n  width?: number;\n  height?: number;\n  depthOrArrayLayers?: number;\n};\n\n// ADDITIONAL COMMAND ENCODER OPERATIONS DEFINED BY LUMA.GL\n\n/** Options for clearing a texture mip level */\nexport type ClearTextureOptions = {\n  /** Texture to Clear. */\n  texture: Texture;\n  /**  Mip-map level of the texture clear. (Default 0) */\n  mipLevel?: number;\n  /** Defines which aspects of the Texture to clear. */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n};\n\n// export type WriteBufferOptions = {\n//   buffer: Buffer;\n//   bufferOffset?: number;\n//   data: BufferSource;\n//   dataOffset?: number;\n//   size?: number;\n// };\n\n// export type WriteTextureOptions = {\n//   destination: Texture;\n//   mipLevel?: number; //  = 0;\n//   origin?: [number, number, number] | number[];\n//   aspect?: 'all' | 'stencil-only' | 'depth-only';\n//   data: BufferSource;\n//   // dataLayout;\n//   offset: number;\n//   bytesPerRow: number;\n//   rowsPerImage: number;\n//   size: [number, number, number] | number[];\n// };\n\nexport type CommandEncoderProps = ResourceProps & {\n  measureExecutionTime?: boolean;\n};\n\n/**\n * Encodes commands to queue that can be executed later\n */\nexport abstract class CommandEncoder extends Resource<CommandEncoderProps> {\n  static override defaultProps: Required<CommandEncoderProps> = {\n    ...Resource.defaultProps,\n    measureExecutionTime: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'CommandEncoder';\n  }\n\n  constructor(device: Device, props: CommandEncoderProps) {\n    super(device, props, CommandEncoder.defaultProps);\n  }\n\n  /** Completes recording of the commands sequence */\n  abstract finish(): void; // TODO - return the CommandBuffer?\n\n  /** Add a command that that copies data from a sub-region of a Buffer to a sub-region of another Buffer. */\n  abstract copyBufferToBuffer(options: CopyBufferToBufferOptions): void;\n\n  /** Add a command that copies data from a sub-region of a GPUBuffer to a sub-region of one or multiple continuous texture subresources. */\n  abstract copyBufferToTexture(options: CopyBufferToTextureOptions): void;\n\n  /** Add a command that copies data from a sub-region of one or multiple continuous texture subresources to a sub-region of a Buffer. */\n  abstract copyTextureToBuffer(options: CopyTextureToBufferOptions): void;\n\n  /** Add a command that copies data from a sub-region of one or multiple contiguous texture subresources to another sub-region of one or multiple continuous texture subresources. */\n  abstract copyTextureToTexture(options: CopyTextureToTextureOptions): void;\n\n  /** Add a command that clears a texture mip level. */\n  // abstract clearTexture(options: ClearTextureOptions): void;\n\n  // abstract readTexture(options: ReadTextureOptions): Promise<TypedArray>;\n\n  /** Reads results from a query set into a GPU buffer. Values are 64 bits so byteLength must be querySet.props.count * 8 */\n  abstract resolveQuerySet(\n    querySet: QuerySet,\n    destination: Buffer,\n    options?: {\n      firstQuery?: number;\n      queryCount?: number;\n      destinationOffset?: number;\n    }\n  ): void;\n\n  /** Begins a labeled debug group containing subsequent commands */\n  abstract pushDebugGroup(groupLabel: string): void;\n  /** Ends the labeled debug group most recently started by pushDebugGroup() */\n  abstract popDebugGroup(): void;\n  /** Marks a point in a stream of commands with a label */\n  abstract insertDebugMarker(markerLabel: string): void;\n\n  // TODO - luma.gl has these on the device, should we align with WebGPU API?\n  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;\n  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n\n// interface Queue {\n//   submit(commandBuffers);\n\n//   // onSubmittedWorkDone(): Promise<undefined>;\n\n//   writeBuffer(options: WriteBufferOptions): void;\n//   writeTexture(options: WriteTextureOptions): void;\n\n//   // copyExternalImageToTexture(\n//   //   GPUImageCopyExternalImage source,\n//   //   GPUImageCopyTextureTagged destination,\n//   //   GPUExtent3D copySize\n//   // ): void;\n// }\n\nexport type CommandBufferProps = ResourceProps & {};\n\n/**\n * Encodes commands to queue that can be executed later\n */\nexport abstract class CommandBuffer extends Resource<CommandBufferProps> {\n  static override defaultProps: Required<CommandBufferProps> = {\n    ...Resource.defaultProps\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'CommandBuffer';\n  }\n\n  constructor(device: Device, props: CommandBufferProps) {\n    super(device, props, CommandBuffer.defaultProps);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderDataType, ShaderAttributeType} from './shader-types';\nimport {VertexFormat, VertexType} from './vertex-formats';\n\n/** Information extracted from a ShaderAttributeInfo constant */\nexport type ShaderAttributeTypeInfo = {\n  /** WGSL-style primitive data type, f32, i32, u32 */\n  dataType: ShaderDataType;\n  /** Whether this is a normalized integer (that must be used as float) */\n  components: 1 | 2 | 3 | 4;\n  /** Length in bytes of the data for one vertex */\n  byteLength?: number;\n  /** Whether this is for integer or float vert */\n  integer: boolean;\n  /** Whether this data type is signed */\n  signed: boolean;\n  /** The simplest vertex format that matches the shader attribute's data type */\n  defaultVertexFormat: VertexFormat;\n};\n\n/** Decodes a vertex type, returning byte length and flags (integer, signed, normalized) */\nexport function decodeShaderAttributeType(\n  attributeType: ShaderAttributeType\n): ShaderAttributeTypeInfo {\n  const [dataType, components] = TYPE_INFO[attributeType];\n  const integer: boolean = dataType === 'i32' || dataType === 'u32';\n  const signed: boolean = dataType !== 'u32';\n\n  const byteLength = TYPE_SIZES[dataType] * components;\n  const defaultVertexFormat = getCompatibleVertexFormat(dataType, components);\n  return {\n    dataType,\n    components,\n    defaultVertexFormat,\n    byteLength,\n    integer,\n    signed\n  };\n}\n\n/** Get the \"default\" vertex format for a certain shader data type */\nfunction getCompatibleVertexFormat(\n  dataType: ShaderDataType,\n  components: 1 | 2 | 3 | 4\n): VertexFormat {\n  let vertexType: VertexType;\n  switch (dataType) {\n    case 'f32':\n      vertexType = 'float32';\n      break;\n    case 'i32':\n      vertexType = 'sint32';\n      break;\n    case 'u32':\n      vertexType = 'uint32';\n      break;\n    case 'f16':\n      return components <= 2 ? 'float16x2' : 'float16x4';\n  }\n  // TODO logic does not work for float16\n  if (components === 1) {\n    return vertexType;\n  }\n  return `${vertexType}x${components}`;\n}\n\n/** All valid shader attribute types. A table guarantees exhaustive list and fast execution */\nconst TYPE_INFO: Record<ShaderAttributeType, [ShaderDataType, 1 | 2 | 3 | 4]> = {\n  f32: ['f32', 1],\n  'vec2<f32>': ['f32', 2],\n  'vec3<f32>': ['f32', 3],\n  'vec4<f32>': ['f32', 4],\n  f16: ['f16', 1],\n  'vec2<f16>': ['f16', 2],\n  'vec3<f16>': ['f16', 3],\n  'vec4<f16>': ['f16', 4],\n  i32: ['i32', 1],\n  'vec2<i32>': ['i32', 2],\n  'vec3<i32>': ['i32', 3],\n  'vec4<i32>': ['i32', 4],\n  u32: ['u32', 1],\n  'vec2<u32>': ['u32', 2],\n  'vec3<u32>': ['u32', 3],\n  'vec4<u32>': ['u32', 4]\n};\n\nconst TYPE_SIZES: Record<ShaderDataType, number> = {\n  f32: 4,\n  f16: 2,\n  i32: 4,\n  u32: 4\n  // 'bool-webgl': 4,\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {VertexFormat, VertexType} from './vertex-formats';\nimport {decodeVertexType} from './decode-data-type';\n\nexport type VertexFormatInfo = {\n  /** Length in bytes */\n  byteLength: number;\n  /** Type of each component */\n  type: VertexType;\n  /** Number of components per vertex / row */\n  components: 1 | 2 | 3 | 4;\n  /** Is this an integer format (normalized integer formats are not integer) */\n  integer: boolean;\n  /** Is this a signed format? */\n  signed: boolean;\n  /** Is this a normalized format? */\n  normalized: boolean;\n  /** Is this a webgl only format? */\n  webglOnly?: boolean;\n};\n\n/**\n * Decodes a vertex format, returning type, components, byte  length and flags (integer, signed, normalized)\n */\nexport function decodeVertexFormat(format: VertexFormat): VertexFormatInfo {\n  // Strip the -webgl ending if present\n  let webglOnly: boolean | undefined;\n  if (format.endsWith('-webgl')) {\n    format.replace('-webgl', '');\n    webglOnly = true;\n  }\n  // split components from type\n  const [type_, count] = format.split('x');\n  const type = type_ as VertexType;\n  const components = (count ? parseInt(count) : 1) as 1 | 2 | 3 | 4;\n  // decode the type\n  const decodedType = decodeVertexType(type);\n  const result: VertexFormatInfo = {\n    type,\n    components,\n    byteLength: decodedType.byteLength * components,\n    integer: decodedType.integer,\n    signed: decodedType.signed,\n    normalized: decodedType.normalized\n  };\n  if (webglOnly) {\n    result.webglOnly = true;\n  }\n  return result;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log} from '../utils/log';\nimport type {ShaderLayout, AttributeDeclaration} from '../adapter/types/shader-layout';\nimport type {BufferLayout} from '../adapter/types/buffer-layout';\nimport type {ShaderDataType, ShaderAttributeType} from '../gpu-type-utils/shader-types';\nimport {decodeShaderAttributeType} from '../gpu-type-utils/decode-attribute-type';\nimport type {VertexFormat, VertexType} from '../gpu-type-utils/vertex-formats';\nimport {decodeVertexFormat} from '../gpu-type-utils/decode-vertex-format';\n\n/** Resolved info for a buffer / attribute combination to help backend configure it correctly */\nexport type AttributeInfo = {\n  /** Attribute name */\n  attributeName: string;\n  /** Location in shader */\n  location: number;\n  /** Type / precision used in shader (buffer values may be converted) */\n  shaderType: ShaderAttributeType;\n  /** Calculations are done in this type in the shader's attribute declaration */\n  shaderDataType: ShaderDataType;\n  /** Components refer to the number of components in the shader's attribute declaration */\n  shaderComponents: 1 | 2 | 3 | 4;\n  /** It is the shader attribute declaration that determines whether GPU will process as integer or float */\n  integer: boolean;\n\n  /** BufferName */\n  bufferName: string;\n  /** Format of buffer data */\n  vertexFormat: VertexFormat;\n  /** Memory data type refers to the data type in the buffer */\n  bufferDataType: VertexType;\n  /** Components refer to the number of components in the buffer's vertex format */\n  bufferComponents: 1 | 2 | 3 | 4;\n  /** Normalization is encoded in the buffer layout's vertex format... */\n  normalized: boolean;\n\n  /** If not specified, the step mode is inferred from the attribute name in the shader (contains string instance) */\n  stepMode: 'vertex' | 'instance';\n\n  /** The byteOffset is encoded in or calculated from the buffer layout */\n  byteOffset: number;\n  /** The byteStride is encoded in or calculated from the buffer layout */\n  byteStride: number;\n};\n\ntype BufferAttributeInfo = {\n  attributeName: string;\n  bufferName: string;\n  stepMode?: 'vertex' | 'instance';\n  vertexFormat: VertexFormat;\n  byteOffset: number;\n  byteStride: number;\n};\n\n/**\n * Map from \"attribute names\" to \"resolved attribute infos\"\n * containing information about both buffer layouts and shader attribute declarations\n */\nexport function getAttributeInfosFromLayouts(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[]\n): Record<string, AttributeInfo> {\n  const attributeInfos: Record<string, AttributeInfo> = {};\n  for (const attribute of shaderLayout.attributes) {\n    const attributeInfo = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);\n    if (attributeInfo) {\n      attributeInfos[attribute.name] = attributeInfo;\n    }\n  }\n  return attributeInfos;\n}\n\n/**\n * Array indexed by \"location\" holding \"resolved attribute infos\"\n */\nexport function getAttributeInfosByLocation(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[],\n  maxVertexAttributes: number = 16\n): AttributeInfo[] {\n  const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);\n  const locationInfos: AttributeInfo[] = new Array(maxVertexAttributes).fill(null);\n  for (const attributeInfo of Object.values(attributeInfos)) {\n    locationInfos[attributeInfo.location] = attributeInfo;\n  }\n  return locationInfos;\n}\n\n/**\n * Get the combined information from a shader layout and a buffer layout for a specific attribute\n */\nfunction getAttributeInfoFromLayouts(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[],\n  name: string\n): AttributeInfo | null {\n  const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name);\n  const bufferMapping: BufferAttributeInfo | null = getAttributeFromBufferLayout(\n    bufferLayout,\n    name\n  );\n\n  // TODO should no longer happen\n  if (!shaderDeclaration) {\n    //  || !bufferMapping\n    return null;\n  }\n\n  const attributeTypeInfo = decodeShaderAttributeType(shaderDeclaration.type);\n  const vertexFormat = bufferMapping?.vertexFormat || attributeTypeInfo.defaultVertexFormat;\n  const vertexFormatInfo = decodeVertexFormat(vertexFormat);\n\n  return {\n    attributeName: bufferMapping?.attributeName || shaderDeclaration.name,\n    bufferName: bufferMapping?.bufferName || shaderDeclaration.name,\n    location: shaderDeclaration.location,\n    shaderType: shaderDeclaration.type,\n    shaderDataType: attributeTypeInfo.dataType,\n    shaderComponents: attributeTypeInfo.components,\n    vertexFormat,\n    bufferDataType: vertexFormatInfo.type,\n    bufferComponents: vertexFormatInfo.components,\n    // normalized is a property of the buffer's vertex format\n    normalized: vertexFormatInfo.normalized,\n    // integer is a property of the shader declaration\n    integer: attributeTypeInfo.integer,\n    stepMode: bufferMapping?.stepMode || shaderDeclaration.stepMode || 'vertex',\n    byteOffset: bufferMapping?.byteOffset || 0,\n    byteStride: bufferMapping?.byteStride || 0\n  };\n}\n\nfunction getAttributeFromShaderLayout(\n  shaderLayout: ShaderLayout,\n  name: string\n): AttributeDeclaration | null {\n  const attribute = shaderLayout.attributes.find(attr => attr.name === name);\n  if (!attribute) {\n    log.warn(`shader layout attribute \"${name}\" not present in shader`);\n  }\n  return attribute || null;\n}\n\nfunction getAttributeFromBufferLayout(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  // Check that bufferLayouts are valid (each either has format or attribute)\n  checkBufferLayouts(bufferLayouts);\n\n  let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name);\n  if (bufferLayoutInfo) {\n    return bufferLayoutInfo;\n  }\n\n  bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name);\n  if (bufferLayoutInfo) {\n    return bufferLayoutInfo;\n  }\n\n  // Didn't find...\n  log.warn(`layout for attribute \"${name}\" not present in buffer layout`);\n  return null;\n}\n\n/** Check that bufferLayouts are valid (each either has format or attribute) */\nfunction checkBufferLayouts(bufferLayouts: BufferLayout[]) {\n  for (const bufferLayout of bufferLayouts) {\n    if (\n      (bufferLayout.attributes && bufferLayout.format) ||\n      (!bufferLayout.attributes && !bufferLayout.format)\n    ) {\n      log.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);\n    }\n  }\n}\n\n/** Get attribute from format shorthand if specified */\nfunction getAttributeFromShortHand(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  for (const bufferLayout of bufferLayouts) {\n    if (bufferLayout.format && bufferLayout.name === name) {\n      return {\n        attributeName: bufferLayout.name,\n        bufferName: name,\n        stepMode: bufferLayout.stepMode,\n        vertexFormat: bufferLayout.format,\n        // If offset is needed, use `attributes` field.\n        byteOffset: 0,\n        byteStride: bufferLayout.byteStride || 0\n      };\n    }\n  }\n  return null;\n}\n\n/**\n * Search attribute mappings (e.g. interleaved attributes) for buffer mapping.\n * Not the name of the buffer might be the same as one of the interleaved attributes.\n */\nfunction getAttributeFromAttributesList(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  for (const bufferLayout of bufferLayouts) {\n    let byteStride: number | undefined = bufferLayout.byteStride;\n\n    // Calculate a default byte stride if not provided\n    if (typeof bufferLayout.byteStride !== 'number') {\n      for (const attributeMapping of bufferLayout.attributes || []) {\n        const info = decodeVertexFormat(attributeMapping.format);\n        // @ts-ignore\n        byteStride += info.byteLength;\n      }\n    }\n\n    const attributeMapping = bufferLayout.attributes?.find(mapping => mapping.attribute === name);\n    if (attributeMapping) {\n      return {\n        attributeName: attributeMapping.attribute,\n        bufferName: bufferLayout.name,\n        stepMode: bufferLayout.stepMode,\n        vertexFormat: attributeMapping.format,\n        byteOffset: attributeMapping.byteOffset,\n        // @ts-ignore\n        byteStride\n      };\n    }\n  }\n\n  return null;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TypedArray} from '../../types';\nimport {\n  AttributeInfo,\n  getAttributeInfosByLocation\n} from '../../adapter-utils/get-attribute-from-layouts';\nimport type {Device} from '../device';\nimport type {Buffer} from './buffer';\nimport type {RenderPass} from './render-pass';\nimport type {RenderPipeline} from './render-pipeline';\nimport {Resource, ResourceProps} from './resource';\n\n/** Properties for initializing a VertexArray */\nexport type VertexArrayProps = ResourceProps & {\n  renderPipeline: RenderPipeline | null;\n};\n\n/**\n * Stores attribute bindings.\n * Makes it easy to share a render pipeline and use separate vertex arrays.\n * @note On WebGL, VertexArray allows non-constant bindings to be performed in advance\n * reducing the number of WebGL calls per draw call.\n * @note On WebGPU this is just a convenience class that collects the bindings.\n */\nexport abstract class VertexArray extends Resource<VertexArrayProps> {\n  static override defaultProps: Required<VertexArrayProps> = {\n    ...Resource.defaultProps,\n    renderPipeline: null\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'VertexArray';\n  }\n\n  /** Max number of vertex attributes */\n  readonly maxVertexAttributes: number;\n  /** Attribute infos indexed by location - TODO only needed by webgl module? */\n  protected readonly attributeInfos: AttributeInfo[];\n\n  /** Index buffer */\n  indexBuffer: Buffer | null = null;\n  /** Attributes indexed by buffer slot */\n  attributes: (Buffer | TypedArray | null)[];\n\n  constructor(device: Device, props: VertexArrayProps) {\n    super(device, props, VertexArray.defaultProps);\n    this.maxVertexAttributes = device.limits.maxVertexAttributes;\n    this.attributes = new Array(this.maxVertexAttributes).fill(null);\n    const {shaderLayout, bufferLayout} = props.renderPipeline || {};\n    if (!shaderLayout || !bufferLayout) {\n      throw new Error('VertexArray');\n    }\n    this.attributeInfos = getAttributeInfosByLocation(\n      shaderLayout,\n      bufferLayout,\n      this.maxVertexAttributes\n    );\n  }\n\n  /** Set attributes (stored on pipeline and set before each call) */\n  abstract setIndexBuffer(indices: Buffer | null): void;\n  /** Set attributes (stored on pipeline and set before each call) */\n  abstract setBuffer(bufferSlot: number, buffer: Buffer | null): void;\n\n  abstract bindBeforeRender(renderPass: RenderPass): void;\n  abstract unbindAfterRender(renderPass: RenderPass): void;\n\n  // DEPRECATED METHODS\n\n  /** @deprecated Set constant attributes (WebGL only) */\n  setConstantWebGL(location: number, value: TypedArray | null): void {\n    this.device.reportError(new Error('constant attributes not supported'));\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {PrimitiveTopology} from '../types/parameters';\nimport {ShaderLayout} from '../types/shader-layout';\nimport type {Buffer} from './buffer';\nimport {Resource, ResourceProps} from './resource';\n\n/** For bindRange */\nexport type BufferRange = {\n  buffer: Buffer;\n  byteOffset?: number;\n  byteLength?: number;\n};\n\n/** Configures a set of output buffers for pipeline (WebGL only) */\nexport type TransformFeedbackProps = ResourceProps & {\n  /** Layout of shader (for varyings) */\n  layout: ShaderLayout;\n  /** Buffer bindings (for varyings) */\n  buffers: Record<string, Buffer | BufferRange>;\n};\n\n/** Holds a set of output buffers for pipeline (WebGL only) */\nexport abstract class TransformFeedback extends Resource<TransformFeedbackProps> {\n  static override defaultProps: Required<TransformFeedbackProps> = {\n    ...Resource.defaultProps,\n    layout: undefined!,\n    buffers: {}\n  };\n\n  get [Symbol.toStringTag](): string {\n    return 'TransformFeedback';\n  }\n\n  constructor(device: Device, props: TransformFeedbackProps) {\n    super(device, props, TransformFeedback.defaultProps);\n  }\n\n  abstract begin(topology?: PrimitiveTopology): void;\n  abstract end(): void;\n\n  abstract setBuffers(buffers: Record<string, Buffer | BufferRange>): void;\n  abstract setBuffer(locationOrName: string | number, bufferOrRange: Buffer | BufferRange): void;\n  abstract getBuffer(locationOrName: string | number): Buffer | BufferRange | null;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n\n/**\n * Properties for creating a QuerySet\n * - 'timestamp' - query the GPU timestamp counter at the start and end of render passes\n *   timestamp queries are available if the 'timestamp-query' feature is present.\n * - 'occlusion' - query the number of fragment samples that pass all per-fragment tests for a set of drawing commands\n *   including scissor, sample mask, alpha to coverage, stencil, and depth tests\n */\nexport type QuerySetProps = ResourceProps & {\n  /**\n   * The type of query set\n   * occlusion - query the number of fragment samples that pass all the per-fragment tests for a set of drawing commands, including scissor, sample mask, alpha to coverage, stencil, and depth tests\n   * timestamp - query the GPU timestamp counter at the start and end of render passes\n   */\n  type: 'occlusion' | 'timestamp';\n  /** The number of queries managed by the query set */\n  count: number;\n};\n\n/** Immutable QuerySet object */\nexport abstract class QuerySet extends Resource<QuerySetProps> {\n  static override defaultProps: Required<QuerySetProps> = {\n    ...Resource.defaultProps,\n    type: undefined!,\n    count: undefined!\n  };\n\n  get [Symbol.toStringTag](): string {\n    return 'QuerySet';\n  }\n\n  constructor(device: Device, props: QuerySetProps) {\n    super(device, props, QuerySet.defaultProps);\n  }\n}\n", "import {Device} from '../device';\nimport {ShaderLayout} from '../types/shader-layout';\nimport {Resource, ResourceProps} from './resource';\n\nexport type PipelineLayoutProps = ResourceProps & {\n  shaderLayout: ShaderLayout;\n};\n\n/** Immutable PipelineLayout object */\nexport abstract class PipelineLayout extends Resource<PipelineLayoutProps> {\n  get [Symbol.toStringTag](): string {\n    return 'PipelineLayout';\n  }\n\n  constructor(device: Device, props: PipelineLayoutProps) {\n    super(device, props, PipelineLayout.defaultProps);\n  }\n\n  static override defaultProps: Required<PipelineLayoutProps> = {\n    ...Resource.defaultProps,\n    shaderLayout: {\n      attributes: [],\n      bindings: []\n    }\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderUniformType, ShaderDataType} from './shader-types';\n\nconst UNIFORM_FORMATS: Record<ShaderUniformType, {type: ShaderDataType; components: number}> = {\n  f32: {type: 'f32', components: 1},\n  i32: {type: 'i32', components: 1},\n  u32: {type: 'u32', components: 1},\n  // 'bool-webgl': {type: 'bool-webgl', components: 1},\n  'vec2<f32>': {type: 'f32', components: 2},\n  'vec3<f32>': {type: 'f32', components: 3},\n  'vec4<f32>': {type: 'f32', components: 4},\n  'vec2<i32>': {type: 'i32', components: 2},\n  'vec3<i32>': {type: 'i32', components: 3},\n  'vec4<i32>': {type: 'i32', components: 4},\n  'vec2<u32>': {type: 'u32', components: 2},\n  'vec3<u32>': {type: 'u32', components: 3},\n  'vec4<u32>': {type: 'u32', components: 4},\n  'mat2x2<f32>': {type: 'f32', components: 4},\n  'mat2x3<f32>': {type: 'f32', components: 6},\n  'mat2x4<f32>': {type: 'f32', components: 8},\n  'mat3x2<f32>': {type: 'f32', components: 6},\n  'mat3x3<f32>': {type: 'f32', components: 9},\n  'mat3x4<f32>': {type: 'f32', components: 12},\n  'mat4x2<f32>': {type: 'f32', components: 8},\n  'mat4x3<f32>': {type: 'f32', components: 12},\n  'mat4x4<f32>': {type: 'f32', components: 16}\n};\n\n/** Split a uniform type string into type and components */\nexport function decodeShaderUniformType(format: ShaderUniformType): {\n  type: ShaderDataType;\n  components: number;\n} {\n  const decoded = UNIFORM_FORMATS[format];\n  return decoded;\n}\n\n/** Align offset to 1, 2 or 4 elements (4, 8 or 16 bytes) */\nexport function alignTo(size: number, count: number): number {\n  // prettier-ignore\n  switch (count) {\n    case 1: return size; // Pad upwards to even multiple of 2\n    case 2: return size + (size % 2); // Pad upwards to even multiple of 2\n    default: return size + ((4 - (size % 4)) % 4); // Pad upwards to even multiple of 4\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TypedArray} from '../types';\n\nlet arrayBuffer: ArrayBuffer;\n\nexport function getScratchArrayBuffer(byteLength: number): ArrayBuffer {\n  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {\n    arrayBuffer = new ArrayBuffer(byteLength);\n  }\n  return arrayBuffer;\n}\n\nexport function getScratchArray(Type: any, length: number): TypedArray {\n  const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);\n  return new Type(scratchArrayBuffer, 0, length); // arrayBuffer, byteOffset, length (in elements)\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TypedArray, NumberArray} from '../types';\n\n/**\n * Check is an array is a typed array\n * @param value value to be tested\n * @returns input as TypedArray, or null\n * @todo this should be provided by @math.gl/types\n */\nexport function isTypedArray(value: unknown): value is TypedArray {\n  return ArrayBuffer.isView(value) && !(value instanceof DataView);\n}\n\n/**\n * Check is an array is a numeric array (typed array or array of numbers)\n * @param value value to be tested\n * @returns input as NumberArray, or null\n * @todo this should be provided by @math.gl/types\n */\nexport function isNumberArray(value: unknown): value is NumberArray {\n  if (Array.isArray(value)) {\n    return value.length === 0 || typeof value[0] === 'number';\n  }\n  return isTypedArray(value);\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderUniformType, ShaderDataType} from '../gpu-type-utils/shader-types';\nimport {decodeShaderUniformType, alignTo} from '../gpu-type-utils/decode-shader-types';\n\nimport type {UniformValue} from '../adapter/types/uniforms';\nimport {getScratchArrayBuffer} from '../utils/array-utils-flat';\nimport {isNumberArray} from '../utils/is-array';\nimport {log} from '../utils/log';\n\n/**\n * Smallest buffer size that can be used for uniform buffers.\n * TODO - does this depend on device?\n */\nconst minBufferSize: number = 1024;\n\n/**\n * Std140 layout for uniform buffers\n * Supports manual listing of uniforms\n */\nexport class UniformBufferLayout {\n  readonly layout: Record<string, {offset: number; size: number; type: ShaderDataType}> = {};\n\n  /** number of bytes needed for buffer allocation */\n  readonly byteLength: number;\n\n  /** Create a new UniformBufferLayout given a map of attributes. */\n  constructor(uniformTypes: Record<string, ShaderUniformType>) {\n    /** number of 4 byte slots taken */\n    let size: number = 0;\n\n    // Add layout (type, size and offset) definitions for each uniform in the layout\n    for (const [key, uniformType] of Object.entries(uniformTypes)) {\n      const typeAndComponents = decodeShaderUniformType(uniformType);\n      const {type, components: count} = typeAndComponents;\n      // First, align (bump) current offset to an even multiple of current object (1, 2, 4)\n      size = alignTo(size, count);\n      // Use the aligned size as the offset of the current uniform.\n      const offset = size;\n      // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset\n      size += count;\n      this.layout[key] = {type, size: count, offset};\n    }\n    size += (4 - (size % 4)) % 4;\n\n    const actualByteLength = size * 4;\n    this.byteLength = Math.max(actualByteLength, minBufferSize);\n  }\n\n  /** Get the data for the complete buffer */\n  getData(uniformValues: Record<string, UniformValue>): Uint8Array {\n    const bufferSize = Math.max(this.byteLength, minBufferSize);\n\n    // Allocate three typed arrays pointing at same memory\n    const arrayBuffer = getScratchArrayBuffer(bufferSize);\n    const typedArrays = {\n      i32: new Int32Array(arrayBuffer),\n      u32: new Uint32Array(arrayBuffer),\n      f32: new Float32Array(arrayBuffer),\n      // TODO not implemented\n      f16: new Uint16Array(arrayBuffer)\n    };\n    // TODO is this needed?\n    // typedArrays.i32.fill(0);\n\n    for (const [name, value] of Object.entries(uniformValues)) {\n      const uniformLayout = this.layout[name];\n      if (!uniformLayout) {\n        log.warn(`Supplied uniform value ${name} not present in uniform block layout`)();\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      const {type, size, offset} = uniformLayout;\n      const typedArray = typedArrays[type];\n      if (size === 1) {\n        if (typeof value !== 'number' && typeof value !== 'boolean') {\n          log.warn(\n            `Supplied value for single component uniform ${name} is not a number: ${value}`\n          )();\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // single value -> just set it\n        typedArray[offset] = Number(value);\n      } else {\n        if (!isNumberArray(value)) {\n          log.warn(\n            `Supplied value for multi component / array uniform ${name} is not a numeric array: ${value}`\n          )();\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // vector/matrix -> copy the supplied (typed) array, starting from offset\n        // TODO: we should limit or check size in case the supplied data overflows\n        typedArray.set(value, offset);\n      }\n    }\n\n    return new Uint8Array(arrayBuffer);\n  }\n\n  /** Does this layout have a field with specified name */\n  has(name: string) {\n    return Boolean(this.layout[name]);\n  }\n\n  /** Get offset and size for a field with specified name */\n  get(name: string): {offset: number; size: number} | undefined {\n    const layout = this.layout[name];\n    return layout;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {isNumberArray} from './is-array';\n\n/** Test if two arrays are deep equal, with a length limit that defaults to 16 */\nexport function arrayEqual(a: unknown, b: unknown, limit: number = 16) {\n  if (a !== b) {\n    return false;\n  }\n  const arrayA = a;\n  const arrayB = b;\n  if (!isNumberArray(arrayA)) {\n    return false;\n  }\n  if (isNumberArray(arrayB) && arrayA.length === arrayB.length) {\n    for (let i = 0; i < arrayA.length; ++i) {\n      if (arrayB[i] !== arrayA[i]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/** Copy a value */\nexport function arrayCopy<T>(a: T): T {\n  if (isNumberArray(a)) {\n    return a.slice() as T;\n  }\n  return a;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderUniformType} from '../gpu-type-utils/shader-types';\nimport type {UniformValue} from '../adapter/types/uniforms';\nimport {\n  ShaderLayout,\n  UniformInfo,\n  UniformBufferBindingLayout\n} from '../adapter/types/shader-layout';\nimport {arrayEqual, arrayCopy} from '../utils/array-equal';\n\n/**\n * A uniform block holds values of the of uniform values for one uniform block / buffer.\n * It also does some book keeping on what has changed, to minimize unnecessary writes to uniform buffers.\n */\nexport class UniformBlock<\n  TUniforms extends Record<string, UniformValue> = Record<string, UniformValue>\n> {\n  name: string;\n\n  uniforms: Record<keyof TUniforms, UniformValue> = {} as Record<keyof TUniforms, UniformValue>;\n  modifiedUniforms: Record<keyof TUniforms, boolean> = {} as Record<keyof TUniforms, boolean>;\n  modified: boolean = true;\n\n  readonly bindingLayout: Record<string, UniformInfo> = {};\n  needsRedraw: string | false = 'initialized';\n\n  constructor(props?: {\n    name?: string;\n    shaderLayout?: ShaderLayout;\n    uniformTypes?: Record<keyof TUniforms, Record<string, ShaderUniformType>>;\n  }) {\n    this.name = props?.name || 'unnamed';\n\n    // TODO - Extract uniform layout from the shaderLayout object\n    if (props?.name && props?.shaderLayout) {\n      const binding = props?.shaderLayout.bindings?.find(\n        binding_ => binding_.type === 'uniform' && binding_.name === props?.name\n      );\n      if (!binding) {\n        throw new Error(props?.name);\n      }\n\n      const uniformBlock = binding as UniformBufferBindingLayout;\n      for (const uniform of uniformBlock.uniforms || []) {\n        this.bindingLayout[uniform.name] = uniform;\n      }\n    }\n  }\n\n  /** Set a map of uniforms */\n  setUniforms(uniforms: Partial<TUniforms>): void {\n    for (const [key, value] of Object.entries(uniforms)) {\n      this._setUniform(key, value);\n      if (!this.needsRedraw) {\n        this.setNeedsRedraw(`${this.name}.${key}=${value}`);\n      }\n    }\n  }\n\n  setNeedsRedraw(reason: string): void {\n    this.needsRedraw = this.needsRedraw || reason;\n  }\n\n  /** Returns all uniforms */\n  getAllUniforms(): Record<string, UniformValue> {\n    // @ts-expect-error\n    this.modifiedUniforms = {};\n    this.needsRedraw = false;\n    return (this.uniforms || {}) as Record<string, UniformValue>;\n  }\n\n  /** Set a single uniform */\n  private _setUniform(key: keyof TUniforms, value: UniformValue) {\n    if (arrayEqual(this.uniforms[key], value)) {\n      return;\n    }\n    this.uniforms[key] = arrayCopy(value);\n    this.modifiedUniforms[key] = true;\n    this.modified = true;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderUniformType} from '../gpu-type-utils/shader-types';\nimport type {UniformValue} from '../adapter/types/uniforms';\nimport type {Device} from '../adapter/device';\nimport {Buffer} from '../adapter/resources/buffer';\nimport {log} from '../utils/log';\nimport {UniformBlock} from './uniform-block';\nimport {UniformBufferLayout} from './uniform-buffer-layout';\n\n/**\n * A uniform store holds a uniform values for one or more uniform blocks,\n * - It can generate binary data for any uniform buffer\n * - It can manage a uniform buffer for each block\n * - It can update managed uniform buffers with a single call\n * - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.\n */\nexport class UniformStore<\n  TPropGroups extends Record<string, Record<string, unknown>> = Record<\n    string,\n    Record<string, unknown>\n  >\n> {\n  /** Stores the uniform values for each uniform block */\n  uniformBlocks = new Map<keyof TPropGroups, UniformBlock>();\n  /** Can generate data for a uniform buffer for each block from data */\n  uniformBufferLayouts = new Map<keyof TPropGroups, UniformBufferLayout>();\n  /** Actual buffer for the blocks */\n  uniformBuffers = new Map<keyof TPropGroups, Buffer>();\n\n  /**\n   * Create a new UniformStore instance\n   * @param blocks\n   */\n  constructor(\n    blocks: Record<\n      keyof TPropGroups,\n      {\n        uniformTypes?: Record<string, ShaderUniformType>;\n        defaultProps?: Record<string, unknown>;\n        defaultUniforms?: Record<string, UniformValue>;\n      }\n    >\n  ) {\n    for (const [bufferName, block] of Object.entries(blocks)) {\n      const uniformBufferName = bufferName as keyof TPropGroups;\n\n      // Create a layout object to help us generate correctly formatted binary uniform buffers\n      const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes || {});\n      this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);\n\n      // Create a Uniform block to store the uniforms for each buffer.\n      const uniformBlock = new UniformBlock({name: bufferName});\n      uniformBlock.setUniforms(block.defaultUniforms || {});\n      this.uniformBlocks.set(uniformBufferName, uniformBlock);\n    }\n  }\n\n  /** Destroy any managed uniform buffers */\n  destroy(): void {\n    for (const uniformBuffer of this.uniformBuffers.values()) {\n      uniformBuffer.destroy();\n    }\n  }\n\n  /**\n   * Set uniforms\n   * Makes all properties partial\n   */\n  setUniforms(\n    uniforms: Partial<{[group in keyof TPropGroups]: Partial<TPropGroups[group]>}>\n  ): void {\n    for (const [blockName, uniformValues] of Object.entries(uniforms)) {\n      this.uniformBlocks.get(blockName)?.setUniforms(uniformValues);\n      // We leverage logging in updateUniformBuffers(), even though slightly less efficient\n      // this.updateUniformBuffer(blockName);\n    }\n\n    this.updateUniformBuffers();\n  }\n\n  /** Get the required minimum length of the uniform buffer */\n  getUniformBufferByteLength(uniformBufferName: keyof TPropGroups): number {\n    return this.uniformBufferLayouts.get(uniformBufferName)?.byteLength || 0;\n  }\n\n  /** Get formatted binary memory that can be uploaded to a buffer */\n  getUniformBufferData(uniformBufferName: keyof TPropGroups): Uint8Array {\n    const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms() || {};\n    // @ts-ignore\n    return this.uniformBufferLayouts.get(uniformBufferName)?.getData(uniformValues);\n  }\n\n  /**\n   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)\n   * The new buffer is initialized with current / supplied values\n   */\n  createUniformBuffer(\n    device: Device,\n    uniformBufferName: keyof TPropGroups,\n    uniforms?: Partial<{[group in keyof TPropGroups]: Partial<TPropGroups[group]>}>\n  ): Buffer {\n    if (uniforms) {\n      this.setUniforms(uniforms);\n    }\n    const byteLength = this.getUniformBufferByteLength(uniformBufferName);\n    const uniformBuffer = device.createBuffer({\n      usage: Buffer.UNIFORM | Buffer.COPY_DST,\n      byteLength\n    });\n    // Note that this clears the needs redraw flag\n    const uniformBufferData = this.getUniformBufferData(uniformBufferName);\n    uniformBuffer.write(uniformBufferData);\n    return uniformBuffer;\n  }\n\n  /** Get the managed uniform buffer. \"managed\" resources are destroyed when the uniformStore is destroyed. */\n  getManagedUniformBuffer(device: Device, uniformBufferName: keyof TPropGroups): Buffer {\n    if (!this.uniformBuffers.get(uniformBufferName)) {\n      const byteLength = this.getUniformBufferByteLength(uniformBufferName);\n      const uniformBuffer = device.createBuffer({\n        usage: Buffer.UNIFORM | Buffer.COPY_DST,\n        byteLength\n      });\n      this.uniformBuffers.set(uniformBufferName, uniformBuffer);\n    }\n    // this.updateUniformBuffers();\n    // @ts-ignore\n    return this.uniformBuffers.get(uniformBufferName);\n  }\n\n  /** Updates all uniform buffers where values have changed */\n  updateUniformBuffers(): false | string {\n    let reason: false | string = false;\n    for (const uniformBufferName of this.uniformBlocks.keys()) {\n      const bufferReason = this.updateUniformBuffer(uniformBufferName);\n      reason ||= bufferReason;\n    }\n    if (reason) {\n      log.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();\n    }\n    return reason;\n  }\n\n  /** Update one uniform buffer. Only updates if values have changed */\n  updateUniformBuffer(uniformBufferName: keyof TPropGroups): false | string {\n    const uniformBlock = this.uniformBlocks.get(uniformBufferName);\n    let uniformBuffer = this.uniformBuffers.get(uniformBufferName);\n\n    let reason: false | string = false;\n    if (uniformBuffer && uniformBlock?.needsRedraw) {\n      reason ||= uniformBlock.needsRedraw;\n      // This clears the needs redraw flag\n      const uniformBufferData = this.getUniformBufferData(uniformBufferName);\n\n      uniformBuffer = this.uniformBuffers.get(uniformBufferName);\n      uniformBuffer?.write(uniformBufferData);\n\n      // logging - TODO - don't query the values unnecessarily\n      const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms();\n      log.log(\n        4,\n        `Writing to uniform buffer ${String(uniformBufferName)}`,\n        uniformBufferData,\n        uniformValues\n      )();\n    }\n    return reason;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TypedArray, TypedArrayConstructor} from '../types';\nimport {VertexFormat} from './vertex-formats';\n\n// import {DataType} from '../types/vertex-formats';\n// type Omit<DataType, 'float16'> unfortunately breaks Typescript inferance\ntype DataType = 'uint8' | 'sint8' | 'uint16' | 'sint16' | 'uint32' | 'sint32' | 'float32';\ntype DataTypeNorm = 'unorm8' | 'snorm8' | 'unorm16' | 'snorm16';\n\nexport function getDataTypeFromTypedArray(\n  arrayOrType: TypedArray | TypedArrayConstructor\n): DataType {\n  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n  switch (type) {\n    case Float32Array:\n      return 'float32';\n    case Uint16Array:\n      return 'uint16';\n    case Uint32Array:\n      return 'uint32';\n    case Uint8Array:\n    case Uint8ClampedArray:\n      return 'uint8';\n    case Int8Array:\n      return 'sint8';\n    case Int16Array:\n      return 'sint16';\n    case Int32Array:\n      return 'sint32';\n    default:\n      // Failed to deduce data type from typed array\n      throw new Error(type.constructor.name);\n  }\n}\n\nexport function getTypedArrayFromDataType(\n  dataType: DataType | DataTypeNorm\n): TypedArrayConstructor {\n  switch (dataType) {\n    case 'float32':\n      return Float32Array;\n    case 'uint32':\n      return Uint32Array;\n    case 'sint32':\n      return Int32Array;\n    case 'uint16':\n    case 'unorm16':\n      return Uint16Array;\n    case 'sint16':\n    case 'snorm16':\n      return Int16Array;\n    case 'uint8':\n    case 'unorm8':\n      return Uint8Array;\n    case 'sint8':\n    case 'snorm8':\n      return Int8Array;\n    default:\n      // Failed to deduce typed array from data type\n      throw new Error(dataType);\n  }\n}\n\n/** Get the vertex format for an attribute with TypedArray and size */\nexport function getVertexFormatFromAttribute(\n  typedArray: TypedArray,\n  size: number,\n  normalized?: boolean\n): VertexFormat {\n  if (!size || size > 4) {\n    throw new Error(`size ${size}`);\n  }\n\n  const components = size as 1 | 2 | 3 | 4;\n  let dataType: DataType | DataTypeNorm = getDataTypeFromTypedArray(typedArray);\n\n  // TODO - Special cases for WebGL (not supported on WebGPU), overrides the check below\n  if (dataType === 'uint8' && normalized && components === 1) {\n    return 'unorm8-webgl';\n  }\n  if (dataType === 'uint8' && normalized && components === 3) {\n    return 'unorm8x3-webgl';\n  }\n\n  if (dataType === 'uint8' || dataType === 'sint8') {\n    if (components === 1 || components === 3) {\n      // WebGPU 8 bit formats must be aligned to 16 bit boundaries');\n      throw new Error(`size: ${size}`);\n    }\n    if (normalized) {\n      dataType = dataType.replace('int', 'norm') as 'unorm8' | 'snorm8';\n    }\n    return `${dataType}x${components}`;\n  }\n  if (dataType === 'uint16' || dataType === 'sint16') {\n    if (components === 1 || components === 3) {\n      // WebGPU 16 bit formats must be aligned to 32 bit boundaries\n      throw new Error(`size: ${size}`);\n    }\n    if (normalized) {\n      dataType = dataType.replace('int', 'norm') as 'unorm16' | 'snorm16';\n    }\n    return `${dataType}x${components}`;\n  }\n\n  if (components === 1) {\n    return dataType;\n  }\n\n  return `${dataType}x${components}`;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {BufferLayout} from '../adapter/types/buffer-layout';\nimport {log} from '../utils/log';\n\n/** BufferLayoutHelper is a helper class that should not be used directly by applications */\nexport class BufferLayoutHelper {\n  bufferLayouts: BufferLayout[];\n\n  constructor(bufferLayouts: BufferLayout[]) {\n    this.bufferLayouts = bufferLayouts;\n  }\n\n  getBufferLayout(name: string): BufferLayout | null {\n    return this.bufferLayouts.find(layout => layout.name === name) || null;\n  }\n\n  /** Get attribute names from a BufferLayout */\n  getAttributeNamesForBuffer(bufferLayout: BufferLayout): string[] {\n    return bufferLayout.attributes\n      ? bufferLayout.attributes?.map(layout => layout.attribute)\n      : [bufferLayout.name];\n  }\n\n  mergeBufferLayouts(\n    bufferLayouts1: BufferLayout[],\n    bufferLayouts2: BufferLayout[]\n  ): BufferLayout[] {\n    const mergedLayouts = [...bufferLayouts1];\n    for (const attribute of bufferLayouts2) {\n      const index = mergedLayouts.findIndex(attribute2 => attribute2.name === attribute.name);\n      if (index < 0) {\n        mergedLayouts.push(attribute);\n      } else {\n        mergedLayouts[index] = attribute;\n      }\n    }\n    return mergedLayouts;\n  }\n\n  getBufferIndex(bufferName: string): number {\n    const bufferIndex = this.bufferLayouts.findIndex(layout => layout.name === bufferName);\n\n    if (bufferIndex === -1) {\n      log.warn(`BufferLayout: Missing buffer for \"${bufferName}\".`)();\n    }\n\n    return bufferIndex;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {BufferLayout} from '../adapter/types/buffer-layout';\nimport {ShaderLayout} from '../adapter/types/shader-layout';\n\nexport function sortedBufferLayoutByShaderSourceLocations(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[]\n): BufferLayout[] {\n  const shaderLayoutMap = Object.fromEntries(\n    shaderLayout.attributes.map(attr => [attr.name, attr.location])\n  );\n\n  const sortedLayout = bufferLayout.slice();\n  sortedLayout.sort((a, b) => {\n    const attributeNamesA = a.attributes ? a.attributes.map(attr => attr.attribute) : [a.name];\n    const attributeNamesB = b.attributes ? b.attributes.map(attr => attr.attribute) : [b.name];\n    const minLocationA = Math.min(...attributeNamesA.map(name => shaderLayoutMap[name]));\n    const minLocationB = Math.min(...attributeNamesB.map(name => shaderLayoutMap[name]));\n\n    return minLocationA - minLocationB;\n  });\n\n  return sortedLayout;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* global window, setTimeout, clearTimeout */\n\n/** Node.js polyfill for requestAnimationFrame */\n// / <reference types=\"@types/node\" />\nexport function requestAnimationFramePolyfill(callback: (time?: any) => void): any {\n  return typeof window !== 'undefined' && window.requestAnimationFrame\n    ? window.requestAnimationFrame(callback)\n    : setTimeout(callback, 1000 / 60);\n}\n\n/** Node.js polyfill for cancelAnimationFrame */\nexport function cancelAnimationFramePolyfill(timerId: any): void {\n  return typeof window !== 'undefined' && window.cancelAnimationFrame\n    ? window.cancelAnimationFrame(timerId)\n    : clearTimeout(timerId);\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {luma, Device} from '@luma.gl/core';\nimport {\n  requestAnimationFramePolyfill,\n  cancelAnimationFramePolyfill\n} from './request-animation-frame';\nimport {Timeline} from '../animation/timeline';\nimport {AnimationProps} from './animation-props';\nimport {Stats, Stat} from '@probe.gl/stats';\n\nlet statIdCounter = 0;\n\n/** AnimationLoop properties */\nexport type AnimationLoopProps = {\n  device: Device | Promise<Device>;\n\n  onAddHTML?: (div: HTMLDivElement) => string; // innerHTML\n  onInitialize?: (animationProps: AnimationProps) => Promise<unknown>;\n  onRender?: (animationProps: AnimationProps) => unknown;\n  onFinalize?: (animationProps: AnimationProps) => void;\n  onError?: (reason: Error) => void;\n\n  stats?: Stats;\n\n  // view parameters - TODO move to CanvasContext?\n  autoResizeViewport?: boolean;\n  autoResizeDrawingBuffer?: boolean;\n  useDevicePixels?: number | boolean;\n};\n\nexport type MutableAnimationLoopProps = {\n  // view parameters\n  autoResizeViewport?: boolean;\n  autoResizeDrawingBuffer?: boolean;\n  useDevicePixels?: number | boolean;\n};\n\nconst DEFAULT_ANIMATION_LOOP_PROPS: Required<AnimationLoopProps> = {\n  device: null!,\n\n  onAddHTML: () => '',\n  onInitialize: async () => {\n    return null;\n  },\n  onRender: () => {},\n  onFinalize: () => {},\n  onError: error => console.error(error), // eslint-disable-line no-console\n\n  stats: luma.stats.get(`animation-loop-${statIdCounter++}`),\n\n  // view parameters\n  useDevicePixels: true,\n  autoResizeViewport: false,\n  autoResizeDrawingBuffer: false\n};\n\n/** Convenient animation loop */\nexport class AnimationLoop {\n  device: Device | null = null;\n  canvas: HTMLCanvasElement | OffscreenCanvas | null = null;\n\n  props: Required<AnimationLoopProps>;\n  animationProps: AnimationProps | null = null;\n  timeline: Timeline | null = null;\n  stats: Stats;\n  cpuTime: Stat;\n  gpuTime: Stat;\n  frameRate: Stat;\n\n  display: any;\n\n  needsRedraw: string | false = 'initialized';\n\n  _initialized: boolean = false;\n  _running: boolean = false;\n  _animationFrameId: any = null;\n  _nextFramePromise: Promise<AnimationLoop> | null = null;\n  _resolveNextFrame: ((animationLoop: AnimationLoop) => void) | null = null;\n  _cpuStartTime: number = 0;\n  _error: Error | null = null;\n\n  // _gpuTimeQuery: Query | null = null;\n\n  /*\n   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context\n   */\n  constructor(props: AnimationLoopProps) {\n    this.props = {...DEFAULT_ANIMATION_LOOP_PROPS, ...props};\n    props = this.props;\n\n    if (!props.device) {\n      throw new Error('No device provided');\n    }\n\n    const {useDevicePixels = true} = this.props;\n\n    // state\n    this.stats = props.stats || new Stats({id: 'animation-loop-stats'});\n    this.cpuTime = this.stats.get('CPU Time');\n    this.gpuTime = this.stats.get('GPU Time');\n    this.frameRate = this.stats.get('Frame Rate');\n\n    this.setProps({\n      autoResizeViewport: props.autoResizeViewport,\n      autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,\n      useDevicePixels\n    });\n\n    // Bind methods\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n\n    this._onMousemove = this._onMousemove.bind(this);\n    this._onMouseleave = this._onMouseleave.bind(this);\n  }\n\n  destroy(): void {\n    this.stop();\n    this._setDisplay(null);\n  }\n\n  /** @deprecated Use .destroy() */\n  delete(): void {\n    this.destroy();\n  }\n\n  setError(error: Error): void {\n    this.props.onError(error);\n    this._error = Error();\n    const canvas = this.device?.canvasContext?.canvas;\n    if (canvas instanceof HTMLCanvasElement) {\n      const errorDiv = document.createElement('h1');\n      errorDiv.innerHTML = error.message;\n      errorDiv.style.position = 'absolute';\n      errorDiv.style.top = '20%'; // left: 50%; transform: translate(-50%, -50%);';\n      errorDiv.style.left = '10px';\n      errorDiv.style.color = 'black';\n      errorDiv.style.backgroundColor = 'red';\n      document.body.appendChild(errorDiv);\n      // canvas.style.position = 'absolute';\n    }\n  }\n\n  /** Flags this animation loop as needing redraw */\n  setNeedsRedraw(reason: string): this {\n    this.needsRedraw = this.needsRedraw || reason;\n    return this;\n  }\n\n  /** TODO - move these props to CanvasContext? */\n  setProps(props: MutableAnimationLoopProps): this {\n    if ('autoResizeViewport' in props) {\n      this.props.autoResizeViewport = props.autoResizeViewport || false;\n    }\n    if ('autoResizeDrawingBuffer' in props) {\n      this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;\n    }\n    if ('useDevicePixels' in props) {\n      this.props.useDevicePixels = props.useDevicePixels || false;\n    }\n    return this;\n  }\n\n  /** Starts a render loop if not already running */\n  async start() {\n    if (this._running) {\n      return this;\n    }\n    this._running = true;\n\n    try {\n      let appContext;\n      if (!this._initialized) {\n        this._initialized = true;\n        // Create the WebGL context\n        await this._initDevice();\n        this._initialize();\n\n        // Note: onIntialize can return a promise (e.g. in case app needs to load resources)\n        await this.props.onInitialize(this._getAnimationProps());\n      }\n\n      // check that we haven't been stopped\n      if (!this._running) {\n        return null;\n      }\n\n      // Start the loop\n      if (appContext !== false) {\n        // cancel any pending renders to ensure only one loop can ever run\n        this._cancelAnimationFrame();\n        this._requestAnimationFrame();\n      }\n\n      return this;\n    } catch (err: unknown) {\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.props.onError(error);\n      // this._running = false; // TODO\n      throw error;\n    }\n  }\n\n  /** Stops a render loop if already running, finalizing */\n  stop() {\n    // console.debug(`Stopping ${this.constructor.name}`);\n    if (this._running) {\n      // call callback\n      // If stop is called immediately, we can end up in a state where props haven't been initialized...\n      if (this.animationProps && !this._error) {\n        this.props.onFinalize(this.animationProps);\n      }\n\n      this._cancelAnimationFrame();\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n      this._running = false;\n    }\n    return this;\n  }\n\n  /** Explicitly draw a frame */\n  redraw(): this {\n    if (this.device?.isLost || this._error) {\n      return this;\n    }\n\n    this._beginFrameTimers();\n\n    this._setupFrame();\n    this._updateAnimationProps();\n\n    this._renderFrame(this._getAnimationProps());\n\n    // clear needsRedraw flag\n    this._clearNeedsRedraw();\n\n    if (this._resolveNextFrame) {\n      this._resolveNextFrame(this);\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n    }\n\n    this._endFrameTimers();\n\n    return this;\n  }\n\n  /** Add a timeline, it will be automatically updated by the animation loop. */\n  attachTimeline(timeline: Timeline): Timeline {\n    this.timeline = timeline;\n    return this.timeline;\n  }\n\n  /** Remove a timeline */\n  detachTimeline(): void {\n    this.timeline = null;\n  }\n\n  /** Wait until a render completes */\n  waitForRender(): Promise<AnimationLoop> {\n    this.setNeedsRedraw('waitForRender');\n\n    if (!this._nextFramePromise) {\n      this._nextFramePromise = new Promise(resolve => {\n        this._resolveNextFrame = resolve;\n      });\n    }\n    return this._nextFramePromise;\n  }\n\n  /** TODO - should use device.deviceContext */\n  async toDataURL(): Promise<string> {\n    this.setNeedsRedraw('toDataURL');\n    await this.waitForRender();\n    if (this.canvas instanceof HTMLCanvasElement) {\n      return this.canvas.toDataURL();\n    }\n    throw new Error('OffscreenCanvas');\n  }\n\n  // PRIVATE METHODS\n\n  _initialize(): void {\n    this._startEventHandling();\n\n    // Initialize the callback data\n    this._initializeAnimationProps();\n    this._updateAnimationProps();\n\n    // Default viewport setup, in case onInitialize wants to render\n    this._resizeCanvasDrawingBuffer();\n    this._resizeViewport();\n\n    // this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;\n  }\n\n  _setDisplay(display: any): void {\n    if (this.display) {\n      this.display.destroy();\n      this.display.animationLoop = null;\n    }\n\n    // store animation loop on the display\n    if (display) {\n      display.animationLoop = this;\n    }\n\n    this.display = display;\n  }\n\n  _requestAnimationFrame(): void {\n    if (!this._running) {\n      return;\n    }\n\n    // VR display has a separate animation frame to sync with headset\n    // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/\n    // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame\n    // if (this.display && this.display.requestAnimationFrame) {\n    //   this._animationFrameId = this.display.requestAnimationFrame(this._animationFrame.bind(this));\n    // }\n    this._animationFrameId = requestAnimationFramePolyfill(this._animationFrame.bind(this));\n  }\n\n  _cancelAnimationFrame(): void {\n    if (this._animationFrameId === null) {\n      return;\n    }\n\n    // VR display has a separate animation frame to sync with headset\n    // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/\n    // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame\n    // if (this.display && this.display.cancelAnimationFramePolyfill) {\n    //   this.display.cancelAnimationFrame(this._animationFrameId);\n    // }\n    cancelAnimationFramePolyfill(this._animationFrameId);\n    this._animationFrameId = null;\n  }\n\n  _animationFrame(): void {\n    if (!this._running) {\n      return;\n    }\n    this.redraw();\n    this._requestAnimationFrame();\n  }\n\n  // Called on each frame, can be overridden to call onRender multiple times\n  // to support e.g. stereoscopic rendering\n  _renderFrame(animationProps: AnimationProps): void {\n    // Allow e.g. VR display to render multiple frames.\n    if (this.display) {\n      this.display._renderFrame(animationProps);\n      return;\n    }\n\n    // call callback\n    this.props.onRender(this._getAnimationProps());\n    // end callback\n\n    // Submit commands (necessary on WebGPU)\n    this.device?.submit();\n  }\n\n  _clearNeedsRedraw(): void {\n    this.needsRedraw = false;\n  }\n\n  _setupFrame(): void {\n    this._resizeCanvasDrawingBuffer();\n    this._resizeViewport();\n  }\n\n  // Initialize the  object that will be passed to app callbacks\n  _initializeAnimationProps(): void {\n    const canvas = this.device?.canvasContext?.canvas;\n\n    if (!this.device || !canvas) {\n      throw new Error('loop');\n    }\n    this.animationProps = {\n      animationLoop: this,\n\n      device: this.device,\n      canvas,\n      timeline: this.timeline,\n\n      // Initial values\n      useDevicePixels: this.props.useDevicePixels,\n      needsRedraw: false,\n\n      // Placeholders\n      width: 1,\n      height: 1,\n      aspect: 1,\n\n      // Animation props\n      time: 0,\n      startTime: Date.now(),\n      engineTime: 0,\n      tick: 0,\n      tock: 0,\n\n      // Experimental\n      _mousePosition: null // Event props\n    };\n  }\n\n  _getAnimationProps(): AnimationProps {\n    if (!this.animationProps) {\n      throw new Error('animationProps');\n    }\n    return this.animationProps;\n  }\n\n  // Update the context object that will be passed to app callbacks\n  _updateAnimationProps(): void {\n    if (!this.animationProps) {\n      return;\n    }\n\n    // Can this be replaced with canvas context?\n    const {width, height, aspect} = this._getSizeAndAspect();\n    if (width !== this.animationProps.width || height !== this.animationProps.height) {\n      this.setNeedsRedraw('drawing buffer resized');\n    }\n    if (aspect !== this.animationProps.aspect) {\n      this.setNeedsRedraw('drawing buffer aspect changed');\n    }\n\n    this.animationProps.width = width;\n    this.animationProps.height = height;\n    this.animationProps.aspect = aspect;\n\n    this.animationProps.needsRedraw = this.needsRedraw;\n\n    // Update time properties\n    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n\n    if (this.timeline) {\n      this.timeline.update(this.animationProps.engineTime);\n    }\n\n    this.animationProps.tick = Math.floor((this.animationProps.time / 1000) * 60);\n    this.animationProps.tock++;\n\n    // For back compatibility\n    this.animationProps.time = this.timeline\n      ? this.timeline.getTime()\n      : this.animationProps.engineTime;\n  }\n\n  /** Wait for supplied device */\n  async _initDevice() {\n    this.device = await this.props.device;\n    if (!this.device) {\n      throw new Error('No device provided');\n    }\n    this.canvas = this.device.canvasContext?.canvas || null;\n    // this._createInfoDiv();\n  }\n\n  _createInfoDiv(): void {\n    if (this.canvas && this.props.onAddHTML) {\n      const wrapperDiv = document.createElement('div');\n      document.body.appendChild(wrapperDiv);\n      wrapperDiv.style.position = 'relative';\n      const div = document.createElement('div');\n      div.style.position = 'absolute';\n      div.style.left = '10px';\n      div.style.bottom = '10px';\n      div.style.width = '300px';\n      div.style.background = 'white';\n      if (this.canvas instanceof HTMLCanvasElement) {\n        wrapperDiv.appendChild(this.canvas);\n      }\n      wrapperDiv.appendChild(div);\n      const html = this.props.onAddHTML(div);\n      if (html) {\n        div.innerHTML = html;\n      }\n    }\n  }\n\n  _getSizeAndAspect(): {width: number; height: number; aspect: number} {\n    if (!this.device) {\n      return {width: 1, height: 1, aspect: 1};\n    }\n    // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n    const [width, height] = this.device?.canvasContext?.getPixelSize() || [1, 1];\n\n    // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html\n    let aspect = 1;\n    const canvas = this.device?.canvasContext?.canvas;\n\n    // @ts-expect-error\n    if (canvas && canvas.clientHeight) {\n      // @ts-expect-error\n      aspect = canvas.clientWidth / canvas.clientHeight;\n    } else if (width > 0 && height > 0) {\n      aspect = width / height;\n    }\n\n    return {width, height, aspect};\n  }\n\n  /** Default viewport setup */\n  _resizeViewport(): void {\n    // TODO can we use canvas context to code this in a portable way?\n    // @ts-expect-error Expose on canvasContext\n    if (this.props.autoResizeViewport && this.device.gl) {\n      // @ts-expect-error Expose canvasContext\n      this.device.gl.viewport(\n        0,\n        0,\n        // @ts-expect-error Expose canvasContext\n        this.device.gl.drawingBufferWidth,\n        // @ts-expect-error Expose canvasContext\n        this.device.gl.drawingBufferHeight\n      );\n    }\n  }\n\n  /**\n   * Resize the render buffer of the canvas to match canvas client size\n   * Optionally multiplying with devicePixel ratio\n   */\n  _resizeCanvasDrawingBuffer(): void {\n    if (this.props.autoResizeDrawingBuffer) {\n      this.device?.canvasContext?.resize({useDevicePixels: this.props.useDevicePixels});\n    }\n  }\n\n  _beginFrameTimers() {\n    this.frameRate.timeEnd();\n    this.frameRate.timeStart();\n\n    // Check if timer for last frame has completed.\n    // GPU timer results are never available in the same\n    // frame they are captured.\n    // if (\n    //   this._gpuTimeQuery &&\n    //   this._gpuTimeQuery.isResultAvailable() &&\n    //   !this._gpuTimeQuery.isTimerDisjoint()\n    // ) {\n    //   this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n    // }\n\n    // if (this._gpuTimeQuery) {\n    //   // GPU time query start\n    //   this._gpuTimeQuery.beginTimeElapsedQuery();\n    // }\n\n    this.cpuTime.timeStart();\n  }\n\n  _endFrameTimers() {\n    this.cpuTime.timeEnd();\n\n    // if (this._gpuTimeQuery) {\n    //   // GPU time query end. Results will be available on next frame.\n    //   this._gpuTimeQuery.end();\n    // }\n  }\n\n  // Event handling\n\n  _startEventHandling() {\n    if (this.canvas) {\n      this.canvas.addEventListener('mousemove', this._onMousemove.bind(this));\n      this.canvas.addEventListener('mouseleave', this._onMouseleave.bind(this));\n    }\n  }\n\n  _onMousemove(event: Event) {\n    if (event instanceof MouseEvent) {\n      this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];\n    }\n  }\n\n  _onMouseleave(event: Event) {\n    this._getAnimationProps()._mousePosition = null;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {luma, Adapter} from '@luma.gl/core';\nimport {AnimationLoopTemplate} from './animation-loop-template';\nimport {AnimationLoop, AnimationLoopProps} from './animation-loop';\nimport type {AnimationProps} from './animation-props';\n\nexport type MakeAnimationLoopProps = Omit<\n  AnimationLoopProps,\n  'onCreateDevice' | 'onInitialize' | 'onRedraw' | 'onFinalize'\n> & {\n  /** List of adapters to use when creating the device */\n  adapters?: Adapter[];\n};\n\n/** Instantiates and runs the render loop */\nexport function makeAnimationLoop(\n  AnimationLoopTemplateCtor: typeof AnimationLoopTemplate,\n  props?: MakeAnimationLoopProps\n): AnimationLoop {\n  let renderLoop: AnimationLoopTemplate | null = null;\n\n  const device =\n    props?.device ||\n    luma.createDevice({id: 'animation-loop', adapters: props?.adapters, createCanvasContext: true});\n\n  // Create an animation loop;\n  const animationLoop = new AnimationLoop({\n    ...props,\n\n    device,\n\n    async onInitialize(animationProps: AnimationProps): Promise<unknown> {\n      // @ts-expect-error abstract to prevent instantiation\n      renderLoop = new AnimationLoopTemplateCtor(animationProps);\n      // Any async loading can be handled here\n      return await renderLoop?.onInitialize(animationProps);\n    },\n\n    onRender: (animationProps: AnimationProps) => renderLoop?.onRender(animationProps),\n\n    onFinalize: (animationProps: AnimationProps) => renderLoop?.onFinalize(animationProps)\n  });\n\n  // @ts-expect-error Hack: adds info for the website to find\n  animationLoop.getInfo = () => {\n    // @ts-ignore\n    // eslint-disable-next-line no-invalid-this\n    return this.AnimationLoopTemplateCtor.info;\n  };\n\n  // Start the loop automatically\n  // animationLoop.start();\n\n  return animationLoop;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Recommendation is to ignore message but current test suite checks agains the\n// message so keep it for now.\nexport function assert(condition: unknown, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'shadertools: assertion failed.');\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {assert} from '../utils/assert';\n\n/**\n * For use by shader module and shader pass writers to describe the types of the\n * properties they expose (properties ultimately map to uniforms).\n */\nexport type PropType =\n  | {\n      type?: string;\n      value?: unknown;\n      max?: number;\n      min?: number;\n      softMax?: number;\n      softMin?: number;\n      hint?: string;\n      /** @deprecated internal uniform */\n      private?: boolean;\n    }\n  | number;\n\n/**\n * Internal property validators generated by processing the prop types ,\n * The `validate()` method can be used to validate the type of properties passed in to\n * shader module or shader pass\n */\nexport type PropValidator = {\n  type: string;\n  value?: unknown;\n  max?: number;\n  min?: number;\n  private?: boolean;\n  validate?(value: unknown, propDef: PropValidator): boolean;\n};\n\n/** Minimal validators for number and array types */\nconst DEFAULT_PROP_VALIDATORS: Record<string, PropValidator> = {\n  number: {\n    type: 'number',\n    validate(value: unknown, propType: PropType) {\n      return (\n        Number.isFinite(value) &&\n        typeof propType === 'object' &&\n        (propType.max === undefined || (value as number) <= propType.max) &&\n        (propType.min === undefined || (value as number) >= propType.min)\n      );\n    }\n  },\n  array: {\n    type: 'array',\n    validate(value: unknown, propType: PropType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n\n/**\n * Parse a list of property types into property definitions that can be used to validate\n * values passed in by applications.\n * @param propTypes\n * @returns\n */\nexport function makePropValidators(\n  propTypes: Record<string, PropType>\n): Record<string, PropValidator> {\n  const propValidators: Record<string, PropValidator> = {};\n  for (const [name, propType] of Object.entries(propTypes)) {\n    propValidators[name] = makePropValidator(propType);\n  }\n  return propValidators;\n}\n\n/**\n * Validate a map of user supplied properties against a map of validators\n * Inject default values when user doesn't supply a property\n * @param properties\n * @param propValidators\n * @returns\n */\nexport function getValidatedProperties(\n  properties: Record<string, unknown>,\n  propValidators: Record<string, PropValidator>,\n  errorMessage: string\n): Record<string, unknown> {\n  const validated: Record<string, unknown> = {};\n\n  for (const [key, propsValidator] of Object.entries(propValidators)) {\n    if (properties && key in properties && !propsValidator.private) {\n      if (propsValidator.validate) {\n        assert(\n          propsValidator.validate(properties[key], propsValidator),\n          `${errorMessage}: invalid ${key}`\n        );\n      }\n      validated[key] = properties[key];\n    } else {\n      // property not supplied - use default value\n      validated[key] = propsValidator.value;\n    }\n  }\n\n  // TODO - warn for unused properties that don't match a validator?\n\n  return validated;\n}\n\n/**\n * Creates a property validator for a prop type. Either contains:\n * - a valid prop type object ({type, ...})\n * - or just a default value, in which case type and name inference is used\n */\nfunction makePropValidator(propType: PropType): PropValidator {\n  let type = getTypeOf(propType);\n\n  if (type !== 'object') {\n    return {value: propType, ...DEFAULT_PROP_VALIDATORS[type], type};\n  }\n\n  // Special handling for objects\n  if (typeof propType === 'object') {\n    if (!propType) {\n      return {type: 'object', value: null};\n    }\n    if (propType.type !== undefined) {\n      return {...propType, ...DEFAULT_PROP_VALIDATORS[propType.type], type: propType.type};\n    }\n    // If no type and value this object is likely the value\n    if (propType.value === undefined) {\n      return {type: 'object', value: propType};\n    }\n\n    type = getTypeOf(propType.value);\n    return {...propType, ...DEFAULT_PROP_VALIDATORS[type], type};\n  }\n\n  throw new Error('props');\n}\n\n/**\n * \"improved\" version of javascript typeof that can distinguish arrays and null values\n */\nfunction getTypeOf(value: unknown): string {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const MODULE_INJECTORS_VS = /* glsl */ `\\\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n`;\n\nexport const MODULE_INJECTORS_FS = /* glsl */ `\\\n#ifdef MODULE_MATERIAL\n  fragColor = material_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  fragColor = lighting_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_FOG\n  fragColor = fog_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  fragColor = picking_filterHighlightColor(fragColor);\n  fragColor = picking_filterPickingColor(fragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../../module-injectors';\nimport {assert} from '../utils/assert';\n\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  vertex: MODULE_INJECTORS_VS,\n  fragment: MODULE_INJECTORS_FS\n};\n\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments: string[] = [];\n\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';\n\n/**\n *\n */\nexport type ShaderInjection = {\n  injection: string;\n  order: number;\n};\n\n/**\n *  ShaderInjections, parsed and split per shader\n */\nexport type ShaderInjections = {\n  vertex: Record<string, ShaderInjection>;\n  fragment: Record<string, ShaderInjection>;\n};\n\n/**\n *\n */\nexport function normalizeInjections(\n  injections: Record<string, string | ShaderInjection>\n): ShaderInjections {\n  const result: ShaderInjections = {vertex: {}, fragment: {}};\n\n  for (const hook in injections) {\n    let injection = injections[hook];\n    const stage = getHookStage(hook);\n    if (typeof injection === 'string') {\n      injection = {\n        order: 0,\n        injection\n      };\n    }\n\n    result[stage][hook] = injection;\n  }\n\n  return result;\n}\n\nfunction getHookStage(hook: string): 'vertex' | 'fragment' {\n  const type = hook.slice(0, 2);\n  switch (type) {\n    case 'vs':\n      return 'vertex';\n    case 'fs':\n      return 'fragment';\n    default:\n      throw new Error(type);\n  }\n}\n\n/**\n// A minimal shader injection/templating system.\n// RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n * @param source \n * @param type \n * @param inject \n * @param injectStandardStubs \n * @returns \n */\n// eslint-disable-next-line complexity\nexport function injectShader(\n  source: string,\n  stage: 'vertex' | 'fragment',\n  inject: Record<string, ShaderInjection[]>,\n  injectStandardStubs = false\n): string {\n  const isVertex = stage === 'vertex';\n\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a: ShaderInjection, b: ShaderInjection): number => a.order - b.order);\n    fragments.length = fragmentData.length;\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    const fragmentString = `${fragments.join('\\n')}\\n`;\n    switch (key) {\n      // declarations are injected before the main function\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // inject code at the beginning of the main function\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, (match: string) => match + fragmentString);\n        }\n        break;\n      // inject code at the end of main function\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, (match: string) => fragmentString + match);\n        }\n        break;\n      // declarations are injected before the main function\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // inject code at the beginning of the main function\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, (match: string) => match + fragmentString);\n        }\n        break;\n      // inject code at the end of main function\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, (match: string) => fragmentString + match);\n        }\n        break;\n\n      default:\n        // TODO(Tarek): I think this usage should be deprecated.\n\n        // inject code after key, leaving key in place\n        source = source.replace(key, (match: string) => match + fragmentString);\n    }\n  }\n\n  // Remove if it hasn't already been replaced\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, (match: string) => match + MODULE_INJECTORS[stage]);\n  }\n\n  return source;\n}\n\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects: any[]): Record<string, string> {\n  const result: Record<string, string> = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {UniformFormat} from '../../types';\nimport {\n  PropType,\n  PropValidator,\n  makePropValidators,\n  getValidatedProperties\n} from '../filters/prop-types';\nimport type {UniformTypes, UniformValue} from '../utils/uniform-types';\nimport {ShaderInjection, normalizeInjections} from '../shader-assembly/shader-injections';\n\n// To avoid dependency on core module, do not import `Binding` type.\n// The ShaderModule is not concerned with the type of `Binding`,\n// it is the repsonsibility of `splitUniformsAndBindings` in\n// ShaderInputs to type the result of `getUniforms()`\ntype Binding = unknown; // import type {Binding} from '@luma.gl/core';\n\nexport type UniformInfo = {\n  format?: UniformFormat;\n} & PropType;\n\n// Helper types\ntype BindingKeys<T> = {[K in keyof T]: T[K] extends UniformValue ? never : K}[keyof T];\ntype UniformKeys<T> = {[K in keyof T]: T[K] extends UniformValue ? K : never}[keyof T];\nexport type PickBindings<T> = {[K in BindingKeys<Required<T>>]: T[K]};\nexport type PickUniforms<T> = {[K in UniformKeys<Required<T>>]: T[K]};\n\n/**\n * A shader module definition object\n *\n * @note Needs to be initialized with `initializeShaderModules`\n * @note `UniformsT` & `BindingsT` are deduced from `PropsT` by default. If\n * a custom type for `UniformsT` is used, `BindingsT` should be also be provided.\n */\nexport type ShaderModule<\n  PropsT extends Record<string, any> = Record<string, any>,\n  UniformsT extends Record<string, UniformValue> = PickUniforms<PropsT>,\n  BindingsT extends Record<string, Binding> = PickBindings<PropsT>\n> = {\n  /** Used for type inference not for values */\n  props?: PropsT;\n  /** Used for type inference, not currently used for values */\n  uniforms?: UniformsT;\n  /** Used for type inference, not currently used for values */\n  bindings?: BindingsT;\n\n  name: string;\n\n  /** WGSL code */\n  source?: string;\n  /** GLSL fragment shader code */\n  fs?: string;\n  /** GLSL vertex shader code */\n  vs?: string;\n\n  /** Uniform shader types @note: Both order and types MUST match uniform block declarations in shader */\n  uniformTypes?: Required<UniformTypes<UniformsT>>; // Record<keyof UniformsT, UniformFormat>;\n  /** Uniform JS prop types  */\n  propTypes?: Record<keyof UniformsT, UniformInfo>;\n  /** Default uniform values */\n  defaultUniforms?: Required<UniformsT>; // Record<keyof UniformsT, UniformValue>;\n\n  /** Function that maps props to uniforms & bindings */\n  getUniforms?: (\n    props: Partial<PropsT>,\n    prevUniforms?: UniformsT\n  ) => Partial<UniformsT & BindingsT>;\n\n  defines?: Record<string, string | number>;\n  /** Injections */\n  inject?: Record<string, string | {injection: string; order: number}>;\n  dependencies?: ShaderModule<any, any>[];\n  /** Information on deprecated properties */\n  deprecations?: ShaderModuleDeprecation[];\n\n  /** The instance field contains information that is generated at run-time */\n  instance?: {\n    propValidators?: Record<string, PropValidator>;\n    parsedDeprecations: ShaderModuleDeprecation[];\n\n    normalizedInjections: {\n      vertex: Record<string, ShaderInjection>;\n      fragment: Record<string, ShaderInjection>;\n    };\n  };\n};\n\n/** Use to generate deprecations when shader module is used */\nexport type ShaderModuleDeprecation = {\n  type: string;\n  regex?: RegExp;\n  new: string;\n  old: string;\n  deprecated?: boolean;\n};\n\n// SHNDER MODULE API\n\nexport function initializeShaderModules(modules: ShaderModule[]): void {\n  modules.map((module: ShaderModule) => initializeShaderModule(module));\n}\n\nexport function initializeShaderModule(module: ShaderModule): void {\n  if (module.instance) {\n    return;\n  }\n\n  initializeShaderModules(module.dependencies || []);\n\n  const {\n    propTypes = {},\n    deprecations = [],\n    // defines = {},\n    inject = {}\n  } = module;\n\n  const instance: Required<ShaderModule>['instance'] = {\n    normalizedInjections: normalizeInjections(inject),\n    parsedDeprecations: parseDeprecationDefinitions(deprecations)\n  };\n\n  if (propTypes) {\n    instance.propValidators = makePropValidators(propTypes);\n  }\n\n  module.instance = instance;\n\n  // TODO(ib) - we need to apply the original prop types to the default uniforms\n  let defaultProps: ShaderModule['props'] = {};\n  if (propTypes) {\n    defaultProps = Object.entries(propTypes).reduce(\n      (obj: ShaderModule['props'], [key, propType]) => {\n        // @ts-expect-error\n        const value = propType?.value;\n        if (value) {\n          // @ts-expect-error\n          obj[key] = value;\n        }\n        return obj;\n      },\n      {} as ShaderModule['props']\n    );\n  }\n\n  module.defaultUniforms = {...module.defaultUniforms, ...defaultProps} as any;\n}\n\n/** Convert module props to uniforms */\nexport function getShaderModuleUniforms<\n  ShaderModuleT extends ShaderModule<Record<string, unknown>, Record<string, UniformValue>>\n>(\n  module: ShaderModuleT,\n  props?: ShaderModuleT['props'],\n  oldUniforms?: ShaderModuleT['uniforms']\n): Record<string, Binding | UniformValue> {\n  initializeShaderModule(module);\n\n  const uniforms = oldUniforms || {...module.defaultUniforms};\n  // If module has a getUniforms function, use it\n  if (props && module.getUniforms) {\n    return module.getUniforms(props, uniforms);\n  }\n\n  // Build uniforms from the uniforms array\n  // @ts-expect-error\n  return getValidatedProperties(props, module.instance?.propValidators, module.name);\n}\n\n/* TODO this looks like it was unused code\n  _defaultGetUniforms(opts: Record<string, any> = {}): Record<string, any> {\n    const uniforms: Record<string, any> = {};\n    const propTypes = this.uniforms;\n\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          assert(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);\n        }\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n\n    return uniforms;\n  }\n}\n*/\n// Warn about deprecated uniforms or functions\nexport function checkShaderModuleDeprecations(\n  shaderModule: ShaderModule,\n  shaderSource: string,\n  log: any\n): void {\n  shaderModule.deprecations?.forEach(def => {\n    if (def.regex?.test(shaderSource)) {\n      if (def.deprecated) {\n        log.deprecated(def.old, def.new)();\n      } else {\n        log.removed(def.old, def.new)();\n      }\n    }\n  });\n}\n\n// HELPERS\n\nfunction parseDeprecationDefinitions(deprecations: ShaderModuleDeprecation[]) {\n  deprecations.forEach(def => {\n    switch (def.type) {\n      case 'function':\n        def.regex = new RegExp(`\\\\b${def.old}\\\\(`);\n        break;\n      default:\n        def.regex = new RegExp(`${def.type} ${def.old};`);\n    }\n  });\n\n  return deprecations;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderModule, initializeShaderModules} from './shader-module';\n\n// import type {ShaderModule} from '../shader-module/shader-module';\n\ntype AbstractModule = {\n  name: string;\n  dependencies?: AbstractModule[];\n};\n\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param modules - Array of modules (inline modules or module names)\n * @return - Array of modules\n */\nexport function getShaderModuleDependencies<T extends AbstractModule>(modules: T[]): T[] {\n  initializeShaderModules(modules);\n  const moduleMap: Record<string, T> = {};\n  const moduleDepth: Record<string, number> = {};\n  getDependencyGraph({modules, level: 0, moduleMap, moduleDepth});\n\n  // Return a reverse sort so that dependencies come before the modules that use them\n  const dependencies = Object.keys(moduleDepth)\n    .sort((a, b) => moduleDepth[b] - moduleDepth[a])\n    .map(name => moduleMap[name]);\n  initializeShaderModules(dependencies);\n  return dependencies;\n}\n\n/**\n * Recursively checks module dependencies to calculate dependency level of each module.\n *\n * @param options.modules - Array of modules\n * @param options.level - Current level\n * @param options.moduleMap -\n * @param options.moduleDepth - Current level\n * @return - Map of module name to its level\n */\n// Adds another level of dependencies to the result map\nexport function getDependencyGraph<T extends AbstractModule>(options: {\n  modules: T[];\n  level: number;\n  moduleMap: Record<string, T>;\n  moduleDepth: Record<string, number>;\n}) {\n  const {modules, level, moduleMap, moduleDepth} = options;\n  if (level >= 5) {\n    throw new Error('Possible loop in shader dependency graph');\n  }\n\n  // Update level on all current modules\n  for (const module of modules) {\n    moduleMap[module.name] = module;\n    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {\n      moduleDepth[module.name] = level;\n    }\n  }\n\n  // Recurse\n  for (const module of modules) {\n    if (module.dependencies) {\n      getDependencyGraph({modules: module.dependencies, level: level + 1, moduleMap, moduleDepth});\n    }\n  }\n}\n\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param modules - Array of modules (inline modules or module names)\n * @return - Array of modules\n */\nexport function getShaderDependencies(modules: ShaderModule[]): ShaderModule[] {\n  initializeShaderModules(modules);\n  const moduleMap: Record<string, ShaderModule> = {};\n  const moduleDepth: Record<string, number> = {};\n  getDependencyGraph({modules, level: 0, moduleMap, moduleDepth});\n\n  // Return a reverse sort so that dependencies come before the modules that use them\n  modules = Object.keys(moduleDepth)\n    .sort((a, b) => moduleDepth[b] - moduleDepth[a])\n    .map(name => moduleMap[name]);\n  initializeShaderModules(modules);\n  return modules;\n}\n\n// DEPRECATED\n\n/**\n * Instantiate shader modules and resolve any dependencies\n * @deprecated Use getShaderDpendencies\n */\nexport function resolveModules(modules: ShaderModule[]): ShaderModule[] {\n  return getShaderDependencies(modules);\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {PlatformInfo} from './platform-info';\n\n/** Adds defines to help identify GPU architecture / platform */\nexport function getPlatformShaderDefines(platformInfo: PlatformInfo): string {\n  switch (platformInfo?.gpu.toLowerCase()) {\n    case 'apple':\n      return /* glsl */ `\\\n#define APPLE_GPU\n// Apple optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n\n    case 'nvidia':\n      return /* glsl */ `\\\n#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n`;\n\n    case 'intel':\n      return /* glsl */ `\\\n#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n\n    case 'amd':\n      // AMD Does not eliminate fp64 code\n      return /* glsl */ `\\\n#define AMD_GPU\n`;\n\n    default:\n      // We don't know what GPU it is, could be that the GPU driver or\n      // browser is not implementing UNMASKED_RENDERER constant and not\n      // reporting a correct name\n      return /* glsl */ `\\\n#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Headless Chrome's software shader 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// If the GPU doesn't have full 32 bits precision, will causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// TRANSPILATION TABLES\n\n/**\n * Transpiles GLSL 3.00 shader source code to target GLSL version (3.00 or 1.00)\n *\n * @note We always run transpiler even if same version e.g. 3.00 => 3.00\n * @note For texture sampling transpilation, apps need to use non-standard texture* calls in GLSL 3.00 source\n * RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\n */\nexport function transpileGLSLShader(source: string, stage: 'vertex' | 'fragment'): string {\n  const sourceGLSLVersion = Number(source.match(/^#version[ \\t]+(\\d+)/m)?.[1] || 100);\n  if (sourceGLSLVersion !== 300) {\n    // TODO - we splurge on a longer error message to help deck.gl custom layer developers\n    throw new Error('luma.gl v9 only supports GLSL 3.00 shader sources');\n  }\n\n  switch (stage) {\n    case 'vertex':\n      source = convertShader(source, ES300_VERTEX_REPLACEMENTS);\n      return source;\n    case 'fragment':\n      source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);\n      return source;\n    default:\n      // Unknown shader stage\n      throw new Error(stage);\n  }\n}\n\ntype GLSLReplacement = [RegExp, string];\n\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_REPLACEMENTS: GLSLReplacement[] = [\n  // Fix poorly formatted version directive\n  [/^(#version[ \\t]+(100|300[ \\t]+es))?[ \\t]*\\n/, '#version 300 es\\n'],\n  // The individual `texture...()` functions were replaced with `texture()` overloads\n  [/\\btexture(2D|2DProj|Cube)Lod(EXT)?\\(/g, 'textureLod('],\n  [/\\btexture(2D|2DProj|Cube)(EXT)?\\(/g, 'texture(']\n];\n\nconst ES300_VERTEX_REPLACEMENTS: GLSLReplacement[] = [\n  ...ES300_REPLACEMENTS,\n  // `attribute` keyword replaced with `in`\n  [makeVariableTextRegExp('attribute'), 'in $1'],\n  // `varying` keyword replaced with `out`\n  [makeVariableTextRegExp('varying'), 'out $1']\n];\n\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_FRAGMENT_REPLACEMENTS: GLSLReplacement[] = [\n  ...ES300_REPLACEMENTS,\n  // `varying` keyword replaced with `in`\n  [makeVariableTextRegExp('varying'), 'in $1']\n];\n\nfunction convertShader(source: string, replacements: GLSLReplacement[]) {\n  for (const [pattern, replacement] of replacements) {\n    source = source.replace(pattern, replacement);\n  }\n  return source;\n}\n\n/**\n * Creates a regexp that tests for a specific variable type\n * @example\n *   should match:\n *     in float weight;\n *     out vec4 positions[2];\n *   should not match:\n *     void f(out float a, in float b) {}\n */\nfunction makeVariableTextRegExp(qualifier: 'attribute' | 'varying' | 'in' | 'out'): RegExp {\n  return new RegExp(`\\\\b${qualifier}[ \\\\t]+(\\\\w+[ \\\\t]+\\\\w+(\\\\[\\\\w+\\\\])?;)`, 'g');\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderInjection} from './shader-injections';\n\n// A normalized hook function\n/**\n * The shader hook mechanism allows the application to create shaders\n * that can be automatically extended by the shader modules the application\n * includes.\n *\n * A shader hook function that shader modules can inject code into.\n * Shaders can call these functions, which will be no-ops by default.\n *\n * If a shader module injects code it will be executed upon the hook\n * function call.\n */\nexport type ShaderHook = {\n  /** `vs:` or `fs:` followed by the name and arguments of the function, e.g. `vs:MYHOOK_func(inout vec4 value)`. Hook name without arguments\n  will also be used as the name of the shader hook */\n  hook: string;\n  /** Code always included at the beginning of a hook function */\n  header: string;\n  /** Code always included at the end of a hook function */\n  footer: string;\n  /** To Be Documented */\n  signature?: string;\n};\n\n/** Normalized shader hooks per shader */\nexport type ShaderHooks = {\n  /** Normalized shader hooks for vertex shader */\n  vertex: Record<string, ShaderHook>;\n  /** Normalized shader hooks for fragment shader */\n  fragment: Record<string, ShaderHook>;\n};\n\n/** Generate hook source code */\nexport function getShaderHooks(\n  hookFunctions: Record<string, ShaderHook>,\n  hookInjections: Record<string, ShaderInjection[]>\n): string {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a: {order: number}, b: {order: number}): number => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n\n/**\n * Parse string based hook functions\n * And split per shader\n */\nexport function normalizeShaderHooks(hookFunctions: (string | ShaderHook)[]): ShaderHooks {\n  const result: ShaderHooks = {vertex: {}, fragment: {}};\n\n  for (const hookFunction of hookFunctions) {\n    let opts: ShaderHook;\n    let hook: string;\n    if (typeof hookFunction !== 'string') {\n      opts = hookFunction;\n      hook = opts.hook;\n    } else {\n      opts = {} as ShaderHook;\n      hook = hookFunction;\n    }\n    hook = hook.trim();\n    const [shaderStage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    const normalizedHook: ShaderHook = Object.assign(opts, {signature});\n    switch (shaderStage) {\n      case 'vs':\n        result.vertex[name] = normalizedHook;\n        break;\n      case 'fs':\n        result.fragment[name] = normalizedHook;\n        break;\n      default:\n        throw new Error(shaderStage);\n    }\n  }\n\n  return result;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/** Information extracted from shader source code */\nexport type ShaderInfo = {\n  name: string;\n  language: 'glsl' | 'wgsl';\n  version: number;\n};\n\n/** Extracts information from shader source code */\nexport function getShaderInfo(source: string, defaultName?: string): ShaderInfo {\n  return {\n    name: getShaderName(source, defaultName),\n    language: 'glsl',\n    version: getShaderVersion(source)\n  };\n}\n\n/** Extracts GLSLIFY style naming of shaders: `#define SHADER_NAME ...` */\nfunction getShaderName(shader: string, defaultName: string = 'unnamed'): string {\n  const SHADER_NAME_REGEXP = /#define[^\\S\\r\\n]*SHADER_NAME[^\\S\\r\\n]*([A-Za-z0-9_-]+)\\s*/;\n  const match = SHADER_NAME_REGEXP.exec(shader);\n  return match ? match[1] : defaultName;\n}\n\n/** returns GLSL shader version of given shader string */\nfunction getShaderVersion(source: string): 100 | 300 {\n  let version = 100;\n  const words = source.match(/[^\\s]+/g);\n  if (words && words.length >= 2 && words[0] === '#version') {\n    const parsedVersion = parseInt(words[1], 10);\n    if (Number.isFinite(parsedVersion)) {\n      version = parsedVersion;\n    }\n  }\n  if (version !== 100 && version !== 300) {\n    throw new Error(`Invalid GLSL version ${version}`);\n  }\n  return version;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {getShaderModuleDependencies} from '../shader-module/shader-module-dependencies';\nimport {PlatformInfo} from './platform-info';\nimport {getPlatformShaderDefines} from './platform-defines';\nimport {injectShader, DECLARATION_INJECT_MARKER} from './shader-injections';\nimport {transpileGLSLShader} from '../shader-transpiler/transpile-glsl-shader';\nimport {checkShaderModuleDeprecations} from '../shader-module/shader-module';\nimport type {ShaderInjection} from './shader-injections';\nimport type {ShaderModule} from '../shader-module/shader-module';\nimport {ShaderHook, normalizeShaderHooks, getShaderHooks} from './shader-hooks';\nimport {assert} from '../utils/assert';\nimport {getShaderInfo} from '../glsl-utils/get-shader-info';\n\n/** Define map */\nexport type ShaderDefine = string | number | boolean;\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n`;\n\n/**\n * Precision prologue to inject before functions are injected in shader\n * TODO - extract any existing prologue in the fragment source and move it up...\n */\nconst FRAGMENT_SHADER_PROLOGUE = /* glsl */ `\\\nprecision highp float;\n`;\n\n/**\n * Options for `ShaderAssembler.assembleShaders()`\n */\nexport type AssembleShaderProps = AssembleShaderOptions & {\n  platformInfo: PlatformInfo;\n  /** WGSL: single shader source. */\n  source?: string | null;\n  /** GLSL vertex shader source. */\n  vs?: string | null;\n  /** GLSL fragment shader source. */\n  fs?: string | null;\n};\n\nexport type AssembleShaderOptions = {\n  /** information about the platform (which shader language & version, extensions etc.) */\n  platformInfo: PlatformInfo;\n  /** Inject shader id #defines */\n  id?: string;\n  /** Modules to be injected */\n  modules?: ShaderModule[];\n  /** Defines to be injected */\n  defines?: Record<string, ShaderDefine>;\n  /** Hook functions */\n  hookFunctions?: (ShaderHook | string)[];\n  /** Code injections */\n  inject?: Record<string, string | ShaderInjection>;\n  /** Whether to inject prologue */\n  prologue?: boolean;\n  /** logger object */\n  log?: any;\n};\n\ntype AssembleStageOptions = {\n  /** Inject shader id #defines */\n  id?: string;\n  /** Vertex shader */\n  source: string;\n  stage: 'vertex' | 'fragment';\n  /** Modules to be injected */\n  modules: any[];\n  /** Defines to be injected */\n  defines?: Record<string, ShaderDefine>;\n  /** Hook functions */\n  hookFunctions?: (ShaderHook | string)[];\n  /** Code injections */\n  inject?: Record<string, string | ShaderInjection>;\n  /** Whether to inject prologue */\n  prologue?: boolean;\n  /** logger object */\n  log?: any;\n};\n\nexport type HookFunction = {hook: string; header: string; footer: string; signature?: string};\n\n/**\n * getUniforms function returned from the shader module system\n */\nexport type GetUniformsFunc = (opts: Record<string, any>) => Record<string, any>;\n\n/**\n * Inject a list of shader modules into a single shader source for WGSL\n */\nexport function assembleWGSLShader(\n  options: AssembleShaderOptions & {\n    /** Single WGSL shader */\n    source: string;\n  }\n): {\n  source: string;\n  getUniforms: GetUniformsFunc;\n} {\n  const modules = getShaderModuleDependencies(options.modules || []);\n\n  return {\n    source: assembleShaderWGSL(options.platformInfo, {\n      ...options,\n      source: options.source,\n      stage: 'vertex',\n      modules\n    }),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n\n/**\n * Injects dependent shader module sources into pair of main vertex/fragment shader sources for GLSL\n */\nexport function assembleGLSLShaderPair(\n  options: AssembleShaderOptions & {\n    /** Vertex shader */\n    vs: string;\n    /** Fragment shader */\n    fs?: string;\n  }\n): {\n  vs: string;\n  fs: string;\n  getUniforms: GetUniformsFunc;\n} {\n  const {vs, fs} = options;\n  const modules = getShaderModuleDependencies(options.modules || []);\n\n  return {\n    vs: assembleShaderGLSL(options.platformInfo, {\n      ...options,\n      source: vs,\n      stage: 'vertex',\n      modules\n    }),\n    fs: assembleShaderGLSL(options.platformInfo, {\n      ...options,\n      // @ts-expect-error\n      source: fs,\n      stage: 'fragment',\n      modules\n    }),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n\n/**\n * Pulls together complete source code for either a vertex or a fragment shader\n * adding prologues, requested module chunks, and any final injections.\n * @param gl\n * @param options\n * @returns\n */\nexport function assembleShaderWGSL(platformInfo: PlatformInfo, options: AssembleStageOptions) {\n  const {\n    // id,\n    source,\n    stage,\n    modules,\n    // defines = {},\n    hookFunctions = [],\n    inject = {},\n    log\n  } = options;\n\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  // const isVertex = type === 'vs';\n  // const sourceLines = source.split('\\n');\n\n  const coreSource = source;\n\n  // Combine Module and Application Defines\n  // const allDefines = {};\n  // modules.forEach(module => {\n  //   Object.assign(allDefines, module.getDefines());\n  // });\n  // Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = '';\n  //   prologue\n  //     ? `\\\n  // ${getShaderNameDefine({id, source, type})}\n  // ${getShaderType(type)}\n  // ${getPlatformShaderDefines(platformInfo)}\n  // ${getApplicationDefines(allDefines)}\n  // ${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n  // `\n  // `;\n\n  const hookFunctionMap = normalizeShaderHooks(hookFunctions);\n\n  // Add source of dependent modules in resolved order\n  const hookInjections: Record<string, ShaderInjection[]> = {};\n  const declInjections: Record<string, ShaderInjection[]> = {};\n  const mainInjections: Record<string, ShaderInjection[]> = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    const match = /^(v|f)s:(#)?([\\w-]+)$/.exec(key);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection as any];\n        } else {\n          mainInjections[key] = [injection as any];\n        }\n      } else {\n        hookInjections[key] = [injection as any];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection as any];\n    }\n  }\n\n  // TODO - hack until shadertool modules support WebGPU\n  const modulesToInject = modules;\n\n  for (const module of modulesToInject) {\n    if (log) {\n      checkShaderModuleDeprecations(module, coreSource, log);\n    }\n    const moduleSource = getShaderModuleSource(module, 'wgsl');\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n\n    const injections = module.injections?.[stage] || {};\n    for (const key in injections) {\n      const match = /^(v|f)s:#([\\w-]+)$/.exec(key);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource = injectShader(assembledSource, stage, declInjections);\n\n  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, stage, mainInjections);\n\n  return assembledSource;\n}\n\n/**\n * Pulls together complete source code for either a vertex or a fragment shader\n * adding prologues, requested module chunks, and any final injections.\n * @param gl\n * @param options\n * @returns\n */\nfunction assembleShaderGLSL(\n  platformInfo: PlatformInfo,\n  options: {\n    id?: string;\n    source: string;\n    language?: 'glsl' | 'wgsl';\n    stage: 'vertex' | 'fragment';\n    modules: ShaderModule[];\n    defines?: Record<string, ShaderDefine>;\n    hookFunctions?: any[];\n    inject?: Record<string, string | ShaderInjection>;\n    prologue?: boolean;\n    log?: any;\n  }\n) {\n  const {\n    id,\n    source,\n    stage,\n    language = 'glsl',\n    modules,\n    defines = {},\n    hookFunctions = [],\n    inject = {},\n    prologue = true,\n    log\n  } = options;\n\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const sourceVersion = language === 'glsl' ? getShaderInfo(source).version : -1;\n  const targetVersion = platformInfo.shaderLanguageVersion;\n\n  const sourceVersionDirective = sourceVersion === 100 ? '#version 100' : '#version 300 es';\n\n  const sourceLines = source.split('\\n');\n  // TODO : keep all pre-processor statements at the beginning of the shader.\n  const coreSource = sourceLines.slice(1).join('\\n');\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.defines);\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = '';\n  switch (language) {\n    case 'wgsl':\n      break;\n    case 'glsl':\n      assembledSource = prologue\n        ? `\\\n${sourceVersionDirective}\n\n// ----- PROLOGUE -------------------------\n${getShaderNameDefine({id, source, stage})}\n${`#define SHADER_TYPE_${stage.toUpperCase()}`}\n\n${getPlatformShaderDefines(platformInfo)}\n${stage === 'fragment' ? FRAGMENT_SHADER_PROLOGUE : ''}\n\n// ----- APPLICATION DEFINES -------------------------\n\n${getApplicationDefines(allDefines)}\n\n`\n        : `${sourceVersionDirective}\n`;\n      break;\n  }\n\n  const hookFunctionMap = normalizeShaderHooks(hookFunctions);\n\n  // Add source of dependent modules in resolved order\n  const hookInjections: Record<string, ShaderInjection[]> = {};\n  const declInjections: Record<string, ShaderInjection[]> = {};\n  const mainInjections: Record<string, ShaderInjection[]> = {};\n\n  for (const key in inject) {\n    const injection: ShaderInjection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    const match = /^(v|f)s:(#)?([\\w-]+)$/.exec(key);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    if (log) {\n      checkShaderModuleDeprecations(module, coreSource, log);\n    }\n    const moduleSource = getShaderModuleSource(module, stage);\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n\n    const injections = module.instance?.normalizedInjections[stage] || {};\n    for (const key in injections) {\n      const match = /^(v|f)s:#([\\w-]+)$/.exec(key);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n\n  assembledSource += '// ----- MAIN SHADER SOURCE -------------------------';\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource = injectShader(assembledSource, stage, declInjections);\n\n  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, stage, mainInjections);\n\n  if (language === 'glsl' && sourceVersion !== targetVersion) {\n    assembledSource = transpileGLSLShader(assembledSource, stage);\n  }\n\n  return assembledSource.trim();\n}\n\n/**\n * Returns a combined `getUniforms` covering the options for all the modules,\n * the created function will pass on options to the inidividual `getUniforms`\n * function of each shader module and combine the results into one object that\n * can be passed to setUniforms.\n * @param modules\n * @returns\n */\nexport function assembleGetUniforms(modules: ShaderModule[]) {\n  return function getUniforms(opts: Record<string, any>): Record<string, any> {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms?.(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\n/**\n * Generate \"glslify-compatible\" SHADER_NAME defines\n * These are understood by the GLSL error parsing function\n * If id is provided and no SHADER_NAME constant is present in source, create one\n */\nfunction getShaderNameDefine(options: {\n  id?: string;\n  source: string;\n  stage: 'vertex' | 'fragment';\n}): string {\n  const {id, source, stage} = options;\n  const injectShaderName = id && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${stage}`\n    : '';\n}\n\n/** Generates application defines from an object of key value pairs */\nfunction getApplicationDefines(defines: Record<string, ShaderDefine> = {}): string {\n  let sourceText = '';\n  for (const define in defines) {\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  return sourceText;\n}\n\n/** Extracts the source code chunk for the specified shader type from the named shader module */\nexport function getShaderModuleSource(\n  module: ShaderModule,\n  stage: 'vertex' | 'fragment' | 'wgsl'\n): string {\n  let moduleSource;\n  switch (stage) {\n    case 'vertex':\n      moduleSource = module.vs || '';\n      break;\n    case 'fragment':\n      moduleSource = module.fs || '';\n      break;\n    case 'wgsl':\n      moduleSource = module.source || '';\n      break;\n    default:\n      assert(false);\n  }\n\n  if (!module.name) {\n    throw new Error('Shader module must have a name');\n  }\n  const moduleName = module.name.toUpperCase().replace(/[^0-9a-z]/gi, '_');\n  let source = `\\\n// ----- MODULE ${module.name} ---------------\n\n`;\n  if (stage !== 'wgsl') {\n    source += `#define MODULE_${moduleName}\\n`;\n  }\n  source += `${moduleSource}\\n`;\n  return source;\n}\n\n/*\nfunction getHookFunctions(\n  hookFunctions: Record<string, HookFunction>,\n  hookInjections: Record<string, Injection[]>\n): string {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a: {order: number}, b: {order: number}): number => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n\nfunction normalizeHookFunctions(hookFunctions: (string | HookFunction)[]): {\n  vs: Record<string, HookFunction>;\n  fs: Record<string, HookFunction>;\n} {\n  const result: {vs: Record<string, any>; fs: Record<string, any>} = {\n    vs: {},\n    fs: {}\n  };\n\n  hookFunctions.forEach((hookFunction: string | HookFunction) => {\n    let opts: HookFunction;\n    let hook: string;\n    if (typeof hookFunction !== 'string') {\n      opts = hookFunction;\n      hook = opts.hook;\n    } else {\n      opts = {} as HookFunction;\n      hook = hookFunction;\n    }\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    if (stage !== 'vs' && stage !== 'fs') {\n      throw new Error(stage);\n    }\n    result[stage][name] = Object.assign(opts, {signature});\n  });\n\n  return result;\n}\n*/\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nconst IFDEF_REGEXP = /^\\s*\\#\\s*ifdef\\s*([a-zA-Z_]+)\\s*$/;\nconst ENDIF_REGEXP = /^\\s*\\#\\s*endif\\s*$/;\n\nexport type PreprocessorOptions = {\n  defines?: Record<string, boolean>;\n};\n\nexport function preprocess(source: string, options?: PreprocessorOptions): string {\n  const lines = source.split('\\n');\n  const output: string[] = [];\n\n  let conditional = true;\n  let currentDefine: string | null = null;\n  for (const line of lines) {\n    const matchIf = line.match(IFDEF_REGEXP);\n    const matchEnd = line.match(ENDIF_REGEXP);\n    if (matchIf) {\n      currentDefine = matchIf[1];\n      conditional = Boolean(options?.defines?.[currentDefine]);\n    } else if (matchEnd) {\n      conditional = true;\n    } else if (conditional) {\n      output.push(line);\n    }\n  }\n  return output.join('\\n');\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from './shader-module/shader-module';\nimport {initializeShaderModules} from './shader-module/shader-module';\nimport {\n  AssembleShaderProps,\n  GetUniformsFunc,\n  assembleWGSLShader,\n  assembleGLSLShaderPair\n} from './shader-assembly/assemble-shaders';\nimport {preprocess} from './preprocessor/preprocessor';\n\n/**\n * A stateful version of `assembleShaders` that can be used to assemble shaders.\n * Supports setting of default modules and hooks.\n */\nexport class ShaderAssembler {\n  /** Default ShaderAssembler instance */\n  static defaultShaderAssembler: ShaderAssembler;\n  /** Hook functions */\n  private readonly _hookFunctions: any[] = [];\n  /** Shader modules */\n  private _defaultModules: ShaderModule[] = [];\n\n  /**\n   * A default shader assembler instance - the natural place to register default modules and hooks\n   * @returns\n   */\n  static getDefaultShaderAssembler(): ShaderAssembler {\n    ShaderAssembler.defaultShaderAssembler =\n      ShaderAssembler.defaultShaderAssembler || new ShaderAssembler();\n    return ShaderAssembler.defaultShaderAssembler;\n  }\n\n  /**\n   * Add a default module that does not have to be provided with every call to assembleShaders()\n   */\n  addDefaultModule(module: ShaderModule): void {\n    if (\n      !this._defaultModules.find(\n        m => m.name === (typeof module === 'string' ? module : module.name)\n      )\n    ) {\n      this._defaultModules.push(module);\n    }\n  }\n\n  /**\n   * Remove a default module\n   */\n  removeDefaultModule(module: ShaderModule): void {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);\n  }\n\n  /**\n   * Register a shader hook\n   * @param hook\n   * @param opts\n   */\n  addShaderHook(hook: string, opts?: any): void {\n    if (opts) {\n      hook = Object.assign(opts, {hook});\n    }\n    this._hookFunctions.push(hook);\n  }\n\n  /**\n   * Assemble a WGSL unified shader\n   * @param platformInfo\n   * @param props\n   * @returns\n   */\n  assembleWGSLShader(props: AssembleShaderProps): {\n    source: string;\n    getUniforms: GetUniformsFunc;\n    modules: ShaderModule[];\n  } {\n    const modules = this._getModuleList(props.modules); // Combine with default modules\n    const hookFunctions = this._hookFunctions; // TODO - combine with default hook functions\n    const {source, getUniforms} = assembleWGSLShader({\n      ...props,\n      // @ts-expect-error\n      source: props.source,\n      modules,\n      hookFunctions\n    });\n    // WGSL does not have built-in preprocessing support (just compile time constants)\n    const preprocessedSource =\n      props.platformInfo.shaderLanguage === 'wgsl' ? preprocess(source) : source;\n    return {source: preprocessedSource, getUniforms, modules};\n  }\n\n  /**\n   * Assemble a pair of shaders into a single shader program\n   * @param platformInfo\n   * @param props\n   * @returns\n   */\n  assembleGLSLShaderPair(props: AssembleShaderProps): {\n    vs: string;\n    fs: string;\n    getUniforms: GetUniformsFunc;\n    modules: ShaderModule[];\n  } {\n    const modules = this._getModuleList(props.modules); // Combine with default modules\n    const hookFunctions = this._hookFunctions; // TODO - combine with default hook functions\n    const assembled = assembleGLSLShaderPair({\n      ...props,\n      // @ts-expect-error\n      vs: props.vs,\n      // @ts-expect-error\n      fs: props.fs,\n      modules,\n      hookFunctions\n    });\n\n    return {...assembled, modules};\n  }\n\n  /**\n   * Dedupe and combine with default modules\n   */\n  _getModuleList(appModules: ShaderModule[] = []): ShaderModule[] {\n    const modules = new Array<ShaderModule>(this._defaultModules.length + appModules.length);\n    const seen: Record<string, boolean> = {};\n    let count = 0;\n\n    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {\n      const module = this._defaultModules[i];\n      const name = module.name;\n      modules[count++] = module;\n      seen[name] = true;\n    }\n\n    for (let i = 0, len = appModules.length; i < len; ++i) {\n      const module = appModules[i];\n      const name = module.name;\n      if (!seen[name]) {\n        modules[count++] = module;\n        seen[name] = true;\n      }\n    }\n\n    modules.length = count;\n\n    initializeShaderModules(modules);\n    return modules;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nconst FS_GLES = /* glsl */ `\\\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}`;\nconst FS300 = `#version 300 es\\n${FS_GLES}`;\n\ntype QualifierInfo = {\n  qualifier: string;\n  type: string;\n  name: string;\n};\n\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(\n  line: string,\n  qualifiers: string | string[]\n): QualifierInfo | null {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, '').split(/\\s+/);\n  // TODO add support for precession qualifiers (highp, mediump and lowp)\n  const [qualifier, type, definition] = words;\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n  const name = definition.split(';')[0];\n  return {qualifier, type, name};\n}\n\n/**\n * Given the shader input and output variable names,\n * builds and return a pass through fragment shader.\n */\nexport function getPassthroughFS(options?: {\n  input?: string;\n  inputChannels?: 1 | 2 | 3 | 4;\n  output?: string;\n}): string {\n  const {input, inputChannels, output} = options || {};\n  if (!input) {\n    // Default shader\n    return FS300;\n  }\n  if (!inputChannels) {\n    throw new Error('inputChannels');\n  }\n  const inputType = channelCountToType(inputChannels);\n  const outputValue = convertToVec4(input, inputChannels);\n  return `\\\n#version 300 es\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n}\n\n/** convert glsl type to suffix */\nexport function typeToChannelSuffix(type: string): 'x' | 'xy' | 'xyz' | 'xyzw' {\n  // prettier-ignore\n  switch (type) {\n    case 'float': return 'x';\n    case 'vec2': return 'xy';\n    case 'vec3': return 'xyz';\n    case 'vec4': return 'xyzw';\n    default:\n      throw new Error(type);\n  }\n}\n\n/** convert glsl type to channel count */\nexport function typeToChannelCount(type: string): 1 | 2 | 3 | 4 {\n  // prettier-ignore\n  switch (type) {\n    case 'float': return 1;\n    case 'vec2': return 2;\n    case 'vec3': return 3;\n    case 'vec4': return 4;\n    default:\n      throw new Error(type);\n  }\n}\nfunction channelCountToType(channels: 1 | 2 | 3 | 4): 'float' | 'vec2' | 'vec3' | 'vec4' {\n  // prettier-ignore\n  switch (channels) {\n    case 1: return 'float';\n    case 2: return 'vec2';\n    case 3: return 'vec3';\n    case 4: return 'vec4';\n    default:\n      throw new Error(`invalid channels: ${channels}`);\n  }\n}\n\n/** Returns glsl instruction for converting to vec4 */\nexport function convertToVec4(variable: string, channels: 1 | 2 | 3 | 4): string {\n  // prettier-ignore\n  switch (channels) {\n    case 1: return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n    case 2: return `vec4(${variable}, 0.0, 1.0)`;\n    case 3: return `vec4(${variable}, 1.0)`;\n    case 4: return variable;\n    default:\n      throw new Error(`invalid channels: ${channels}`);\n  }\n}\n", "import { Attribute } from \"../wgsl_ast.js\";\r\n\r\nexport class TypeInfo {\r\n  name: string;\r\n  attributes: Attribute[] | null;\r\n  size: number;\r\n\r\n  constructor(name: string, attributes: Attribute[] | null) {\r\n    this.name = name;\r\n    this.attributes = attributes;\r\n    this.size = 0;\r\n  }\r\n\r\n  get isArray(): boolean {\r\n    return false;\r\n  }\r\n\r\n  get isStruct(): boolean {\r\n    return false;\r\n  }\r\n\r\n  get isTemplate(): boolean {\r\n    return false;\r\n  }\r\n\r\n  get isPointer(): boolean {\r\n    return false;\r\n  }\r\n\r\n  getTypeName(): string {\r\n    return this.name;\r\n  }\r\n}\r\n\r\nexport class MemberInfo {\r\n  name: string;\r\n  type: TypeInfo;\r\n  attributes: Attribute[] | null;\r\n  offset: number;\r\n  size: number;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: TypeInfo,\r\n    attributes: Attribute[] | null\r\n  ) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.attributes = attributes;\r\n    this.offset = 0;\r\n    this.size = 0;\r\n  }\r\n\r\n  get isArray(): boolean {\r\n    return this.type.isArray;\r\n  }\r\n\r\n  get isStruct(): boolean {\r\n    return this.type.isStruct;\r\n  }\r\n\r\n  get isTemplate(): boolean {\r\n    return this.type.isTemplate;\r\n  }\r\n\r\n  get align(): number {\r\n    return this.type.isStruct ? (this.type as StructInfo).align : 0;\r\n  }\r\n\r\n  get members(): MemberInfo[] | null {\r\n    return this.type.isStruct ? (this.type as StructInfo).members : null;\r\n  }\r\n\r\n  get format(): TypeInfo | null {\r\n    return this.type.isArray\r\n      ? (this.type as ArrayInfo).format\r\n      : this.type.isTemplate\r\n      ? (this.type as TemplateInfo).format\r\n      : null;\r\n  }\r\n\r\n  get count(): number {\r\n    return this.type.isArray ? (this.type as ArrayInfo).count : 0;\r\n  }\r\n\r\n  get stride(): number {\r\n    return this.type.isArray ? (this.type as ArrayInfo).stride : this.size;\r\n  }\r\n}\r\n\r\nexport class StructInfo extends TypeInfo {\r\n  members: MemberInfo[] = [];\r\n  align: number = 0;\r\n  startLine: number = -1;\r\n  endLine: number = -1;\r\n  inUse: boolean = false;\r\n\r\n  constructor(name: string, attributes: Attribute[] | null) {\r\n    super(name, attributes);\r\n  }\r\n\r\n  get isStruct(): boolean {\r\n    return true;\r\n  }\r\n}\r\n\r\nexport class ArrayInfo extends TypeInfo {\r\n  format: TypeInfo;\r\n  count: number;\r\n  stride: number;\r\n\r\n  constructor(name: string, attributes: Attribute[] | null) {\r\n    super(name, attributes);\r\n    this.count = 0;\r\n    this.stride = 0;\r\n  }\r\n\r\n  get isArray(): boolean {\r\n    return true;\r\n  }\r\n\r\n  getTypeName(): string {\r\n    return `array<${this.format.getTypeName()}, ${this.count}>`;\r\n  }\r\n}\r\n\r\nexport class PointerInfo extends TypeInfo {\r\n  format: TypeInfo;\r\n  constructor(name: string, format: TypeInfo, attributes: Attribute[] | null) {\r\n    super(name, attributes);\r\n    this.format = format;\r\n  }\r\n\r\n  get isPointer(): boolean {\r\n    return true;\r\n  }\r\n\r\n  getTypeName(): string {\r\n    return `&${this.format.getTypeName()}`;\r\n  }\r\n}\r\n\r\nexport class TemplateInfo extends TypeInfo {\r\n  format: TypeInfo | null;\r\n  access: string;\r\n  constructor(\r\n    name: string,\r\n    format: TypeInfo | null,\r\n    attributes: Attribute[] | null,\r\n    access: string\r\n  ) {\r\n    super(name, attributes);\r\n    this.format = format;\r\n    this.access = access;\r\n  }\r\n\r\n  get isTemplate(): boolean {\r\n    return true;\r\n  }\r\n\r\n  getTypeName(): string {\r\n    let name = this.name;\r\n    if (this.format !== null) {\r\n      if (name === \"vec2\" || name === \"vec3\" || name === \"vec4\" ||\r\n          name === \"mat2x2\" || name === \"mat2x3\" || name === \"mat2x4\" ||\r\n          name === \"mat3x2\" || name === \"mat3x3\" || name === \"mat3x4\" ||\r\n          name === \"mat4x2\" || name === \"mat4x3\" || name === \"mat4x4\") {\r\n        if (this.format.name === \"f32\") {\r\n          name += \"f\";\r\n          return name;\r\n        } else if (this.format.name === \"i32\") {\r\n          name += \"i\";\r\n          return name;\r\n        } else if (this.format.name === \"u32\") {\r\n          name += \"u\";\r\n          return name;\r\n        } else if (this.format.name === \"bool\") {\r\n          name += \"b\";\r\n          return name;\r\n        } else if (this.format.name === \"f16\") {\r\n          name += \"h\";\r\n          return name;\r\n        }\r\n      }\r\n      name += `<${this.format.name}>`;\r\n    } else {\r\n      if (name === \"vec2\" || name === \"vec3\" || name === \"vec4\") {\r\n        return name;\r\n      }\r\n      //console.error(\"Template format is null.\");\r\n    }\r\n    return name;\r\n  }\r\n}\r\n\r\nexport enum ResourceType {\r\n  Uniform,\r\n  Storage,\r\n  Texture,\r\n  Sampler,\r\n  StorageTexture,\r\n}\r\n\r\nexport class VariableInfo {\r\n  attributes: Attribute[] | null;\r\n  name: string;\r\n  type: TypeInfo;\r\n  group: number;\r\n  binding: number;\r\n  resourceType: ResourceType;\r\n  access: string;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: TypeInfo,\r\n    group: number,\r\n    binding: number,\r\n    attributes: Attribute[] | null,\r\n    resourceType: ResourceType,\r\n    access: string\r\n  ) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.group = group;\r\n    this.binding = binding;\r\n    this.attributes = attributes;\r\n    this.resourceType = resourceType;\r\n    this.access = access;\r\n  }\r\n\r\n  get isArray(): boolean {\r\n    return this.type.isArray;\r\n  }\r\n\r\n  get isStruct(): boolean {\r\n    return this.type.isStruct;\r\n  }\r\n\r\n  get isTemplate(): boolean {\r\n    return this.type.isTemplate;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.type.size;\r\n  }\r\n\r\n  get align(): number {\r\n    return this.type.isStruct ? (this.type as StructInfo).align : 0;\r\n  }\r\n\r\n  get members(): MemberInfo[] | null {\r\n    return this.type.isStruct ? (this.type as StructInfo).members : null;\r\n  }\r\n\r\n  get format(): TypeInfo | null {\r\n    return this.type.isArray\r\n      ? (this.type as ArrayInfo).format\r\n      : this.type.isTemplate\r\n      ? (this.type as TemplateInfo).format\r\n      : null;\r\n  }\r\n\r\n  get count(): number {\r\n    return this.type.isArray ? (this.type as ArrayInfo).count : 0;\r\n  }\r\n\r\n  get stride(): number {\r\n    return this.type.isArray ? (this.type as ArrayInfo).stride : this.size;\r\n  }\r\n}\r\n\r\nexport class AliasInfo {\r\n  name: string;\r\n  type: TypeInfo;\r\n\r\n  constructor(name: string, type: TypeInfo) {\r\n    this.name = name;\r\n    this.type = type;\r\n  }\r\n}\r\n\r\nexport class InputInfo {\r\n  name: string;\r\n  type: TypeInfo | null;\r\n  locationType: string;\r\n  location: number | string;\r\n  interpolation: string | null;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: TypeInfo | null,\r\n    locationType: string,\r\n    location: number | string\r\n  ) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.locationType = locationType;\r\n    this.location = location;\r\n    this.interpolation = null;\r\n  }\r\n}\r\n\r\nexport class OutputInfo {\r\n  name: string;\r\n  type: TypeInfo | null;\r\n  locationType: string;\r\n  location: number | string;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: TypeInfo | null,\r\n    locationType: string,\r\n    location: number | string\r\n  ) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.locationType = locationType;\r\n    this.location = location;\r\n  }\r\n}\r\n\r\nexport class OverrideInfo {\r\n  name: string;\r\n  type: TypeInfo | null;\r\n  attributes: Attribute[] | null;\r\n  id: number;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: TypeInfo | null,\r\n    attributes: Attribute[] | null,\r\n    id: number\r\n  ) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.attributes = attributes;\r\n    this.id = id;\r\n  }\r\n}\r\n\r\nexport class ArgumentInfo {\r\n  name: string;\r\n  type: TypeInfo;\r\n  attributes: Attribute[] | null;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: TypeInfo,\r\n    attributes: Attribute[] | null\r\n  ) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.attributes = attributes;\r\n  }\r\n}\r\n\r\nexport class FunctionInfo {\r\n  name: string;\r\n  stage: string | null = null;\r\n  inputs: InputInfo[] = [];\r\n  outputs: OutputInfo[] = [];\r\n  arguments: ArgumentInfo[] = [];\r\n  returnType: TypeInfo | null = null;\r\n  resources: VariableInfo[] = [];\r\n  overrides: OverrideInfo[] = [];\r\n  attributes: Attribute[] | null;\r\n  startLine: number = -1;\r\n  endLine: number = -1;\r\n  inUse: boolean = false;\r\n  calls: Set<FunctionInfo> = new Set();\r\n\r\n  constructor(name: string, stage: string | null = null, attributes: Attribute[] | null) {\r\n    this.name = name;\r\n    this.stage = stage;\r\n    this.attributes = attributes;\r\n  }\r\n}\r\n\r\nexport class EntryFunctions {\r\n  vertex: FunctionInfo[] = [];\r\n  fragment: FunctionInfo[] = [];\r\n  compute: FunctionInfo[] = [];\r\n}\r\n", "// From https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\r\nexport function float16ToFloat32(float16: number): number {\r\n    var s = (float16 & 0x8000) >> 15;\r\n    var e = (float16 & 0x7C00) >> 10;\r\n    var f = float16 & 0x03FF;\r\n\r\n    if (e == 0) {\r\n      return (s ? -1:1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\r\n    } else if (e == 0x1F) {\r\n      return f ? NaN : ((s ? -1 : 1) * Infinity);\r\n    }\r\n\r\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + (f / Math.pow(2, 10)));\r\n}\r\n\r\nconst float32View = new Float32Array(1);\r\nconst int32View = new Int32Array(float32View.buffer);\r\nconst float16View = new Uint16Array(1);\r\n\r\nexport function float32ToFloat16(float32: number): number {\r\n  float32View[0] = float32;\r\n\r\n  const f32 = int32View[0];\r\n  const sign = (f32 >> 31) & 1;\r\n  let exponent = (f32 >> 23) & 0xff;\r\n  let fraction = f32 & 0x7fffff;\r\n\r\n  if (exponent === 0xff) { // Infinity or NaN\r\n    float16View[0] = (sign << 15) | 0x7c00 | (fraction !== 0 ? 0x0200 : 0);\r\n    return float16View[0];\r\n  }\r\n\r\n  if (exponent === 0) { // Zero or subnormal\r\n    if (fraction === 0) { // Zero\r\n      float16View[0] = sign << 15;\r\n      return float16View[0];\r\n    }\r\n    // Subnormal\r\n    fraction |= 0x800000;\r\n    let shift = 113;\r\n    while ((fraction & 0x800000) === 0) {\r\n      fraction <<= 1;\r\n      shift--;\r\n    }\r\n    exponent = 127 - shift;\r\n    fraction &= 0x7fffff;\r\n    if (exponent > 0) {\r\n      fraction = (fraction >> (126 - exponent)) + ((fraction >> (127 - exponent)) & 1);\r\n      float16View[0] = (sign << 15) | (exponent << 10) | (fraction >> 13);\r\n      return float16View[0];\r\n    } else {\r\n      float16View[0] = sign << 15;\r\n      return float16View[0];\r\n    }\r\n  }\r\n\r\n  // Normalized\r\n  exponent = exponent - 127 + 15;\r\n  if (exponent >= 31) { // Overflow\r\n    float16View[0] = (sign << 15) | 0x7c00;\r\n    return float16View[0];\r\n  }\r\n  if (exponent <= 0) { // Underflow\r\n    if (exponent < -10) {\r\n      float16View[0] = sign << 15;\r\n      return float16View[0];\r\n    }\r\n    fraction = (fraction | 0x800000) >> (1 - exponent);\r\n    float16View[0] = (sign << 15) | (fraction >> 13);\r\n    return float16View[0];\r\n  }\r\n\r\n  fraction = fraction >> 13;\r\n  float16View[0] = (sign << 15) | (exponent << 10) | fraction;\r\n  return float16View[0];\r\n}\r\n\r\nconst uint32 = new Uint32Array(1);\r\nconst uint32ToFloat32 = new Float32Array(uint32.buffer, 0, 1);\r\n\r\nexport function float11ToFloat32(f11: number): number {\r\n  const u32 = (((((f11) >> 6) & 0x1F) + (127 - 15)) << 23) | (((f11) & 0x3F) << 17);\r\n  uint32[0] = u32;\r\n  return uint32ToFloat32[0];\r\n}\r\n\r\nexport function float10ToFloat32(f10: number): number {\r\n  const u32 = (((((f10) >> 5) & 0x1F) + (127 - 15)) << 23) | (((f10) & 0x1F) << 18);\r\n  uint32[0] = u32;\r\n  return uint32ToFloat32[0];\r\n}\r\n", "import { float16ToFloat32, float32ToFloat16, float10ToFloat32, float11ToFloat32 } from \"./float.js\";\r\n\r\nexport function setTexturePixel(imageData: Uint8Array, x: number, y: number, z: number, mipLevel: number,\r\n        height: number, bytesPerRow: number, texelByteSize: number, format: string, value: number[]): void {\r\n    bytesPerRow = bytesPerRow >> mipLevel;\r\n    height = height >> mipLevel;\r\n\r\n    const offset = (z * bytesPerRow * height) + y * bytesPerRow + x * texelByteSize;\r\n\r\n    switch (format) {\r\n        case \"r8unorm\": {\r\n            setPixelValue(imageData, offset, \"8unorm\", 1, value);\r\n            return;\r\n        }\r\n        case \"r8snorm\": {\r\n            setPixelValue(imageData, offset, \"8snorm\", 1, value);\r\n            return;\r\n        }\r\n        case \"r8uint\": {\r\n            setPixelValue(imageData, offset, \"8uint\", 1, value);\r\n            return;\r\n        }\r\n        case \"r8sint\": {\r\n            setPixelValue(imageData, offset, \"8sint\", 1, value);\r\n            return;\r\n        }\r\n\r\n        case \"rg8unorm\": {\r\n            setPixelValue(imageData, offset, \"8unorm\", 2, value);\r\n            return;\r\n        }\r\n        case \"rg8snorm\": {\r\n            setPixelValue(imageData, offset, \"8snorm\", 2, value);\r\n            return;\r\n        }\r\n        case \"rg8uint\": {\r\n            setPixelValue(imageData, offset, \"8uint\", 2, value);\r\n            return;\r\n        }\r\n        case \"rg8sint\": {\r\n            setPixelValue(imageData, offset, \"8sint\", 2, value);\r\n            return;\r\n        }\r\n\r\n        case \"rgba8unorm-srgb\":\r\n        case \"rgba8unorm\": {\r\n            setPixelValue(imageData, offset, \"8unorm\", 4, value);\r\n            return;\r\n        }\r\n        case \"rgba8snorm\": {\r\n            setPixelValue(imageData, offset, \"8snorm\", 4, value);\r\n            return;\r\n        }\r\n        case \"rgba8uint\": {\r\n            setPixelValue(imageData, offset, \"8uint\", 4, value);\r\n            return;\r\n        }\r\n        case \"rgba8sint\": {\r\n            setPixelValue(imageData, offset, \"8sint\", 4, value);\r\n            return;\r\n        }\r\n\r\n        case \"bgra8unorm-srgb\":\r\n        case \"bgra8unorm\": {\r\n            setPixelValue(imageData, offset, \"8unorm\", 4, value);\r\n            return;\r\n        }\r\n\r\n        case \"r16uint\": {\r\n            setPixelValue(imageData, offset, \"16uint\", 1, value);\r\n            return;\r\n        }\r\n        case \"r16sint\": {\r\n            setPixelValue(imageData, offset, \"16sint\", 1, value);\r\n            return;\r\n        }\r\n        case \"r16float\": {\r\n            setPixelValue(imageData, offset, \"16float\", 1, value);\r\n            return;\r\n        }\r\n\r\n        case \"rg16uint\": {\r\n            setPixelValue(imageData, offset, \"16uint\", 2, value);\r\n            return;\r\n        }\r\n        case \"rg16sint\": {\r\n            setPixelValue(imageData, offset, \"16sint\", 2, value);\r\n            return;\r\n        }\r\n        case \"rg16float\": {\r\n            setPixelValue(imageData, offset, \"16float\", 2, value);\r\n            return;\r\n        }\r\n\r\n        case \"rgba16uint\": {\r\n            setPixelValue(imageData, offset, \"16uint\", 4, value);\r\n            return;\r\n        }\r\n        case \"rgba16sint\": {\r\n            setPixelValue(imageData, offset, \"16sint\", 4, value);\r\n            return;\r\n        }\r\n        case \"rgba16float\": {\r\n            setPixelValue(imageData, offset, \"16float\", 4, value);\r\n            return;\r\n        }\r\n\r\n        case \"r32uint\": {\r\n            setPixelValue(imageData, offset, \"32uint\", 1, value);\r\n            return;\r\n        }\r\n        case \"r32sint\": {\r\n            setPixelValue(imageData, offset, \"32sint\", 1, value);\r\n            return;\r\n        }\r\n        case \"depth16unorm\": // depth formats get conerted to r32float\r\n        case \"depth24plus\":\r\n        case \"depth24plus-stencil8\":\r\n        case \"depth32float\":\r\n        case \"depth32float-stencil8\":\r\n        case \"r32float\": {\r\n            setPixelValue(imageData, offset, \"32float\", 1, value);\r\n            return;\r\n        }\r\n        case \"rg32uint\": {\r\n            setPixelValue(imageData, offset, \"32uint\", 2, value);\r\n            return;\r\n        }\r\n        case \"rg32sint\": {\r\n            setPixelValue(imageData, offset, \"32sint\", 2, value);\r\n            return;\r\n        }\r\n        case \"rg32float\": {\r\n            setPixelValue(imageData, offset, \"32float\", 2, value);\r\n            return;\r\n        }\r\n        case \"rgba32uint\": {\r\n            setPixelValue(imageData, offset, \"32uint\", 4, value);\r\n            return;\r\n        }\r\n        case \"rgba32sint\": {\r\n            setPixelValue(imageData, offset, \"32sint\", 4, value);\r\n            return;\r\n        }\r\n        case \"rgba32float\": {\r\n            setPixelValue(imageData, offset, \"32float\", 4, value);\r\n            return;\r\n        }\r\n\r\n        case \"rg11b10ufloat\": {\r\n            console.error(\"TODO: rg11b10ufloat not supported for writing\");\r\n            /*const uintValue = new Uint32Array(imageData.buffer, offset, 1)[0];\r\n            const ri = uintValue & 0x7FF;\r\n            const gi = (uintValue & 0x3FF800) >> 11;\r\n            const bi = (uintValue & 0xFFC00000) >> 22;\r\n            const rf = float11ToFloat32(ri);\r\n            const gf = float11ToFloat32(gi);\r\n            const bf = float10ToFloat32(bi);\r\n            return [rf, gf, bf, 1.0];*/\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\nexport function getTexturePixel(imageData: Uint8Array, x: number, y: number, z: number, mipLevel: number,\r\n        height: number, bytesPerRow: number, texelByteSize: number, format: string): number[] | null {\r\n    bytesPerRow = bytesPerRow >> mipLevel;\r\n    height = height >> mipLevel;\r\n\r\n    const offset = (z * bytesPerRow * height) + y * bytesPerRow + x * texelByteSize;\r\n\r\n    switch (format) {\r\n        case \"r8unorm\": {\r\n            const value = pixelValue(imageData, offset, \"8unorm\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"r8snorm\": {\r\n            const value = pixelValue(imageData, offset, \"8snorm\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"r8uint\": {\r\n            const value = pixelValue(imageData, offset, \"8uint\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"r8sint\": {\r\n            const value = pixelValue(imageData, offset, \"8sint\", 1);\r\n            return [value[0]];\r\n        }\r\n\r\n        case \"rg8unorm\": {\r\n            const value = pixelValue(imageData, offset, \"8unorm\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rg8snorm\": {\r\n            const value = pixelValue(imageData, offset, \"8snorm\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rg8uint\": {\r\n            const value = pixelValue(imageData, offset, \"8uint\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rg8sint\": {\r\n            const value = pixelValue(imageData, offset, \"8sint\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n\r\n        case \"rgba8unorm-srgb\":\r\n        case \"rgba8unorm\": {\r\n            const value = pixelValue(imageData, offset, \"8unorm\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n        case \"rgba8snorm\": {\r\n            const value = pixelValue(imageData, offset, \"8snorm\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n        case \"rgba8uint\": {\r\n            const value = pixelValue(imageData, offset, \"8uint\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n        case \"rgba8sint\": {\r\n            const value = pixelValue(imageData, offset, \"8sint\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n\r\n        case \"bgra8unorm-srgb\":\r\n        case \"bgra8unorm\": {\r\n            const value = pixelValue(imageData, offset, \"8unorm\", 4);\r\n            return [value[2], value[1], value[0], value[3]];\r\n        }\r\n\r\n        case \"r16uint\": {\r\n            const value = pixelValue(imageData, offset, \"16uint\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"r16sint\": {\r\n            const value = pixelValue(imageData, offset, \"16sint\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"r16float\": {\r\n            const value = pixelValue(imageData, offset, \"16float\", 1);\r\n            return [value[0]];\r\n        }\r\n\r\n        case \"rg16uint\": {\r\n            const value = pixelValue(imageData, offset, \"16uint\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rg16sint\": {\r\n            const value = pixelValue(imageData, offset, \"16sint\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rg16float\": {\r\n            const value = pixelValue(imageData, offset, \"16float\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n\r\n        case \"rgba16uint\": {\r\n            const value = pixelValue(imageData, offset, \"16uint\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n        case \"rgba16sint\": {\r\n            const value = pixelValue(imageData, offset, \"16sint\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n        case \"rgba16float\": {\r\n            const value = pixelValue(imageData, offset, \"16float\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n\r\n        case \"r32uint\": {\r\n            const value = pixelValue(imageData, offset, \"32uint\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"r32sint\": {\r\n            const value = pixelValue(imageData, offset, \"32sint\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"depth16unorm\": // depth formats get conerted to r32float\r\n        case \"depth24plus\":\r\n        case \"depth24plus-stencil8\":\r\n        case \"depth32float\":\r\n        case \"depth32float-stencil8\":\r\n        case \"r32float\": {\r\n            const value = pixelValue(imageData, offset, \"32float\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"rg32uint\": {\r\n            const value = pixelValue(imageData, offset, \"32uint\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rg32sint\": {\r\n            const value = pixelValue(imageData, offset, \"32sint\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rg32float\": {\r\n            const value = pixelValue(imageData, offset, \"32float\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rgba32uint\": {\r\n            const value = pixelValue(imageData, offset, \"32uint\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n        case \"rgba32sint\": {\r\n            const value = pixelValue(imageData, offset, \"32sint\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n        case \"rgba32float\": {\r\n            const value = pixelValue(imageData, offset, \"32float\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n\r\n        case \"rg11b10ufloat\": {\r\n            const uintValue = new Uint32Array(imageData.buffer, offset, 1)[0];\r\n            const ri = uintValue & 0x7FF;\r\n            const gi = (uintValue & 0x3FF800) >> 11;\r\n            const bi = (uintValue & 0xFFC00000) >> 22;\r\n            const rf = float11ToFloat32(ri);\r\n            const gf = float11ToFloat32(gi);\r\n            const bf = float10ToFloat32(bi);\r\n            return [rf, gf, bf, 1.0];\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction pixelValue(imageData: Uint8Array, offset: number, format: string, numChannels: number) {\r\n    const value = [0, 0, 0, 0];\r\n    for (let i = 0; i < numChannels; ++i) {\r\n      switch (format) {\r\n        case \"8unorm\":\r\n          value[i] = imageData[offset] / 255;\r\n          offset++;\r\n          break;\r\n        case \"8snorm\":\r\n          value[i] = (imageData[offset] / 255) * 2 - 1;\r\n          offset++;\r\n          break;\r\n        case \"8uint\":\r\n          value[i] = imageData[offset];\r\n          offset++;\r\n          break;\r\n        case \"8sint\":\r\n          value[i] = imageData[offset] - 127;\r\n          offset++;\r\n          break;\r\n        case \"16uint\":\r\n          value[i] = imageData[offset] | (imageData[offset + 1] << 8);\r\n          offset += 2;\r\n          break;\r\n        case \"16sint\":\r\n          value[i] = (imageData[offset] | (imageData[offset + 1] << 8)) - 32768;\r\n          offset += 2;\r\n          break;\r\n        case \"16float\":\r\n          value[i] = float16ToFloat32(imageData[offset] | (imageData[offset + 1] << 8));\r\n          offset += 2;\r\n          break;\r\n        case \"32uint\":\r\n          value[i] = imageData[offset] | (imageData[offset + 1] << 8) | (imageData[offset + 2] << 16) | (imageData[offset + 3] << 24);\r\n          offset += 4;\r\n          break;\r\n        case \"32sint\":\r\n          value[i] = (imageData[offset] | (imageData[offset + 1] << 8) | (imageData[offset + 2] << 16) | (imageData[offset + 3] << 24)) | 0;\r\n          offset += 4;\r\n          break;\r\n        case \"32float\":\r\n          value[i] = new Float32Array(imageData.buffer, offset, 1)[0];\r\n          offset += 4;\r\n          break;\r\n      }\r\n    }\r\n    return value;\r\n}\r\n\r\nfunction setPixelValue(imageData: Uint8Array, offset: number, format: string, numChannels: number, value: number[]) {\r\n    for (let i = 0; i < numChannels; ++i) {\r\n      switch (format) {\r\n        case \"8unorm\":\r\n          imageData[offset] = value[i] * 255;\r\n          offset++;\r\n          break;\r\n        case \"8snorm\":\r\n          imageData[offset] = ((value[i] + 1.0) * 0.5) * 255;\r\n          offset++;\r\n          break;\r\n        case \"8uint\":\r\n          imageData[offset] = value[i];\r\n          offset++;\r\n          break;\r\n        case \"8sint\":\r\n          imageData[offset] = value[i] + 127;\r\n          offset++;\r\n          break;\r\n        case \"16uint\":\r\n          new Uint16Array(imageData.buffer, offset, 1)[0] = value[i];\r\n          offset += 2;\r\n          break;\r\n        case \"16sint\":\r\n          new Int16Array(imageData.buffer, offset, 1)[0] = value[i];\r\n          offset += 2;\r\n          break;\r\n        case \"16float\": {\r\n          const f16 = float32ToFloat16(value[i]);\r\n          new Uint16Array(imageData.buffer, offset, 1)[0] = f16;\r\n          offset += 2;\r\n          break;\r\n        }\r\n        case \"32uint\":\r\n          new Uint32Array(imageData.buffer, offset, 1)[0] = value[i];\r\n          offset += 4;\r\n          break;\r\n        case \"32sint\":\r\n          new Int32Array(imageData.buffer, offset, 1)[0] = value[i];\r\n          offset += 4;\r\n          break;\r\n        case \"32float\":\r\n          new Float32Array(imageData.buffer, offset, 1)[0] = value[i];\r\n          offset += 4;\r\n          break;\r\n      }\r\n    }\r\n    return value;\r\n}\r\n", "\r\nexport const TextureFormatInfo = {\r\n    \"r8unorm\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"r8snorm\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"r8uint\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"r8sint\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"rg8unorm\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n    \"rg8snorm\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n    \"rg8uint\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n    \"rg8sint\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n\r\n    \"rgba8unorm\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba8unorm-srgb\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba8snorm\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba8uint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba8sint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"bgra8unorm\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"bgra8unorm-srgb\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n\r\n    \"r16uint\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"r16sint\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"r16float\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n\r\n    \"rg16uint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n    \"rg16sint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n    \"rg16float\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n\r\n    \"rgba16uint\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba16sint\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba16float\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n\r\n    \"r32uint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"r32sint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"r32float\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n\r\n    \"rg32uint\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n    \"rg32sint\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n    \"rg32float\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n\r\n    \"rgba32uint\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba32sint\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba32float\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgb10a2uint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgb10a2unorm\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rg11b10ufloat\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n\r\n    // Depth Stencil Formats\r\n    \"stencil8\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": false, \"hasStencil\": true, \"channels\": 1 }, // bytesPerBlock is actually 1-4\r\n    \"depth16unorm\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": false, \"channels\": 1 },\r\n    \"depth24plus\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": false, \"depthOnlyFormat\": \"depth32float\", \"channels\": 1 },\r\n    \"depth24plus-stencil8\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": true, \"depthOnlyFormat\": \"depth32float\", \"channels\": 1 }, // bytesPerBlock is actually 4-8\r\n    \"depth32float\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": false, \"channels\": 1 },\r\n    \"depth32float-stencil8\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": true, \"stencilOnlyFormat\": \"depth32float\", \"channels\": 1 }, // bytesPerBlock is actually 5-8\r\n\r\n    // Packed Formats\r\n    \"rgb9e5ufloat\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n\r\n    // Compressed Formats\r\n    \"bc1-rgba-unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc1-rgba-unorm-srgb\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc2-rgba-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc2-rgba-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc3-rgba-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc3-rgba-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n\r\n    \"bc4-r-unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 1 },\r\n    \"bc4-r-snorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 1 },\r\n\r\n    \"bc5-rg-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 2 },\r\n    \"bc5-rg-snorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 2 },\r\n\r\n    \"bc6h-rgb-ufloat\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc6h-rgb-float\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc7-rgba-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc7-rgba-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \r\n    \"etc2-rgb8unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"etc2-rgb8unorm-srgb\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"etc2-rgb8a1unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"etc2-rgb8a1unorm-srgb\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"etc2-rgba8unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"etc2-rgba8unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \r\n    \"eac-r11unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": true, \"channels\": 1 },\r\n    \"eac-r11snorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": true, \"channels\": 1 },\r\n\r\n    \"eac-rg11unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": true, \"channels\": 2 },\r\n    \"eac-rg11snorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": true, \"channels\": 2 },\r\n\r\n    \"astc-4x4-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-4x4-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-5x4-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 5, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-5x4-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 5, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-5x5-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 5, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-5x5-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 5, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-6x5-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 6, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-6x5-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 6, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-6x6-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 6, \"blockHeight\": 6, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-6x6-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 6, \"blockHeight\": 6, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-8x5-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-8x5-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-8x6-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 6, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-8x6-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 6, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-8x8-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 8, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-8x8-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 8, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x5-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x5-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x6-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 6, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x6-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 6, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x8-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 8, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x8-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 8, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x10-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 10, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x10-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 10, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-12x10-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 12, \"blockHeight\": 10, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-12x10-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 12, \"blockHeight\": 10, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-12x12-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 12, \"blockHeight\": 12, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-12x12-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 12, \"blockHeight\": 12, \"isCompressed\": true, \"channels\": 4 },\r\n};\r\n", "import { WgslExec } from \"./wgsl_exec.js\";\r\nimport { TypeInfo, PointerInfo, TemplateInfo, ArrayInfo, StructInfo } from \"./reflect/info.js\";\r\nimport { ExecContext } from \"./exec/exec_context.js\";\r\nimport { ExecInterface } from \"./exec/exec_interface.js\";\r\nimport { setTexturePixel, getTexturePixel } from \"./utils/texture_sample.js\";\r\nimport { TextureFormatInfo } from \"./utils/texture_format_info.js\";\r\n\r\n/**\r\n * @class Node\r\n * @category AST\r\n * Base class for AST nodes parsed from a WGSL shader.\r\n */\r\nexport class Node {\r\n  static _id = 0;\r\n\r\n  id: number;\r\n  line: number;\r\n\r\n  constructor() {\r\n    this.id = Node._id++;\r\n    this.line = 0;\r\n  }\r\n\r\n  get isAstNode(): boolean {\r\n    return true;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    callback(this);\r\n  }\r\n\r\n  searchBlock(block: Node[] | null, callback: (node: Node) => void): void {\r\n    if (block) {\r\n      callback(_BlockStart.instance);\r\n      for (const node of block) {\r\n        if (node instanceof Array) {\r\n          this.searchBlock(node as Node[], callback);\r\n        } else {\r\n          node.search(callback);\r\n        }\r\n      }\r\n      callback(_BlockEnd.instance);\r\n    }\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    throw new Error(\"Cannot evaluate node\");\r\n  }\r\n\r\n  constEvaluateString(context: WgslExec): string {\r\n    return this.constEvaluate(context).toString();\r\n  } \r\n}\r\n\r\n// For internal use only\r\nexport class _BlockStart extends Node {\r\n  static instance = new _BlockStart();\r\n}\r\n\r\n // For internal use only\r\nexport class _BlockEnd extends Node {\r\n  static instance = new _BlockEnd();\r\n}\r\n\r\nconst BuiltinFunctionNames = new Set([\r\n  \"all\",\r\n  \"all\",\r\n  \"any\",\r\n  \"select\",\r\n  \"arrayLength\",\r\n  \"abs\",\r\n  \"acos\",\r\n  \"acosh\",\r\n  \"asin\",\r\n  \"asinh\",\r\n  \"atan\",\r\n  \"atanh\",\r\n  \"atan2\",\r\n  \"ceil\",\r\n  \"clamp\",\r\n  \"cos\",\r\n  \"cosh\",\r\n  \"countLeadingZeros\",\r\n  \"countOneBits\",\r\n  \"countTrailingZeros\",\r\n  \"cross\",\r\n  \"degrees\",\r\n  \"determinant\",\r\n  \"distance\",\r\n  \"dot\",\r\n  \"dot4U8Packed\",\r\n  \"dot4I8Packed\",\r\n  \"exp\",\r\n  \"exp2\",\r\n  \"extractBits\",\r\n  \"faceForward\",\r\n  \"firstLeadingBit\",\r\n  \"firstTrailingBit\",\r\n  \"floor\",\r\n  \"fma\",\r\n  \"fract\",\r\n  \"frexp\",\r\n  \"insertBits\",\r\n  \"inverseSqrt\",\r\n  \"ldexp\",\r\n  \"length\",\r\n  \"log\",\r\n  \"log2\",\r\n  \"max\",\r\n  \"min\",\r\n  \"mix\",\r\n  \"modf\",\r\n  \"normalize\",\r\n  \"pow\",\r\n  \"quantizeToF16\",\r\n  \"radians\",\r\n  \"reflect\",\r\n  \"refract\",\r\n  \"reverseBits\",\r\n  \"round\",\r\n  \"saturate\",\r\n  \"sign\",\r\n  \"sin\",\r\n  \"sinh\",\r\n  \"smoothStep\",\r\n  \"sqrt\",\r\n  \"step\",\r\n  \"tan\",\r\n  \"tanh\",\r\n  \"transpose\",\r\n  \"trunc\",\r\n  \"dpdx\",\r\n  \"dpdxCoarse\",\r\n  \"dpdxFine\",\r\n  \"dpdy\",\r\n  \"dpdyCoarse\",\r\n  \"dpdyFine\",\r\n  \"fwidth\",\r\n  \"fwidthCoarse\",\r\n  \"fwidthFine\",\r\n  \"textureDimensions\",\r\n  \"textureGather\",\r\n  \"textureGatherCompare\",\r\n  \"textureLoad\",\r\n  \"textureNumLayers\",\r\n  \"textureNumLevels\",\r\n  \"textureNumSamples\",\r\n  \"textureSample\",\r\n  \"textureSampleBias\",\r\n  \"textureSampleCompare\",\r\n  \"textureSampleCompareLevel\",\r\n  \"textureSampleGrad\",\r\n  \"textureSampleLevel\",\r\n  \"textureSampleBaseClampToEdge\",\r\n  \"textureStore\",\r\n  \"atomicLoad\",\r\n  \"atomicStore\",\r\n  \"atomicAdd\",\r\n  \"atomicSub\",\r\n  \"atomicMax\",\r\n  \"atomicMin\",\r\n  \"atomicAnd\",\r\n  \"atomicOr\",\r\n  \"atomicXor\",\r\n  \"atomicExchange\",\r\n  \"atomicCompareExchangeWeak\",\r\n  \"pack4x8snorm\",\r\n  \"pack4x8unorm\",\r\n  \"pack4xI8\",\r\n  \"pack4xU8\",\r\n  \"pack4x8Clamp\",\r\n  \"pack4xU8Clamp\",\r\n  \"pack2x16snorm\",\r\n  \"pack2x16unorm\",\r\n  \"pack2x16float\",\r\n  \"unpack4x8snorm\",\r\n  \"unpack4x8unorm\",\r\n  \"unpack4xI8\",\r\n  \"unpack4xU8\",\r\n  \"unpack2x16snorm\",\r\n  \"unpack2x16unorm\",\r\n  \"unpack2x16float\",\r\n  \"storageBarrier\",\r\n  \"textureBarrier\",\r\n  \"workgroupBarrier\",\r\n  \"workgroupUniformLoad\",\r\n  \"subgroupAdd\",\r\n  \"subgroupExclusiveAdd\",\r\n  \"subgroupInclusiveAdd\",\r\n  \"subgroupAll\",\r\n  \"subgroupAnd\",\r\n  \"subgroupAny\",\r\n  \"subgroupBallot\",\r\n  \"subgroupBroadcast\",\r\n  \"subgroupBroadcastFirst\",\r\n  \"subgroupElect\",\r\n  \"subgroupMax\",\r\n  \"subgroupMin\",\r\n  \"subgroupMul\",\r\n  \"subgroupExclusiveMul\",\r\n  \"subgroupInclusiveMul\",\r\n  \"subgroupOr\",\r\n  \"subgroupShuffle\",\r\n  \"subgroupShuffleDown\",\r\n  \"subgroupShuffleUp\",\r\n  \"subgroupShuffleXor\",\r\n  \"subgroupXor\",\r\n  \"quadBroadcast\",\r\n  \"quadSwapDiagonal\",\r\n  \"quadSwapX\",\r\n  \"quadSwapY\",\r\n]);\r\n\r\n/**\r\n * @class Statement\r\n * @extends Node\r\n * @category AST\r\n */\r\nexport class Statement extends Node {\r\n  constructor() {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * @class Function\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Function extends Statement {\r\n  name: string;\r\n  args: Argument[];\r\n  returnType: Type | null;\r\n  body: Statement[];\r\n  attributes: Attribute[] | null;\r\n  startLine: number;\r\n  endLine: number;\r\n  calls: Set<Function> = new Set();\r\n\r\n  constructor(\r\n    name: string,\r\n    args: Argument[],\r\n    returnType: Type | null,\r\n    body: Statement[],\r\n    startLine: number,\r\n    endLine: number\r\n  ) {\r\n    super();\r\n    this.name = name;\r\n    this.args = args;\r\n    this.returnType = returnType;\r\n    this.body = body;\r\n    this.startLine = startLine;\r\n    this.endLine = endLine;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"function\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    if (this.attributes) {\r\n      for (const attr of this.attributes) {\r\n        callback(attr);\r\n      }\r\n    }\r\n    callback(this);\r\n    for (const arg of this.args) {\r\n      callback(arg);\r\n    }\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class StaticAssert\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class StaticAssert extends Statement {\r\n  expression: Expression;\r\n\r\n  constructor(expression: Expression) {\r\n    super();\r\n    this.expression = expression;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"staticAssert\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.expression.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class While\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class While extends Statement {\r\n  condition: Expression;\r\n  body: Statement[];\r\n\r\n  constructor(condition: Expression, body: Statement[]) {\r\n    super();\r\n    this.condition = condition;\r\n    this.body = body;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"while\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.condition.search(callback);\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Continuing\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Continuing extends Statement {\r\n  body: Statement[];\r\n  loopId: number;\r\n\r\n  constructor(body: Statement[], loopId: number) {\r\n    super();\r\n    this.body = body;\r\n    this.loopId = loopId;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"continuing\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class For\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class For extends Statement {\r\n  init: Statement | null;\r\n  condition: Expression | null;\r\n  increment: Statement | null;\r\n  body: Statement[];\r\n\r\n  constructor(\r\n    init: Statement | null,\r\n    condition: Expression | null,\r\n    increment: Statement | null,\r\n    body: Statement[]\r\n  ) {\r\n    super();\r\n    this.init = init;\r\n    this.condition = condition;\r\n    this.increment = increment;\r\n    this.body = body;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"for\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.init?.search(callback);\r\n    this.condition?.search(callback);\r\n    this.increment?.search(callback);\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Var\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Var extends Statement {\r\n  name: string;\r\n  type: Type | null;\r\n  storage: string | null;\r\n  access: string | null;\r\n  value: Expression | null;\r\n  attributes: Attribute[] | null = null;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: Type | null,\r\n    storage: string | null,\r\n    access: string | null,\r\n    value: Expression | null\r\n  ) {\r\n    super();\r\n    this.name = name;\r\n    this.type = type;\r\n    this.storage = storage;\r\n    this.access = access;\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"var\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    callback(this);\r\n    this.value?.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Override\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Override extends Statement {\r\n  name: string;\r\n  type: Type | null;\r\n  value: Expression | null;\r\n  attributes: Attribute[] | null = null;\r\n\r\n  constructor(name: string, type: Type | null, value: Expression | null) {\r\n    super();\r\n    this.name = name;\r\n    this.type = type;\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"override\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.value?.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Let\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Let extends Statement {\r\n  name: string;\r\n  type: Type | null;\r\n  storage: string | null;\r\n  access: string | null;\r\n  value: Expression | null;\r\n  attributes: Attribute[] | null = null;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: Type | null,\r\n    storage: string | null,\r\n    access: string | null,\r\n    value: Expression | null\r\n  ) {\r\n    super();\r\n    this.name = name;\r\n    this.type = type;\r\n    this.storage = storage;\r\n    this.access = access;\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"let\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    callback(this);\r\n    this.value?.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Const\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Const extends Statement {\r\n  name: string;\r\n  type: Type | null;\r\n  storage: string | null;\r\n  access: string | null;\r\n  value: Expression;\r\n  attributes: Attribute[] | null = null;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: Type | null,\r\n    storage: string | null,\r\n    access: string | null,\r\n    value: Expression\r\n  ) {\r\n    super();\r\n    this.name = name;\r\n    this.type = type;\r\n    this.storage = storage;\r\n    this.access = access;\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"const\";\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    return this.value.constEvaluate(context, type);\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    callback(this);\r\n    this.value?.search(callback);\r\n  }\r\n}\r\n\r\nexport enum IncrementOperator {\r\n  increment = \"++\",\r\n  decrement = \"--\",\r\n}\r\n\r\nexport namespace IncrementOperator {\r\n  export function parse(val: string): IncrementOperator {\r\n    const key = val as keyof typeof IncrementOperator;\r\n    if (key == \"parse\") throw new Error(\"Invalid value for IncrementOperator\");\r\n    return IncrementOperator[key];\r\n  }\r\n}\r\n\r\n/**\r\n * @class Increment\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Increment extends Statement {\r\n  operator: IncrementOperator;\r\n  variable: Expression;\r\n\r\n  constructor(operator: IncrementOperator, variable: Expression) {\r\n    super();\r\n    this.operator = operator;\r\n    this.variable = variable;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"increment\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.variable.search(callback);\r\n  }\r\n}\r\n\r\nexport enum AssignOperator {\r\n  assign = \"=\",\r\n  addAssign = \"+=\",\r\n  subtractAssin = \"-=\",\r\n  multiplyAssign = \"*=\",\r\n  divideAssign = \"/=\",\r\n  moduloAssign = \"%=\",\r\n  andAssign = \"&=\",\r\n  orAssign = \"|=\",\r\n  xorAssign = \"^=\",\r\n  shiftLeftAssign = \"<<=\",\r\n  shiftRightAssign = \">>=\",\r\n}\r\n\r\nexport namespace AssignOperator {\r\n  export function parse(val: string): AssignOperator {\r\n    const key = val as keyof typeof AssignOperator;\r\n    if (key == \"parse\") {\r\n      throw new Error(\"Invalid value for AssignOperator\");\r\n    }\r\n    //return AssignOperator[key];\r\n    return key as AssignOperator;\r\n  }\r\n}\r\n\r\n/**\r\n * @class Assign\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Assign extends Statement {\r\n  operator: AssignOperator;\r\n  variable: Expression;\r\n  value: Expression;\r\n\r\n  constructor(\r\n    operator: AssignOperator,\r\n    variable: Expression,\r\n    value: Expression\r\n  ) {\r\n    super();\r\n    this.operator = operator;\r\n    this.variable = variable;\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"assign\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.variable.search(callback);\r\n    this.value.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Call\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Call extends Statement {\r\n  name: string;\r\n  args: Expression[];\r\n\r\n  constructor(name: string, args: Expression[]) {\r\n    super();\r\n    this.name = name;\r\n    this.args = args;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"call\";\r\n  }\r\n\r\n  isBuiltin(): boolean {\r\n    return BuiltinFunctionNames.has(this.name);\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    for (const node of this.args) {\r\n      node.search(callback);\r\n    }\r\n    callback(this);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Loop\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Loop extends Statement {\r\n  body: Statement[];\r\n  continuing: Continuing | null;\r\n\r\n  constructor(body: Statement[], continuing: Continuing | null) {\r\n    super();\r\n    this.body = body;\r\n    this.continuing = continuing;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"loop\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.searchBlock(this.body, callback);\r\n    this.continuing?.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Switch\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Switch extends Statement {\r\n  condition: Expression;\r\n  cases: SwitchCase[];\r\n\r\n  constructor(condition: Expression, cases: SwitchCase[]) {\r\n    super();\r\n    this.condition = condition;\r\n    this.cases = cases;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"switch\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    callback(this);\r\n    for (const node of this.cases) {\r\n      node.search(callback);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @class If\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class If extends Statement {\r\n  condition: Expression;\r\n  body: Statement[];\r\n  elseif: ElseIf[] | null;\r\n  else: Statement[] | null;\r\n\r\n  constructor(\r\n    condition: Expression,\r\n    body: Statement[],\r\n    elseif: ElseIf[] | null,\r\n    _else: Statement[] | null\r\n  ) {\r\n    super();\r\n    this.condition = condition;\r\n    this.body = body;\r\n    this.elseif = elseif;\r\n    this.else = _else;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"if\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.condition.search(callback);\r\n    this.searchBlock(this.body, callback);\r\n    this.searchBlock(this.elseif, callback);\r\n    this.searchBlock(this.else, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Return\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Return extends Statement {\r\n  value: Expression;\r\n\r\n  constructor(value: Expression) {\r\n    super();\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"return\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.value?.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Enable\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Enable extends Statement {\r\n  name: string;\r\n\r\n  constructor(name: string) {\r\n    super();\r\n    this.name = name;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"enable\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Requires\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Requires extends Statement {\r\n  extensions: string[];\r\n\r\n  constructor(extensions: string[]) {\r\n    super();\r\n    this.extensions = extensions;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"requires\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Diagnostic\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Diagnostic extends Statement {\r\n  severity: string;\r\n  rule: string;\r\n\r\n  constructor(severity: string, rule: string) {\r\n    super();\r\n    this.severity = severity;\r\n    this.rule = rule;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"diagnostic\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Alias\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Alias extends Statement {\r\n  name: string;\r\n  type: Type;\r\n\r\n  constructor(name: string, type: Type) {\r\n    super();\r\n    this.name = name;\r\n    this.type = type;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"alias\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Discard\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Discard extends Statement {\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"discard\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Break\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Break extends Statement {\r\n  condition: Expression | null = null;\r\n  loopId: number = -1;\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"break\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Continue\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Continue extends Statement {\r\n  loopId: number = -1;\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"continue\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Type\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Type extends Statement {\r\n  name: string;\r\n  attributes: Attribute[] | null = null;\r\n\r\n  constructor(name: string) {\r\n    super();\r\n    this.name = name;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"type\";\r\n  }\r\n\r\n  get isStruct(): boolean {\r\n    return false;\r\n  }\r\n\r\n  get isArray(): boolean {\r\n    return false;\r\n  }\r\n\r\n  static x32 = new Type(\"x32\");\r\n  static f32 = new Type(\"f32\");\r\n  static i32 = new Type(\"i32\");\r\n  static u32 = new Type(\"u32\");\r\n  static f16 = new Type(\"f16\");\r\n  static bool = new Type(\"bool\");\r\n  static void = new Type(\"void\");\r\n\r\n  static _priority = new Map<string, number>([[\"f32\", 0], [\"f16\", 1], [\"u32\", 2], [\"i32\", 3], [\"x32\", 3]]);\r\n\r\n  static maxFormatType(x: Type[]): Type {\r\n    let t = x[0];\r\n    if (t.name === \"f32\") {\r\n      return t;\r\n    }\r\n    for (let i = 1; i < x.length; ++i) {\r\n      const tv = Type._priority.get(t.name);\r\n      const xv = Type._priority.get(x[i].name);\r\n      if (xv < tv) {\r\n        t = x[i];\r\n      }\r\n    }\r\n\r\n    if (t.name === \"x32\") {\r\n      return Type.i32;\r\n    }\r\n\r\n    return t;\r\n  }\r\n\r\n  getTypeName(): string {\r\n    return this.name;\r\n  }\r\n}\r\n\r\n/**\r\n * @class ForwardType\r\n * @extends Type\r\n * @category AST\r\n * Internal type used as a placeholder for a type being used before it has been defined.\r\n */\r\nexport class ForwardType extends Type {\r\n  constructor(name: string) {\r\n    super(name);\r\n  }\r\n}\r\n\r\n/**\r\n * @class StructType\r\n * @extends Type\r\n * @category AST\r\n */\r\nexport class Struct extends Type {\r\n  members: Member[];\r\n  startLine: number;\r\n  endLine: number;\r\n\r\n  constructor(name: string, members: Member[], startLine: number, endLine: number) {\r\n    super(name);\r\n    this.members = members;\r\n    this.startLine = startLine;\r\n    this.endLine = endLine;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"struct\";\r\n  }\r\n\r\n  get isStruct(): boolean {\r\n    return true;\r\n  }\r\n\r\n  /// Return the index of the member with the given name, or -1 if not found.\r\n  getMemberIndex(name: string): number {\r\n    for (let i = 0; i < this.members.length; i++) {\r\n      if (this.members[i].name == name) return i;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    for (const member of this.members) {\r\n      callback(member);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @class TemplateType\r\n * @extends Type\r\n * @category AST\r\n */\r\nexport class TemplateType extends Type {\r\n  format: Type | null;\r\n  access: string | null;\r\n\r\n  constructor(name: string, format: Type | null, access: string | null) {\r\n    super(name);\r\n    this.format = format;\r\n    this.access = access;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"template\";\r\n  }\r\n\r\n  getTypeName(): string {\r\n    let name = this.name;\r\n    if (this.format !== null) {\r\n      if (name === \"vec2\" || name === \"vec3\" || name === \"vec4\" ||\r\n          name === \"mat2x2\" || name === \"mat2x3\" || name === \"mat2x4\" ||\r\n          name === \"mat3x2\" || name === \"mat3x3\" || name === \"mat3x4\" ||\r\n          name === \"mat4x2\" || name === \"mat4x3\" || name === \"mat4x4\") {\r\n        if (this.format.name === \"f32\") {\r\n          name += \"f\";\r\n          return name;\r\n        } else if (this.format.name === \"i32\") {\r\n          name += \"i\";\r\n          return name;\r\n        } else if (this.format.name === \"u32\") {\r\n          name += \"u\";\r\n          return name;\r\n        } else if (this.format.name === \"bool\") {\r\n          name += \"b\";\r\n          return name;\r\n        } else if (this.format.name === \"f16\") {\r\n          name += \"h\";\r\n          return name;\r\n        }\r\n      }\r\n      name += `<${this.format.name}>`;\r\n    } else {\r\n      if (name === \"vec2\" || name === \"vec3\" || name === \"vec4\") {\r\n        return name;\r\n      }\r\n      //console.error(\"Template format is null.\");\r\n    }\r\n    return name;\r\n  }\r\n\r\n  static vec2f = new TemplateType(\"vec2\", Type.f32, null);\r\n  static vec3f = new TemplateType(\"vec3\", Type.f32, null);\r\n  static vec4f = new TemplateType(\"vec4\", Type.f32, null);\r\n  static vec2i = new TemplateType(\"vec2\", Type.i32, null);\r\n  static vec3i = new TemplateType(\"vec3\", Type.i32, null);\r\n  static vec4i = new TemplateType(\"vec4\", Type.i32, null);\r\n  static vec2u = new TemplateType(\"vec2\", Type.u32, null);\r\n  static vec3u = new TemplateType(\"vec3\", Type.u32, null);\r\n  static vec4u = new TemplateType(\"vec4\", Type.u32, null);\r\n  static vec2h = new TemplateType(\"vec2\", Type.f16, null);\r\n  static vec3h = new TemplateType(\"vec3\", Type.f16, null);\r\n  static vec4h = new TemplateType(\"vec4\", Type.f16, null);\r\n  static vec2b = new TemplateType(\"vec2\", Type.bool, null);\r\n  static vec3b = new TemplateType(\"vec3\", Type.bool, null);\r\n  static vec4b = new TemplateType(\"vec4\", Type.bool, null);\r\n\r\n  static mat2x2f = new TemplateType(\"mat2x2\", Type.f32, null);\r\n  static mat2x3f = new TemplateType(\"mat2x3\", Type.f32, null);\r\n  static mat2x4f = new TemplateType(\"mat2x4\", Type.f32, null);\r\n  static mat3x2f = new TemplateType(\"mat3x2\", Type.f32, null);\r\n  static mat3x3f = new TemplateType(\"mat3x3\", Type.f32, null);\r\n  static mat3x4f = new TemplateType(\"mat3x4\", Type.f32, null);\r\n  static mat4x2f = new TemplateType(\"mat4x2\", Type.f32, null);\r\n  static mat4x3f = new TemplateType(\"mat4x3\", Type.f32, null);\r\n  static mat4x4f = new TemplateType(\"mat4x4\", Type.f32, null);\r\n\r\n  static mat2x2h = new TemplateType(\"mat2x2\", Type.f16, null);\r\n  static mat2x3h = new TemplateType(\"mat2x3\", Type.f16, null);\r\n  static mat2x4h = new TemplateType(\"mat2x4\", Type.f16, null);\r\n  static mat3x2h = new TemplateType(\"mat3x2\", Type.f16, null);\r\n  static mat3x3h = new TemplateType(\"mat3x3\", Type.f16, null);\r\n  static mat3x4h = new TemplateType(\"mat3x4\", Type.f16, null);\r\n  static mat4x2h = new TemplateType(\"mat4x2\", Type.f16, null);\r\n  static mat4x3h = new TemplateType(\"mat4x3\", Type.f16, null);\r\n  static mat4x4h = new TemplateType(\"mat4x4\", Type.f16, null);\r\n\r\n  static mat2x2i = new TemplateType(\"mat2x2\", Type.i32, null);\r\n  static mat2x3i = new TemplateType(\"mat2x3\", Type.i32, null);\r\n  static mat2x4i = new TemplateType(\"mat2x4\", Type.i32, null);\r\n  static mat3x2i = new TemplateType(\"mat3x2\", Type.i32, null);\r\n  static mat3x3i = new TemplateType(\"mat3x3\", Type.i32, null);\r\n  static mat3x4i = new TemplateType(\"mat3x4\", Type.i32, null);\r\n  static mat4x2i = new TemplateType(\"mat4x2\", Type.i32, null);\r\n  static mat4x3i = new TemplateType(\"mat4x3\", Type.i32, null);\r\n  static mat4x4i = new TemplateType(\"mat4x4\", Type.i32, null);\r\n\r\n  static mat2x2u = new TemplateType(\"mat2x2\", Type.u32, null);\r\n  static mat2x3u = new TemplateType(\"mat2x3\", Type.u32, null);\r\n  static mat2x4u = new TemplateType(\"mat2x4\", Type.u32, null);\r\n  static mat3x2u = new TemplateType(\"mat3x2\", Type.u32, null);\r\n  static mat3x3u = new TemplateType(\"mat3x3\", Type.u32, null);\r\n  static mat3x4u = new TemplateType(\"mat3x4\", Type.u32, null);\r\n  static mat4x2u = new TemplateType(\"mat4x2\", Type.u32, null);\r\n  static mat4x3u = new TemplateType(\"mat4x3\", Type.u32, null);\r\n  static mat4x4u = new TemplateType(\"mat4x4\", Type.u32, null);\r\n}\r\n\r\n/**\r\n * @class PointerType\r\n * @extends Type\r\n * @category AST\r\n */\r\nexport class PointerType extends Type {\r\n  storage: string;\r\n  type: Type | null;\r\n  access: string | null;\r\n\r\n  constructor(\r\n    name: string,\r\n    storage: string,\r\n    type: Type | null,\r\n    access: string | null\r\n  ) {\r\n    super(name);\r\n    this.storage = storage;\r\n    this.type = type;\r\n    this.access = access;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"pointer\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class ArrayType\r\n * @extends Type\r\n * @category AST\r\n */\r\nexport class ArrayType extends Type {\r\n  attributes: Attribute[] | null;\r\n  format: Type | null;\r\n  count: number;\r\n\r\n  constructor(\r\n    name: string,\r\n    attributes: Attribute[] | null,\r\n    format: Type | null,\r\n    count: number\r\n  ) {\r\n    super(name);\r\n    this.attributes = attributes;\r\n    this.format = format;\r\n    this.count = count;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"array\";\r\n  }\r\n\r\n  get isArray(): boolean {\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * @class SamplerType\r\n * @extends Type\r\n * @category AST\r\n */\r\nexport class SamplerType extends Type {\r\n  format: Type | string | null;\r\n  access: string | null;\r\n\r\n  constructor(\r\n    name: string,\r\n    format: Type | string | null,\r\n    access: string | null\r\n  ) {\r\n    super(name);\r\n    this.format = format;\r\n    this.access = access;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"sampler\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Expression\r\n * @extends Node\r\n * @category AST\r\n */\r\nexport class Expression extends Node {\r\n  postfix: Expression | null = null;\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * @class StringExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class StringExpr extends Expression {\r\n  value: string;\r\n\r\n  constructor(value: string) {\r\n    super();\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"stringExpr\";\r\n  }\r\n\r\n  toString(): string {\r\n    return this.value;\r\n  }\r\n\r\n  constEvaluateString(): string {\r\n    return this.value;\r\n  }\r\n}\r\n\r\n/**\r\n * @class CreateExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class CreateExpr extends Expression {\r\n  type: Type | null;\r\n  args: Expression[] | null;\r\n\r\n  constructor(type: Type | null, args: Expression[] | null) {\r\n    super();\r\n    this.type = type;\r\n    this.args = args;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"createExpr\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    callback(this);\r\n    if (this.args) {\r\n      for (const node of this.args) {\r\n        node.search(callback);\r\n      }\r\n    }\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    if (type) {\r\n      type[0] = this.type;\r\n    }\r\n    return context.evalExpression(this, context.context);\r\n  }\r\n}\r\n\r\n/**\r\n * @class CallExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class CallExpr extends Expression {\r\n  name: string;\r\n  args: Expression[] | null;\r\n  cachedReturnValue: any = null;\r\n\r\n  constructor(name: string, args: Expression[] | null) {\r\n    super();\r\n    this.name = name;\r\n    this.args = args;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"callExpr\";\r\n  }\r\n\r\n  setCachedReturnValue(value: any): void {\r\n    this.cachedReturnValue = value;\r\n  }\r\n\r\n  get isBuiltin(): boolean {\r\n    return BuiltinFunctionNames.has(this.name);\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data {\r\n    return context.evalExpression(this, context.context);\r\n  }\r\n\r\n  search(callback: (node: Node) => void) {\r\n    for (const node of this.args) {\r\n      node.search(callback);\r\n    }\r\n    callback(this);\r\n  }\r\n}\r\n\r\n/**\r\n * @class VariableExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class VariableExpr extends Expression {\r\n  name: string;\r\n\r\n  constructor(name: string) {\r\n    super();\r\n    this.name = name;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"varExpr\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void) {\r\n    callback(this);\r\n    if (this.postfix) {\r\n      this.postfix.search(callback);\r\n    }\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data {\r\n    return context.evalExpression(this, context.context);\r\n  }\r\n}\r\n\r\n/**\r\n * @class ConstExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class ConstExpr extends Expression {\r\n  name: string;\r\n  initializer: Expression;\r\n\r\n  constructor(name: string, initializer: Expression) {\r\n    super();\r\n    this.name = name;\r\n    this.initializer = initializer;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"constExpr\";\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    if (this.initializer) {\r\n      const data = context.evalExpression(this.initializer, context.context);\r\n      if (data !== null && this.postfix) {\r\n        return data.getSubData(context, this.postfix, context.context);\r\n      }\r\n      return data;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.initializer.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class LiteralExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class LiteralExpr extends Expression {\r\n  value: Data\r\n  type: Type;\r\n\r\n  constructor(value: Data, type: Type) {\r\n    super();\r\n    this.value = value;\r\n    this.type = type;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"literalExpr\";\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    if (type !== undefined) {\r\n      type[0] = this.type;\r\n    }\r\n    return this.value;\r\n  }\r\n\r\n  get isScalar(): boolean {\r\n    return this.value instanceof ScalarData;\r\n  }\r\n\r\n  get isVector(): boolean {\r\n    return this.value instanceof VectorData || this.value instanceof MatrixData;\r\n  }\r\n\r\n  get scalarValue(): number {\r\n    if (this.value instanceof ScalarData) {\r\n      return this.value.value;\r\n    }\r\n    console.error(\"Value is not scalar.\");\r\n    return 0.0;\r\n  }\r\n\r\n  get vectorValue(): Float32Array | Int32Array | Uint32Array {\r\n    if (this.value instanceof VectorData) {\r\n      return this.value.data;\r\n    }\r\n    if (this.value instanceof MatrixData) {\r\n      return this.value.data;\r\n    }\r\n    console.error(\"Value is not a vector or matrix.\");\r\n    return new Float32Array(0);\r\n  }\r\n}\r\n\r\n/**\r\n * @class BitcastExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class BitcastExpr extends Expression {\r\n  type: Type | null;\r\n  value: Expression;\r\n\r\n  constructor(type: Type | null, value: Expression) {\r\n    super();\r\n    this.type = type;\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"bitcastExpr\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.value.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class TypecastExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class TypecastExpr extends Expression {\r\n  type: Type | null;\r\n  args: Expression[] | null;\r\n\r\n  constructor(type: Type | null, args: Expression[] | null) {\r\n    super();\r\n    this.type = type;\r\n    this.args = args;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"typecastExpr\";\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    return context.evalExpression(this, context.context);\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.searchBlock(this.args, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class ArrayIndex\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class ArrayIndex extends Expression {\r\n  index: Expression;\r\n  constructor(index: Expression) {\r\n    super();\r\n    this.index = index;\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.index.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Operator\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class Operator extends Expression {\r\n  constructor() {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * @class UnaryOperator\r\n * @extends Operator\r\n * @category AST\r\n * @property {string} operator +, -, !, ~\r\n */\r\nexport class UnaryOperator extends Operator {\r\n  operator: string;\r\n  right: Expression;\r\n\r\n  constructor(operator: string, right: Expression) {\r\n    super();\r\n    this.operator = operator;\r\n    this.right = right;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"unaryOp\";\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    return context.evalExpression(this, context.context);\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.right.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class BinaryOperator\r\n * @extends Operator\r\n * @category AST\r\n * @property {string} operator +, -, *, /, %, ==, !=, <, >, <=, >=, &&, ||\r\n */\r\nexport class BinaryOperator extends Operator {\r\n  operator: string;\r\n  left: Expression;\r\n  right: Expression;\r\n\r\n  constructor(operator: string, left: Expression, right: Expression) {\r\n    super();\r\n    this.operator = operator;\r\n    this.left = left;\r\n    this.right = right;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"binaryOp\";\r\n  }\r\n\r\n  _getPromotedType(t1: Type, t2: Type): Type {\r\n    if (t1.name === t2.name) {\r\n      return t1;\r\n    }\r\n    if (t1.name === \"f32\" || t2.name === \"f32\") {\r\n      return Type.f32;\r\n    }\r\n    if (t1.name === \"u32\" || t2.name === \"u32\") {\r\n      return Type.u32;\r\n    }\r\n    return Type.i32;\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    return context.evalExpression(this, context.context);\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.left.search(callback);\r\n    this.right.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class SwitchCase\r\n * @extends Node\r\n * @category AST\r\n */\r\nexport class SwitchCase extends Node {\r\n  body: Statement[];\r\n\r\n  constructor(body: Statement[]) {\r\n    super();\r\n    this.body = body;\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    callback(this);\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\nexport class DefaultSelector extends Expression {\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"default\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Case\r\n * @extends SwitchCase\r\n * @category AST\r\n */\r\nexport class Case extends SwitchCase {\r\n  selectors: Expression[];\r\n\r\n  constructor(selectors: Expression[], body: Statement[]) {\r\n    super(body);\r\n    this.selectors = selectors;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"case\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Default\r\n * @extends SwitchCase\r\n * @category AST\r\n */\r\nexport class Default extends SwitchCase {\r\n  constructor(body: Statement[]) {\r\n    super(body);\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"default\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Argument\r\n * @extends Node\r\n * @category AST\r\n */\r\nexport class Argument extends Node {\r\n  name: string;\r\n  type: Type;\r\n  attributes: Attribute[] | null;\r\n\r\n  constructor(name: string, type: Type, attributes: Attribute[] | null) {\r\n    super();\r\n    this.name = name;\r\n    this.type = type;\r\n    this.attributes = attributes;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"argument\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class ElseIf\r\n * @extends Node\r\n * @category AST\r\n */\r\nexport class ElseIf extends Node {\r\n  condition: Expression;\r\n  body: Statement[];\r\n\r\n  constructor(condition: Expression, body: Statement[]) {\r\n    super();\r\n    this.condition = condition;\r\n    this.body = body;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"elseif\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.condition.search(callback);\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Member\r\n * @extends Node\r\n * @category AST\r\n */\r\nexport class Member extends Node {\r\n  name: string;\r\n  type: Type | null;\r\n  attributes: Attribute[] | null;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: Type | null,\r\n    attributes: Attribute[] | null\r\n  ) {\r\n    super();\r\n    this.name = name;\r\n    this.type = type;\r\n    this.attributes = attributes;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"member\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Attribute\r\n * @extends Node\r\n * @category AST\r\n */\r\nexport class Attribute extends Node {\r\n  name: string;\r\n  value: string | string[] | null;\r\n\r\n  constructor(name: string, value: string | string[] | null) {\r\n    super();\r\n    this.name = name;\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"attribute\";\r\n  }\r\n}\r\n\r\n\r\n\r\nexport class Data {\r\n  static _id = 0;\r\n\r\n  typeInfo: TypeInfo;\r\n  parent: Data | null = null;\r\n  id: number;\r\n\r\n  constructor(typeInfo: TypeInfo, parent: Data | null) {\r\n      this.typeInfo = typeInfo;\r\n      this.parent = parent;\r\n      this.id = Data._id++;\r\n  }\r\n\r\n  clone(): Data {\r\n    throw `Clone: Not implemented for ${this.constructor.name}`;\r\n  }\r\n\r\n  setDataValue(exec: ExecInterface, value: Data, postfix: Expression | null, context: ExecContext): void {\r\n      console.error(`SetDataValue: Not implemented for ${this.constructor.name}`);\r\n  }\r\n\r\n  getSubData(exec: ExecInterface, postfix: Expression | null, context: ExecContext): Data | null {\r\n      console.error(`GetDataValue: Not implemented for ${this.constructor.name}`);\r\n      return null;\r\n  }\r\n\r\n  toString(): string {\r\n      return `<${this.typeInfo.getTypeName()}>`;\r\n  }\r\n}\r\n\r\nexport class VoidData extends Data {\r\n  constructor() {\r\n      super(new TypeInfo(\"void\", null), null);\r\n  }\r\n\r\n  static void = new VoidData();\r\n\r\n  toString(): string {\r\n      return \"void\";\r\n  }\r\n}\r\n\r\nexport class PointerData extends Data {\r\n  reference: Data;\r\n\r\n  constructor(reference: Data) {\r\n    super(new PointerInfo(\"pointer\", reference.typeInfo, null), null);\r\n    this.reference = reference;\r\n  }\r\n\r\n  clone(): Data {\r\n    return this;\r\n  }\r\n\r\n  setDataValue(exec: ExecInterface, value: Data, postfix: Expression | null, context: ExecContext): void {\r\n    this.reference.setDataValue(exec, value, postfix, context);\r\n  }\r\n\r\n  getSubData(exec: ExecInterface, postfix: Expression | null, context: ExecContext): Data | null {\r\n    if (postfix) {\r\n      return this.reference.getSubData(exec, postfix, context);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  toString() {\r\n    return `&${this.reference.toString()}`;\r\n  }\r\n}\r\n\r\nexport class ScalarData extends Data {\r\n  data: Int32Array | Uint32Array | Float32Array;\r\n\r\n  constructor(value: number | Int32Array | Uint32Array | Float32Array, typeInfo: TypeInfo, parent: Data | null = null) {\r\n    super(typeInfo, parent);\r\n    if (value instanceof Int32Array || value instanceof Uint32Array || value instanceof Float32Array) {\r\n        this.data = value;\r\n    } else {\r\n      if (this.typeInfo.name === \"x32\") {\r\n        if (value - Math.floor(value) !== 0) {\r\n          this.data = new Float32Array([value]);\r\n        } else if (value >= 0) {\r\n            this.data = new Uint32Array([value]);\r\n        } else {\r\n            this.data = new Int32Array([value]);\r\n        } \r\n      } else if (this.typeInfo.name === \"i32\" || this.typeInfo.name === \"bool\") {\r\n          this.data = new Int32Array([value]);\r\n      } else if (this.typeInfo.name === \"u32\") {\r\n          this.data = new Uint32Array([value]);\r\n      } else if (this.typeInfo.name === \"f32\" || this.typeInfo.name === \"f16\") {\r\n          this.data = new Float32Array([value]);\r\n      } else {\r\n          console.error(`ScalarData2: Invalid type`, typeInfo);\r\n      }\r\n    }\r\n  }\r\n\r\n  clone(): Data {\r\n    if (this.data instanceof Float32Array) {\r\n        return new ScalarData(new Float32Array(this.data), this.typeInfo, null);\r\n    } else if (this.data instanceof Int32Array) {\r\n        return new ScalarData(new Int32Array(this.data), this.typeInfo, null);\r\n    } else if (this.data instanceof Uint32Array) {\r\n        return new ScalarData(new Uint32Array(this.data), this.typeInfo, null);\r\n    }\r\n    throw `ScalarData: Invalid data type`;\r\n  }\r\n\r\n  get value(): number {\r\n    return this.data[0];\r\n  }\r\n\r\n  set value(v: number) {\r\n    this.data[0] = v;\r\n  }\r\n\r\n  setDataValue(exec: ExecInterface, value: Data, postfix: Expression | null, context: ExecContext): void {\r\n    if (postfix) {\r\n      console.error(`SetDataValue: Scalar data does not support postfix`, postfix);\r\n      return;\r\n    }\r\n\r\n    if (!(value instanceof ScalarData)) {\r\n      console.error(`SetDataValue: Invalid value`, value);\r\n      return;\r\n    }\r\n\r\n    let v = value.data[0];\r\n\r\n    if (this.typeInfo.name === \"i32\" || this.typeInfo.name === \"u32\") {\r\n      v = Math.floor(v);\r\n    } else if (this.typeInfo.name === \"bool\") {\r\n      v = v ? 1 : 0;\r\n    }\r\n\r\n    this.data[0] = v;\r\n  }\r\n\r\n  getSubData(exec: ExecInterface, postfix: Expression | null, context: ExecContext): Data | null {\r\n    if (postfix) {\r\n      console.error(`getSubData: Scalar data does not support postfix`, postfix);\r\n      return null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  toString(): string {\r\n    return `${this.value}`;\r\n  }\r\n}\r\n\r\nfunction _getVectorData(exec: ExecInterface, values: number[], formatName: string): VectorData | null {\r\n  const size = values.length;\r\n  if (size === 2) {\r\n      if (formatName === \"f32\") {\r\n          return new VectorData(new Float32Array(values), exec.getTypeInfo(\"vec2f\")!);\r\n      } else if (formatName === \"i32\" || formatName === \"bool\") {\r\n          return new VectorData(new Int32Array(values), exec.getTypeInfo(\"vec2i\")!);\r\n      } else if (formatName === \"u32\") {\r\n          return new VectorData(new Uint32Array(values), exec.getTypeInfo(\"vec2u\")!);\r\n      } else if (formatName === \"f16\") {\r\n          return new VectorData(new Float32Array(values), exec.getTypeInfo(\"vec2h\")!);\r\n      } else {\r\n          console.error(`getSubData: Unknown format ${formatName}`);\r\n      }\r\n      return null;\r\n  }\r\n\r\n  if (size === 3) {\r\n      if (formatName === \"f32\") {\r\n          return new VectorData(new Float32Array(values), exec.getTypeInfo(\"vec3f\")!);\r\n      } else if (formatName === \"i32\" || formatName === \"bool\") {\r\n          return new VectorData(new Int32Array(values), exec.getTypeInfo(\"vec3i\")!);\r\n      } else if (formatName === \"u32\") {\r\n          return new VectorData(new Uint32Array(values), exec.getTypeInfo(\"vec3u\")!);\r\n      } else if (formatName === \"f16\") {\r\n          return new VectorData(new Float32Array(values), exec.getTypeInfo(\"vec3h\")!);\r\n      } else {\r\n          console.error(`getSubData: Unknown format ${formatName}`);\r\n      }\r\n      return null;\r\n  }\r\n\r\n  if (size === 4) {\r\n      if (formatName === \"f32\") {\r\n          return new VectorData(new Float32Array(values), exec.getTypeInfo(\"vec4f\")!);\r\n      } else if (formatName === \"i32\" || formatName === \"bool\") {\r\n          return new VectorData(new Int32Array(values), exec.getTypeInfo(\"vec4i\")!);\r\n      } else if (formatName === \"u32\") {\r\n          return new VectorData(new Uint32Array(values), exec.getTypeInfo(\"vec4u\")!);\r\n      } else if (formatName === \"f16\") {\r\n          return new VectorData(new Float32Array(values), exec.getTypeInfo(\"vec4h\")!);\r\n      }\r\n      console.error(`getSubData: Unknown format ${formatName}`);\r\n      return null;\r\n  }\r\n\r\n  console.error(`getSubData: Invalid vector size ${values.length}`);\r\n  return null;\r\n}\r\n\r\nexport class VectorData extends Data {\r\n  data: Int32Array | Uint32Array | Float32Array;\r\n\r\n  constructor(value: number[] | Float32Array | Uint32Array | Int32Array, typeInfo: TypeInfo, parent: Data | null = null) {\r\n    super(typeInfo, parent);\r\n    if (value instanceof Float32Array || value instanceof Uint32Array || value instanceof Int32Array) {\r\n      this.data = value;\r\n    } else {\r\n      const typename = this.typeInfo.name;\r\n      if (typename === \"vec2f\" || typename === \"vec3f\" || typename === \"vec4f\") {\r\n        this.data = new Float32Array(value);\r\n      } else if (typename === \"vec2i\" || typename === \"vec3i\" || typename === \"vec4i\") {\r\n        this.data = new Int32Array(value);\r\n      } else if (typename === \"vec2u\" || typename === \"vec3u\" || typename === \"vec4u\") {\r\n        this.data = new Uint32Array(value);\r\n      } else if (typename === \"vec2h\" || typename === \"vec3h\" || typename === \"vec4h\") {\r\n        this.data = new Float32Array(value);\r\n      } else if (typename === \"vec2b\" || typename === \"vec3b\" || typename === \"vec4b\") {\r\n        this.data = new Int32Array(value);\r\n      } else if (typename === \"vec2\" || typename === \"vec3\" || typename === \"vec4\") {\r\n        this.data = new Float32Array(value);\r\n      } else {\r\n        console.error(`VectorData: Invalid type ${typename}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  clone(): Data {\r\n    if (this.data instanceof Float32Array) {\r\n      return new VectorData(new Float32Array(this.data), this.typeInfo, null);\r\n    } else if (this.data instanceof Int32Array) {\r\n      return new VectorData(new Int32Array(this.data), this.typeInfo, null);\r\n    } else if (this.data instanceof Uint32Array) {\r\n      return new VectorData(new Uint32Array(this.data), this.typeInfo, null);\r\n    }\r\n    throw `VectorData: Invalid data type`;\r\n  }\r\n\r\n  setDataValue(exec: ExecInterface, value: Data, postfix: Expression | null, context: ExecContext): void {\r\n    if (postfix instanceof StringExpr) {\r\n      console.error(\"TODO: Set vector postfix\");\r\n      return;\r\n    }\r\n\r\n    if (!(value instanceof VectorData)) {\r\n      console.error(`SetDataValue: Invalid value`, value);\r\n      return\r\n    }\r\n\r\n    this.data = value.data;\r\n  }\r\n\r\n  getSubData(exec: ExecInterface, postfix: Expression | null, context: ExecContext): Data | null {\r\n    if (postfix === null) {\r\n      return this;\r\n    }\r\n\r\n    let format = exec.getTypeInfo(\"f32\");\r\n    if (this.typeInfo instanceof TemplateInfo) {\r\n        format = this.typeInfo.format || format;\r\n    } else {\r\n        const typeName = this.typeInfo.name;\r\n        if (typeName === \"vec2f\" || typeName === \"vec3f\" || typeName === \"vec4f\") {\r\n          format = exec.getTypeInfo(\"f32\");\r\n        } else if (typeName === \"vec2i\" || typeName === \"vec3i\" || typeName === \"vec4i\") {\r\n          format = exec.getTypeInfo(\"i32\");\r\n        } else if (typeName === \"vec2b\" || typeName === \"vec3b\" || typeName === \"vec4b\") {\r\n          format = exec.getTypeInfo(\"bool\");\r\n        } else if (typeName === \"vec2u\" || typeName === \"vec3u\" || typeName === \"vec4u\") {\r\n          format = exec.getTypeInfo(\"u32\");\r\n        } else if ( typeName === \"vec2h\" || typeName === \"vec3h\" || typeName === \"vec4h\") {\r\n          format = exec.getTypeInfo(\"f16\");\r\n        } else {\r\n          console.error(`GetSubData: Unknown type ${typeName}`);\r\n        }\r\n    }\r\n\r\n    let self: VectorData | null = this;\r\n    while (postfix !== null && self !== null) {\r\n      if (postfix instanceof ArrayIndex) {\r\n        const idx = postfix.index;\r\n        let i = -1;\r\n        if (idx instanceof LiteralExpr) {\r\n          if (idx.value instanceof ScalarData) {\r\n            i = idx.value.value;\r\n          } else {\r\n            console.error(`GetSubData: Invalid array index ${idx.value}`);\r\n            return null;\r\n          }\r\n        } else {\r\n          const d = exec.evalExpression(idx, context);\r\n          if (d instanceof ScalarData) {\r\n            i = d.value;\r\n          } else {\r\n            console.error(`GetSubData: Unknown index type`, idx);\r\n            return null;\r\n          }\r\n        }\r\n        if (i < 0 || i >= self.data.length) {\r\n          console.error(`GetSubData: Index out of range`, i);\r\n          return null;\r\n        }\r\n\r\n        if (self.data instanceof Float32Array) {\r\n          const d = new Float32Array(self.data.buffer, self.data.byteOffset + i * 4, 1);\r\n          return new ScalarData(d, format!);\r\n        } else if (self.data instanceof Int32Array) {\r\n          const d = new Int32Array(self.data.buffer, self.data.byteOffset + i * 4, 1);\r\n          return new ScalarData(d, format!);\r\n        } else if (self.data instanceof Uint32Array) {\r\n          const d = new Uint32Array(self.data.buffer, self.data.byteOffset + i * 4, 1);\r\n          return new ScalarData(d, format!);\r\n        }\r\n\r\n        throw `GetSubData: Invalid data type`;\r\n      } else if (postfix instanceof StringExpr) {\r\n        const member = postfix.value.toLowerCase();\r\n        if (member.length === 1) {\r\n          let i = 0;\r\n          if (member === \"x\" || member === \"r\") {\r\n            i = 0;\r\n          } else if (member === \"y\" || member === \"g\") {\r\n            i = 1;\r\n          } else if (member === \"z\" || member === \"b\") {\r\n            i = 2;\r\n          } else if (member === \"w\" || member === \"a\") {\r\n            i = 3;\r\n          } else {\r\n            console.error(`GetSubData: Unknown member ${member}`);\r\n            return null;\r\n          }\r\n\r\n          if (this.data instanceof Float32Array) {\r\n            let d = new Float32Array(this.data.buffer, this.data.byteOffset + i * 4, 1);\r\n            return new ScalarData(d, format!, this);\r\n          } else if (this.data instanceof Int32Array) {\r\n            let d = new Int32Array(this.data.buffer, this.data.byteOffset + i * 4, 1);\r\n            return new ScalarData(d, format!, this);\r\n          } else if (this.data instanceof Uint32Array) {\r\n            let d = new Uint32Array(this.data.buffer, this.data.byteOffset + i * 4, 1);\r\n            return new ScalarData(d, format!, this);\r\n          }\r\n        }\r\n\r\n        const values: number[] = [];\r\n        for (const m of member) {\r\n          if (m === \"x\" || m === \"r\") {\r\n            values.push(this.data[0]);\r\n          } else if (m === \"y\" || m === \"g\") {\r\n            values.push(this.data[1]);\r\n          } else if (m === \"z\" || m === \"b\") {\r\n            values.push(this.data[2]);\r\n          } else if (m === \"w\" || m === \"a\") {\r\n            values.push(this.data[3]);\r\n          } else {\r\n            console.error(`GetDataValue: Unknown member ${m}`);\r\n          }\r\n        }\r\n\r\n        self = _getVectorData(exec, values, format.name);\r\n      } else {\r\n        console.error(`GetSubData: Unknown postfix`, postfix);\r\n        return null;\r\n      }\r\n\r\n      postfix = postfix.postfix;\r\n    }\r\n\r\n    return self;\r\n  }\r\n\r\n  toString(): string {\r\n    let s = `${this.data[0]}`;\r\n    for (let i = 1; i < this.data.length; ++i) {\r\n      s += `, ${this.data[i]}`;\r\n    }\r\n    return s;\r\n  }\r\n}\r\n\r\nexport class MatrixData extends Data {\r\n  data: Float32Array;\r\n\r\n  constructor(value: number[] | Float32Array, typeInfo: TypeInfo, parent: Data | null = null) {\r\n    super(typeInfo, parent);\r\n    if (value instanceof Float32Array) {\r\n      this.data = value;\r\n    } else {\r\n      this.data = new Float32Array(value);\r\n    }\r\n  }\r\n\r\n  clone(): Data {\r\n    return new MatrixData(new Float32Array(this.data), this.typeInfo, null);\r\n  }\r\n\r\n  setDataValue(exec: ExecInterface, value: Data, postfix: Expression | null, context: ExecContext): void {\r\n    if (postfix instanceof StringExpr) {\r\n      console.error(\"TODO: Set matrix postfix\");\r\n      return;\r\n    }\r\n\r\n    if (!(value instanceof MatrixData)) {\r\n      console.error(`SetDataValue: Invalid value`, value);\r\n      return\r\n    }\r\n\r\n    this.data = value.data;\r\n  }\r\n\r\n  getSubData(exec: ExecInterface, postfix: Expression | null, context: ExecContext): Data | null {\r\n    if (postfix === null) {\r\n      return this;\r\n    }\r\n\r\n    const typeName = this.typeInfo.name;\r\n    let format = exec.getTypeInfo(\"f32\");\r\n    if (this.typeInfo instanceof TemplateInfo) {\r\n      format = this.typeInfo.format;\r\n    } else {\r\n      if (typeName.endsWith(\"f\")) {\r\n        format = exec.getTypeInfo(\"f32\");\r\n      } else if (typeName.endsWith(\"i\")) {\r\n        format = exec.getTypeInfo(\"i32\");\r\n      } else if (typeName.endsWith(\"u\")) {\r\n        format = exec.getTypeInfo(\"u32\");\r\n      } else if ( typeName.endsWith(\"h\")) {\r\n        format = exec.getTypeInfo(\"f16\");\r\n      } else {\r\n        console.error(`GetDataValue: Unknown type ${typeName}`);\r\n        return null;\r\n      }\r\n    }\r\n\r\n    if (postfix instanceof ArrayIndex) {\r\n      const idx = postfix.index;\r\n      let i = -1;\r\n      if (idx instanceof LiteralExpr) {\r\n        if (idx.value instanceof ScalarData) {\r\n          i = idx.value.value;\r\n        } else {\r\n          console.error(`GetDataValue: Invalid array index ${idx.value}`);\r\n          return null;\r\n        }\r\n      } else {\r\n        const d = exec.evalExpression(idx, context);\r\n        if (d instanceof ScalarData) {\r\n          i = d.value;\r\n        } else {\r\n          console.error(`GetDataValue: Unknown index type`, idx);\r\n          return null;\r\n        }\r\n      }\r\n      if (i < 0 || i >= this.data.length) {\r\n        console.error(`GetDataValue: Index out of range`, i);\r\n        return null;\r\n      }\r\n\r\n      const formatSuffix = typeName.endsWith(\"h\") ? \"h\" : \"f\";\r\n\r\n      let vectorData: VectorData;\r\n      if (typeName === \"mat2x2\" || typeName === \"mat2x2f\" || typeName === \"mat2x2h\" ||\r\n          typeName === \"mat3x2\" || typeName === \"mat3x2f\" || typeName === \"mat3x2h\" ||\r\n          typeName === \"mat4x2\" || typeName === \"mat4x2f\" || typeName === \"mat4x2h\") {\r\n        vectorData = new VectorData(new Float32Array(this.data.buffer, this.data.byteOffset + i * 2 * 4, 2), exec.getTypeInfo(`vec2${formatSuffix}`)!);\r\n      } else if (typeName === \"mat2x3\" || typeName === \"mat2x3f\" || typeName === \"mat2x3h\" ||\r\n                typeName === \"mat3x3\" || typeName === \"mat3x3f\" || typeName === \"mat3x3h\" ||\r\n                typeName === \"mat4x3\" || typeName === \"mat4x3f\" || typeName === \"mat4x3h\") {\r\n        vectorData = new VectorData(new Float32Array(this.data.buffer, this.data.byteOffset + i * 3 * 4, 3), exec.getTypeInfo(`vec3${formatSuffix}`)!);\r\n      } else if (typeName === \"mat2x4\" || typeName === \"mat2x4f\" || typeName === \"mat2x4h\" ||\r\n                typeName === \"mat3x4\" || typeName === \"mat3x4f\" || typeName === \"mat3x4h\" ||\r\n                typeName === \"mat4x4\" || typeName === \"mat4x4f\" || typeName === \"mat4x4h\") {\r\n        vectorData = new VectorData(new Float32Array(this.data.buffer, this.data.byteOffset + i * 4 * 4, 4), exec.getTypeInfo(`vec4${formatSuffix}`)!);\r\n      } else {\r\n        console.error(`GetDataValue: Unknown type ${typeName}`);\r\n        return null;\r\n      }\r\n\r\n      if (postfix.postfix) {\r\n        return vectorData.getSubData(exec, postfix.postfix, context);\r\n      }\r\n\r\n      return vectorData;\r\n    } else {\r\n      console.error(`GetDataValue: Invalid postfix`, postfix);\r\n      return null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  toString(): string {\r\n    let s = `${this.data[0]}`;\r\n    for (let i = 1; i < this.data.length; ++i) {\r\n      s += `, ${this.data[i]}`;\r\n    }\r\n    return s;\r\n  }\r\n}\r\n\r\n// Used to store array and struct data\r\nexport class TypedData extends Data {\r\n  buffer: ArrayBuffer;\r\n  offset: number;\r\n\r\n  constructor(data: ArrayBuffer | Float32Array | Uint32Array | Int32Array | Uint8Array | Int8Array,\r\n      typeInfo: TypeInfo, offset: number = 0, parent: Data | null = null) {\r\n    super(typeInfo, parent);\r\n    this.buffer = data instanceof ArrayBuffer ? data : data.buffer;\r\n    this.offset = offset;\r\n  }\r\n\r\n  clone(): Data {\r\n    const cloned = new Uint8Array(new Uint8Array(this.buffer, this.offset, this.typeInfo.size));\r\n    return new TypedData(cloned.buffer, this.typeInfo, 0, null);\r\n  }\r\n\r\n  setDataValue(exec: ExecInterface, value: Data, postfix: Expression | null, context: ExecContext): void {\r\n    if (value === null) {\r\n      console.log(`setDataValue: NULL data.`);\r\n      return;\r\n    }\r\n\r\n    let offset = this.offset;\r\n    let typeInfo = this.typeInfo;\r\n    while (postfix) {\r\n      if (postfix instanceof ArrayIndex) {\r\n        if (typeInfo instanceof ArrayInfo) {\r\n          const idx = postfix.index;\r\n          if (idx instanceof LiteralExpr) {\r\n            if (idx.value instanceof ScalarData) {\r\n              offset += idx.value.value * typeInfo.stride;\r\n            } else {\r\n              console.error(`SetDataValue: Invalid index type ${idx.value}`);\r\n              return;\r\n            }\r\n          } else {\r\n            const i = exec.evalExpression(idx, context);\r\n            if (i instanceof ScalarData) {\r\n              offset += i.value * typeInfo.stride;\r\n            } else {\r\n              console.error(`SetDataValue: Unknown index type`, idx);\r\n              return;\r\n            }\r\n          }\r\n          typeInfo = typeInfo.format;\r\n        } else {\r\n          console.error(`SetDataValue: Type ${typeInfo.getTypeName()} is not an array`);\r\n        }\r\n      } else if (postfix instanceof StringExpr) {\r\n        const member = postfix.value;\r\n        if (typeInfo instanceof StructInfo) {\r\n          let found = false;\r\n          for (const m of typeInfo.members) {\r\n            if (m.name === member) {\r\n              offset += m.offset;\r\n              typeInfo = m.type;\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!found) {\r\n            console.error(`SetDataValue: Member ${member} not found`);\r\n            return;\r\n          }\r\n        } else if (typeInfo instanceof TypeInfo) {\r\n          const typeName = typeInfo.getTypeName();\r\n          let element = 0;\r\n          if (member === \"x\" || member === \"r\") {\r\n            element = 0;\r\n          } else if (member === \"y\" || member === \"g\") {\r\n            element = 1;\r\n          } else if (member === \"z\" || member === \"b\") {\r\n            element = 2;\r\n          } else if (member === \"w\" || member === \"a\") {\r\n            element = 3;\r\n          } else {\r\n            console.error(`SetDataValue: Unknown member ${member}`);\r\n            return;\r\n          }\r\n          if (!(value instanceof ScalarData)) {\r\n            console.error(`SetDataValue: Invalid value`, value);\r\n            return;\r\n          }\r\n          const v = value.value;\r\n          if (typeName === \"vec2f\") {\r\n            new Float32Array(this.buffer, offset, 2)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec3f\") {\r\n            new Float32Array(this.buffer, offset, 3)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec4f\") {\r\n            new Float32Array(this.buffer, offset, 4)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec2i\") {\r\n            new Int32Array(this.buffer, offset, 2)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec3i\") {\r\n            new Int32Array(this.buffer, offset, 3)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec4i\") {\r\n            new Int32Array(this.buffer, offset, 4)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec2u\") {\r\n            new Uint32Array(this.buffer, offset, 2)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec3u\") {\r\n            new Uint32Array(this.buffer, offset, 3)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec4u\") {\r\n            new Uint32Array(this.buffer, offset, 4)[element] = v;\r\n            return;\r\n          }\r\n          console.error(`SetDataValue: Type ${typeName} is not a struct`);\r\n          return;\r\n        }\r\n      } else {\r\n        console.error(`SetDataValue: Unknown postfix type`, postfix);\r\n        return;\r\n      }\r\n      postfix = postfix.postfix;\r\n    }\r\n\r\n    this.setData(exec, value, typeInfo, offset, context);\r\n  }\r\n\r\n  setData(exec: ExecInterface, value: Data, typeInfo: TypeInfo, offset: number, context: ExecContext): void {\r\n    const typeName = typeInfo.getTypeName();\r\n\r\n    if (typeName === \"f32\" || typeName === \"f16\") {\r\n      if (value instanceof ScalarData) {\r\n        new Float32Array(this.buffer, offset, 1)[0] = value.value;\r\n      }\r\n      return;\r\n    } else if (typeName === \"i32\" || typeName === \"atomic<i32>\" || typeName === \"x32\") {\r\n      if (value instanceof ScalarData) {\r\n        new Int32Array(this.buffer, offset, 1)[0] = value.value;\r\n      }\r\n      return;\r\n    } else if (typeName === \"u32\" || typeName === \"atomic<u32>\") {\r\n      if (value instanceof ScalarData) {\r\n        new Uint32Array(this.buffer, offset, 1)[0] = value.value;\r\n      }\r\n      return;\r\n    } else if (typeName === \"bool\") {\r\n      if (value instanceof ScalarData) {\r\n        new Int32Array(this.buffer, offset, 1)[0] = value.value;\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec2f\" || typeName === \"vec2h\") {\r\n      const x = new Float32Array(this.buffer, offset, 2);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec3f\" || typeName === \"vec3h\") {\r\n      const x = new Float32Array(this.buffer, offset, 3);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec4f\" || typeName === \"vec4h\") {\r\n      const x = new Float32Array(this.buffer, offset, 4);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec2i\") {\r\n      const x = new Int32Array(this.buffer, offset, 2);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec3i\") {\r\n      const x = new Int32Array(this.buffer, offset, 3);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec4i\") {\r\n      const x = new Int32Array(this.buffer, offset, 4);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec2u\") {\r\n      const x = new Uint32Array(this.buffer, offset, 2);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec3u\") {\r\n      const x = new Uint32Array(this.buffer, offset, 3);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec4u\") {\r\n      const x = new Uint32Array(this.buffer, offset, 4);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec2b\") {\r\n      const x = new Uint32Array(this.buffer, offset, 2);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec3b\") {\r\n      const x = new Uint32Array(this.buffer, offset, 3);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec4b\") {\r\n      const x = new Uint32Array(this.buffer, offset, 4);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat2x2f\" || typeName === \"mat2x2h\") {\r\n      const x = new Float32Array(this.buffer, offset, 4);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat2x3f\" || typeName === \"mat2x3h\") {\r\n      const x = new Float32Array(this.buffer, offset, 6);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat2x4f\" || typeName === \"mat2x4h\") {\r\n      const x = new Float32Array(this.buffer, offset, 8);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n        x[6] = value.data[6];\r\n        x[7] = value.data[7];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n        x[6] = value[6];\r\n        x[7] = value[7];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat3x2f\" || typeName === \"mat3x2h\") {\r\n      const x = new Float32Array(this.buffer, offset, 6);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat3x3f\" || typeName === \"mat3x3h\") {\r\n      const x = new Float32Array(this.buffer, offset, 9);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n        x[6] = value.data[6];\r\n        x[7] = value.data[7];\r\n        x[8] = value.data[8];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n        x[6] = value[6];\r\n        x[7] = value[7];\r\n        x[8] = value[8];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat3x4f\" || typeName === \"mat3x4h\") {\r\n      const x = new Float32Array(this.buffer, offset, 12);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n        x[6] = value.data[6];\r\n        x[7] = value.data[7];\r\n        x[8] = value.data[8];\r\n        x[9] = value.data[9];\r\n        x[10] = value.data[10];\r\n        x[11] = value.data[11];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n        x[6] = value[6];\r\n        x[7] = value[7];\r\n        x[8] = value[8];\r\n        x[9] = value[9];\r\n        x[10] = value[10];\r\n        x[11] = value[11];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat4x2f\" || typeName === \"mat4x2h\") {\r\n      const x = new Float32Array(this.buffer, offset, 8);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n        x[6] = value.data[6];\r\n        x[7] = value.data[7];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n        x[6] = value[6];\r\n        x[7] = value[7];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat4x3f\" || typeName === \"mat4x3h\") {\r\n      const x = new Float32Array(this.buffer, offset, 12);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n        x[6] = value.data[6];\r\n        x[7] = value.data[7];\r\n        x[8] = value.data[8];\r\n        x[9] = value.data[9];\r\n        x[10] = value.data[10];\r\n        x[11] = value.data[11];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n        x[6] = value[6];\r\n        x[7] = value[7];\r\n        x[8] = value[8];\r\n        x[9] = value[9];\r\n        x[10] = value[10];\r\n        x[11] = value[11];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat4x4f\" || typeName === \"mat4x4h\") {\r\n      const x = new Float32Array(this.buffer, offset, 16);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n        x[6] = value.data[6];\r\n        x[7] = value.data[7];\r\n        x[8] = value.data[8];\r\n        x[9] = value.data[9];\r\n        x[10] = value.data[10];\r\n        x[11] = value.data[11];\r\n        x[12] = value.data[12];\r\n        x[13] = value.data[13];\r\n        x[14] = value.data[14];\r\n        x[15] = value.data[15];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n        x[6] = value[6];\r\n        x[7] = value[7];\r\n        x[8] = value[8];\r\n        x[9] = value[9];\r\n        x[10] = value[10];\r\n        x[11] = value[11];\r\n        x[12] = value[12];\r\n        x[13] = value[13];\r\n        x[14] = value[14];\r\n        x[15] = value[15];\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (value instanceof TypedData) {\r\n      if (typeInfo === value.typeInfo) {\r\n        const x = new Uint8Array(this.buffer, offset, value.buffer.byteLength);\r\n        x.set(new Uint8Array(value.buffer));\r\n        return;\r\n      } else {\r\n        console.error(`SetDataValue: Type mismatch`, typeName, value.typeInfo.getTypeName());\r\n        return;\r\n      }\r\n    }\r\n\r\n    console.error(`SetData: Unknown type ${typeName}`);\r\n  }\r\n\r\n  getSubData(exec: ExecInterface, postfix: Expression | null, context: ExecContext): Data | null {\r\n    if (postfix === null) {\r\n      return this;\r\n    }\r\n\r\n    let offset = this.offset;\r\n    let typeInfo = this.typeInfo;\r\n    while (postfix) {\r\n      if (postfix instanceof ArrayIndex) {\r\n        const idx = postfix.index;\r\n        const _i = idx instanceof Expression ? exec.evalExpression(idx, context) : idx;\r\n        let i = 0;\r\n        if (_i instanceof ScalarData) {\r\n          i = _i.value;\r\n        } else if (typeof _i === \"number\") {\r\n          i = _i;\r\n        } else {\r\n          console.error(`GetDataValue: Invalid index type`, idx);\r\n        }\r\n        if (typeInfo instanceof ArrayInfo) {\r\n          offset += i * typeInfo.stride;\r\n          typeInfo = typeInfo.format;\r\n        } else {\r\n          const typeName = typeInfo.getTypeName();\r\n          if (typeName === \"mat4x4\" || typeName === \"mat4x4f\" || typeName === \"mat4x4h\") {\r\n            offset += i * 16;\r\n            typeInfo = exec.getTypeInfo(\"vec4f\")!;\r\n          } else {\r\n            console.error(`getDataValue: Type ${typeInfo.getTypeName()} is not an array`);\r\n          }\r\n        }\r\n      } else if (postfix instanceof StringExpr) {\r\n        const member = postfix.value;\r\n        if (typeInfo instanceof StructInfo) {\r\n          let found = false;\r\n          for (const m of typeInfo.members) {\r\n            if (m.name === member) {\r\n              offset += m.offset;\r\n              typeInfo = m.type;\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!found) {\r\n            console.error(`GetDataValue: Member ${member} not found`);\r\n            return null;\r\n          }\r\n        } else if (typeInfo instanceof TypeInfo) {\r\n          const typeName = typeInfo.getTypeName();\r\n          if (typeName === \"vec2f\" || typeName === \"vec3f\" || typeName === \"vec4f\" ||\r\n              typeName === \"vec2i\" || typeName === \"vec3i\" || typeName === \"vec4i\" ||\r\n              typeName === \"vec2u\" || typeName === \"vec3u\" || typeName === \"vec4u\" ||\r\n              typeName === \"vec2b\" || typeName === \"vec3b\" || typeName === \"vec4b\" ||\r\n              typeName === \"vec2h\" || typeName === \"vec3h\" || typeName === \"vec4h\" ||\r\n              typeName === \"vec2\" || typeName === \"vec3\" || typeName === \"vec4\") {\r\n\r\n            if (member.length > 0 && member.length < 5) {\r\n              let formatName = \"f32\";\r\n              let formatSuffix = \"f\";\r\n              const value: number[] = [];\r\n              for (let i = 0; i < member.length; ++i) {\r\n                const m = member[i].toLowerCase();\r\n                let element = 0;\r\n                if (m === \"x\" || m === \"r\") {\r\n                  element = 0;\r\n                } else if (m === \"y\" || m === \"g\") {\r\n                  element = 1;\r\n                } else if (m === \"z\" || m === \"b\") {\r\n                  element = 2;\r\n                } else if (m === \"w\" || m === \"a\") {\r\n                  element = 3;\r\n                } else {\r\n                  console.error(`Unknown member ${member}`);\r\n                  return null;\r\n                }\r\n\r\n                if (member.length === 1) {\r\n                  if (typeName.endsWith(\"f\")) {\r\n                    if (this.buffer.byteLength < (offset + element * 4 + 4)) {\r\n                      console.log(\"Insufficient buffer data\");\r\n                      return null;\r\n                    }\r\n                    return new ScalarData(new Float32Array(this.buffer, offset + element * 4, 1), exec.getTypeInfo(\"f32\")!, this);\r\n                  } else if (typeName.endsWith(\"h\")) {\r\n                    return new ScalarData(new Float32Array(this.buffer, offset + element * 4, 1), exec.getTypeInfo(\"f16\")!, this);\r\n                  } else if (typeName.endsWith(\"i\")) {\r\n                    return new ScalarData(new Int32Array(this.buffer, offset + element * 4, 1), exec.getTypeInfo(\"i32\")!, this);\r\n                  } else if (typeName.endsWith(\"b\")) {\r\n                    return new ScalarData(new Int32Array(this.buffer, offset + element * 4, 1), exec.getTypeInfo(\"bool\")!, this);\r\n                  } else if (typeName.endsWith(\"u\")) {\r\n                    return new ScalarData(new Uint32Array(this.buffer, offset + element * 4, 1), exec.getTypeInfo(\"i32\")!, this);\r\n                  }\r\n                }\r\n\r\n                if (typeName === \"vec2f\") {\r\n                  value.push(new Float32Array(this.buffer, offset, 2)[element]);\r\n                } else if (typeName === \"vec3f\") {\r\n                  if ((offset + 12) >= this.buffer.byteLength) {\r\n                    console.log(\"Insufficient buffer data\");\r\n                    return null;\r\n                  }\r\n                  const fa = new Float32Array(this.buffer, offset, 3);\r\n                  value.push(fa[element]);\r\n                } else if (typeName === \"vec4f\") {\r\n                  value.push(new Float32Array(this.buffer, offset, 4)[element]);\r\n                } else if (typeName === \"vec2i\") {\r\n                  formatName = \"i32\";\r\n                  formatSuffix = \"i\";\r\n                  value.push(new Int32Array(this.buffer, offset, 2)[element]);\r\n                } else if (typeName === \"vec3i\") {\r\n                  formatName = \"i32\";\r\n                  formatSuffix = \"i\";\r\n                  value.push(new Int32Array(this.buffer, offset, 3)[element]);\r\n                } else if (typeName === \"vec4i\") {\r\n                  formatName = \"i32\";\r\n                  formatSuffix = \"i\";\r\n                  value.push(new Int32Array(this.buffer, offset, 4)[element]);\r\n                } else if (typeName === \"vec2u\") {\r\n                  formatName = \"u32\";\r\n                  formatSuffix = \"u\";\r\n                  const ua = new Uint32Array(this.buffer, offset, 2);\r\n                  value.push(ua[element]);\r\n                } else if (typeName === \"vec3u\") {\r\n                  formatName = \"u32\";\r\n                  formatSuffix = \"u\";\r\n                  value.push(new Uint32Array(this.buffer, offset, 3)[element]);\r\n                } else if (typeName === \"vec4u\") {\r\n                  formatName = \"u32\";\r\n                  formatSuffix = \"u\";\r\n                  value.push(new Uint32Array(this.buffer, offset, 4)[element]);\r\n                }\r\n              }\r\n\r\n              if (value.length === 2) {\r\n                typeInfo = exec.getTypeInfo(`vec2${formatSuffix}`)!;\r\n              } else if (value.length === 3) {\r\n                typeInfo = exec.getTypeInfo(`vec3${formatSuffix}`)!;\r\n              } else if (value.length === 4) {\r\n                typeInfo = exec.getTypeInfo(`vec4${formatSuffix}`)!;\r\n              } else {\r\n                console.error(`GetDataValue: Invalid vector length ${value.length}`);\r\n              }\r\n\r\n              return new VectorData(value, typeInfo, null);\r\n            } else {\r\n              console.error(`GetDataValue: Unknown member ${member}`);\r\n              return null;\r\n            }\r\n          }\r\n\r\n          console.error(`GetDataValue: Type ${typeName} is not a struct`);\r\n          return null;\r\n        }\r\n      } else {\r\n        console.error(`GetDataValue: Unknown postfix type`, postfix);\r\n        return null;\r\n      }\r\n\r\n      postfix = postfix.postfix;\r\n    }\r\n\r\n    const typeName = typeInfo.getTypeName();\r\n\r\n    if (typeName === \"f32\") {\r\n      return new ScalarData(new Float32Array(this.buffer, offset, 1), typeInfo, this);\r\n    } else if (typeName === \"i32\") {\r\n      return new ScalarData(new Int32Array(this.buffer, offset, 1), typeInfo, this);\r\n    } else if (typeName === \"u32\") {\r\n      return new ScalarData(new Uint32Array(this.buffer, offset, 1), typeInfo, this);\r\n    } else if (typeName === \"vec2f\") {\r\n      return new VectorData(new Float32Array(this.buffer, offset, 2), typeInfo, this);\r\n    } else if (typeName === \"vec3f\") {\r\n      return new VectorData(new Float32Array(this.buffer, offset, 3), typeInfo, this);\r\n    } else if (typeName === \"vec4f\") {\r\n      return new VectorData(new Float32Array(this.buffer, offset, 4), typeInfo, this);\r\n    } else if (typeName === \"vec2i\") {\r\n      return new VectorData(new Int32Array(this.buffer, offset, 2), typeInfo, this);\r\n    } else if (typeName === \"vec3i\") {\r\n      return new VectorData(new Int32Array(this.buffer, offset, 3), typeInfo, this);\r\n    } else if (typeName === \"vec4i\") {\r\n      return new VectorData(new Int32Array(this.buffer, offset, 4), typeInfo, this);\r\n    } else if (typeName === \"vec2u\") {\r\n      return new VectorData(new Uint32Array(this.buffer, offset, 2), typeInfo, this);\r\n    } else if (typeName === \"vec3u\") {\r\n      return new VectorData(new Uint32Array(this.buffer, offset, 3), typeInfo, this);\r\n    } else if (typeName === \"vec4u\") {\r\n      return new VectorData(new Uint32Array(this.buffer, offset, 4), typeInfo, this);\r\n    }\r\n\r\n    if (typeInfo instanceof TemplateInfo && typeInfo.name === \"atomic\") {\r\n      if (typeInfo.format?.name === \"u32\") {\r\n        return new ScalarData(new Uint32Array(this.buffer, offset, 1)[0], typeInfo.format, this);\r\n      } else if (typeInfo.format?.name === \"i32\") {\r\n        return new ScalarData(new Int32Array(this.buffer, offset, 1)[0], typeInfo.format, this);\r\n      } else {\r\n        console.error(`GetDataValue: Invalid atomic format ${typeInfo.format?.name}`);\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return new TypedData(this.buffer, typeInfo, offset, this);\r\n  }\r\n\r\n  toString(): string {\r\n    let s = \"\";\r\n    if (this.typeInfo instanceof ArrayInfo) {\r\n      if (this.typeInfo.format.name === \"f32\") {\r\n        const fa = new Float32Array(this.buffer, this.offset);\r\n        s = `[${fa[0]}`;\r\n        for (let i = 1; i < fa.length; ++i) {\r\n          s += `, ${fa[i]}`;\r\n        }\r\n      } else if (this.typeInfo.format.name === \"i32\") {\r\n        const fa = new Int32Array(this.buffer, this.offset);\r\n        s = `[${fa[0]}`;\r\n        for (let i = 1; i < fa.length; ++i) {\r\n          s += `, ${fa[i]}`;\r\n        }\r\n      } else if (this.typeInfo.format.name === \"u32\") {\r\n        const fa = new Uint32Array(this.buffer, this.offset);\r\n        s = `[${fa[0]}`;\r\n        for (let i = 1; i < fa.length; ++i) {\r\n          s += `, ${fa[i]}`;\r\n        }\r\n      } else if (this.typeInfo.format.name === \"vec2f\") {\r\n        const fa = new Float32Array(this.buffer, this.offset);\r\n        s = `[${fa[0]}, ${fa[1]}]`;\r\n        for (let i = 1; i < fa.length / 2; ++i) {\r\n          s += `, [${fa[i * 2]}, ${fa[i * 2 + 1]}]`;\r\n        }\r\n      } else if (this.typeInfo.format.name === \"vec3f\") {\r\n        const fa = new Float32Array(this.buffer, this.offset);\r\n        s = `[${fa[0]}, ${fa[1]}, ${fa[2]}]`;\r\n        for (let i = 4; i < fa.length; i += 4) {\r\n          s += `, [${fa[i]}, ${fa[i + 1]}, ${fa[i + 2]}]`;\r\n        }\r\n      } else if (this.typeInfo.format.name === \"vec4f\") {\r\n        const fa = new Float32Array(this.buffer, this.offset);\r\n        s = `[${fa[0]}, ${fa[1]}, ${fa[2]}, ${fa[3]}]`;\r\n        for (let i = 4; i < fa.length; i += 4) {\r\n          s += `, [${fa[i]}, ${fa[i + 1]}, ${fa[i + 2]}, ${fa[i + 3]}]`;\r\n        }\r\n      } else {\r\n        s = `[...]`;\r\n      }\r\n    } else if (this.typeInfo instanceof StructInfo) {\r\n      s += `{...}`;\r\n    } else {\r\n      s = `[...]`;\r\n    }\r\n    return s;\r\n  }\r\n}\r\n\r\nexport class TextureData extends Data {\r\n  data: Array<ArrayBuffer>;\r\n  descriptor: Object;\r\n  view: Object | null;\r\n\r\n  constructor(data: Array<ArrayBuffer | Float32Array | Uint32Array | Int32Array | Uint8Array | Int8Array>,\r\n      typeInfo: TypeInfo, descriptor: Object, view: Object | null) {\r\n      super(typeInfo, null);\r\n      this.data = data;\r\n      this.descriptor = descriptor;\r\n      this.view = view;\r\n  }\r\n\r\n  clone(): Data {\r\n    return new TextureData(this.data, this.typeInfo, this.descriptor, this.view);\r\n  }\r\n\r\n  get width(): number {\r\n    const size = this.descriptor[\"size\"];\r\n    if (size instanceof Array && size.length > 0) {\r\n      return size[0] ?? 0;\r\n    } else if (size instanceof Object) {\r\n      return size[\"width\"] ?? 0;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  get height(): number {\r\n    const size = this.descriptor[\"size\"];\r\n    if (size instanceof Array && size.length > 1) {\r\n      return size[1] ?? 0;\r\n    } else if (size instanceof Object) {\r\n      return size[\"height\"] ?? 0;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  get depthOrArrayLayers(): number {\r\n    const size = this.descriptor[\"size\"];\r\n    if (size instanceof Array && size.length > 2) {\r\n      return size[2] ?? 0;\r\n    } else if (size instanceof Object) {\r\n      return size[\"depthOrArrayLayers\"] ?? 0;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  get format(): string {\r\n    if (this.descriptor) {\r\n      return this.descriptor[\"format\"] ?? \"rgba8unorm\";\r\n    }\r\n    return \"rgba8unorm\";\r\n  }\r\n\r\n  get sampleCount(): number {\r\n    if (this.descriptor) {\r\n      return this.descriptor[\"sampleCount\"] ?? 1;\r\n    }\r\n    return 1;\r\n  }\r\n\r\n  get mipLevelCount(): number {\r\n    if (this.descriptor) {\r\n      return this.descriptor[\"mipLevelCount\"] ?? 1;\r\n    }\r\n    return 1;\r\n  }\r\n\r\n  get dimension(): string {\r\n    if (this.descriptor) {\r\n      return this.descriptor[\"dimension\"] ?? \"2d\";\r\n    }\r\n    return \"2d\";\r\n  }\r\n\r\n  getMipLevelSize(level: number): number[] {\r\n    if (level >= this.mipLevelCount) {\r\n      return [0, 0, 0];\r\n    }\r\n\r\n    const size = [this.width, this.height, this.depthOrArrayLayers];\r\n    for (let i = 0; i < size.length; ++i) {\r\n      size[i] = Math.max(1, size[i] >> level);\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  get texelByteSize(): number {\r\n    const format = this.format;\r\n    const formatInfo = TextureFormatInfo[format];\r\n    if (!formatInfo) {\r\n      return 0;\r\n    }\r\n    if (formatInfo.isDepthStencil) {\r\n      return 4; // depth textures have r32float imageData\r\n    }\r\n    return formatInfo.bytesPerBlock;\r\n  }\r\n\r\n  get bytesPerRow(): number {\r\n    const width = this.width;\r\n    const texelByteSize = this.texelByteSize;\r\n    //return (width * texelByteSize + 255) & ~0xff; // bytesPerRow is aligned to a multiple of 256 bytes\r\n    return width * texelByteSize;\r\n  }\r\n\r\n  get isDepthStencil(): boolean {\r\n    const format = this.format;\r\n    const formatInfo = TextureFormatInfo[format];\r\n    if (!formatInfo) {\r\n      return false;\r\n    }\r\n    return formatInfo.isDepthStencil;\r\n  }\r\n\r\n  getGpuSize(): number {\r\n    const format = this.format;\r\n    const formatInfo = TextureFormatInfo[format];\r\n    const width = this.width;\r\n    if (!format || width <= 0 || !formatInfo) {\r\n      return -1;\r\n    }\r\n\r\n    const height = this.height;\r\n    const depthOrArrayLayers = this.depthOrArrayLayers;\r\n    const dimension = this.dimension;\r\n    const blockWidth = width / formatInfo.blockWidth;\r\n    const blockHeight = dimension === \"1d\" ? 1 : height / formatInfo.blockHeight;\r\n    const bytesPerBlock = formatInfo.bytesPerBlock;\r\n\r\n    return blockWidth * blockHeight * bytesPerBlock * depthOrArrayLayers;\r\n  }\r\n\r\n  getPixel(x: number, y: number, z: number = 0, mipLevel: number = 0): number[] | null {\r\n    const texelByteSize = this.texelByteSize;\r\n    const bytesPerRow = this.bytesPerRow;\r\n    const height = this.height;\r\n    const buffer = this.data[mipLevel];\r\n    const imageData = new Uint8Array(buffer);\r\n    return getTexturePixel(imageData, x, y, z, mipLevel, height, bytesPerRow, texelByteSize, this.format);\r\n  }\r\n\r\n  setPixel(x: number, y: number, z: number, mipLevel: number, value: number[]): void {\r\n    const texelByteSize = this.texelByteSize;\r\n    const bytesPerRow = this.bytesPerRow;\r\n    const height = this.height;\r\n    const buffer = this.data[mipLevel];\r\n    const imageData = new Uint8Array(buffer);\r\n    setTexturePixel(imageData, x, y, z, mipLevel, height, bytesPerRow, texelByteSize, this.format, value);\r\n  }\r\n}\r\n", "export enum TokenClass {\r\n  token,\r\n  keyword,\r\n  reserved,\r\n}\r\n\r\nexport class TokenType {\r\n  name: string;\r\n  type: TokenClass;\r\n  rule: RegExp | string;\r\n\r\n  constructor(name: string, type: TokenClass, rule: RegExp | string) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.rule = rule;\r\n  }\r\n\r\n  toString(): string {\r\n    return this.name;\r\n  }\r\n}\r\n\r\n/// Catalog of defined token types, keywords, and reserved words.\r\nexport class TokenTypes {\r\n  static readonly none = new TokenType(\"\", TokenClass.reserved, \"\");\r\n  static readonly eof = new TokenType(\"EOF\", TokenClass.token, \"\");\r\n\r\n  static readonly reserved = {\r\n    asm: new TokenType(\"asm\", TokenClass.reserved, \"asm\"),\r\n    bf16: new TokenType(\"bf16\", TokenClass.reserved, \"bf16\"),\r\n    do: new TokenType(\"do\", TokenClass.reserved, \"do\"),\r\n    enum: new TokenType(\"enum\", TokenClass.reserved, \"enum\"),\r\n    f16: new TokenType(\"f16\", TokenClass.reserved, \"f16\"),\r\n    f64: new TokenType(\"f64\", TokenClass.reserved, \"f64\"),\r\n    handle: new TokenType(\"handle\", TokenClass.reserved, \"handle\"),\r\n    i8: new TokenType(\"i8\", TokenClass.reserved, \"i8\"),\r\n    i16: new TokenType(\"i16\", TokenClass.reserved, \"i16\"),\r\n    i64: new TokenType(\"i64\", TokenClass.reserved, \"i64\"),\r\n    mat: new TokenType(\"mat\", TokenClass.reserved, \"mat\"),\r\n    premerge: new TokenType(\"premerge\", TokenClass.reserved, \"premerge\"),\r\n    regardless: new TokenType(\"regardless\", TokenClass.reserved, \"regardless\"),\r\n    typedef: new TokenType(\"typedef\", TokenClass.reserved, \"typedef\"),\r\n    u8: new TokenType(\"u8\", TokenClass.reserved, \"u8\"),\r\n    u16: new TokenType(\"u16\", TokenClass.reserved, \"u16\"),\r\n    u64: new TokenType(\"u64\", TokenClass.reserved, \"u64\"),\r\n    unless: new TokenType(\"unless\", TokenClass.reserved, \"unless\"),\r\n    using: new TokenType(\"using\", TokenClass.reserved, \"using\"),\r\n    vec: new TokenType(\"vec\", TokenClass.reserved, \"vec\"),\r\n    void: new TokenType(\"void\", TokenClass.reserved, \"void\"),\r\n  };\r\n\r\n  static readonly keywords = {\r\n    array: new TokenType(\"array\", TokenClass.keyword, \"array\"),\r\n    atomic: new TokenType(\"atomic\", TokenClass.keyword, \"atomic\"),\r\n    bool: new TokenType(\"bool\", TokenClass.keyword, \"bool\"),\r\n    f32: new TokenType(\"f32\", TokenClass.keyword, \"f32\"),\r\n    i32: new TokenType(\"i32\", TokenClass.keyword, \"i32\"),\r\n    mat2x2: new TokenType(\"mat2x2\", TokenClass.keyword, \"mat2x2\"),\r\n    mat2x3: new TokenType(\"mat2x3\", TokenClass.keyword, \"mat2x3\"),\r\n    mat2x4: new TokenType(\"mat2x4\", TokenClass.keyword, \"mat2x4\"),\r\n    mat3x2: new TokenType(\"mat3x2\", TokenClass.keyword, \"mat3x2\"),\r\n    mat3x3: new TokenType(\"mat3x3\", TokenClass.keyword, \"mat3x3\"),\r\n    mat3x4: new TokenType(\"mat3x4\", TokenClass.keyword, \"mat3x4\"),\r\n    mat4x2: new TokenType(\"mat4x2\", TokenClass.keyword, \"mat4x2\"),\r\n    mat4x3: new TokenType(\"mat4x3\", TokenClass.keyword, \"mat4x3\"),\r\n    mat4x4: new TokenType(\"mat4x4\", TokenClass.keyword, \"mat4x4\"),\r\n    ptr: new TokenType(\"ptr\", TokenClass.keyword, \"ptr\"),\r\n    sampler: new TokenType(\"sampler\", TokenClass.keyword, \"sampler\"),\r\n    sampler_comparison: new TokenType(\r\n      \"sampler_comparison\",\r\n      TokenClass.keyword,\r\n      \"sampler_comparison\"\r\n    ),\r\n    struct: new TokenType(\"struct\", TokenClass.keyword, \"struct\"),\r\n    texture_1d: new TokenType(\"texture_1d\", TokenClass.keyword, \"texture_1d\"),\r\n    texture_2d: new TokenType(\"texture_2d\", TokenClass.keyword, \"texture_2d\"),\r\n    texture_2d_array: new TokenType(\r\n      \"texture_2d_array\",\r\n      TokenClass.keyword,\r\n      \"texture_2d_array\"\r\n    ),\r\n    texture_3d: new TokenType(\"texture_3d\", TokenClass.keyword, \"texture_3d\"),\r\n    texture_cube: new TokenType(\r\n      \"texture_cube\",\r\n      TokenClass.keyword,\r\n      \"texture_cube\"\r\n    ),\r\n    texture_cube_array: new TokenType(\r\n      \"texture_cube_array\",\r\n      TokenClass.keyword,\r\n      \"texture_cube_array\"\r\n    ),\r\n    texture_multisampled_2d: new TokenType(\r\n      \"texture_multisampled_2d\",\r\n      TokenClass.keyword,\r\n      \"texture_multisampled_2d\"\r\n    ),\r\n    texture_storage_1d: new TokenType(\r\n      \"texture_storage_1d\",\r\n      TokenClass.keyword,\r\n      \"texture_storage_1d\"\r\n    ),\r\n    texture_storage_2d: new TokenType(\r\n      \"texture_storage_2d\",\r\n      TokenClass.keyword,\r\n      \"texture_storage_2d\"\r\n    ),\r\n    texture_storage_2d_array: new TokenType(\r\n      \"texture_storage_2d_array\",\r\n      TokenClass.keyword,\r\n      \"texture_storage_2d_array\"\r\n    ),\r\n    texture_storage_3d: new TokenType(\r\n      \"texture_storage_3d\",\r\n      TokenClass.keyword,\r\n      \"texture_storage_3d\"\r\n    ),\r\n    texture_depth_2d: new TokenType(\r\n      \"texture_depth_2d\",\r\n      TokenClass.keyword,\r\n      \"texture_depth_2d\"\r\n    ),\r\n    texture_depth_2d_array: new TokenType(\r\n      \"texture_depth_2d_array\",\r\n      TokenClass.keyword,\r\n      \"texture_depth_2d_array\"\r\n    ),\r\n    texture_depth_cube: new TokenType(\r\n      \"texture_depth_cube\",\r\n      TokenClass.keyword,\r\n      \"texture_depth_cube\"\r\n    ),\r\n    texture_depth_cube_array: new TokenType(\r\n      \"texture_depth_cube_array\",\r\n      TokenClass.keyword,\r\n      \"texture_depth_cube_array\"\r\n    ),\r\n    texture_depth_multisampled_2d: new TokenType(\r\n      \"texture_depth_multisampled_2d\",\r\n      TokenClass.keyword,\r\n      \"texture_depth_multisampled_2d\"\r\n    ),\r\n    texture_external: new TokenType(\r\n      \"texture_external\",\r\n      TokenClass.keyword,\r\n      \"texture_external\"\r\n    ),\r\n    u32: new TokenType(\"u32\", TokenClass.keyword, \"u32\"),\r\n    vec2: new TokenType(\"vec2\", TokenClass.keyword, \"vec2\"),\r\n    vec3: new TokenType(\"vec3\", TokenClass.keyword, \"vec3\"),\r\n    vec4: new TokenType(\"vec4\", TokenClass.keyword, \"vec4\"),\r\n    bitcast: new TokenType(\"bitcast\", TokenClass.keyword, \"bitcast\"),\r\n    block: new TokenType(\"block\", TokenClass.keyword, \"block\"),\r\n    break: new TokenType(\"break\", TokenClass.keyword, \"break\"),\r\n    case: new TokenType(\"case\", TokenClass.keyword, \"case\"),\r\n    continue: new TokenType(\"continue\", TokenClass.keyword, \"continue\"),\r\n    continuing: new TokenType(\"continuing\", TokenClass.keyword, \"continuing\"),\r\n    default: new TokenType(\"default\", TokenClass.keyword, \"default\"),\r\n    diagnostic: new TokenType(\"diagnostic\", TokenClass.keyword, \"diagnostic\"),\r\n    discard: new TokenType(\"discard\", TokenClass.keyword, \"discard\"),\r\n    else: new TokenType(\"else\", TokenClass.keyword, \"else\"),\r\n    enable: new TokenType(\"enable\", TokenClass.keyword, \"enable\"),\r\n    fallthrough: new TokenType(\r\n      \"fallthrough\",\r\n      TokenClass.keyword,\r\n      \"fallthrough\"\r\n    ),\r\n    false: new TokenType(\"false\", TokenClass.keyword, \"false\"),\r\n    fn: new TokenType(\"fn\", TokenClass.keyword, \"fn\"),\r\n    for: new TokenType(\"for\", TokenClass.keyword, \"for\"),\r\n    function: new TokenType(\"function\", TokenClass.keyword, \"function\"),\r\n    if: new TokenType(\"if\", TokenClass.keyword, \"if\"),\r\n    let: new TokenType(\"let\", TokenClass.keyword, \"let\"),\r\n    const: new TokenType(\"const\", TokenClass.keyword, \"const\"),\r\n    loop: new TokenType(\"loop\", TokenClass.keyword, \"loop\"),\r\n    while: new TokenType(\"while\", TokenClass.keyword, \"while\"),\r\n    private: new TokenType(\"private\", TokenClass.keyword, \"private\"),\r\n    read: new TokenType(\"read\", TokenClass.keyword, \"read\"),\r\n    read_write: new TokenType(\"read_write\", TokenClass.keyword, \"read_write\"),\r\n    return: new TokenType(\"return\", TokenClass.keyword, \"return\"),\r\n    requires: new TokenType(\"requires\", TokenClass.keyword, \"requires\"),\r\n    storage: new TokenType(\"storage\", TokenClass.keyword, \"storage\"),\r\n    switch: new TokenType(\"switch\", TokenClass.keyword, \"switch\"),\r\n    true: new TokenType(\"true\", TokenClass.keyword, \"true\"),\r\n    alias: new TokenType(\"alias\", TokenClass.keyword, \"alias\"),\r\n    type: new TokenType(\"type\", TokenClass.keyword, \"type\"),\r\n    uniform: new TokenType(\"uniform\", TokenClass.keyword, \"uniform\"),\r\n    var: new TokenType(\"var\", TokenClass.keyword, \"var\"),\r\n    override: new TokenType(\"override\", TokenClass.keyword, \"override\"),\r\n    workgroup: new TokenType(\"workgroup\", TokenClass.keyword, \"workgroup\"),\r\n    write: new TokenType(\"write\", TokenClass.keyword, \"write\"),\r\n    r8unorm: new TokenType(\"r8unorm\", TokenClass.keyword, \"r8unorm\"),\r\n    r8snorm: new TokenType(\"r8snorm\", TokenClass.keyword, \"r8snorm\"),\r\n    r8uint: new TokenType(\"r8uint\", TokenClass.keyword, \"r8uint\"),\r\n    r8sint: new TokenType(\"r8sint\", TokenClass.keyword, \"r8sint\"),\r\n    r16uint: new TokenType(\"r16uint\", TokenClass.keyword, \"r16uint\"),\r\n    r16sint: new TokenType(\"r16sint\", TokenClass.keyword, \"r16sint\"),\r\n    r16float: new TokenType(\"r16float\", TokenClass.keyword, \"r16float\"),\r\n    rg8unorm: new TokenType(\"rg8unorm\", TokenClass.keyword, \"rg8unorm\"),\r\n    rg8snorm: new TokenType(\"rg8snorm\", TokenClass.keyword, \"rg8snorm\"),\r\n    rg8uint: new TokenType(\"rg8uint\", TokenClass.keyword, \"rg8uint\"),\r\n    rg8sint: new TokenType(\"rg8sint\", TokenClass.keyword, \"rg8sint\"),\r\n    r32uint: new TokenType(\"r32uint\", TokenClass.keyword, \"r32uint\"),\r\n    r32sint: new TokenType(\"r32sint\", TokenClass.keyword, \"r32sint\"),\r\n    r32float: new TokenType(\"r32float\", TokenClass.keyword, \"r32float\"),\r\n    rg16uint: new TokenType(\"rg16uint\", TokenClass.keyword, \"rg16uint\"),\r\n    rg16sint: new TokenType(\"rg16sint\", TokenClass.keyword, \"rg16sint\"),\r\n    rg16float: new TokenType(\"rg16float\", TokenClass.keyword, \"rg16float\"),\r\n    rgba8unorm: new TokenType(\"rgba8unorm\", TokenClass.keyword, \"rgba8unorm\"),\r\n    rgba8unorm_srgb: new TokenType(\r\n      \"rgba8unorm_srgb\",\r\n      TokenClass.keyword,\r\n      \"rgba8unorm_srgb\"\r\n    ),\r\n    rgba8snorm: new TokenType(\"rgba8snorm\", TokenClass.keyword, \"rgba8snorm\"),\r\n    rgba8uint: new TokenType(\"rgba8uint\", TokenClass.keyword, \"rgba8uint\"),\r\n    rgba8sint: new TokenType(\"rgba8sint\", TokenClass.keyword, \"rgba8sint\"),\r\n    bgra8unorm: new TokenType(\"bgra8unorm\", TokenClass.keyword, \"bgra8unorm\"),\r\n    bgra8unorm_srgb: new TokenType(\r\n      \"bgra8unorm_srgb\",\r\n      TokenClass.keyword,\r\n      \"bgra8unorm_srgb\"\r\n    ),\r\n    rgb10a2unorm: new TokenType(\r\n      \"rgb10a2unorm\",\r\n      TokenClass.keyword,\r\n      \"rgb10a2unorm\"\r\n    ),\r\n    rg11b10float: new TokenType(\r\n      \"rg11b10float\",\r\n      TokenClass.keyword,\r\n      \"rg11b10float\"\r\n    ),\r\n    rg32uint: new TokenType(\"rg32uint\", TokenClass.keyword, \"rg32uint\"),\r\n    rg32sint: new TokenType(\"rg32sint\", TokenClass.keyword, \"rg32sint\"),\r\n    rg32float: new TokenType(\"rg32float\", TokenClass.keyword, \"rg32float\"),\r\n    rgba16uint: new TokenType(\"rgba16uint\", TokenClass.keyword, \"rgba16uint\"),\r\n    rgba16sint: new TokenType(\"rgba16sint\", TokenClass.keyword, \"rgba16sint\"),\r\n    rgba16float: new TokenType(\r\n      \"rgba16float\",\r\n      TokenClass.keyword,\r\n      \"rgba16float\"\r\n    ),\r\n    rgba32uint: new TokenType(\"rgba32uint\", TokenClass.keyword, \"rgba32uint\"),\r\n    rgba32sint: new TokenType(\"rgba32sint\", TokenClass.keyword, \"rgba32sint\"),\r\n    rgba32float: new TokenType(\r\n      \"rgba32float\",\r\n      TokenClass.keyword,\r\n      \"rgba32float\"\r\n    ),\r\n    static_assert: new TokenType(\r\n      \"static_assert\",\r\n      TokenClass.keyword,\r\n      \"static_assert\"\r\n    ),\r\n\r\n    // WGSL grammar has a few keywords that have different token names than the strings they\r\n    // represent. Aliasing them here.\r\n    /*int32: new TokenType(\"i32\", TokenClass.keyword, \"i32\"),\r\n        uint32: new TokenType(\"u32\", TokenClass.keyword, \"u32\"),\r\n        float32: new TokenType(\"f32\", TokenClass.keyword, \"f32\"),\r\n        pointer: new TokenType(\"ptr\", TokenClass.keyword, \"ptr\"),*/\r\n  };\r\n\r\n  static readonly tokens = {\r\n    decimal_float_literal: new TokenType(\r\n      \"decimal_float_literal\",\r\n      TokenClass.token,\r\n      /((-?[0-9]*\\.[0-9]+|-?[0-9]+\\.[0-9]*)((e|E)(\\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/\r\n    ),\r\n    hex_float_literal: new TokenType(\r\n      \"hex_float_literal\",\r\n      TokenClass.token,\r\n      /-?0x((([0-9a-fA-F]*\\.[0-9a-fA-F]+|[0-9a-fA-F]+\\.[0-9a-fA-F]*)((p|P)(\\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\\+|-)?[0-9]+[fh]?))/\r\n    ),\r\n    int_literal: new TokenType(\r\n      \"int_literal\",\r\n      TokenClass.token,\r\n      /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/\r\n    ),\r\n    uint_literal: new TokenType(\r\n      \"uint_literal\",\r\n      TokenClass.token,\r\n      /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/\r\n    ),\r\n    name: new TokenType(\"name\", TokenClass.token,  /([_\\p{XID_Start}][\\p{XID_Continue}]+)|([\\p{XID_Start}])/u),\r\n    //name: new TokenType(\"name\", TokenClass.token, /[_a-zA-Z][0-9a-zA-Z_]*/),\r\n    ident: new TokenType(\"ident\", TokenClass.token, /[_a-zA-Z][0-9a-zA-Z_]*/),\r\n    and: new TokenType(\"and\", TokenClass.token, \"&\"),\r\n    and_and: new TokenType(\"and_and\", TokenClass.token, \"&&\"),\r\n    arrow: new TokenType(\"arrow \", TokenClass.token, \"->\"),\r\n    attr: new TokenType(\"attr\", TokenClass.token, \"@\"),\r\n    forward_slash: new TokenType(\"forward_slash\", TokenClass.token, \"/\"),\r\n    bang: new TokenType(\"bang\", TokenClass.token, \"!\"),\r\n    bracket_left: new TokenType(\"bracket_left\", TokenClass.token, \"[\"),\r\n    bracket_right: new TokenType(\"bracket_right\", TokenClass.token, \"]\"),\r\n    brace_left: new TokenType(\"brace_left\", TokenClass.token, \"{\"),\r\n    brace_right: new TokenType(\"brace_right\", TokenClass.token, \"}\"),\r\n    colon: new TokenType(\"colon\", TokenClass.token, \":\"),\r\n    comma: new TokenType(\"comma\", TokenClass.token, \",\"),\r\n    equal: new TokenType(\"equal\", TokenClass.token, \"=\"),\r\n    equal_equal: new TokenType(\"equal_equal\", TokenClass.token, \"==\"),\r\n    not_equal: new TokenType(\"not_equal\", TokenClass.token, \"!=\"),\r\n    greater_than: new TokenType(\"greater_than\", TokenClass.token, \">\"),\r\n    greater_than_equal: new TokenType(\r\n      \"greater_than_equal\",\r\n      TokenClass.token,\r\n      \">=\"\r\n    ),\r\n    shift_right: new TokenType(\"shift_right\", TokenClass.token, \">>\"),\r\n    less_than: new TokenType(\"less_than\", TokenClass.token, \"<\"),\r\n    less_than_equal: new TokenType(\"less_than_equal\", TokenClass.token, \"<=\"),\r\n    shift_left: new TokenType(\"shift_left\", TokenClass.token, \"<<\"),\r\n    modulo: new TokenType(\"modulo\", TokenClass.token, \"%\"),\r\n    minus: new TokenType(\"minus\", TokenClass.token, \"-\"),\r\n    minus_minus: new TokenType(\"minus_minus\", TokenClass.token, \"--\"),\r\n    period: new TokenType(\"period\", TokenClass.token, \".\"),\r\n    plus: new TokenType(\"plus\", TokenClass.token, \"+\"),\r\n    plus_plus: new TokenType(\"plus_plus\", TokenClass.token, \"++\"),\r\n    or: new TokenType(\"or\", TokenClass.token, \"|\"),\r\n    or_or: new TokenType(\"or_or\", TokenClass.token, \"||\"),\r\n    paren_left: new TokenType(\"paren_left\", TokenClass.token, \"(\"),\r\n    paren_right: new TokenType(\"paren_right\", TokenClass.token, \")\"),\r\n    semicolon: new TokenType(\"semicolon\", TokenClass.token, \";\"),\r\n    star: new TokenType(\"star\", TokenClass.token, \"*\"),\r\n    tilde: new TokenType(\"tilde\", TokenClass.token, \"~\"),\r\n    underscore: new TokenType(\"underscore\", TokenClass.token, \"_\"),\r\n    xor: new TokenType(\"xor\", TokenClass.token, \"^\"),\r\n    plus_equal: new TokenType(\"plus_equal\", TokenClass.token, \"+=\"),\r\n    minus_equal: new TokenType(\"minus_equal\", TokenClass.token, \"-=\"),\r\n    times_equal: new TokenType(\"times_equal\", TokenClass.token, \"*=\"),\r\n    division_equal: new TokenType(\"division_equal\", TokenClass.token, \"/=\"),\r\n    modulo_equal: new TokenType(\"modulo_equal\", TokenClass.token, \"%=\"),\r\n    and_equal: new TokenType(\"and_equal\", TokenClass.token, \"&=\"),\r\n    or_equal: new TokenType(\"or_equal\", TokenClass.token, \"|=\"),\r\n    xor_equal: new TokenType(\"xor_equal\", TokenClass.token, \"^=\"),\r\n    shift_right_equal: new TokenType(\r\n      \"shift_right_equal\",\r\n      TokenClass.token,\r\n      \">>=\"\r\n    ),\r\n    shift_left_equal: new TokenType(\r\n      \"shift_left_equal\",\r\n      TokenClass.token,\r\n      \"<<=\"\r\n    ),\r\n  };\r\n\r\n  static readonly simpleTokens = {\r\n    \"@\": this.tokens.attr,\r\n    \"{\": this.tokens.brace_left,\r\n    \"}\": this.tokens.brace_right,\r\n    \":\": this.tokens.colon,\r\n    \",\": this.tokens.comma,\r\n    \"(\": this.tokens.paren_left,\r\n    \")\": this.tokens.paren_right,\r\n    \";\": this.tokens.semicolon,\r\n  };\r\n\r\n  static readonly literalTokens = {\r\n    \"&\": this.tokens.and,\r\n    \"&&\": this.tokens.and_and,\r\n    \"->\": this.tokens.arrow ,\r\n    \"/\": this.tokens.forward_slash,\r\n    \"!\": this.tokens.bang,\r\n    \"[\": this.tokens.bracket_left,\r\n    \"]\": this.tokens.bracket_right,\r\n    \"=\": this.tokens.equal,\r\n    \"==\": this.tokens.equal_equal,\r\n    \"!=\": this.tokens.not_equal,\r\n    \">\": this.tokens.greater_than,\r\n    \">=\": this.tokens.greater_than_equal,\r\n    \">>\": this.tokens.shift_right,\r\n    \"<\": this.tokens.less_than,\r\n    \"<=\": this.tokens.less_than_equal,\r\n    \"<<\": this.tokens.shift_left,\r\n    \"%\": this.tokens.modulo,\r\n    \"-\": this.tokens.minus,\r\n    \"--\": this.tokens.minus_minus,\r\n    \".\": this.tokens.period,\r\n    \"+\": this.tokens.plus,\r\n    \"++\": this.tokens.plus_plus,\r\n    \"|\": this.tokens.or,\r\n    \"||\": this.tokens.or_or,\r\n    \"*\": this.tokens.star,\r\n    \"~\": this.tokens.tilde,\r\n    \"_\": this.tokens.underscore,\r\n    \"^\": this.tokens.xor,\r\n    \"+=\": this.tokens.plus_equal,\r\n    \"-=\": this.tokens.minus_equal,\r\n    \"*=\": this.tokens.times_equal,\r\n    \"/=\": this.tokens.division_equal,\r\n    \"%=\": this.tokens.modulo_equal,\r\n    \"&=\": this.tokens.and_equal,\r\n    \"|=\": this.tokens.or_equal,\r\n    \"^=\": this.tokens.xor_equal,\r\n    \">>=\": this.tokens.shift_right_equal,\r\n    \"<<=\": this.tokens.shift_left_equal,\r\n  };\r\n\r\n  static readonly regexTokens = {\r\n    decimal_float_literal: this.tokens.decimal_float_literal,\r\n    hex_float_literal: this.tokens.hex_float_literal,\r\n    int_literal: this.tokens.int_literal,\r\n    uint_literal: this.tokens.uint_literal,\r\n    ident: this.tokens.ident,\r\n  };\r\n\r\n  static readonly storage_class = [\r\n    this.keywords.function,\r\n    this.keywords.private,\r\n    this.keywords.workgroup,\r\n    this.keywords.uniform,\r\n    this.keywords.storage,\r\n  ];\r\n\r\n  static readonly access_mode = [\r\n    this.keywords.read,\r\n    this.keywords.write,\r\n    this.keywords.read_write,\r\n  ];\r\n\r\n  static readonly sampler_type = [\r\n    this.keywords.sampler,\r\n    this.keywords.sampler_comparison,\r\n  ];\r\n\r\n  static readonly sampled_texture_type = [\r\n    this.keywords.texture_1d,\r\n    this.keywords.texture_2d,\r\n    this.keywords.texture_2d_array,\r\n    this.keywords.texture_3d,\r\n    this.keywords.texture_cube,\r\n    this.keywords.texture_cube_array,\r\n  ];\r\n\r\n  static readonly multisampled_texture_type = [\r\n    this.keywords.texture_multisampled_2d,\r\n  ];\r\n\r\n  static readonly storage_texture_type = [\r\n    this.keywords.texture_storage_1d,\r\n    this.keywords.texture_storage_2d,\r\n    this.keywords.texture_storage_2d_array,\r\n    this.keywords.texture_storage_3d,\r\n  ];\r\n\r\n  static readonly depth_texture_type = [\r\n    this.keywords.texture_depth_2d,\r\n    this.keywords.texture_depth_2d_array,\r\n    this.keywords.texture_depth_cube,\r\n    this.keywords.texture_depth_cube_array,\r\n    this.keywords.texture_depth_multisampled_2d,\r\n  ];\r\n\r\n  static readonly texture_external_type = [this.keywords.texture_external];\r\n\r\n  static readonly any_texture_type = [\r\n    ...this.sampled_texture_type,\r\n    ...this.multisampled_texture_type,\r\n    ...this.storage_texture_type,\r\n    ...this.depth_texture_type,\r\n    ...this.texture_external_type,\r\n  ];\r\n\r\n  static readonly texel_format = [\r\n    this.keywords.r8unorm,\r\n    this.keywords.r8snorm,\r\n    this.keywords.r8uint,\r\n    this.keywords.r8sint,\r\n    this.keywords.r16uint,\r\n    this.keywords.r16sint,\r\n    this.keywords.r16float,\r\n    this.keywords.rg8unorm,\r\n    this.keywords.rg8snorm,\r\n    this.keywords.rg8uint,\r\n    this.keywords.rg8sint,\r\n    this.keywords.r32uint,\r\n    this.keywords.r32sint,\r\n    this.keywords.r32float,\r\n    this.keywords.rg16uint,\r\n    this.keywords.rg16sint,\r\n    this.keywords.rg16float,\r\n    this.keywords.rgba8unorm,\r\n    this.keywords.rgba8unorm_srgb,\r\n    this.keywords.rgba8snorm,\r\n    this.keywords.rgba8uint,\r\n    this.keywords.rgba8sint,\r\n    this.keywords.bgra8unorm,\r\n    this.keywords.bgra8unorm_srgb,\r\n    this.keywords.rgb10a2unorm,\r\n    this.keywords.rg11b10float,\r\n    this.keywords.rg32uint,\r\n    this.keywords.rg32sint,\r\n    this.keywords.rg32float,\r\n    this.keywords.rgba16uint,\r\n    this.keywords.rgba16sint,\r\n    this.keywords.rgba16float,\r\n    this.keywords.rgba32uint,\r\n    this.keywords.rgba32sint,\r\n    this.keywords.rgba32float,\r\n  ];\r\n\r\n  static readonly const_literal = [\r\n    this.tokens.int_literal,\r\n    this.tokens.uint_literal,\r\n    this.tokens.decimal_float_literal,\r\n    this.tokens.hex_float_literal,\r\n    this.keywords.true,\r\n    this.keywords.false,\r\n  ];\r\n\r\n  static readonly literal_or_ident = [\r\n    this.tokens.ident,\r\n    this.tokens.int_literal,\r\n    this.tokens.uint_literal,\r\n    this.tokens.decimal_float_literal,\r\n    this.tokens.hex_float_literal,\r\n    this.tokens.name\r\n  ];\r\n\r\n  static readonly element_count_expression = [\r\n    this.tokens.int_literal,\r\n    this.tokens.uint_literal,\r\n    this.tokens.ident,\r\n  ];\r\n\r\n  static readonly template_types = [\r\n    this.keywords.vec2,\r\n    this.keywords.vec3,\r\n    this.keywords.vec4,\r\n    this.keywords.mat2x2,\r\n    this.keywords.mat2x3,\r\n    this.keywords.mat2x4,\r\n    this.keywords.mat3x2,\r\n    this.keywords.mat3x3,\r\n    this.keywords.mat3x4,\r\n    this.keywords.mat4x2,\r\n    this.keywords.mat4x3,\r\n    this.keywords.mat4x4,\r\n    this.keywords.atomic,\r\n    this.keywords.bitcast,\r\n    ...this.any_texture_type,\r\n  ];\r\n\r\n  // The grammar calls out 'block', but attribute grammar is defined to use a 'ident'.\r\n  // The attribute grammar should be ident | block.\r\n  static readonly attribute_name = [this.tokens.ident, this.keywords.block, this.keywords.diagnostic];\r\n\r\n  static readonly assignment_operators = [\r\n    this.tokens.equal,\r\n    this.tokens.plus_equal,\r\n    this.tokens.minus_equal,\r\n    this.tokens.times_equal,\r\n    this.tokens.division_equal,\r\n    this.tokens.modulo_equal,\r\n    this.tokens.and_equal,\r\n    this.tokens.or_equal,\r\n    this.tokens.xor_equal,\r\n    this.tokens.shift_right_equal,\r\n    this.tokens.shift_left_equal,\r\n  ];\r\n\r\n  static readonly increment_operators = [\r\n    this.tokens.plus_plus,\r\n    this.tokens.minus_minus,\r\n  ];\r\n}\r\n\r\n/// A token parsed by the WgslScanner.\r\nexport class Token {\r\n  readonly type: TokenType; // The type of the token.\r\n  readonly lexeme: string; // The string of the token, as parsed from the source text.\r\n  readonly line: number; // The line number of the token in the source text.\r\n  readonly start: number; // The start position of the token in the source text.\r\n  readonly end: number; // The end position of the token in the source text.\r\n\r\n  constructor(type: TokenType, lexeme: string, line: number, start: number, end: number) {\r\n    this.type = type;\r\n    this.lexeme = lexeme;\r\n    this.line = line;\r\n    this.start = start;\r\n    this.end = end;\r\n  }\r\n\r\n  toString(): string {\r\n    return this.lexeme;\r\n  }\r\n\r\n  isTemplateType(): boolean {\r\n    return TokenTypes.template_types.indexOf(this.type) != -1;\r\n  }\r\n\r\n  isArrayType(): boolean {\r\n    return this.type == TokenTypes.keywords.array;\r\n  }\r\n\r\n  isArrayOrTemplateType(): boolean {\r\n    return this.isArrayType() || this.isTemplateType();\r\n  }\r\n}\r\n\r\n/// Lexical scanner for the WGSL language. This takes an input source text and generates a list\r\n/// of Token objects, which can then be fed into the WgslParser to generate an AST.\r\nexport class WgslScanner {\r\n  private _source: string;\r\n  private _tokens: Token[] = [];\r\n  private _start = 0;\r\n  private _current = 0;\r\n  private _line = 1;\r\n\r\n  constructor(source?: string) {\r\n    this._source = source ?? \"\";\r\n  }\r\n\r\n  /// Scan all tokens from the source.\r\n  scanTokens(): Token[] {\r\n    while (!this._isAtEnd()) {\r\n      this._start = this._current;\r\n      if (!this.scanToken()) {\r\n        throw `Invalid syntax at line ${this._line}`;\r\n      }\r\n    }\r\n\r\n    this._tokens.push(new Token(TokenTypes.eof, \"\", this._line, this._current, this._current));\r\n\r\n    return this._tokens;\r\n  }\r\n\r\n  /// Scan a single token from the source.\r\n  scanToken(): boolean {\r\n    // Find the longest consecutive set of characters that match a rule.\r\n    let lexeme = this._advance();\r\n\r\n    // Skip line-feed, adding to the line counter.\r\n    if (lexeme == \"\\n\") {\r\n      this._line++;\r\n      return true;\r\n    }\r\n\r\n    // Skip whitespace\r\n    if (this._isWhitespace(lexeme)) {\r\n      return true;\r\n    }\r\n\r\n    if (lexeme == \"/\") {\r\n      // If it's a // comment, skip everything until the next line-feed.\r\n      if (this._peekAhead() == \"/\") {\r\n        while (lexeme != \"\\n\") {\r\n          if (this._isAtEnd()) {\r\n            return true;\r\n          }\r\n          lexeme = this._advance();\r\n        }\r\n        // skip the linefeed\r\n        this._line++;\r\n        return true;\r\n      } else if (this._peekAhead() == \"*\") {\r\n        // If it's a / * block comment, skip everything until the matching * /,\r\n        // allowing for nested block comments.\r\n        this._advance();\r\n        let commentLevel = 1;\r\n        while (commentLevel > 0) {\r\n          if (this._isAtEnd()) {\r\n            return true;\r\n          }\r\n          lexeme = this._advance();\r\n          if (lexeme == \"\\n\") {\r\n            this._line++;\r\n          } else if (lexeme == \"*\") {\r\n            if (this._peekAhead() == \"/\") {\r\n              this._advance();\r\n              commentLevel--;\r\n              if (commentLevel == 0) {\r\n                return true;\r\n              }\r\n            }\r\n          } else if (lexeme == \"/\") {\r\n            if (this._peekAhead() == \"*\") {\r\n              this._advance();\r\n              commentLevel++;\r\n            }\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // Shortcut single character tokens\r\n    const simpleToken = TokenTypes.simpleTokens[lexeme];\r\n    if (simpleToken) {\r\n      this._addToken(simpleToken);\r\n      return true;\r\n    }\r\n\r\n    // Shortcut keywords and identifiers\r\n    let matchType = TokenTypes.none;\r\n    const isAlpha = this._isAlpha(lexeme);\r\n    const isUnderscore = lexeme === \"_\";\r\n\r\n    if (this._isAlphaNumeric(lexeme)) {\r\n      let nextChar = this._peekAhead();\r\n      while (this._isAlphaNumeric(nextChar)) {\r\n        lexeme += this._advance();\r\n        nextChar = this._peekAhead();\r\n      }\r\n    }\r\n\r\n    if (isAlpha) {\r\n      const matchedType = TokenTypes.keywords[lexeme];\r\n      if (matchedType) {\r\n        this._addToken(matchedType);\r\n        return true;\r\n      }\r\n    }\r\n\r\n    if (isAlpha || isUnderscore) {\r\n      this._addToken(TokenTypes.tokens.ident);\r\n      return true;\r\n    }\r\n\r\n    // Scan for the next valid token type\r\n    for (;;) {\r\n      let matchedType = this._findType(lexeme);\r\n\r\n      // An exception to \"longest lexeme\" rule is '>>'. In the case of 1>>2, it's a\r\n      // shift_right.\r\n      // In the case of array<vec4<f32>>, it's two greater_than's (one to close the vec4,\r\n      // and one to close the array).\r\n      // Another ambiguity is '>='. In the case of vec2<i32>=vec2(1,2),\r\n      // it's a greather_than and an equal, not a greater_than_equal.\r\n      // Another ambiguity is '-'. In the case of a-2, it's a minus; in the case of a*-2, it's a -2;\r\n      // in the case of foo()->int, it's a ->; in the case of foo-- or --foo, it's a -- decrement.\r\n\r\n      // WGSL requires context sensitive parsing to resolve these ambiguities. Both of these cases\r\n      // are predicated on it the > either closing a template, or being part of an operator.\r\n      // The solution here is to check if there was a less_than up to some number of tokens\r\n      // previously, and the token prior to that is a keyword that requires a '<', then it will be\r\n      // split into two operators; otherwise it's a single operator.\r\n      const nextLexeme = this._peekAhead();\r\n      if (lexeme == \"-\" && this._tokens.length > 0) {\r\n        if (nextLexeme == \"=\") {\r\n          this._current++;\r\n          lexeme += nextLexeme;\r\n          this._addToken(TokenTypes.tokens.minus_equal);\r\n          return true;\r\n        }\r\n        if (nextLexeme == \"-\") {\r\n          this._current++;\r\n          lexeme += nextLexeme;\r\n          this._addToken(TokenTypes.tokens.minus_minus);\r\n          return true;\r\n        }\r\n        const ti = this._tokens.length - 1;\r\n        const isIdentOrLiteral = TokenTypes.literal_or_ident.indexOf(this._tokens[ti].type) != -1;\r\n        if ((isIdentOrLiteral || this._tokens[ti].type == TokenTypes.tokens.paren_right) && nextLexeme != \">\") {\r\n          this._addToken(matchedType);\r\n          return true;\r\n        }\r\n      }\r\n      if (lexeme == \">\" && (nextLexeme == \">\" || nextLexeme == \"=\")) {\r\n        let foundLessThan = false;\r\n        let ti = this._tokens.length - 1;\r\n        for (let count = 0; count < 5 && ti >= 0; ++count, --ti) {\r\n          if (TokenTypes.assignment_operators.indexOf(this._tokens[ti].type) !== -1) {\r\n            break;\r\n          }\r\n          if (this._tokens[ti].type === TokenTypes.tokens.less_than) {\r\n            if (ti > 0 && this._tokens[ti - 1].isArrayOrTemplateType()) {\r\n              foundLessThan = true;\r\n            }\r\n            break;\r\n          }\r\n        }\r\n        // If there was a less_than in the recent token history, then this is probably a\r\n        // greater_than.\r\n        if (foundLessThan) {\r\n          this._addToken(matchedType);\r\n          return true;\r\n        }\r\n      }\r\n\r\n      // The current lexeme may not match any rule, but some token types may be invalid for\r\n      // part of the string but valid after a few more characters.\r\n      // For example, 0x.5 is a hex_float_literal. But as it's being scanned,\r\n      // \"0\" is a int_literal, then \"0x\" is invalid. If we stopped there, it would return\r\n      // the int_literal \"0\", but that's incorrect. So if we look forward a few characters,\r\n      // we'd get \"0x.\", which is still invalid, followed by \"0x.5\" which is the correct\r\n      // hex_float_literal. So that means if we hit an non-matching string, we should look\r\n      // ahead up to two characters to see if the string starts matching a valid rule again.\r\n      if (matchedType === TokenTypes.none) {\r\n        let lookAheadLexeme = lexeme;\r\n        let lookAhead = 0;\r\n        const maxLookAhead = 2;\r\n        for (let li = 0; li < maxLookAhead; ++li) {\r\n          lookAheadLexeme += this._peekAhead(li);\r\n          matchedType = this._findType(lookAheadLexeme);\r\n          if (matchedType !== TokenTypes.none) {\r\n            lookAhead = li;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (matchedType === TokenTypes.none) {\r\n          if (matchType === TokenTypes.none) {\r\n            return false;\r\n          }\r\n          this._current--;\r\n          this._addToken(matchType);\r\n          return true;\r\n        }\r\n\r\n        lexeme = lookAheadLexeme;\r\n        this._current += lookAhead + 1;\r\n      }\r\n\r\n      matchType = matchedType;\r\n\r\n      if (this._isAtEnd()) {\r\n        break;\r\n      }\r\n\r\n      lexeme += this._advance();\r\n    }\r\n\r\n    // We got to the end of the input stream. Then the token we've ready so far is it.\r\n    if (matchType === TokenTypes.none) {\r\n      return false;\r\n    }\r\n\r\n    this._addToken(matchType);\r\n    return true;\r\n  }\r\n\r\n  _findType(lexeme: string): TokenType {\r\n    for (const name in TokenTypes.regexTokens) {\r\n      const type = TokenTypes.regexTokens[name];\r\n      if (this._match(lexeme, type.rule)) {\r\n        return type;\r\n      }\r\n    }\r\n\r\n    const type = TokenTypes.literalTokens[lexeme];\r\n    if (type) {\r\n      return type;\r\n    }\r\n\r\n    return TokenTypes.none;\r\n  }\r\n\r\n  _match(lexeme: string, rule: RegExp): boolean {\r\n    const match = rule.exec(lexeme);\r\n    return match && match.index == 0 && match[0] == lexeme;\r\n  }\r\n\r\n  _isAtEnd(): boolean {\r\n    return this._current >= this._source.length;\r\n  }\r\n\r\n  _isAlpha(c: string): boolean {\r\n    // To support UTF-8 characters, allow anything other than whitespace, numbers, or operators\r\n    return !this._isNumeric(c) && !this._isWhitespace(c) && c !== \"_\" && c !== \".\" && c !== \"(\" && c !== \")\" &&\r\n      c !== \"[\" && c !== \"]\" && c !== \"{\" && c !== \"}\" && c !== \",\" && c !== \";\" && c !== \":\" && c !== \"=\" &&\r\n      c !== \"!\" && c !== \"<\" && c !== \">\" && c !== \"+\" && c !== \"-\" && c !== \"*\" && c !== \"/\" && c !== \"%\" &&\r\n      c !== \"&\" && c !== \"|\" && c !== \"^\" && c !== \"~\" && c !== \"@\" && c !== \"#\" && c !== \"?\" && c !== \"'\" &&\r\n      c !== \"`\" && c !== \"\\\"\" && c !== \"\\\\\" && c !== \"\\n\" && c !== \"\\r\" && c !== \"\\t\" && c !== \"\\0\";\r\n  }\r\n\r\n  _isNumeric(c: string): boolean {\r\n    return c >= \"0\" && c <= \"9\";\r\n  }\r\n\r\n  _isAlphaNumeric(c: string): boolean {\r\n    return this._isAlpha(c) || this._isNumeric(c) || c === \"_\";\r\n  }\r\n\r\n  _isWhitespace(c: string): boolean {\r\n    return c == \" \" || c == \"\\t\" || c == \"\\r\";\r\n  }\r\n\r\n  _advance(amount: number = 0): string {\r\n    let c = this._source[this._current];\r\n    amount = amount || 0;\r\n    amount++;\r\n    this._current += amount;\r\n    return c;\r\n  }\r\n\r\n  _peekAhead(offset: number = 0): string {\r\n    offset = offset || 0;\r\n    if (this._current + offset >= this._source.length) {\r\n      return \"\\0\";\r\n    }\r\n    return this._source[this._current + offset];\r\n  }\r\n\r\n  _addToken(type: TokenType) {\r\n    const text = this._source.substring(this._start, this._current);\r\n    this._tokens.push(new Token(type, text, this._line, this._start, this._current));\r\n  }\r\n}\r\n", "export function isArray(value: any): boolean {\r\n    return Array.isArray(value) || value?.buffer instanceof ArrayBuffer;\r\n}\r\n\r\nexport function isNumber(value: any): boolean {\r\n    return typeof value === \"number\";\r\n}\r\n\r\nconst _f32 = new Float32Array(1);\r\nconst _f32_i32 = new Uint32Array(_f32.buffer);\r\nconst _f32_u32 = new Uint32Array(_f32.buffer);\r\nconst _i32 = new Int32Array(1);\r\nconst _i32_f32 = new Float32Array(_i32.buffer);\r\nconst _i32_u32 = new Uint32Array(_i32.buffer);\r\nconst _u32 = new Uint32Array(1);\r\nconst _u32_f32 = new Float32Array(_u32.buffer);\r\nconst _u32_i32 = new Int32Array(_u32.buffer);\r\n\r\nexport function castScalar(v: number, from: string, to: string): number {\r\n    if (from === to) {\r\n        return v;\r\n    }\r\n\r\n    if (from === \"f32\") {\r\n        if (to === \"i32\" || to === \"x32\") {\r\n            _f32[0] = v;\r\n            return _f32_i32[0];\r\n        } else if (to === \"u32\") {\r\n            _f32[0] = v;\r\n            return _f32_u32[0];\r\n        }\r\n    } else if (from === \"i32\" || from === \"x32\") {\r\n        if (to === \"f32\") {\r\n            _i32[0] = v;\r\n            return _i32_f32[0];\r\n        } else if (to === \"u32\") {\r\n            _i32[0] = v;\r\n            return _i32_u32[0];\r\n        }\r\n    } else if (from === \"u32\") {\r\n        if (to === \"f32\") {\r\n            _u32[0] = v;\r\n            return _u32_f32[0];\r\n        } else if (to === \"i32\" || to === \"x32\") {\r\n            _u32[0] = v;\r\n            return _u32_i32[0];\r\n        }\r\n    }\r\n\r\n    console.error(`Unsupported cast from ${from} to ${to}`);\r\n    return v;\r\n}\r\n\r\nexport function castVector(v: number[], from: string, to: string): number[] {\r\n    if (from === to) {\r\n        return v;\r\n    }\r\n\r\n    const cast = new Array<number>(v.length);\r\n    for (let i = 0; i < v.length; i++) {\r\n        cast[i] = castScalar(v[i], from, to);\r\n    }\r\n\r\n    return cast;\r\n}\r\n", "/**\r\n * @author Brendan Duncan / https://github.com/brendan-duncan\r\n */\r\nimport { TokenTypes } from \"../wgsl_scanner.js\";\r\nimport { Type, Struct, Alias, Override, Var, Node, Function, VariableExpr, CreateExpr,\r\n    Let, CallExpr, Call, Argument, Member, Attribute, ArrayType, SamplerType, TemplateType, \r\n    PointerType } from \"../wgsl_ast.js\";\r\nimport { _BlockStart, _BlockEnd } from \"../wgsl_ast.js\";\r\nimport { FunctionInfo, VariableInfo, AliasInfo, OverrideInfo, PointerInfo,\r\n  StructInfo, TypeInfo, MemberInfo, ArrayInfo, TemplateInfo, OutputInfo,\r\n  InputInfo, ArgumentInfo, ResourceType, EntryFunctions } from \"./info.js\";\r\nimport { isArray } from \"../utils/cast.js\";\r\n \r\nclass _FunctionResources {\r\n  node: Function;\r\n  resources: VariableInfo[] | null = null;\r\n  inUse: boolean = false;\r\n  info: FunctionInfo | null = null;\r\n  constructor(node: Function) {\r\n    this.node = node;\r\n  }\r\n}\r\n\r\nclass _TypeSize {\r\n  align: number;\r\n  size: number;\r\n\r\n  constructor(align: number, size: number) {\r\n    this.align = align;\r\n    this.size = size;\r\n  }\r\n}\r\n\r\nexport class Reflect {\r\n  /// All top-level uniform vars in the shader.\r\n  uniforms: VariableInfo[] = [];\r\n  /// All top-level storage vars in the shader.\r\n  storage: VariableInfo[] = [];\r\n  /// All top-level texture vars in the shader;\r\n  textures: VariableInfo[] = [];\r\n  // All top-level sampler vars in the shader.\r\n  samplers: VariableInfo[] = [];\r\n  /// All top-level type aliases in the shader.\r\n  aliases: AliasInfo[] = [];\r\n  /// All top-level overrides in the shader.\r\n  overrides: OverrideInfo[] = [];\r\n  /// All top-level structs in the shader.\r\n  structs: StructInfo[] = [];\r\n  /// All entry functions in the shader: vertex, fragment, and/or compute.\r\n  entry: EntryFunctions = new EntryFunctions();\r\n  /// All functions in the shader, including entry functions.\r\n  functions: FunctionInfo[] = [];\r\n\r\n  _types: Map<Type, TypeInfo> = new Map();\r\n  _functions: Map<string, _FunctionResources> = new Map();\r\n\r\n  _isStorageTexture(type: TypeInfo): boolean {\r\n    return (\r\n      type.name == \"texture_storage_1d\" ||\r\n      type.name == \"texture_storage_2d\" ||\r\n      type.name == \"texture_storage_2d_array\" ||\r\n      type.name == \"texture_storage_3d\"\r\n    );\r\n  }\r\n\r\n  updateAST(ast: Node[]): void {\r\n    for (const node of ast) {\r\n      if (node instanceof Function) {\r\n        this._functions.set(node.name, new _FunctionResources(node as Function));\r\n      }\r\n    }\r\n\r\n    for (const node of ast) {\r\n      if (node instanceof Struct) {\r\n        const info = this.getTypeInfo(node as Struct, null);\r\n        if (info instanceof StructInfo) {\r\n          this.structs.push(info as StructInfo);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const node of ast) {\r\n      if (node instanceof Alias) {\r\n        this.aliases.push(this._getAliasInfo(node as Alias));\r\n        continue;\r\n      }\r\n\r\n      if (node instanceof Override) {\r\n        const v = node as Override;\r\n        const id = this._getAttributeNum(v.attributes, \"id\", 0);\r\n        const type = v.type != null ? this.getTypeInfo(v.type, v.attributes) : null;\r\n        this.overrides.push(new OverrideInfo(v.name, type, v.attributes, id));\r\n        continue;\r\n      }\r\n\r\n      if (this._isUniformVar(node)) {\r\n        const v = node as Var;\r\n        const g = this._getAttributeNum(v.attributes, \"group\", 0);\r\n        const b = this._getAttributeNum(v.attributes, \"binding\", 0);\r\n        const type = this.getTypeInfo(v.type!, v.attributes);\r\n        const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, ResourceType.Uniform, v.access);\r\n        if (!varInfo.access) {\r\n          varInfo.access = \"read\";\r\n        }\r\n        this.uniforms.push(varInfo);\r\n        continue;\r\n      }\r\n\r\n      if (this._isStorageVar(node)) {\r\n        const v = node as Var;\r\n        const g = this._getAttributeNum(v.attributes, \"group\", 0);\r\n        const b = this._getAttributeNum(v.attributes, \"binding\", 0);\r\n        const type = this.getTypeInfo(v.type!, v.attributes);\r\n        const isStorageTexture = this._isStorageTexture(type);\r\n        const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, isStorageTexture ? ResourceType.StorageTexture : ResourceType.Storage, v.access);\r\n        if (!varInfo.access) {\r\n          varInfo.access = \"read\";\r\n        }\r\n        this.storage.push(varInfo);\r\n        continue;\r\n      }\r\n\r\n      if (this._isTextureVar(node)) {\r\n        const v = node as Var;\r\n        const g = this._getAttributeNum(v.attributes, \"group\", 0);\r\n        const b = this._getAttributeNum(v.attributes, \"binding\", 0);\r\n        const type = this.getTypeInfo(v.type!, v.attributes);\r\n        const isStorageTexture = this._isStorageTexture(type);\r\n        const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, \r\n            isStorageTexture ? ResourceType.StorageTexture : ResourceType.Texture, v.access);\r\n        if (!varInfo.access) {\r\n          varInfo.access = \"read\";\r\n        }\r\n        if (isStorageTexture) {\r\n          this.storage.push(varInfo);\r\n        } else {\r\n          this.textures.push(varInfo);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      if (this._isSamplerVar(node)) {\r\n        const v = node as Var;\r\n        const g = this._getAttributeNum(v.attributes, \"group\", 0);\r\n        const b = this._getAttributeNum(v.attributes, \"binding\", 0);\r\n        const type = this.getTypeInfo(v.type!, v.attributes);\r\n        const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, ResourceType.Sampler, v.access);\r\n        this.samplers.push(varInfo);\r\n        continue;\r\n      }\r\n    }\r\n\r\n    for (const node of ast) {\r\n      if (node instanceof Function) {\r\n        const vertexStage = this._getAttribute(node, \"vertex\");\r\n        const fragmentStage = this._getAttribute(node, \"fragment\");\r\n        const computeStage = this._getAttribute(node, \"compute\");\r\n        const stage = vertexStage || fragmentStage || computeStage;\r\n\r\n        const fn = new FunctionInfo(node.name, stage?.name, node.attributes);\r\n        fn.attributes = node.attributes;\r\n        fn.startLine = node.startLine;\r\n        fn.endLine = node.endLine;\r\n        this.functions.push(fn);\r\n        this._functions.get(node.name)!.info = fn;\r\n\r\n        if (stage) {\r\n          this._functions.get(node.name)!.inUse = true;\r\n          fn.inUse = true;\r\n          fn.resources = this._findResources(node, !!stage);\r\n          fn.inputs = this._getInputs(node.args);\r\n          fn.outputs = this._getOutputs(node.returnType);\r\n          this.entry[stage.name].push(fn);\r\n        }\r\n\r\n        fn.arguments = node.args.map(\r\n          (arg) => new ArgumentInfo(arg.name, this.getTypeInfo(arg.type, arg.attributes), arg.attributes)\r\n        );\r\n\r\n        fn.returnType = node.returnType ? this.getTypeInfo(node.returnType, node.attributes) : null;\r\n\r\n        continue;\r\n      }\r\n    }\r\n\r\n    for (const fn of this._functions.values()) {\r\n      if (fn.info) {\r\n        fn.info.inUse = fn.inUse;\r\n        this._addCalls(fn.node, fn.info.calls);\r\n      }\r\n    }\r\n\r\n    for (const fn of this._functions.values()) {\r\n      fn.node.search((node) => {\r\n        if (node instanceof Attribute) {\r\n          if (node.value) {\r\n            if (isArray(node.value)) {\r\n              for (const value of node.value) {\r\n                for (const override of this.overrides) {\r\n                  if (value === override.name) {\r\n                    fn.info?.overrides.push(override);\r\n                  }\r\n                }\r\n              }\r\n            } else {\r\n              for (const override of this.overrides) {\r\n                if (node.value === override.name) {\r\n                  fn.info?.overrides.push(override);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } else if (node instanceof VariableExpr) {\r\n          for (const override of this.overrides) {\r\n            if (node.name === override.name) {\r\n              fn.info?.overrides.push(override);\r\n            }\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    for (const u of this.uniforms) {\r\n      this._markStructsInUse(u.type);\r\n    }\r\n    for (const s of this.storage) {\r\n      this._markStructsInUse(s.type);\r\n    }\r\n  }\r\n\r\n  getFunctionInfo(name: string): FunctionInfo | null {\r\n    for (const fn of this.functions) {\r\n      if (fn.name == name) {\r\n        return fn;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  getStructInfo(name: string): StructInfo | null {\r\n    for (const s of this.structs) {\r\n      if (s.name == name) {\r\n        return s;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  getOverrideInfo(name: string): OverrideInfo | null {\r\n    for (const o of this.overrides) {\r\n      if (o.name == name) {\r\n        return o;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _markStructsInUse(type: TypeInfo) {\r\n    if (!type) {\r\n      return;\r\n    }\r\n    if (type.isStruct) {\r\n      (type as StructInfo).inUse = true;\r\n      if ((type as StructInfo).members) {\r\n        for (const m of (type as StructInfo).members) {\r\n          this._markStructsInUse(m.type);\r\n        }\r\n      }\r\n    } else if (type.isArray) {\r\n      this._markStructsInUse((type as ArrayInfo).format);\r\n    } else if (type.isTemplate) {\r\n      if ((type as TemplateInfo).format) {\r\n        this._markStructsInUse((type as TemplateInfo).format!);\r\n      }\r\n    } else {\r\n      const alias = this._getAlias(type.name);\r\n      if (alias) {\r\n        this._markStructsInUse(alias);\r\n      }\r\n    }\r\n  }\r\n\r\n  _addCalls(fn: Function, calls: Set<FunctionInfo>, ) {\r\n    for (const call of fn.calls) {\r\n      const info = this._functions.get(call.name)?.info;\r\n      if (info) {\r\n        calls.add(info);\r\n      }\r\n    }\r\n  }\r\n\r\n  /// Find a resource by its group and binding.\r\n  findResource(group: number, binding: number, entry?: string) {\r\n    if (entry) {\r\n      for (const fn of this.entry.compute) {\r\n        if (fn.name === entry) {\r\n          for (const r of fn.resources) {\r\n            if (r.group == group && r.binding == binding) {\r\n              return r;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      for (const fn of this.entry.vertex) {\r\n        if (fn.name === entry) {\r\n          for (const r of fn.resources) {\r\n            if (r.group == group && r.binding == binding) {\r\n              return r;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      for (const fn of this.entry.fragment) {\r\n        if (fn.name === entry) {\r\n          for (const r of fn.resources) {\r\n            if (r.group == group && r.binding == binding) {\r\n              return r;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const u of this.uniforms) {\r\n      if (u.group == group && u.binding == binding) {\r\n        return u;\r\n      }\r\n    }\r\n    for (const s of this.storage) {\r\n      if (s.group == group && s.binding == binding) {\r\n        return s;\r\n      }\r\n    }\r\n    for (const t of this.textures) {\r\n      if (t.group == group && t.binding == binding) {\r\n        return t;\r\n      }\r\n    }\r\n    for (const s of this.samplers) {\r\n      if (s.group == group && s.binding == binding) {\r\n        return s;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _findResource(name: string): VariableInfo | null {\r\n    for (const u of this.uniforms) {\r\n      if (u.name == name) {\r\n        return u;\r\n      }\r\n    }\r\n    for (const s of this.storage) {\r\n      if (s.name == name) {\r\n        return s;\r\n      }\r\n    }\r\n    for (const t of this.textures) {\r\n      if (t.name == name) {\r\n        return t;\r\n      }\r\n    }\r\n    for (const s of this.samplers) {\r\n      if (s.name == name) {\r\n        return s;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  _markStructsFromAST(type: Type) {\r\n    const info = this.getTypeInfo(type, null);\r\n    this._markStructsInUse(info);\r\n  }\r\n\r\n  _findResources(fn: Node, isEntry: boolean): VariableInfo[] {\r\n    const resources: any[] = [];\r\n    const self = this;\r\n    const varStack: any[] = [];\r\n    fn.search((node) => {\r\n      if (node instanceof _BlockStart) {\r\n        varStack.push({});\r\n      } else if (node instanceof _BlockEnd) {\r\n        varStack.pop();\r\n      } else if (node instanceof Var) {\r\n        const v = node as Var;\r\n        if (isEntry && v.type !== null) {\r\n          this._markStructsFromAST(v.type);\r\n        }\r\n        if (varStack.length > 0) {\r\n          varStack[varStack.length - 1][v.name] = v;\r\n        }\r\n      } else if (node instanceof CreateExpr) {\r\n        const c = node as CreateExpr;\r\n        if (isEntry && c.type !== null) {\r\n          this._markStructsFromAST(c.type);\r\n        }\r\n      } else if (node instanceof Let) {\r\n        const v = node as Let;\r\n        if (isEntry && v.type !== null) {\r\n          this._markStructsFromAST(v.type);\r\n        }\r\n        if (varStack.length > 0) {\r\n          varStack[varStack.length - 1][v.name] = v;\r\n        }\r\n      } else if (node instanceof VariableExpr) {\r\n        const v = node as VariableExpr;\r\n        // Check to see if the variable is a local variable before checking to see if it's\r\n        // a resource.\r\n        if (varStack.length > 0) {\r\n          const varInfo = varStack[varStack.length - 1][v.name];\r\n          if (varInfo) {\r\n            return;\r\n          }\r\n        }\r\n        const varInfo = self._findResource(v.name);\r\n        if (varInfo) {\r\n          resources.push(varInfo);\r\n        }\r\n      } else if (node instanceof CallExpr) {\r\n        const c = node as CallExpr;\r\n        const callFn = self._functions.get(c.name);\r\n        if (callFn) {\r\n          if (isEntry) {\r\n            callFn.inUse = true;\r\n          }\r\n          (fn as Function).calls.add(callFn.node);\r\n          if (callFn.resources === null) {\r\n            callFn.resources = self._findResources(callFn.node, isEntry);\r\n          }\r\n          resources.push(...callFn.resources);\r\n        }\r\n      } else if (node instanceof Call) {\r\n        const c = node as Call;\r\n        const callFn = self._functions.get(c.name);\r\n        if (callFn) {\r\n          if (isEntry) {\r\n            callFn.inUse = true;\r\n          }\r\n          (fn as Function).calls.add(callFn.node);\r\n          if (callFn.resources === null) {\r\n            callFn.resources = self._findResources(callFn.node, isEntry);\r\n          }\r\n          resources.push(...callFn.resources);\r\n        }\r\n      }\r\n    });\r\n    return [...new Map(resources.map(r => [r.name, r])).values()];\r\n  }\r\n\r\n  getBindGroups(): Array<VariableInfo[]> {\r\n    const groups: Array<VariableInfo[]> = [];\r\n\r\n    function _makeRoom(group: number, binding: number) {\r\n      if (group >= groups.length) {\r\n        groups.length = group + 1;\r\n      }\r\n\r\n      if (groups[group] === undefined) {\r\n        groups[group] = [];\r\n      }\r\n\r\n      if (binding >= groups[group].length) {\r\n        groups[group].length = binding + 1;\r\n      }\r\n    }\r\n\r\n    for (const u of this.uniforms) {\r\n      _makeRoom(u.group, u.binding);\r\n      const group = groups[u.group];\r\n      group[u.binding] = u;\r\n    }\r\n\r\n    for (const u of this.storage) {\r\n      _makeRoom(u.group, u.binding);\r\n      const group = groups[u.group];\r\n      group[u.binding] = u;\r\n    }\r\n\r\n    for (const t of this.textures) {\r\n      _makeRoom(t.group, t.binding);\r\n      const group = groups[t.group];\r\n      group[t.binding] = t;\r\n    }\r\n\r\n    for (const t of this.samplers) {\r\n      _makeRoom(t.group, t.binding);\r\n      const group = groups[t.group];\r\n      group[t.binding] = t;\r\n    }\r\n\r\n    return groups;\r\n  }\r\n\r\n  _getOutputs(\r\n    type: Type,\r\n    outputs: OutputInfo[] | undefined = undefined\r\n  ): OutputInfo[] {\r\n    if (outputs === undefined) {\r\n      outputs = [];\r\n    }\r\n\r\n    if (type instanceof Struct) {\r\n      this._getStructOutputs(type, outputs);\r\n    } else {\r\n      const output = this._getOutputInfo(type);\r\n      if (output !== null) {\r\n        outputs.push(output);\r\n      }\r\n    }\r\n\r\n    return outputs;\r\n  }\r\n\r\n  _getStructOutputs(struct: Struct, outputs: OutputInfo[]) {\r\n    for (const m of struct.members) {\r\n      if (m.type instanceof Struct) {\r\n        this._getStructOutputs(m.type, outputs);\r\n      } else {\r\n        const location =\r\n          this._getAttribute(m, \"location\") || this._getAttribute(m, \"builtin\");\r\n        if (location !== null) {\r\n          const typeInfo = this.getTypeInfo(m.type, m.type.attributes);\r\n          const locationValue = this._parseInt(location.value);\r\n          const info = new OutputInfo(\r\n            m.name,\r\n            typeInfo,\r\n            location.name,\r\n            locationValue\r\n          );\r\n          outputs.push(info);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  _getOutputInfo(type: Type): OutputInfo | null {\r\n    const location =\r\n      this._getAttribute(type, \"location\") ||\r\n      this._getAttribute(type, \"builtin\");\r\n    if (location !== null) {\r\n      const typeInfo = this.getTypeInfo(type, type.attributes);\r\n      const locationValue = this._parseInt(location.value);\r\n      const info = new OutputInfo(\"\", typeInfo, location.name, locationValue);\r\n      return info;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _getInputs(\r\n    args: Argument[],\r\n    inputs: InputInfo[] | undefined = undefined\r\n  ): InputInfo[] {\r\n    if (inputs === undefined) {\r\n      inputs = [];\r\n    }\r\n\r\n    for (const arg of args) {\r\n      if (arg.type instanceof Struct) {\r\n        this._getStructInputs(arg.type, inputs);\r\n      } else {\r\n        const input = this._getInputInfo(arg);\r\n        if (input !== null) {\r\n          inputs.push(input);\r\n        }\r\n      }\r\n    }\r\n\r\n    return inputs;\r\n  }\r\n\r\n  _getStructInputs(struct: Struct, inputs: InputInfo[]) {\r\n    for (const m of struct.members) {\r\n      if (m.type instanceof Struct) {\r\n        this._getStructInputs(m.type, inputs);\r\n      } else {\r\n        const input = this._getInputInfo(m);\r\n        if (input !== null) {\r\n          inputs.push(input);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  _getInputInfo(node: Member | Argument): InputInfo | null {\r\n    const location =\r\n      this._getAttribute(node, \"location\") ||\r\n      this._getAttribute(node, \"builtin\");\r\n    if (location !== null) {\r\n      const interpolation = this._getAttribute(node, \"interpolation\");\r\n      const type = this.getTypeInfo(node.type, node.attributes);\r\n      const locationValue = this._parseInt(location.value);\r\n      const info = new InputInfo(node.name, type, location.name, locationValue);\r\n      if (interpolation !== null) {\r\n        info.interpolation = this._parseString(interpolation.value);\r\n      }\r\n      return info;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _parseString(s: string | string[]): string {\r\n    if (s instanceof Array) {\r\n      s = s[0];\r\n    }\r\n    return s;\r\n  }\r\n\r\n  _parseInt(s: string | string[]): number | string {\r\n    if (s instanceof Array) {\r\n      s = s[0];\r\n    }\r\n    const n = parseInt(s);\r\n    return isNaN(n) ? s : n;\r\n  }\r\n\r\n  _getAlias(name: string): TypeInfo | null {\r\n    for (const a of this.aliases) {\r\n      if (a.name == name) {\r\n        return a.type;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _getAliasInfo(node: Alias): AliasInfo {\r\n    return new AliasInfo(node.name, this.getTypeInfo(node.type!, null));\r\n  }\r\n\r\n  getTypeInfoByName(name: string): TypeInfo | null {\r\n    for (const s of this.structs) {\r\n      if (s.name == name) {\r\n        return s;\r\n      }\r\n    }\r\n    for (const a of this.aliases) {\r\n      if (a.name == name) {\r\n        return a.type;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  getTypeInfo(type: Type, attributes: Attribute[] | null = null): TypeInfo {\r\n    if (this._types.has(type)) {\r\n      return this._types.get(type)!;\r\n    }\r\n\r\n    if (type instanceof PointerType) {\r\n      const t = type.type ? this.getTypeInfo(type.type!, type.attributes) : null;\r\n      const info = new PointerInfo(type.name, t, attributes);\r\n      this._types.set(type, info);\r\n      this._updateTypeInfo(info);\r\n      return info;\r\n    }\r\n\r\n    if (type instanceof ArrayType) {\r\n      const a = type as ArrayType;\r\n      const t = a.format ? this.getTypeInfo(a.format!, a.attributes) : null;\r\n      const info = new ArrayInfo(a.name, attributes);\r\n      info.format = t;\r\n      info.count = a.count;\r\n      this._types.set(type, info);\r\n      this._updateTypeInfo(info);\r\n      return info;\r\n    }\r\n\r\n    if (type instanceof Struct) {\r\n      const s = type as Struct;\r\n      const info = new StructInfo(s.name, attributes);\r\n      info.startLine = s.startLine;\r\n      info.endLine = s.endLine;\r\n      for (const m of s.members) {\r\n        const t = this.getTypeInfo(m.type!, m.attributes);\r\n        info.members.push(new MemberInfo(m.name, t, m.attributes));\r\n      }\r\n      this._types.set(type, info);\r\n      this._updateTypeInfo(info);\r\n      return info;\r\n    }\r\n\r\n    if (type instanceof SamplerType) {\r\n      const s = type as SamplerType;\r\n      const formatIsType = s.format instanceof Type;\r\n      const format = s.format\r\n        ? formatIsType\r\n          ? this.getTypeInfo(s.format! as Type, null)\r\n          : new TypeInfo(s.format! as string, null)\r\n        : null;\r\n      const info = new TemplateInfo(s.name, format, attributes, s.access);\r\n      this._types.set(type, info);\r\n      this._updateTypeInfo(info);\r\n      return info;\r\n    }\r\n\r\n    if (type instanceof TemplateType) {\r\n      const t = type as TemplateType;\r\n      const format = t.format ? this.getTypeInfo(t.format!, null) : null;\r\n      const info = new TemplateInfo(t.name, format, attributes, t.access);\r\n      this._types.set(type, info);\r\n      this._updateTypeInfo(info);\r\n      return info;\r\n    }\r\n\r\n    const info = new TypeInfo(type.name, attributes);\r\n    this._types.set(type, info);\r\n    this._updateTypeInfo(info);\r\n    return info;\r\n  }\r\n\r\n  _updateTypeInfo(type: TypeInfo) {\r\n    const typeSize = this._getTypeSize(type);\r\n    type.size = typeSize?.size ?? 0;\r\n\r\n    if (type instanceof ArrayInfo) {\r\n      if (type[\"format\"]) {\r\n        const formatInfo = this._getTypeSize(type[\"format\"]);\r\n        // Array stride is the maximum of the format size and alignment.\r\n        // In the case of a vec3f, the size is 12 bytes, but the alignment is 16 bytes.\r\n        // Buffer alignment is therefore 16 bytes.\r\n        type.stride = Math.max(formatInfo?.size ?? 0, formatInfo?.align ?? 0);\r\n        this._updateTypeInfo(type[\"format\"]);\r\n      }\r\n    }\r\n\r\n    if (type instanceof PointerInfo) {\r\n      this._updateTypeInfo(type[\"format\"]);\r\n    }\r\n\r\n    if (type instanceof StructInfo) {\r\n      this._updateStructInfo(type);\r\n    }\r\n  }\r\n\r\n  _updateStructInfo(struct: StructInfo) {\r\n    let offset = 0;\r\n    let lastSize = 0;\r\n    let lastOffset = 0;\r\n    let structAlign = 0;\r\n\r\n    for (let mi = 0, ml = struct.members.length; mi < ml; ++mi) {\r\n      const member = struct.members[mi];\r\n\r\n      const sizeInfo = this._getTypeSize(member);\r\n      if (!sizeInfo) {\r\n        continue;\r\n      }\r\n\r\n      const type = this._getAlias(member.type.name) ?? member.type;\r\n      const align = sizeInfo.align;\r\n      const size = sizeInfo.size;\r\n      offset = this._roundUp(align, offset + lastSize);\r\n      lastSize = size;\r\n      lastOffset = offset;\r\n      structAlign = Math.max(structAlign, align);\r\n\r\n      member.offset = offset;\r\n      member.size = size;\r\n\r\n      this._updateTypeInfo(member.type);\r\n    }\r\n\r\n    struct.size = this._roundUp(structAlign, lastOffset + lastSize);\r\n    struct.align = structAlign;\r\n  }\r\n\r\n  _getTypeSize(\r\n    type: TypeInfo | MemberInfo | null | undefined\r\n  ): _TypeSize | null {\r\n    if (type === null || type === undefined) {\r\n      return null;\r\n    }\r\n\r\n    const explicitSize = this._getAttributeNum(type.attributes, \"size\", 0);\r\n    const explicitAlign = this._getAttributeNum(type.attributes, \"align\", 0);\r\n\r\n    if (type instanceof MemberInfo) {\r\n      type = type.type;\r\n    }\r\n\r\n    if (type instanceof TypeInfo) {\r\n      const alias = this._getAlias(type.name);\r\n      if (alias !== null) {\r\n        type = alias;\r\n      }\r\n    }\r\n\r\n    {\r\n      const info = Reflect._typeInfo[type.name];\r\n      if (info !== undefined) {\r\n        const divisor = type[\"format\"]?.name === \"f16\" ? 2 : 1;\r\n        return new _TypeSize(\r\n          Math.max(explicitAlign, info.align / divisor),\r\n          Math.max(explicitSize, info.size / divisor)\r\n        );\r\n      }\r\n    }\r\n\r\n    {\r\n      const info =\r\n        Reflect._typeInfo[type.name.substring(0, type.name.length - 1)];\r\n      if (info) {\r\n        const divisor = type.name[type.name.length - 1] === \"h\" ? 2 : 1;\r\n        return new _TypeSize(\r\n          Math.max(explicitAlign, info.align / divisor),\r\n          Math.max(explicitSize, info.size / divisor)\r\n        );\r\n      }\r\n    }\r\n\r\n    if (type instanceof ArrayInfo) {\r\n      let arrayType = type as ArrayInfo;\r\n      let align = 8;\r\n      let size = 8;\r\n      // Type                 AlignOf(T)          Sizeof(T)\r\n      // array<E, N>          AlignOf(E)          N * roundUp(AlignOf(E), SizeOf(E))\r\n      // array<E>             AlignOf(E)          N * roundUp(AlignOf(E), SizeOf(E))  (N determined at runtime)\r\n      //\r\n      // @stride(Q)\r\n      // array<E, N>          AlignOf(E)          N * Q\r\n      //\r\n      // @stride(Q)\r\n      // array<E>             AlignOf(E)          Nruntime * Q\r\n      //const E = type.format.name;\r\n      const E = this._getTypeSize(arrayType.format);\r\n      if (E !== null) {\r\n        size = E.size;\r\n        align = E.align;\r\n      }\r\n\r\n      const N = arrayType.count;\r\n\r\n      const stride = this._getAttributeNum(\r\n        type?.attributes ?? null,\r\n        \"stride\",\r\n        this._roundUp(align, size)\r\n      );\r\n      size = N * stride;\r\n\r\n      if (explicitSize) {\r\n        size = explicitSize;\r\n      }\r\n\r\n      return new _TypeSize(\r\n        Math.max(explicitAlign, align),\r\n        Math.max(explicitSize, size)\r\n      );\r\n    }\r\n\r\n    if (type instanceof StructInfo) {\r\n      let align = 0;\r\n      let size = 0;\r\n      // struct S     AlignOf:    max(AlignOfMember(S, M1), ... , AlignOfMember(S, MN))\r\n      //              SizeOf:     roundUp(AlignOf(S), OffsetOfMember(S, L) + SizeOfMember(S, L))\r\n      //                          Where L is the last member of the structure\r\n      let offset = 0;\r\n      let lastSize = 0;\r\n      let lastOffset = 0;\r\n      for (const m of type.members) {\r\n        const mi = this._getTypeSize(m.type);\r\n        if (mi !== null) {\r\n          align = Math.max(mi.align, align);\r\n          offset = this._roundUp(mi.align, offset + lastSize);\r\n          lastSize = mi.size;\r\n          lastOffset = offset;\r\n        }\r\n      }\r\n      size = this._roundUp(align, lastOffset + lastSize);\r\n\r\n      return new _TypeSize(\r\n        Math.max(explicitAlign, align),\r\n        Math.max(explicitSize, size)\r\n      );\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _isUniformVar(node: Node): boolean {\r\n    return node instanceof Var && node.storage == \"uniform\";\r\n  }\r\n\r\n  _isStorageVar(node: Node): boolean {\r\n    return node instanceof Var && node.storage == \"storage\";\r\n  }\r\n\r\n  _isTextureVar(node: Node): boolean {\r\n    return (\r\n      node instanceof Var &&\r\n      node.type !== null &&\r\n      Reflect._textureTypes.indexOf(node.type.name) != -1\r\n    );\r\n  }\r\n\r\n  _isSamplerVar(node: Node): boolean {\r\n    return (\r\n      node instanceof Var &&\r\n      node.type !== null &&\r\n      Reflect._samplerTypes.indexOf(node.type.name) != -1\r\n    );\r\n  }\r\n\r\n  _getAttribute(node: Node, name: string): Attribute | null {\r\n    const obj = node as Object;\r\n    if (!obj || !obj[\"attributes\"]) {\r\n      return null;\r\n    }\r\n    const attrs = obj[\"attributes\"];\r\n    for (let a of attrs) {\r\n      if (a.name == name) {\r\n        return a;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _getAttributeNum(\r\n    attributes: Attribute[] | null,\r\n    name: string,\r\n    defaultValue: number\r\n  ): number {\r\n    if (attributes === null) {\r\n      return defaultValue;\r\n    }\r\n    for (let a of attributes) {\r\n      if (a.name == name) {\r\n        let v = a !== null && a.value !== null ? a.value : defaultValue;\r\n        if (v instanceof Array) {\r\n          v = v[0];\r\n        }\r\n        if (typeof v === \"number\") {\r\n          return v;\r\n        }\r\n        if (typeof v === \"string\") {\r\n          return parseInt(v);\r\n        }\r\n        return defaultValue;\r\n      }\r\n    }\r\n    return defaultValue;\r\n  }\r\n\r\n  _roundUp(k: number, n: number): number {\r\n    return Math.ceil(n / k) * k;\r\n  }\r\n\r\n  // Type                 AlignOf(T)          Sizeof(T)\r\n  // i32, u32, or f32     4                   4\r\n  // atomic<T>            4                   4\r\n  // vec2<T>              8                   8\r\n  // vec3<T>              16                  12\r\n  // vec4<T>              16                  16\r\n  // mat2x2<f32>          8                   16\r\n  // mat3x2<f32>          8                   24\r\n  // mat4x2<f32>          8                   32\r\n  // mat2x3<f32>          16                  32\r\n  // mat3x3<f32>          16                  48\r\n  // mat4x3<f32>          16                  64\r\n  // mat2x4<f32>          16                  32\r\n  // mat3x4<f32>          16                  48\r\n  // mat4x4<f32>          16                  64\r\n  static readonly _typeInfo = {\r\n    f16: { align: 2, size: 2 },\r\n    i32: { align: 4, size: 4 },\r\n    u32: { align: 4, size: 4 },\r\n    f32: { align: 4, size: 4 },\r\n    atomic: { align: 4, size: 4 },\r\n    vec2: { align: 8, size: 8 },\r\n    vec3: { align: 16, size: 12 },\r\n    vec4: { align: 16, size: 16 },\r\n    mat2x2: { align: 8, size: 16 },\r\n    mat3x2: { align: 8, size: 24 },\r\n    mat4x2: { align: 8, size: 32 },\r\n    mat2x3: { align: 16, size: 32 },\r\n    mat3x3: { align: 16, size: 48 },\r\n    mat4x3: { align: 16, size: 64 },\r\n    mat2x4: { align: 16, size: 32 },\r\n    mat3x4: { align: 16, size: 48 },\r\n    mat4x4: { align: 16, size: 64 },\r\n  };\r\n\r\n  static readonly _textureTypes = TokenTypes.any_texture_type.map((t) => {\r\n    return t.name;\r\n  });\r\n\r\n  static readonly _samplerTypes = TokenTypes.sampler_type.map((t) => {\r\n    return t.name;\r\n  });\r\n}\r\n", "import { Let, Var, Argument, Function } from \"../wgsl_ast.js\";\r\nimport { Data } from \"../wgsl_ast.js\";\r\n\r\ntype ASTVarNode = Let | Var | Argument;\r\n\r\nlet _id = 0;\r\n\r\nexport class VarRef {\r\n    name: string;\r\n    value: Data;\r\n    node: ASTVarNode | null;\r\n    readonly id: number = _id++;\r\n\r\n    constructor(n: string, v: Data, node: ASTVarNode | null) {\r\n        this.name = n;\r\n        this.value = v;\r\n        this.node = node;\r\n    }\r\n\r\n    clone(): VarRef {\r\n        return new VarRef(this.name, this.value, this.node);\r\n    }\r\n};\r\n\r\nexport class FunctionRef {\r\n    name: string;\r\n    node: Function;\r\n    readonly id: number = _id++;\r\n\r\n    constructor(node: Function) {\r\n        this.name = node.name;\r\n        this.node = node;\r\n    }\r\n\r\n    clone(): FunctionRef {\r\n        return new FunctionRef(this.node);\r\n    }\r\n};\r\n\r\nexport class ExecContext {\r\n    parent: ExecContext | null = null;\r\n    variables = new Map<string, VarRef>();\r\n    functions = new Map<string, FunctionRef>();\r\n    currentFunctionName = \"\";\r\n    readonly id: number = _id++;\r\n\r\n    constructor(parent?: ExecContext) {\r\n        if (parent) {\r\n            this.parent = parent;\r\n            this.currentFunctionName = parent.currentFunctionName;\r\n        }\r\n    }\r\n\r\n    getVariable(name: string): VarRef | null {\r\n        if (this.variables.has(name)) {\r\n            return this.variables.get(name) ?? null;\r\n        }\r\n        if (this.parent) {\r\n            return this.parent.getVariable(name);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getFunction(name: string): FunctionRef | null {\r\n        if (this.functions.has(name)) {\r\n            return this.functions.get(name) ?? null;\r\n        }\r\n        if (this.parent) {\r\n            return this.parent.getFunction(name);\r\n        }\r\n        return null\r\n    }\r\n\r\n    createVariable(name: string, value: Data, node?: ASTVarNode) {\r\n        this.variables.set(name, new VarRef(name, value, node ?? null));\r\n    }\r\n\r\n    setVariable(name: string, value: Data, node?: ASTVarNode) {\r\n        const v = this.getVariable(name);\r\n        if (v !== null) {\r\n            v.value = value;\r\n        } else {\r\n            this.createVariable(name, value, node);\r\n        }\r\n    }\r\n\r\n    getVariableValue(name: string): Data | null {\r\n        const v = this.getVariable(name);\r\n        return v?.value ?? null;\r\n    }\r\n\r\n    clone(): ExecContext {\r\n        return new ExecContext(this);\r\n    }\r\n};\r\n", "import { Node, Type } from \"../wgsl_ast.js\";\r\nimport { ExecContext } from \"./exec_context.js\";\r\nimport { TypeInfo } from \"../wgsl_reflect.js\";\r\nimport { Data } from \"../wgsl_ast.js\";\r\n\r\nexport class ExecInterface {\r\n    evalExpression(node: Node, context: ExecContext): Data | null {\r\n        return null;\r\n    }\r\n\r\n    getTypeInfo(type: Type | string): TypeInfo | null {\r\n        return null; \r\n    }\r\n\r\n    getVariableName(node: Node, context: ExecContext): string | null {\r\n        return \"\";\r\n    }\r\n}\r\n", "import { CallExpr, Call, UnaryOperator, VariableExpr } from \"../wgsl_ast.js\";\r\nimport { Data, TypedData, TextureData, ScalarData, VectorData, MatrixData } from \"../wgsl_ast.js\";\r\nimport { ExecContext } from \"./exec_context.js\";\r\nimport { ExecInterface } from \"./exec_interface.js\";\r\nimport { ArrayInfo, TypeInfo } from \"../reflect/info.js\";\r\n\r\nexport class BuiltinFunctions {\r\n    exec: ExecInterface;\r\n\r\n    constructor(exec: ExecInterface) {\r\n        this.exec = exec;\r\n    }\r\n\r\n    getTypeInfo(type: string): TypeInfo | null {\r\n        return this.exec.getTypeInfo(type);\r\n    }\r\n\r\n    // Logical Built-in Functions\r\n    All(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        let isTrue = true;\r\n        if (value instanceof VectorData) {\r\n            value.data.forEach((x: any) => { if (!x) isTrue = false; });\r\n            return new ScalarData(isTrue ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n        }\r\n        throw new Error(`All() expects a vector argument. Line ${node.line}`);\r\n    }\r\n\r\n    Any(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            const res = value.data.some((v: any) => v);\r\n            return new ScalarData(res ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n        }\r\n        throw new Error(`Any() expects a vector argument. Line ${node.line}`);\r\n    }\r\n\r\n    Select(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // select(false, true, condition)\r\n        const condition = this.exec.evalExpression(node.args[2], context);\r\n        if (!(condition instanceof ScalarData)) {\r\n            throw new Error(`Select() expects a bool condition. Line ${node.line}`);\r\n        }\r\n        if (!condition.value) {\r\n            return this.exec.evalExpression(node.args[0], context);\r\n        } else {\r\n            return this.exec.evalExpression(node.args[1], context);\r\n        }\r\n    }\r\n\r\n    // Array Built-in Functions\r\n    ArrayLength(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let arrayArg = node.args[0];\r\n        // TODO: handle \"&\" operator\r\n        if (arrayArg instanceof UnaryOperator) {\r\n            arrayArg = (arrayArg as UnaryOperator).right;\r\n        }\r\n        const arrayData = this.exec.evalExpression(arrayArg, context);\r\n        if (arrayData instanceof TypedData && arrayData.typeInfo.size === 0) {\r\n            const ta = arrayData.typeInfo as ArrayInfo;\r\n            const count = arrayData.buffer.byteLength / ta.stride;\r\n            return new ScalarData(count, this.getTypeInfo(\"u32\"));\r\n        }\r\n        return new ScalarData(arrayData.typeInfo.size, this.getTypeInfo(\"u32\"));\r\n    }\r\n\r\n    // Numeric Built-in Functions\r\n    Abs(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.abs(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.abs(s.value), s.typeInfo);\r\n    }\r\n\r\n    Acos(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.acos(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.acos(s.value), value.typeInfo);\r\n    }\r\n\r\n    Acosh(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.acosh(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.acosh(s.value), value.typeInfo);\r\n    }\r\n\r\n    Asin(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.asin(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.asin(s.value), value.typeInfo);\r\n    }\r\n\r\n    Asinh(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.asinh(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.asinh(s.value), value.typeInfo);\r\n    }\r\n\r\n    Atan(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.atan(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.atan(s.value), value.typeInfo);\r\n    }\r\n\r\n    Atanh(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.atanh(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.atanh(s.value), value.typeInfo);\r\n    }\r\n\r\n    Atan2(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const y = this.exec.evalExpression(node.args[0], context);\r\n        const x = this.exec.evalExpression(node.args[1], context);\r\n        if (y instanceof VectorData && x instanceof VectorData) {\r\n            return new VectorData(y.data.map((v: number, i: number) => Math.atan2(v, x.data[i])), y.typeInfo);\r\n        }\r\n        const ys = y as ScalarData;\r\n        const xs = x as ScalarData;\r\n        return new ScalarData(Math.atan2(ys.value, xs.value), y.typeInfo);\r\n    }\r\n\r\n    Ceil(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.ceil(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.ceil(s.value), value.typeInfo);\r\n    }\r\n\r\n    _clamp(value: number, min: number, max: number): number {\r\n        return Math.min(Math.max(value, min), max);\r\n    }\r\n\r\n    Clamp(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        const min = this.exec.evalExpression(node.args[1], context);\r\n        const max = this.exec.evalExpression(node.args[2], context);\r\n        if (value instanceof VectorData && min instanceof VectorData && max instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number, i: number) => this._clamp(v, min.data[i], max.data[i])), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        const minS = min as ScalarData;\r\n        const maxS = max as ScalarData\r\n        return new ScalarData(this._clamp(s.value, minS.value, maxS.value), value.typeInfo);\r\n    }\r\n\r\n    Cos(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.cos(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.cos(s.value), value.typeInfo);\r\n    }\r\n\r\n    Cosh(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.cosh(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.cos(s.value), value.typeInfo);\r\n    }\r\n\r\n    CountLeadingZeros(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.clz32(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.clz32(s.value), value.typeInfo);\r\n    }\r\n\r\n    _countOneBits(value: number): number {\r\n        let count = 0;\r\n        while (value !== 0) {\r\n            if (value & 1) {\r\n                count++;\r\n            }\r\n            value >>= 1;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    CountOneBits(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => this._countOneBits(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(this._countOneBits(s.value), value.typeInfo);\r\n    }\r\n\r\n    _countTrailingZeros(value: number): number {\r\n        if (value === 0) {\r\n            return 32; // Special case for 0\r\n        }\r\n        let count = 0;\r\n        while ((value & 1) === 0) {\r\n            value >>= 1;\r\n            count++;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    CountTrailingZeros(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => this._countTrailingZeros(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(this._countTrailingZeros(s.value), value.typeInfo);\r\n    }\r\n\r\n    Cross(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const l = this.exec.evalExpression(node.args[0], context);\r\n        const r = this.exec.evalExpression(node.args[1], context);\r\n        if (l instanceof VectorData && r instanceof VectorData) {\r\n            if (l.data.length !== 3 || r.data.length !== 3) {\r\n                console.error(`Cross() expects 3D vectors. Line ${node.line}`);\r\n                return null;\r\n            }\r\n            const lv = l.data;\r\n            const rv = r.data;\r\n            return new VectorData([\r\n                lv[1] * rv[2] - rv[1] * lv[2],\r\n                lv[2] * rv[0] - rv[2] * lv[0],\r\n                lv[0] * rv[1] - rv[0] * lv[1],\r\n            ], l.typeInfo);\r\n        }\r\n        console.error(`Cross() expects vector arguments. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Degrees(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        const radToDeg = 180.0 / Math.PI;\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => v * radToDeg), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(s.value * radToDeg, this.getTypeInfo(\"f32\"));\r\n    }\r\n\r\n    Determinant(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const m = this.exec.evalExpression(node.args[0], context);\r\n        if (m instanceof MatrixData) {\r\n            const mv = m.data;\r\n            const mt = m.typeInfo.getTypeName();\r\n            const isHalf = mt.endsWith(\"h\");\r\n            const formatType = isHalf ? this.getTypeInfo(\"f16\") : this.getTypeInfo(\"f32\");\r\n            if (mt === \"mat2x2\" || mt === \"mat2x2f\" || mt === \"mat2x2h\") {\r\n                return new ScalarData(mv[0] * mv[3] - mv[1] * mv[2], formatType);\r\n            } else if (mt === \"mat2x3\" || mt === \"mat2x3f\" || mt === \"mat2x3h\") {\r\n                return new ScalarData(mv[0] * (mv[4] * mv[8] - mv[5] * mv[7]) -\r\n                        mv[1] * (mv[3] * mv[8] - mv[5] * mv[6]) + mv[2] * (mv[3] * mv[7] - mv[4] * mv[6]), formatType);\r\n            } else if (mt === \"mat2x4\" || mt === \"mat2x4f\" || mt === \"mat2x4h\") {\r\n                console.error(`TODO: Determinant for ${mt}`);\r\n            } else if (mt === \"mat3x2\" || mt === \"mat3x2f\" || mt === \"mat3x2h\") {\r\n                console.error(`TODO: Determinant for ${mt}`);\r\n            } else if (mt === \"mat3x3\" || mt === \"mat3x3f\" || mt === \"mat3x3h\") {\r\n                return new ScalarData(mv[0] * (mv[4] * mv[8] - mv[5] * mv[7]) -\r\n                        mv[1] * (mv[3] * mv[8] - mv[5] * mv[6]) + mv[2] * (mv[3] * mv[7] - mv[4] * mv[6]), formatType);\r\n            } else if (mt === \"mat3x4\" || mt === \"mat3x4f\" || mt === \"mat3x4h\") {\r\n                console.error(`TODO: Determinant for ${mt}`);\r\n            } else if (mt === \"mat4x2\" || mt === \"mat4x2f\" || mt === \"mat4x2h\") {\r\n                console.error(`TODO: Determinant for ${mt}`);\r\n            } else if (mt === \"mat4x3\" || mt === \"mat4x3f\" || mt === \"mat4x3h\") {\r\n                console.error(`TODO: Determinant for ${mt}`);\r\n            } else if (mt === \"mat4x4\" || mt === \"mat4x4f\" || mt === \"mat4x4h\") {\r\n                console.error(`TODO: Determinant for ${mt}`);\r\n            }\r\n        }\r\n        console.error(`Determinant expects a matrix argument. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Distance(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const l = this.exec.evalExpression(node.args[0], context);\r\n        const r = this.exec.evalExpression(node.args[1], context);\r\n        if (l instanceof VectorData && r instanceof VectorData) {\r\n            let sum = 0;\r\n            for (let i = 0; i < l.data.length; ++i) {\r\n                sum += (l.data[i] - r.data[i]) * (l.data[i] - r.data[i]);\r\n            }\r\n            return new ScalarData(Math.sqrt(sum), this.getTypeInfo(\"f32\"));\r\n        }\r\n        const ls = l as ScalarData;\r\n        const rs = r as ScalarData;\r\n        return new ScalarData(Math.abs(ls.value - rs.value), l.typeInfo);\r\n    }\r\n\r\n    _dot(e1: Int32Array | Uint32Array | Float32Array, e2: Int32Array | Uint32Array | Float32Array) {\r\n        let dot = 0;\r\n        for (let i = 0; i < e1.length; ++i) {\r\n            dot += e2[i] * e1[i];\r\n        }\r\n        return dot;\r\n    }\r\n\r\n    Dot(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const l = this.exec.evalExpression(node.args[0], context);\r\n        const r = this.exec.evalExpression(node.args[1], context);\r\n        if (l instanceof VectorData && r instanceof VectorData) {\r\n            return new ScalarData(this._dot(l.data, r.data), this.getTypeInfo(\"f32\"));\r\n        }\r\n        console.error(`Dot() expects vector arguments. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Dot4U8Packed(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(`TODO: dot4U8Packed. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Dot4I8Packed(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(`TODO: dot4I8Packed. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Exp(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.exp(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.exp(s.value), value.typeInfo);\r\n    }\r\n\r\n    Exp2(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.pow(2, v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.pow(2, s.value), value.typeInfo);\r\n    }\r\n\r\n    ExtractBits(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        const offset = this.exec.evalExpression(node.args[1], context);\r\n        const count = this.exec.evalExpression(node.args[2], context);\r\n        if (offset.typeInfo.name !== \"u32\" && offset.typeInfo.name !== \"x32\") {\r\n            console.error(`ExtractBits() expects an i32 offset argument. Line ${node.line}`);\r\n            return null;\r\n        }\r\n        if (count.typeInfo.name !== \"u32\" && count.typeInfo.name !== \"x32\") {\r\n            console.error(`ExtractBits() expects an i32 count argument. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        const o = (offset as ScalarData).value;\r\n        const c = (count as ScalarData).value;\r\n\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => (v >> o) & ((1 << c) - 1)), value.typeInfo);\r\n        }\r\n\r\n        if (value.typeInfo.name !== \"i32\" && value.typeInfo.name !== \"x32\") {\r\n            console.error(`ExtractBits() expects an i32 argument. Line ${node.line}`);\r\n            return null;\r\n        }\r\n        const v = (value as ScalarData).value;\r\n        return new ScalarData((v >> o) & ((1 << c) - 1), this.getTypeInfo(\"i32\"));\r\n    }\r\n\r\n    FaceForward(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const e1 = this.exec.evalExpression(node.args[0], context);\r\n        const e2 = this.exec.evalExpression(node.args[1], context);\r\n        const n = this.exec.evalExpression(node.args[2], context);\r\n        if (e1 instanceof VectorData && e2 instanceof VectorData && n instanceof VectorData) {\r\n            const dot = this._dot(e2.data, n.data);\r\n            if (dot < 0) {\r\n                return new VectorData(Array.from(e1.data), e1.typeInfo);\r\n            }\r\n            return new VectorData(e1.data.map((v: number) => -v), e1.typeInfo);\r\n        }\r\n        console.error(`FaceForward() expects vector arguments. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    _firstLeadingBit(s: number): number {\r\n        if (s === 0) {\r\n            return -1;\r\n        }\r\n        return 31 - Math.clz32(s);  // clz32: count leading zeros\r\n    }\r\n\r\n    FirstLeadingBit(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => this._firstLeadingBit(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(this._firstLeadingBit(s.value), value.typeInfo);\r\n    }\r\n\r\n    _firstTrailingBit(s: number): number {\r\n        if (s === 0) {\r\n            return -1;\r\n        }\r\n        return Math.log2(s & -s); // n & -n isolates the lowest set bit.  Math.log2 gives its position.\r\n    }\r\n\r\n    FirstTrailingBit(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => this._firstTrailingBit(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(this._firstTrailingBit(s.value), value.typeInfo);\r\n    }\r\n\r\n    Floor(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.floor(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.floor(s.value), value.typeInfo);\r\n    }\r\n\r\n    Fma(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const a = this.exec.evalExpression(node.args[0], context);\r\n        const b = this.exec.evalExpression(node.args[1], context);\r\n        const c = this.exec.evalExpression(node.args[2], context);\r\n        if (a instanceof VectorData && b instanceof VectorData && c instanceof VectorData) {\r\n            if (a.data.length !== b.data.length || a.data.length !== c.data.length) {\r\n                console.error(`Fma() expects vectors of the same length. Line ${node.line}`);\r\n                return null;\r\n            }\r\n            return new VectorData(a.data.map((v: number, i: number) => v * b.data[i] + c.data[i]), a.typeInfo);\r\n        }\r\n        const av = a as ScalarData;\r\n        const bv = b as ScalarData;\r\n        const cv = c as ScalarData;\r\n        return new ScalarData(av.value * bv.value + cv.value, av.typeInfo);\r\n    }\r\n\r\n    Fract(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => v - Math.floor(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(s.value - Math.floor(s.value), value.typeInfo);\r\n    }\r\n\r\n    Frexp(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(`TODO: frexp. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    InsertBits(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        const insert = this.exec.evalExpression(node.args[1], context);\r\n        const offset = this.exec.evalExpression(node.args[2], context);\r\n        const count = this.exec.evalExpression(node.args[3], context);\r\n\r\n        if (offset.typeInfo.name !== \"u32\" && offset.typeInfo.name !== \"x32\") {\r\n            console.error(`InsertBits() expects an i32 offset argument. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        const o = (offset as ScalarData).value;\r\n        const c = (count as ScalarData).value;\r\n        const mask = ((1 << c) - 1) << o;\r\n        const invMask = ~mask;\r\n\r\n        if (value instanceof VectorData && insert instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number, i: number) => {\r\n                return (v & invMask) | ((insert.data[i] << o) & mask);\r\n            }), value.typeInfo);\r\n        }\r\n        const v = (value as ScalarData).value;\r\n        const i = (insert as ScalarData).value;\r\n        return new ScalarData((v & invMask) | ((i << o) & mask), value.typeInfo);\r\n    }\r\n\r\n    InverseSqrt(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => 1 / Math.sqrt(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(1 / Math.sqrt(s.value), value.typeInfo);\r\n    }\r\n\r\n    Ldexp(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(`TODO: ldexp. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Length(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            let sum = 0;\r\n            value.data.forEach((v: number) => { sum += v * v; });\r\n            return new ScalarData(Math.sqrt(sum), this.getTypeInfo(\"f32\"));\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.abs(s.value), value.typeInfo);\r\n    }\r\n\r\n    Log(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.log(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.log(s.value), value.typeInfo);\r\n    }\r\n\r\n    Log2(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.log2(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData\r\n        return new ScalarData(Math.log2(s.value), value.typeInfo);\r\n    }\r\n\r\n    Max(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const l = this.exec.evalExpression(node.args[0], context);\r\n        const r = this.exec.evalExpression(node.args[1], context);\r\n        if (l instanceof VectorData && r instanceof VectorData) {\r\n            return new VectorData(l.data.map((v: number, i: number) => Math.max(v, r.data[i])), l.typeInfo);\r\n        }\r\n        const ls = l as ScalarData;\r\n        const rs = r as ScalarData;\r\n        return new ScalarData(Math.max(ls.value, rs.value), l.typeInfo);\r\n    }\r\n\r\n    Min(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const l = this.exec.evalExpression(node.args[0], context);\r\n        const r = this.exec.evalExpression(node.args[1], context);\r\n        if (l instanceof VectorData && r instanceof VectorData) {\r\n            return new VectorData(l.data.map((v: number, i: number) => Math.min(v, r.data[i])), l.typeInfo);\r\n        }\r\n        const ls = l as ScalarData;\r\n        const rs = r as ScalarData;\r\n        return new ScalarData(Math.min(ls.value, rs.value), l.typeInfo);\r\n    }\r\n\r\n    Mix(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const x = this.exec.evalExpression(node.args[0], context);\r\n        const y = this.exec.evalExpression(node.args[1], context);\r\n        const a = this.exec.evalExpression(node.args[2], context);\r\n        if (x instanceof VectorData && y instanceof VectorData && a instanceof VectorData) {\r\n            return new VectorData(x.data.map((v: number, i: number) => x.data[i] * (1 - a.data[i]) + y.data[i] * a.data[i]), x.typeInfo);\r\n        }\r\n        const xs = x as ScalarData;\r\n        const ys = y as ScalarData;\r\n        const as = a as ScalarData;\r\n        return new ScalarData(xs.value * (1 - as.value) + ys.value * as.value, x.typeInfo);\r\n    }\r\n\r\n    Modf(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const x = this.exec.evalExpression(node.args[0], context);\r\n        const y = this.exec.evalExpression(node.args[1], context);\r\n        if (x instanceof VectorData && y instanceof VectorData) {\r\n            return new VectorData(x.data.map((v: number, i: number) => v % y.data[i]), x.typeInfo);\r\n        }\r\n        const xs = x as ScalarData;\r\n        const ys = y as ScalarData;\r\n        return new ScalarData(xs.value % ys.value, x.typeInfo);\r\n    }\r\n\r\n    Normalize(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            const length = (this.Length(node, context) as ScalarData).value;\r\n            return new VectorData(value.data.map((v: number) => v / length), value.typeInfo);\r\n        }\r\n        console.error(`Normalize() expects a vector argument. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Pow(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const x = this.exec.evalExpression(node.args[0], context);\r\n        const y = this.exec.evalExpression(node.args[1], context);\r\n        if (x instanceof VectorData && y instanceof VectorData) {\r\n            return new VectorData(x.data.map((v: number, i: number) => Math.pow(v, y.data[i])), x.typeInfo);\r\n        }\r\n        const xs = x as ScalarData;\r\n        const ys = y as ScalarData;\r\n        return new ScalarData(Math.pow(xs.value, ys.value), x.typeInfo);\r\n    }\r\n\r\n    QuantizeToF16(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // TODO: actually quantize the f32 to f16\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => v), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(s.value, value.typeInfo);\r\n    }\r\n\r\n    Radians(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => v * Math.PI / 180), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(s.value * Math.PI / 180, this.getTypeInfo(\"f32\"));\r\n    }\r\n\r\n    Reflect(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // e1 - 2 * dot(e2, e1) * e2\r\n        let e1 = this.exec.evalExpression(node.args[0], context);\r\n        let e2 = this.exec.evalExpression(node.args[1], context);\r\n        if (e1 instanceof VectorData && e2 instanceof VectorData) {\r\n            const dot = this._dot(e1.data, e2.data);\r\n            return new VectorData(e1.data.map((v: number, i: number) => v - 2 * dot * e2.data[i]), e1.typeInfo);\r\n        }\r\n        console.error(`Reflect() expects vector arguments. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Refract(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let e1 = this.exec.evalExpression(node.args[0], context);\r\n        let e2 = this.exec.evalExpression(node.args[1], context);\r\n        let e3 = this.exec.evalExpression(node.args[2], context);\r\n        if (e1 instanceof VectorData && e2 instanceof VectorData && e3 instanceof ScalarData) {\r\n            const dot = this._dot(e2.data, e1.data);\r\n            return new VectorData(e1.data.map((v: number, i: number) => {\r\n                const k = 1.0 - e3.value * e3.value * (1.0 - dot * dot);\r\n                if (k < 0) {\r\n                    return 0;\r\n                }\r\n                const sqrtK = Math.sqrt(k);\r\n                return e3.value * v - (e3.value * dot + sqrtK) * e2.data[i];\r\n            }), e1.typeInfo);\r\n        }\r\n\r\n        console.error(`Refract() expects vector arguments and a scalar argument. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    ReverseBits(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(`TODO: reverseBits. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Round(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.round(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.round(s.value), value.typeInfo);\r\n    }\r\n\r\n    Saturate(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.min(Math.max(v, 0), 1)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.min(Math.max(s.value, 0), 1), value.typeInfo);\r\n    }\r\n\r\n    Sign(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.sign(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.sign(s.value), value.typeInfo);\r\n    }\r\n\r\n    Sin(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.sin(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.sin(s.value), value.typeInfo);\r\n    }\r\n\r\n    Sinh(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.sinh(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.sinh(s.value), value.typeInfo);\r\n    }\r\n\r\n    _smoothstep(edge0: number, edge1: number, x: number): number {\r\n        const t = Math.min(Math.max((x - edge0) / (edge1 - edge0), 0), 1);\r\n        return t * t * (3 - 2 * t);\r\n    }\r\n\r\n    SmoothStep(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const edge0 = this.exec.evalExpression(node.args[0], context);\r\n        const edge1 = this.exec.evalExpression(node.args[1], context);\r\n        const x = this.exec.evalExpression(node.args[2], context);\r\n        if (x instanceof VectorData && edge0 instanceof VectorData && edge1 instanceof VectorData) {\r\n            return new VectorData(x.data.map((v: number, i: number) => this._smoothstep(edge0.data[i], edge1.data[i], v)), x.typeInfo);\r\n        }\r\n        const e0 = edge0 as ScalarData;\r\n        const e1 = edge1 as ScalarData;\r\n        const xS = x as ScalarData;\r\n        return new ScalarData(this._smoothstep(e0.value, e1.value, xS.value), x.typeInfo);\r\n    }\r\n\r\n    Sqrt(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.sqrt(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.sqrt(s.value), value.typeInfo);\r\n    }\r\n\r\n    Step(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const edge = this.exec.evalExpression(node.args[0], context);\r\n        const x = this.exec.evalExpression(node.args[1], context);\r\n        if (x instanceof VectorData && edge instanceof VectorData) {\r\n            return new VectorData(x.data.map((v: number, i: number) => v < edge.data[i] ? 0 : 1), x.typeInfo);\r\n        }\r\n        const e = edge as ScalarData;\r\n        const s = x as ScalarData;\r\n        return new ScalarData(s.value < e.value ? 0 : 1, e.typeInfo);\r\n    }\r\n\r\n    Tan(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.tan(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.tan(s.value), value.typeInfo);\r\n    }\r\n\r\n    Tanh(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.tanh(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.tanh(s.value), value.typeInfo);\r\n    }\r\n\r\n    _getTransposeType(t: TypeInfo): TypeInfo {\r\n        const tname = t.getTypeName();\r\n        if (tname === \"mat2x2f\" || tname === \"mat2x2h\") {\r\n            return t;\r\n        } else if (tname === \"mat2x3f\") {\r\n            return this.getTypeInfo(\"mat3x2f\");\r\n        } else if (tname === \"mat2x3h\") {\r\n            return this.getTypeInfo(\"mat3x2h\");\r\n        } else if (tname === \"mat2x4f\") {\r\n            return this.getTypeInfo(\"mat4x2f\");\r\n        } else if (tname === \"mat2x4h\") {\r\n            return this.getTypeInfo(\"mat4x2h\");\r\n        } else if (tname === \"mat3x2f\") {\r\n            return this.getTypeInfo(\"mat2x3f\");\r\n        } else if (tname === \"mat3x2h\") {\r\n            return this.getTypeInfo(\"mat2x3h\");\r\n        } else if (tname === \"mat3x3f\" || tname === \"mat3x3h\") {\r\n            return t;\r\n        } else if (tname === \"mat3x4f\") {\r\n            return this.getTypeInfo(\"mat4x3f\");\r\n        } else if (tname === \"mat3x4h\") {\r\n            return this.getTypeInfo(\"mat4x3h\");\r\n        } else if (tname === \"mat4x2f\") {\r\n            return this.getTypeInfo(\"mat2x4f\");\r\n        } else if (tname === \"mat4x2h\") {\r\n            return this.getTypeInfo(\"mat2x4h\");\r\n        } else if (tname === \"mat4x3f\") {\r\n            return this.getTypeInfo(\"mat3x4f\");\r\n        } else if (tname === \"mat4x3h\") {\r\n            return this.getTypeInfo(\"mat3x4h\");\r\n        } else if (tname === \"mat4x4f\" || tname === \"mat4x4h\") {\r\n            return t;\r\n        }\r\n\r\n        console.error(`Invalid matrix type ${tname}`);\r\n        return t;\r\n    }\r\n\r\n    Transpose(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const m = this.exec.evalExpression(node.args[0], context);\r\n        if (!(m instanceof MatrixData)) {\r\n            console.error(`Transpose() expects a matrix argument. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        const ttype = this._getTransposeType(m.typeInfo);\r\n\r\n        if (m.typeInfo.name === \"mat2x2\" || m.typeInfo.name === \"mat2x2f\" || m.typeInfo.name === \"mat2x2h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[2], mv[1], mv[3]], ttype);\r\n        } else if (m.typeInfo.name === \"mat2x3\" || m.typeInfo.name === \"mat2x3f\" || m.typeInfo.name === \"mat2x3h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[3], mv[6], mv[1], mv[4], mv[7]], ttype);\r\n        } else if (m.typeInfo.name === \"mat2x4\" || m.typeInfo.name === \"mat2x4f\" || m.typeInfo.name === \"mat2x4h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[4], mv[8], mv[12], mv[1], mv[5], mv[9], mv[13]], ttype);\r\n        } else if (m.typeInfo.name === \"mat3x2\" || m.typeInfo.name === \"mat3x2f\" || m.typeInfo.name === \"mat3x2h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[3], mv[1], mv[4], mv[2], mv[5]], ttype);\r\n        } else if (m.typeInfo.name === \"mat3x3\" || m.typeInfo.name === \"mat3x3f\" || m.typeInfo.name === \"mat3x3h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[3], mv[6], mv[1], mv[4], mv[7], mv[2], mv[5], mv[8]], ttype);\r\n        } else if (m.typeInfo.name === \"mat3x4\" || m.typeInfo.name === \"mat3x4f\" || m.typeInfo.name === \"mat3x4h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[4], mv[8], mv[12], mv[1], mv[5], mv[9], mv[13], mv[2], mv[6], mv[10], mv[14]], ttype);\r\n        } else if (m.typeInfo.name === \"mat4x2\" || m.typeInfo.name === \"mat4x2f\" || m.typeInfo.name === \"mat4x2h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[4], mv[1], mv[5], mv[2], mv[6]], ttype);\r\n        } else if (m.typeInfo.name === \"mat4x3\" || m.typeInfo.name === \"mat4x3f\" || m.typeInfo.name === \"mat4x3h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[4], mv[8], mv[1], mv[5], mv[9], mv[2], mv[6], mv[10]], ttype);\r\n        } else if (m.typeInfo.name === \"mat4x4\" || m.typeInfo.name === \"mat4x4f\" || m.typeInfo.name === \"mat4x4h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[4], mv[8], mv[12],\r\n                                   mv[1], mv[5], mv[9], mv[13],\r\n                                   mv[2], mv[6], mv[10], mv[14],\r\n                                   mv[3], mv[7], mv[11], mv[15]], ttype);\r\n        }\r\n\r\n        console.error(`Invalid matrix type ${m.typeInfo.name}`);\r\n        return null;\r\n    }\r\n\r\n    Trunc(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.trunc(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData\r\n        return new ScalarData(Math.trunc(s.value), value.typeInfo);\r\n    }\r\n\r\n    // Derivative Built-in Functions\r\n    Dpdx(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(`TODO: dpdx. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    DpdxCoarse(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(`TODO: dpdxCoarse. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    DpdxFine(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: dpdxFine\");\r\n        return null;\r\n    }\r\n\r\n    Dpdy(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: dpdy\");\r\n        return null;\r\n    }\r\n\r\n    DpdyCoarse(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: dpdyCoarse\");\r\n        return null;\r\n    }\r\n\r\n    DpdyFine(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: dpdyFine\");\r\n        return null;\r\n    }\r\n\r\n    Fwidth(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: fwidth\");\r\n        return null;\r\n    }\r\n\r\n    FwidthCoarse(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: fwidthCoarse\");\r\n        return null;\r\n    }\r\n\r\n    FwidthFine(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: fwidthFine\");\r\n        return null;\r\n    }\r\n\r\n    // Texture Built-in Functions\r\n    TextureDimensions(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const textureArg = node.args[0];\r\n        const level = node.args.length > 1 ? (this.exec.evalExpression(node.args[1], context) as ScalarData).value : 0;\r\n        if (textureArg instanceof VariableExpr) {\r\n            const textureName = (textureArg as VariableExpr).name;\r\n            const texture = context.getVariableValue(textureName);\r\n            if (texture instanceof TextureData) {\r\n                if (level < 0 || level >= texture.mipLevelCount) {\r\n                    console.error(`Invalid mip level for textureDimensions. Line ${node.line}`);\r\n                    return null;\r\n                }\r\n\r\n                const textureSize = texture.getMipLevelSize(level);\r\n\r\n                const dimension = texture.dimension;\r\n\r\n                if (dimension === \"1d\") {\r\n                    return new ScalarData(textureSize[0], this.getTypeInfo(\"u32\"));\r\n                } else if (dimension === \"3d\") {\r\n                    return new VectorData(textureSize, this.getTypeInfo(\"vec3u\"));\r\n                } else if (dimension === \"2d\") {\r\n                    return new VectorData(textureSize.slice(0, 2), this.getTypeInfo(\"vec2u\"));\r\n                } else {\r\n                    console.error(`Invalid texture dimension ${dimension} not found. Line ${node.line}`);\r\n                    return null;\r\n                }\r\n            } else {\r\n                console.error(`Texture ${textureName} not found. Line ${node.line}`);\r\n                return null;\r\n            }\r\n        }\r\n        console.error(`Invalid texture argument for textureDimensions. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    TextureGather(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureGather\");\r\n        return null;\r\n    }\r\n\r\n    TextureGatherCompare(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureGatherCompare\");\r\n        return null;\r\n    }\r\n\r\n    TextureLoad(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const textureArg = node.args[0];\r\n        const uv = this.exec.evalExpression(node.args[1], context);\r\n        const level = node.args.length > 2 ? (this.exec.evalExpression(node.args[2], context) as ScalarData).value : 0;\r\n\r\n        // TODO: non-vec2 UVs, for non-2D textures\r\n        if (!(uv instanceof VectorData) || uv.data.length !== 2) {\r\n            console.error(`Invalid UV argument for textureLoad. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        if (textureArg instanceof VariableExpr) {\r\n            const textureName = (textureArg as VariableExpr).name;\r\n            const texture = context.getVariableValue(textureName);\r\n            if (texture instanceof TextureData) {\r\n                const x = Math.floor(uv.data[0]);\r\n                const y = Math.floor(uv.data[1]);\r\n                if (x < 0 || x >= texture.width || y < 0 || y >= texture.height) {\r\n                    console.error(`Texture ${textureName} out of bounds. Line ${node.line}`);\r\n                    return null;\r\n                }\r\n\r\n                const texel = texture.getPixel(x, y, 0, level);\r\n                if (texel === null) {\r\n                    console.error(`Invalid texture format for textureLoad. Line ${node.line}`);\r\n                    return null;\r\n                }\r\n\r\n                return new VectorData(texel, this.getTypeInfo(\"vec4f\"));\r\n            } else {\r\n                console.error(`Texture ${textureName} not found. Line ${node.line}`);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        console.error(`Invalid texture argument for textureLoad. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    TextureNumLayers(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const textureArg = node.args[0];\r\n        if (textureArg instanceof VariableExpr) {\r\n            const textureName = (textureArg as VariableExpr).name;\r\n            const texture = context.getVariableValue(textureName);\r\n            if (texture instanceof TextureData) {\r\n                return new ScalarData(texture.depthOrArrayLayers, this.getTypeInfo(\"u32\"));\r\n            } else {\r\n                console.error(`Texture ${textureName} not found. Line ${node.line}`);\r\n                return null;\r\n            }\r\n        }\r\n        console.error(`Invalid texture argument for textureNumLayers. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    TextureNumLevels(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const textureArg = node.args[0];\r\n        if (textureArg instanceof VariableExpr) {\r\n            const textureName = (textureArg as VariableExpr).name;\r\n            const texture = context.getVariableValue(textureName);\r\n            if (texture instanceof TextureData) {\r\n                return new ScalarData(texture.mipLevelCount, this.getTypeInfo(\"u32\"));\r\n            } else {\r\n                console.error(`Texture ${textureName} not found. Line ${node.line}`);\r\n                return null;\r\n            }\r\n        }\r\n        console.error(`Invalid texture argument for textureNumLevels. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    TextureNumSamples(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const textureArg = node.args[0];\r\n        if (textureArg instanceof VariableExpr) {\r\n            const textureName = (textureArg as VariableExpr).name;\r\n            const texture = context.getVariableValue(textureName);\r\n            if (texture instanceof TextureData) {\r\n                return new ScalarData(texture.sampleCount, this.getTypeInfo(\"u32\"));\r\n            } else {\r\n                console.error(`Texture ${textureName} not found. Line ${node.line}`);\r\n                return null;\r\n            }\r\n        }\r\n        console.error(`Invalid texture argument for textureNumSamples. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    TextureSample(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureSample\");\r\n        return null;\r\n    }\r\n\r\n    TextureSampleBias(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureSampleBias\");\r\n        return null;\r\n    }\r\n\r\n    TextureSampleCompare(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureSampleCompare\");\r\n        return null;\r\n    }\r\n\r\n    TextureSampleCompareLevel(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureSampleCompareLevel\");\r\n        return null;\r\n    }\r\n\r\n    TextureSampleGrad(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureSampleGrad\");\r\n        return null;\r\n    }\r\n\r\n    TextureSampleLevel(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureSampleLevel\");\r\n        return null;\r\n    }\r\n\r\n    TextureSampleBaseClampToEdge(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureSampleBaseClampToEdge\");\r\n        return null;\r\n    }\r\n\r\n    TextureStore(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const textureArg = node.args[0];\r\n        const uv = this.exec.evalExpression(node.args[1], context);\r\n        const index = (node.args.length === 4) ? (this.exec.evalExpression(node.args[2], context) as ScalarData).value : 0;\r\n        const value = (node.args.length === 4) ? (this.exec.evalExpression(node.args[3], context) as VectorData).data :\r\n            (this.exec.evalExpression(node.args[2], context) as VectorData).data;\r\n\r\n        if (value.length !== 4) {\r\n            console.error(`Invalid value argument for textureStore. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        // TODO: non-vec2 UVs, for non-2D textures\r\n        if (!(uv instanceof VectorData) || uv.data.length !== 2) {\r\n            console.error(`Invalid UV argument for textureStore. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        if (textureArg instanceof VariableExpr) {\r\n            const textureName = (textureArg as VariableExpr).name;\r\n            const texture = context.getVariableValue(textureName);\r\n            if (texture instanceof TextureData) {\r\n                const textureSize = texture.getMipLevelSize(0);\r\n                const x = Math.floor(uv.data[0]);\r\n                const y = Math.floor(uv.data[1]);\r\n                if (x < 0 || x >= textureSize[0] || y < 0 || y >= textureSize[1]) {\r\n                    console.error(`Texture ${textureName} out of bounds. Line ${node.line}`);\r\n                    return null;\r\n                }\r\n\r\n                texture.setPixel(x, y, 0, index, Array.from(value));\r\n\r\n                return null;\r\n            } else {\r\n                console.error(`Texture ${textureName} not found. Line ${node.line}`);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        console.error(`Invalid texture argument for textureStore. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    // Atomic Built-in Functions\r\n    AtomicLoad(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n        return currentValue;\r\n    }\r\n\r\n    AtomicStore(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value = value.value;\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    AtomicAdd(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value += value.value;\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicSub(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value -= value.value;\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicMax(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value = Math.max(currentValue.value, value.value);\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicMin(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value = Math.min(currentValue.value, value.value);\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicAnd(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value = currentValue.value & value.value;\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicOr(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value = currentValue.value | value.value;\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicXor(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value = currentValue.value ^ value.value;\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicExchange(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value = value.value;\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicCompareExchangeWeak(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: atomicCompareExchangeWeak\");\r\n        return null;\r\n    }\r\n\r\n    // Data Packing Built-in Functions\r\n    Pack4x8snorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack4x8snorm\");\r\n        return null;\r\n    }\r\n\r\n    Pack4x8unorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack4x8unorm\");\r\n        return null;\r\n    }\r\n\r\n    Pack4xI8(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack4xI8\");\r\n        return null;\r\n    }\r\n\r\n    Pack4xU8(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack4xU8\");\r\n        return null;\r\n    }\r\n\r\n    Pack4x8Clamp(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack4x8Clamp\");\r\n        return null;\r\n    }\r\n\r\n    Pack4xU8Clamp(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack4xU8Clamp\");\r\n        return null;\r\n    }\r\n\r\n    Pack2x16snorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack2x16snorm\");\r\n        return null;\r\n    }\r\n\r\n    Pack2x16unorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack2x16unorm\");\r\n        return null;\r\n    }\r\n\r\n    Pack2x16float(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack2x16float\");\r\n        return null;\r\n    }\r\n\r\n    // Data Unpacking Built-in Functions\r\n    Unpack4x8snorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: unpack4x8snorm\");\r\n        return null;\r\n    }\r\n\r\n    Unpack4x8unorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: unpack4x8unorm\");\r\n        return null;\r\n    }\r\n\r\n    Unpack4xI8(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: unpack4xI8\");\r\n        return null;\r\n    }\r\n\r\n    Unpack4xU8(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: unpack4xU8\");\r\n        return null;\r\n    }\r\n\r\n    Unpack2x16snorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: unpack2x16snorm\");\r\n        return null;\r\n    }\r\n\r\n    Unpack2x16unorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: unpack2x16unorm\");\r\n        return null;\r\n    }\r\n\r\n    Unpack2x16float(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: unpack2x16float\");\r\n        return null;\r\n    }\r\n\r\n    // Synchronization Functions\r\n    StorageBarrier(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // Execution is single threaded, barriers not necessary.\r\n        return null;\r\n    }\r\n\r\n    TextureBarrier(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // Execution is single threaded, barriers not necessary.\r\n        return null;\r\n    }\r\n\r\n    WorkgroupBarrier(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // Execution is single threaded, barriers not necessary.\r\n        return null;\r\n    }\r\n\r\n    WorkgroupUniformLoad(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // Execution is single threaded, barriers not necessary.\r\n        return null;\r\n    }\r\n\r\n    // Subgroup Functions\r\n    SubgroupAdd(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupAdd\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupExclusiveAdd(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupExclusiveAdd\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupInclusiveAdd(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupInclusiveAdd\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupAll(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupAll\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupAnd(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupAnd\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupAny(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupAny\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupBallot(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupBallot\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupBroadcast(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupBroadcast\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupBroadcastFirst(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupBroadcastFirst\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupElect(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupElect\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupMax(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupMax\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupMin(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupMin\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupMul(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupMul\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupExclusiveMul(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupExclusiveMul\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupInclusiveMul(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupInclusiveMul\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupOr(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupOr\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupShuffle(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupShuffle\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupShuffleDown(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupShuffleDown\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupShuffleUp(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupShuffleUp\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupShuffleXor(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupShuffleXor\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupXor(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupXor\");\r\n        return null;\r\n    }\r\n\r\n    // Quad Functions\r\n    QuadBroadcast(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: quadBroadcast\");\r\n        return null;\r\n    }\r\n\r\n    QuadSwapDiagonal(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: quadSwapDiagonal\");\r\n        return null;\r\n    }\r\n\r\n    QuadSwapX(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: quadSwapX\");\r\n        return null;\r\n    }\r\n\r\n    QuadSwapY(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: quadSwapY\");\r\n        return null;\r\n    }\r\n}\r\n", "import { TypeInfo } from '../reflect/info';\r\n\r\nexport const VectorTypeSize = {\r\n    \"vec2\": 2, \"vec2f\": 2, \"vec2i\": 2, \"vec2u\": 2, \"vec2b\": 2, \"vec2h\": 2,\r\n    \"vec3\": 3, \"vec3f\": 3, \"vec3i\": 3, \"vec3u\": 3, \"vec3b\": 3, \"vec3h\": 3,\r\n    \"vec4\": 4, \"vec4f\": 4, \"vec4i\": 4, \"vec4u\": 4, \"vec4b\": 4, \"vec4h\": 4\r\n};\r\n\r\nexport const MatrixTypeSize = {\r\n    \"mat2x2\": [2, 2, 4], \"mat2x2f\": [2, 2, 4], \"mat2x2h\": [2, 2, 4],\r\n    \"mat2x3\": [2, 3, 6], \"mat2x3f\": [2, 3, 6], \"mat2x3h\": [2, 3, 6],\r\n    \"mat2x4\": [2, 4, 8], \"mat2x4f\": [2, 4, 8], \"mat2x4h\": [2, 4, 8],\r\n    \"mat3x2\": [3, 2, 6], \"mat3x2f\": [3, 2, 6], \"mat3x2h\": [3, 2, 6],\r\n    \"mat3x3\": [3, 3, 9], \"mat3x3f\": [3, 3, 9], \"mat3x3h\": [3, 3, 9],\r\n    \"mat3x4\": [3, 4, 12], \"mat3x4f\": [3, 4, 12], \"mat3x4h\": [3, 4, 12],\r\n    \"mat4x2\": [4, 2, 8], \"mat4x2f\": [4, 2, 8], \"mat4x2h\": [4, 2, 8],\r\n    \"mat4x3\": [4, 3, 12], \"mat4x3f\": [4, 3, 12], \"mat4x3h\": [4, 3, 12],\r\n    \"mat4x4\": [4, 4, 16], \"mat4x4f\": [4, 4, 16], \"mat4x4h\": [4, 4, 16]\r\n};\r\n\r\nexport const MatrixTransposeType = {\r\n    \"mat2x2\": \"mat2x2\", \"mat2x2f\": \"mat2x2f\", \"mat2x2h\": \"mat2x2h\",\r\n    \"mat2x3\": \"mat3x2\", \"mat2x3f\": \"mat3x2f\", \"mat2x3h\": \"mat3x2h\",\r\n    \"mat2x4\": \"mat4x2\", \"mat2x4f\": \"mat4x2f\", \"mat2x4h\": \"mat4x2h\",\r\n    \"mat3x2\": \"mat2x3\", \"mat3x2f\": \"mat2x3f\", \"mat3x2h\": \"mat2x3h\",\r\n    \"mat3x3\": \"mat3x3\", \"mat3x3f\": \"mat3x3f\", \"mat3x3h\": \"mat3x3h\",\r\n    \"mat3x4\": \"mat4x3\", \"mat3x4f\": \"mat4x3f\", \"mat3x4h\": \"mat4x3h\",\r\n    \"mat4x2\": \"mat2x4\", \"mat4x2f\": \"mat2x4f\", \"mat4x2h\": \"mat2x4h\",\r\n    \"mat4x3\": \"mat4x3\", \"mat4x3f\": \"mat4x3f\", \"mat4x3h\": \"mat4x3h\",\r\n    \"mat4x4\": \"mat4x4\", \"mat4x4f\": \"mat4x4f\", \"mat4x4h\": \"mat4x4h\"\r\n};\r\n\r\nexport function matrixTranspose(matrix: number[], t: TypeInfo) {\r\n    if (MatrixTypeSize[t.name] === undefined) {\r\n        return null;\r\n    }\r\n\r\n    const cols = MatrixTypeSize[t.name][0];\r\n    const rows = MatrixTypeSize[t.name][1];\r\n    const result: number[] = [];\r\n\r\n    for (let i = 0; i < cols; i++) {\r\n        for (let j = 0; j < rows; j++) {\r\n            result[i * rows + j] = matrix[j * cols + i];\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nexport function matrixMultiply(matrixA: number[], t1: TypeInfo, matrixB: number[], t2: TypeInfo): number[] | null {\r\n  if (MatrixTypeSize[t1.name] === undefined || MatrixTypeSize[t2.name] === undefined) {\r\n    return null;\r\n  }\r\n\r\n  const k = MatrixTypeSize[t1.name][0];\r\n  const r = MatrixTypeSize[t1.name][1];\r\n  const c = MatrixTypeSize[t2.name][0];\r\n  const k2 = MatrixTypeSize[t2.name][1];\r\n\r\n  if (k !== k2) {\r\n    return null;\r\n  }\r\n\r\n  const result: number[] = new Array(c * r);\r\n\r\n  for (let j = 0; j < r; j++) { // Iterate through columns of result\r\n    for (let i = 0; i < c; i++) { // Iterate through rows of result\r\n      let sum = 0;\r\n      for (let l = 0; l < k; l++) {\r\n        sum += matrixA[l * r + j] * matrixB[i * k + l]; // Access column-major elements\r\n      }\r\n      result[j * c + i] = sum; // Store in column-major order\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport function matrixVectorMultiply(matrix: number[], t1: TypeInfo, vector: number[], t2: TypeInfo): number[] | null {\r\n  if (MatrixTypeSize[t1.name] === undefined || VectorTypeSize[t2.name] === undefined) {\r\n    return null;\r\n  }\r\n\r\n  const cols = MatrixTypeSize[t1.name][0];\r\n  const rows = MatrixTypeSize[t1.name][1];\r\n  \r\n  if (cols !== vector.length) {\r\n    return null;\r\n  }\r\n\r\n  const resultVec = new Array(rows);\r\n  // Perform matrix-vector multiplication (column-major)\r\n  for (let i = 0; i < rows; i++) {\r\n    let sum = 0;\r\n    for (let j = 0; j < cols; j++) {\r\n      sum += matrix[j * rows + i] * vector[j]; // Access column-major element\r\n    }\r\n    resultVec[i] = sum;\r\n  }\r\n\r\n  return resultVec;\r\n}\r\n\r\nexport function vectorMatrixMultiply(vector: number[], t1: TypeInfo, matrix: number[], t2: TypeInfo): number[] | null {\r\n  if (VectorTypeSize[t1.name] === undefined || MatrixTypeSize[t2.name] === undefined) {\r\n    return null;\r\n  }\r\n\r\n  const cols = MatrixTypeSize[t2.name][0];\r\n  const rows = MatrixTypeSize[t2.name][1];\r\n\r\n  if (rows !== vector.length) {\r\n    return null;\r\n  }\r\n\r\n  const result: number[] = [];\r\n  for (let j = 0; j < cols; j++) {\r\n    let sum = 0;\r\n    for (let i = 0; i < rows; i++) {\r\n      sum += vector[i] * matrix[i * cols + j];\r\n    }\r\n    result[j] = sum;\r\n  }\r\n\r\n  return result;\r\n}\r\n", "import { Node, Type, TemplateType, Return, Break, Continue, Let, Var, Const,\r\n    If, For, While, Loop, Continuing, Assign, Increment, Struct, Override, ArrayType,\r\n    Call, Diagnostic, Alias, BinaryOperator, LiteralExpr, Expression,\r\n    VariableExpr, CallExpr, CreateExpr, ConstExpr, BitcastExpr, UnaryOperator,\r\n    ArrayIndex, StringExpr, Function, Switch, SwitchCase, Case, Default, DefaultSelector } from \"./wgsl_ast.js\";\r\nimport { Data, TypedData, TextureData, ScalarData, VectorData, MatrixData, PointerData, VoidData } from \"./wgsl_ast.js\";\r\nimport { Reflect } from \"./reflect/reflect.js\";\r\nimport { TypeInfo, StructInfo, ArrayInfo, TemplateInfo } from \"./reflect/info.js\";\r\nimport { ExecContext, FunctionRef } from \"./exec/exec_context.js\";\r\nimport { ExecInterface } from \"./exec/exec_interface.js\";\r\nimport { BuiltinFunctions } from \"./exec/builtin_functions.js\";\r\nimport { isArray, castScalar, castVector } from \"./utils/cast.js\";\r\nimport { matrixMultiply, matrixVectorMultiply, vectorMatrixMultiply, MatrixTypeSize, VectorTypeSize } from \"./utils/matrix.js\";\r\n\r\nexport class WgslExec extends ExecInterface {\r\n    ast: Node[];\r\n    context: ExecContext;\r\n    reflection: Reflect;\r\n    builtins: BuiltinFunctions;\r\n    typeInfo: Object;\r\n\r\n    constructor(ast?: Node[], context?: ExecContext) {\r\n        super();\r\n        this.ast = ast ?? [];\r\n        this.reflection = new Reflect();\r\n        this.reflection.updateAST(this.ast);\r\n\r\n        this.context = context?.clone() ?? new ExecContext();\r\n        this.builtins = new BuiltinFunctions(this);\r\n\r\n        this.typeInfo = {\r\n            \"bool\": this.getTypeInfo(Type.bool),\r\n            \"i32\": this.getTypeInfo(Type.i32),\r\n            \"u32\": this.getTypeInfo(Type.u32),\r\n            \"f32\": this.getTypeInfo(Type.f32),\r\n            \"f16\": this.getTypeInfo(Type.f16),\r\n            \"vec2f\": this.getTypeInfo(TemplateType.vec2f),\r\n            \"vec2u\": this.getTypeInfo(TemplateType.vec2u),\r\n            \"vec2i\": this.getTypeInfo(TemplateType.vec2i),\r\n            \"vec2h\": this.getTypeInfo(TemplateType.vec2h),\r\n            \"vec3f\": this.getTypeInfo(TemplateType.vec3f),\r\n            \"vec3u\": this.getTypeInfo(TemplateType.vec3u),\r\n            \"vec3i\": this.getTypeInfo(TemplateType.vec3i),\r\n            \"vec3h\": this.getTypeInfo(TemplateType.vec3h),\r\n            \"vec4f\": this.getTypeInfo(TemplateType.vec4f),\r\n            \"vec4u\": this.getTypeInfo(TemplateType.vec4u),\r\n            \"vec4i\": this.getTypeInfo(TemplateType.vec4i),\r\n            \"vec4h\": this.getTypeInfo(TemplateType.vec4h),\r\n            \"mat2x2f\": this.getTypeInfo(TemplateType.mat2x2f),\r\n            \"mat2x3f\": this.getTypeInfo(TemplateType.mat2x3f),\r\n            \"mat2x4f\": this.getTypeInfo(TemplateType.mat2x4f),\r\n            \"mat3x2f\": this.getTypeInfo(TemplateType.mat3x2f),\r\n            \"mat3x3f\": this.getTypeInfo(TemplateType.mat3x3f),\r\n            \"mat3x4f\": this.getTypeInfo(TemplateType.mat3x4f),\r\n            \"mat4x2f\": this.getTypeInfo(TemplateType.mat4x2f),\r\n            \"mat4x3f\": this.getTypeInfo(TemplateType.mat4x3f),\r\n            \"mat4x4f\": this.getTypeInfo(TemplateType.mat4x4f),\r\n        };\r\n    }\r\n\r\n    getVariableValue(name: string): number | number[] | null {\r\n        const v = this.context.getVariable(name)?.value ?? null;\r\n        if (v === null) {\r\n            return null;\r\n        }\r\n        if (v instanceof ScalarData) {\r\n            return v.value;\r\n        }\r\n        if (v instanceof VectorData) {\r\n            return Array.from(v.data);\r\n        }\r\n        if (v instanceof MatrixData) {\r\n            return Array.from(v.data);\r\n        }\r\n        if (v instanceof TypedData) {\r\n            if (v.typeInfo instanceof ArrayInfo) {\r\n                if (v.typeInfo.format.name === \"u32\") {\r\n                    return Array.from(new Uint32Array(v.buffer, v.offset, v.typeInfo.count));\r\n                } else if (v.typeInfo.format.name === \"i32\") {\r\n                    return Array.from(new Int32Array(v.buffer, v.offset, v.typeInfo.count));\r\n                } else if (v.typeInfo.format.name === \"f32\") {\r\n                    return Array.from(new Float32Array(v.buffer, v.offset, v.typeInfo.count));\r\n                }\r\n            }\r\n        }\r\n        console.error(`Unsupported return variable type ${v.typeInfo.name}`);\r\n        return null;\r\n    }\r\n\r\n    execute(config?: Object): void {\r\n        config = config ?? {};\r\n        if (config[\"constants\"]) {\r\n            this._setOverrides(config[\"constants\"], this.context);\r\n        }\r\n\r\n        this._execStatements(this.ast, this.context);\r\n    }\r\n\r\n    dispatchWorkgroups(kernel: string, dispatchCount: number | number[], bindGroups: Object, config?: Object): void {\r\n        const context = this.context.clone();\r\n\r\n        config = config ?? {};\r\n        if (config[\"constants\"]) {\r\n            this._setOverrides(config[\"constants\"], context);\r\n        }\r\n\r\n        this._execStatements(this.ast, context);\r\n\r\n        const f = context.getFunction(kernel);\r\n        if (!f) {\r\n            console.error(`Function ${kernel} not found`);\r\n            return;\r\n        }\r\n\r\n        if (typeof dispatchCount === \"number\") {\r\n            dispatchCount = [dispatchCount, 1, 1];\r\n        } else if (dispatchCount.length === 0) {\r\n            console.error(`Invalid dispatch count`);\r\n            return;\r\n        } else if (dispatchCount.length === 1) {\r\n            dispatchCount = [dispatchCount[0], 1, 1];\r\n        } else if (dispatchCount.length === 2) {\r\n            dispatchCount = [dispatchCount[0], dispatchCount[1], 1];\r\n        } else if (dispatchCount.length > 3) {\r\n            dispatchCount = [dispatchCount[0], dispatchCount[1], dispatchCount[2]];\r\n        }\r\n\r\n        const width = dispatchCount[0];\r\n        const height = dispatchCount[1];\r\n        const depth = dispatchCount[2];\r\n\r\n        const vec3u = this.getTypeInfo(\"vec3u\");\r\n        context.setVariable(\"@num_workgroups\", new VectorData(dispatchCount, vec3u));\r\n\r\n        const kernelRefl = this.reflection.getFunctionInfo(kernel);\r\n        if (kernelRefl === null) {\r\n            console.error(`Function ${kernel} not found in reflection data`);\r\n        }\r\n\r\n        for (const set in bindGroups) {\r\n            for (const binding in bindGroups[set]) {\r\n                const entry = bindGroups[set][binding];\r\n\r\n                context.variables.forEach((v) => {\r\n                    const node = v.node;\r\n                    if (node?.attributes) {\r\n                        let b = null;\r\n                        let s = null;\r\n                        for (const attr of node.attributes) {\r\n                            if (attr.name === \"binding\") {\r\n                                b = attr.value;\r\n                            } else if (attr.name === \"group\") {\r\n                                s = attr.value;\r\n                            }\r\n                        }\r\n                        if (binding == b && set == s) {\r\n                            let found = false;\r\n                            for (const resource of kernelRefl.resources) {\r\n                                if (resource.name === v.name && resource.group === parseInt(set) && resource.binding === parseInt(binding)) {\r\n                                    found = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            if (found) {\r\n                                if (entry.texture !== undefined && entry.descriptor !== undefined) {\r\n                                    // Texture\r\n                                    const textureData = new TextureData(entry.texture, this.getTypeInfo(node.type), entry.descriptor,\r\n                                            entry.texture.view ?? null);\r\n                                    v.value = textureData;\r\n                                } else if (entry.uniform !== undefined) {\r\n                                    // Uniform buffer\r\n                                    v.value = new TypedData(entry.uniform, this.getTypeInfo(node.type));\r\n                                } else {\r\n                                    // Storage buffer\r\n                                    v.value = new TypedData(entry, this.getTypeInfo(node.type));\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        for (let z = 0; z < depth; ++z) {\r\n            for (let y = 0; y < height; ++y) {\r\n                for (let x = 0; x < width; ++x) {\r\n                    context.setVariable(\"@workgroup_id\", new VectorData([x, y, z], this.getTypeInfo(\"vec3u\")));\r\n                    this._dispatchWorkgroup(f, [x, y, z], context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    static _breakObj = new Data(new TypeInfo(\"BREAK\", null), null);\r\n    static _continueObj = new Data(new TypeInfo(\"CONTINUE\", null), null);\r\n\r\n    execStatement(stmt: Node, context: ExecContext): Data | null {\r\n        if (stmt instanceof Return) {\r\n            return this.evalExpression(stmt.value, context);\r\n        } else if (stmt instanceof Break) {\r\n            if (stmt.condition) {\r\n                const c = this.evalExpression(stmt.condition, context);\r\n                if (!(c instanceof ScalarData)) {\r\n                    throw new Error(`Invalid break-if condition`);\r\n                }\r\n                if (!c.value) {\r\n                    return null;\r\n                }\r\n            }\r\n            return WgslExec._breakObj;\r\n        } else if (stmt instanceof Continue) {\r\n            return WgslExec._continueObj;\r\n        } else if (stmt instanceof Let) {\r\n            this._let(stmt, context);\r\n        } else if (stmt instanceof Var) {\r\n            this._var(stmt, context);\r\n        } else if (stmt instanceof Const) {\r\n            this._const(stmt, context);\r\n        } else if (stmt instanceof Function) {\r\n            this._function(stmt, context);\r\n        } else if (stmt instanceof If) {\r\n            return this._if(stmt, context);\r\n        } else if (stmt instanceof Switch) {\r\n            return this._switch(stmt, context);\r\n        } else if (stmt instanceof For) {\r\n            return this._for(stmt, context);\r\n        } else if (stmt instanceof While) {\r\n            return this._while(stmt, context);\r\n        } else if (stmt instanceof Loop) {\r\n            return this._loop(stmt, context);\r\n        } else if (stmt instanceof Continuing) {\r\n            const subContext = context.clone();\r\n            subContext.currentFunctionName = context.currentFunctionName;\r\n            return this._execStatements(stmt.body, subContext);\r\n        } else if (stmt instanceof Assign) {\r\n            this._assign(stmt, context);\r\n        } else if (stmt instanceof Increment) {\r\n            this._increment(stmt, context);\r\n        } else if (stmt instanceof Struct) {\r\n            return null;\r\n        } else if (stmt instanceof Override) {\r\n            const name = stmt.name;\r\n            if (context.getVariable(name) === null) {\r\n                context.setVariable(name, new ScalarData(0, this.getTypeInfo(\"u32\")));\r\n                //console.error(`Override constant ${name} not found. Line ${stmt.line}`);\r\n            }\r\n        } else if (stmt instanceof Call) {\r\n            this._call(stmt, context);\r\n        } else if (stmt instanceof Diagnostic) {\r\n            return null; // Nothing to do here.\r\n        } else if (stmt instanceof Alias) {\r\n            return null; // Nothing to do here.\r\n        } else {\r\n            console.error(`Invalid statement type.`, stmt, `Line ${stmt.line}`);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    evalExpression(node: Node, context: ExecContext): Data | null {\r\n        if (node instanceof BinaryOperator) {\r\n            return this._evalBinaryOp(node, context);\r\n        } else if (node instanceof LiteralExpr) {\r\n            return this._evalLiteral(node, context);\r\n        } else if (node instanceof VariableExpr) {\r\n            return this._evalVariable(node, context);\r\n        } else if (node instanceof CallExpr) {\r\n            return this._evalCall(node, context);\r\n        } else if (node instanceof CreateExpr) {\r\n            return this._evalCreate(node, context);\r\n        } else if (node instanceof ConstExpr) {\r\n            return this._evalConst(node, context);\r\n        } else if (node instanceof BitcastExpr) {\r\n            return this._evalBitcast(node, context);\r\n        } else if (node instanceof UnaryOperator) {\r\n            return this._evalUnaryOp(node, context);\r\n        }\r\n        console.error(`Invalid expression type`, node, `Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    getTypeInfo(type: Type | string): TypeInfo | null {\r\n        if (type instanceof Type) {\r\n            const t = this.reflection.getTypeInfo(type as Type);\r\n            if (t !== null) {\r\n                return t;\r\n            }\r\n        }\r\n\r\n        let t = this.typeInfo[type as string] ?? null;\r\n        if (t !== null) {\r\n            return t;\r\n        }\r\n\r\n        t = this.reflection.getTypeInfoByName(type as string);\r\n        return t;\r\n    }\r\n\r\n    _setOverrides(constants: Object, context: ExecContext): void {\r\n        for (const k in constants) {\r\n            const v = constants[k];\r\n            const override = this.reflection.getOverrideInfo(k);\r\n            if (override !== null) {\r\n                if (override.type === null) {\r\n                    override.type = this.getTypeInfo(\"u32\");\r\n                }\r\n                if (override.type.name === \"u32\" || override.type.name === \"i32\" || override.type.name === \"f32\" || override.type.name === \"f16\") {\r\n                    context.setVariable(k, new ScalarData(v, override.type));\r\n                } else if (override.type.name === \"bool\") {\r\n                    context.setVariable(k, new ScalarData(v ? 1 : 0, override.type));\r\n                } else if (override.type.name === \"vec2\" || override.type.name === \"vec3\" || override.type.name === \"vec4\" ||\r\n                    override.type.name === \"vec2f\" || override.type.name === \"vec3f\" || override.type.name === \"vec4f\" ||\r\n                    override.type.name === \"vec2i\" || override.type.name === \"vec3i\" || override.type.name === \"vec4i\" ||\r\n                    override.type.name === \"vec2u\" || override.type.name === \"vec3u\" || override.type.name === \"vec4u\" ||\r\n                    override.type.name === \"vec2h\" || override.type.name === \"vec3h\" || override.type.name === \"vec4h\") {\r\n                    context.setVariable(k, new VectorData(v, override.type));\r\n                } else {\r\n                    console.error(`Invalid constant type for ${k}`);\r\n                }\r\n            } else {\r\n                console.error(`Override ${k} does not exist in the shader.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    _dispatchWorkgroup(f: FunctionRef, workgroup_id: number[], context: ExecContext): void {\r\n        const workgroupSize = [1, 1, 1];\r\n        for (const attr of f.node.attributes) {\r\n            if (attr.name === \"workgroup_size\") {\r\n                if (attr.value.length > 0) {\r\n                    // The value could be an override constant\r\n                    const v = context.getVariableValue(attr.value[0]);\r\n                    if (v instanceof ScalarData) {\r\n                        workgroupSize[0] = v.value;\r\n                    } else {\r\n                        workgroupSize[0] = parseInt(attr.value[0]);\r\n                    }\r\n                }\r\n                if (attr.value.length > 1) {\r\n                    const v = context.getVariableValue(attr.value[1]);\r\n                    if (v instanceof ScalarData) {\r\n                        workgroupSize[1] = v.value;\r\n                    } else {\r\n                        workgroupSize[1] = parseInt(attr.value[1]);\r\n                    }\r\n                }\r\n                if (attr.value.length > 2) {\r\n                    const v = context.getVariableValue(attr.value[2]);\r\n                    if (v instanceof ScalarData) {\r\n                        workgroupSize[2] = v.value;\r\n                    } else {\r\n                        workgroupSize[2] = parseInt(attr.value[2]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const vec3u = this.getTypeInfo(\"vec3u\");\r\n        const u32 = this.getTypeInfo(\"u32\");\r\n        context.setVariable(\"@workgroup_size\", new VectorData(workgroupSize, vec3u));\r\n\r\n        const width = workgroupSize[0];\r\n        const height = workgroupSize[1];\r\n        const depth = workgroupSize[2];\r\n\r\n        for (let z = 0, li = 0; z < depth; ++z) {\r\n            for (let y = 0; y < height; ++y) {\r\n                for (let x = 0; x < width; ++x, ++li) {\r\n                    const local_invocation_id = [x, y, z];\r\n                    const global_invocation_id = [\r\n                        x + workgroup_id[0] * workgroupSize[0],\r\n                        y + workgroup_id[1] * workgroupSize[1],\r\n                        z + workgroup_id[2] * workgroupSize[2]];\r\n\r\n                    context.setVariable(\"@local_invocation_id\", new VectorData(local_invocation_id, vec3u));\r\n                    context.setVariable(\"@global_invocation_id\", new VectorData(global_invocation_id, vec3u));\r\n                    context.setVariable(\"@local_invocation_index\", new ScalarData(li, u32));\r\n\r\n                    this._dispatchExec(f, context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    _dispatchExec(f: FunctionRef, context: ExecContext): void {\r\n        // Update any built-in input args.\r\n        // TODO: handle input structs.\r\n        for (const arg of f.node.args) {\r\n            for (const attr of arg.attributes) {\r\n                if (attr.name === \"builtin\") {\r\n                    const globalName = `@${attr.value}`;\r\n                    const globalVar = context.getVariable(globalName);\r\n                    if (globalVar !== undefined) {\r\n                        context.variables.set(arg.name, globalVar);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._execStatements(f.node.body, context);\r\n    }\r\n\r\n    getVariableName(node: Node, context: ExecContext): string | null {\r\n        while (node instanceof UnaryOperator) {\r\n            node = node.right;\r\n        }\r\n\r\n        if (node instanceof VariableExpr) {\r\n            return (node as VariableExpr).name;\r\n        } else {\r\n            console.error(`Unknown variable type`, node, 'Line', node.line);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    _execStatements(statements: Node[], context: ExecContext): Data | null {\r\n        for (const stmt of statements) {\r\n            // Block statements are declared as arrays of statements.\r\n            if (stmt instanceof Array) {\r\n                const subContext = context.clone();\r\n                const res = this._execStatements(stmt, subContext);\r\n                if (res) {\r\n                    return res;\r\n                }\r\n                continue;\r\n            }\r\n\r\n            const res = this.execStatement(stmt, context);\r\n            if (res) {\r\n                return res;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    _call(node: Call, context: ExecContext): void {\r\n        const subContext = context.clone();\r\n        subContext.currentFunctionName = node.name;\r\n\r\n        const f = context.getFunction(node.name);\r\n        if (!f) {\r\n            if (node.isBuiltin) {\r\n                this._callBuiltinFunction(node, subContext);\r\n            } else {\r\n                const typeInfo = this.getTypeInfo(node.name);\r\n                if (typeInfo) {\r\n                    this._evalCreate(node, context);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        for (let ai = 0; ai < f.node.args.length; ++ai) {\r\n            const arg = f.node.args[ai];\r\n            const value = this.evalExpression(node.args[ai], subContext);\r\n            subContext.setVariable(arg.name, value, arg);\r\n        }\r\n\r\n        this._execStatements(f.node.body, subContext);\r\n    }\r\n\r\n    _increment(node: Increment, context: ExecContext): void {\r\n        const name = this.getVariableName(node.variable, context);\r\n        const v = context.getVariable(name);\r\n        if (!v) {\r\n            console.error(`Variable ${name} not found. Line ${node.line}`);\r\n            return;\r\n        }\r\n        if (node.operator === \"++\") {\r\n            if (v.value instanceof ScalarData) {\r\n                v.value.value++;\r\n            } else {\r\n                console.error(`Variable ${name} is not a scalar. Line ${node.line}`);\r\n            }\r\n        } else if (node.operator === \"--\") {\r\n            if (v.value instanceof ScalarData) {\r\n                v.value.value--;\r\n            } else {\r\n                console.error(`Variable ${name} is not a scalar. Line ${node.line}`);\r\n            }\r\n        } else {\r\n            console.error(`Unknown increment operator ${node.operator}. Line ${node.line}`);\r\n        }\r\n    }\r\n\r\n    _getVariableData(node: Node, context: ExecContext): Data | null {\r\n        if (node instanceof VariableExpr) {\r\n            const name = this.getVariableName(node, context);\r\n            const _var = context.getVariable(name);\r\n            if (_var === null) {\r\n                console.error(`Variable ${name} not found. Line ${node.line}`);\r\n                return null;\r\n            }\r\n            return _var.value.getSubData(this, node.postfix, context);\r\n        }\r\n\r\n        if (node instanceof UnaryOperator) {\r\n            if (node.operator === \"*\") {\r\n                const refData = this._getVariableData(node.right, context);\r\n                if (!(refData instanceof PointerData)) {\r\n                    console.error(`Variable ${node.right} is not a pointer. Line ${node.line}`);\r\n                    return null;\r\n                }\r\n\r\n                return refData.reference.getSubData(this, node.postfix, context);\r\n            } else if (node.operator === \"&\") {\r\n                const refData = this._getVariableData(node.right, context);\r\n                return new PointerData(refData);\r\n            } \r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _assign(node: Assign, context: ExecContext): void {\r\n        let v: Data | null = null;\r\n        let name: string = \"<var>\";\r\n\r\n        let postfix: Expression | null = null;\r\n\r\n        if (node.variable instanceof UnaryOperator) {\r\n            const varData = this._getVariableData(node.variable, context);\r\n            const assignValue = this.evalExpression(node.value, context);\r\n            const op = node.operator;\r\n\r\n            if (op === \"=\") {\r\n                if (varData instanceof ScalarData || varData instanceof VectorData || varData instanceof MatrixData) {\r\n                    if (assignValue instanceof ScalarData || assignValue instanceof VectorData || assignValue instanceof MatrixData &&\r\n                        varData.data.length === assignValue.data.length) {\r\n                        varData.data.set(assignValue.data);\r\n                        return;\r\n                    } else {\r\n                        console.error(`Invalid assignment. Line ${node.line}`);\r\n                    }\r\n                } else if (varData instanceof TypedData && assignValue instanceof TypedData) {\r\n                    if ((varData.buffer.byteLength - varData.offset) >= (assignValue.buffer.byteLength - assignValue.offset)) {\r\n                        if (varData.buffer.byteLength % 4 === 0) {\r\n                            new Uint32Array(varData.buffer, varData.offset, varData.typeInfo.size / 4).set(new Uint32Array(assignValue.buffer, assignValue.offset, assignValue.typeInfo.size / 4));\r\n                        } else {\r\n                            new Uint8Array(varData.buffer, varData.offset, varData.typeInfo.size).set(new Uint8Array(assignValue.buffer, assignValue.offset, assignValue.typeInfo.size));\r\n                        }\r\n                        return;\r\n                    }\r\n                }\r\n                console.error(`Invalid assignment. Line ${node.line}`);\r\n                return null;\r\n            } else if (op === \"+=\") {\r\n                if (varData instanceof ScalarData || varData instanceof VectorData || varData instanceof MatrixData) {\r\n                    if (assignValue instanceof ScalarData || assignValue instanceof VectorData || assignValue instanceof MatrixData) {\r\n                        varData.data.set(assignValue.data.map((v: number, i: number) => varData.data[i] + v));\r\n                        return;\r\n                    } else {\r\n                        console.error(`Invalid assignment . Line ${node.line}`);\r\n                        return;\r\n                    }\r\n                } else {\r\n                    console.error(`Invalid assignment. Line ${node.line}`);\r\n                    return;\r\n                }\r\n            } else if (op === \"-=\") {\r\n                if (varData instanceof ScalarData || varData instanceof VectorData || varData instanceof MatrixData) {\r\n                    if (assignValue instanceof ScalarData || assignValue instanceof VectorData || assignValue instanceof MatrixData) {\r\n                        varData.data.set(assignValue.data.map((v: number, i: number) => varData.data[i] - v));\r\n                        return;\r\n                    } else {\r\n                        console.error(`Invalid assignment. Line ${node.line}`);\r\n                        return;\r\n                    }\r\n                } else {\r\n                    console.error(`Invalid assignment. Line ${node.line}`);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (node.variable instanceof UnaryOperator) {\r\n            if (node.variable.operator === \"*\") {\r\n                name = this.getVariableName(node.variable.right, context);\r\n                const _var = context.getVariable(name);\r\n                if (_var && _var.value instanceof PointerData) {\r\n                    v = _var.value.reference;\r\n                } else {\r\n                    console.error(`Variable ${name} is not a pointer. Line ${node.line}`);\r\n                    return;\r\n                }\r\n\r\n                let postfix = node.variable.postfix;\r\n                if (!postfix) {\r\n                    let rNode = node.variable.right;\r\n                    while (rNode instanceof UnaryOperator) {\r\n                        if (rNode.postfix) {\r\n                            postfix = rNode.postfix;\r\n                            break;\r\n                        }\r\n                        rNode = rNode.right;\r\n                    }\r\n                }\r\n                if (postfix) {\r\n                    v = v.getSubData(this, postfix, context);\r\n                }\r\n            }\r\n        } else {\r\n            postfix = node.variable.postfix;\r\n            name = this.getVariableName(node.variable, context);\r\n            const _var = context.getVariable(name);\r\n            if (_var === null) {\r\n                console.error(`Variable ${name} not found. Line ${node.line}`);\r\n                return;\r\n            }\r\n            v = _var.value;\r\n        }\r\n\r\n        if (v instanceof PointerData) {\r\n            v = v.reference;\r\n        }\r\n\r\n        if (v === null) {\r\n            console.error(`Variable ${name} not found. Line ${node.line}`);\r\n            return;\r\n        }\r\n\r\n        const value = this.evalExpression(node.value, context);\r\n\r\n        const op = node.operator;\r\n        if (op !== \"=\") {\r\n            const currentValue = v.getSubData(this, postfix, context);\r\n\r\n            if (currentValue instanceof VectorData && value instanceof ScalarData) {\r\n                const cv = currentValue.data;\r\n                const v = value.value;\r\n\r\n                if (op === \"+=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] += v;\r\n                    }\r\n                } else if (op === \"-=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] -= v;\r\n                    }\r\n                } else if (op === \"*=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] *= v;\r\n                    }\r\n                } else if (op === \"/=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] /= v;\r\n                    }\r\n                } else if (op === \"%=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] %= v;\r\n                    }\r\n                } else if (op === \"&=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] &= v;\r\n                    }\r\n                } else if (op === \"|=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] |= v;\r\n                    }\r\n                } else if (op === \"^=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] ^= v;\r\n                    }\r\n                } else if (op === \"<<=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] <<= v;\r\n                    }\r\n                } else if (op === \">>=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] >>= v;\r\n                    }\r\n                } else {\r\n                    console.error(`Invalid operator ${op}. Line ${node.line}`);\r\n                }\r\n            } else if (currentValue instanceof VectorData && value instanceof VectorData) {\r\n                const cv = currentValue.data;\r\n                const v = value.data;\r\n                if (cv.length !== v.length) {\r\n                    console.error(`Vector length mismatch. Line ${node.line}`);\r\n                    return;\r\n                }\r\n\r\n                if (op === \"+=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] += v[i];\r\n                    }\r\n                } else if (op === \"-=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] -= v[i];\r\n                    }\r\n                } else if (op === \"*=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] *= v[i];\r\n                    }\r\n                } else if (op === \"/=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] /= v[i];\r\n                    }\r\n                } else if (op === \"%=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] %= v[i];\r\n                    }\r\n                } else if (op === \"&=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] &= v[i];\r\n                    }\r\n                } else if (op === \"|=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] |= v[i];\r\n                    }\r\n                } else if (op === \"^=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] ^= v[i];\r\n                    }\r\n                } else if (op === \"<<=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] <<= v[i];\r\n                    }\r\n                } else if (op === \">>=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] >>= v[i];\r\n                    }\r\n                } else {\r\n                    console.error(`Invalid operator ${op}. Line ${node.line}`);\r\n                }\r\n            } else if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n                if (op === \"+=\") {\r\n                    currentValue.value += value.value;\r\n                } else if (op === \"-=\") {\r\n                    currentValue.value -= value.value;\r\n                } else if (op === \"*=\") {\r\n                    currentValue.value *= value.value;\r\n                } else if (op === \"/=\") {\r\n                    currentValue.value /= value.value;\r\n                } else if (op === \"%=\") {\r\n                    currentValue.value %= value.value;\r\n                } else if (op === \"&=\") {\r\n                    currentValue.value &= value.value;\r\n                } else if (op === \"|=\") {\r\n                    currentValue.value |= value.value;\r\n                } else if (op === \"^=\") {\r\n                    currentValue.value ^= value.value;\r\n                } else if (op === \"<<=\") {\r\n                    currentValue.value <<= value.value;\r\n                } else if (op === \">>=\") {\r\n                    currentValue.value >>= value.value;\r\n                } else {\r\n                    console.error(`Invalid operator ${op}. Line ${node.line}`);\r\n                }\r\n            } else {\r\n                console.error(`Invalid type for ${node.operator} operator. Line ${node.line}`);\r\n                return;\r\n            }\r\n\r\n            // If the variable is a TypedData, as in a struct or array, and we're assigning a\r\n            // sub portion of it, set the data in the original buffer.\r\n            if (v instanceof TypedData) {\r\n                v.setDataValue(this, currentValue, postfix, context);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (v instanceof TypedData) {\r\n            v.setDataValue(this, value, postfix, context);\r\n        } else if (postfix) {\r\n            if (!(v instanceof VectorData) && !(v instanceof MatrixData)) {\r\n                console.error(`Variable ${name} is not a vector or matrix. Line ${node.line}`);\r\n                return;\r\n            }\r\n\r\n            if (postfix instanceof ArrayIndex) {\r\n                const idx = (this.evalExpression(postfix.index, context) as ScalarData).value;\r\n\r\n                if (v instanceof VectorData) {\r\n                    if (value instanceof ScalarData) {\r\n                        v.data[idx] = value.value;\r\n                    } else {\r\n                        console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                        return;\r\n                    }\r\n                } else if (v instanceof MatrixData) {\r\n                    const idx = (this.evalExpression(postfix.index, context) as ScalarData).value;\r\n                    if (idx < 0) {\r\n                        console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                        return;\r\n                    }\r\n                    if (value instanceof VectorData) {\r\n                        const typeName = v.typeInfo.getTypeName();\r\n                        if (typeName === \"mat2x2\" || typeName === \"mat2x2f\" || typeName === \"mat2x2h\") {\r\n                            if (idx < 2 && value.data.length === 2) {\r\n                                v.data[idx * 2] = value.data[0];\r\n                                v.data[idx * 2 + 1] = value.data[1];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat2x3\" || typeName === \"mat2x3f\" || typeName === \"mat2x3h\") {\r\n                            if (idx < 2 && value.data.length === 3) {\r\n                                v.data[idx * 3] = value.data[0];\r\n                                v.data[idx * 3 + 1] = value.data[1];\r\n                                v.data[idx * 3 + 2] = value.data[2];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat2x4\" || typeName === \"mat2x4f\" || typeName === \"mat2x4h\") {\r\n                            if (idx < 2 && value.data.length === 4) {\r\n                                v.data[idx * 4] = value.data[0];\r\n                                v.data[idx * 4 + 1] = value.data[1];\r\n                                v.data[idx * 4 + 2] = value.data[2];\r\n                                v.data[idx * 4 + 3] = value.data[3];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat3x2\" || typeName === \"mat3x2f\" || typeName === \"mat3x2h\") {\r\n                            if (idx < 3 && value.data.length === 2) {\r\n                                v.data[idx * 2] = value.data[0];\r\n                                v.data[idx * 2 + 1] = value.data[1];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat3x3\" || typeName === \"mat3x3f\" || typeName === \"mat3x3h\") {\r\n                            if (idx < 3 && value.data.length === 3) {\r\n                                v.data[idx * 3] = value.data[0];\r\n                                v.data[idx * 3 + 1] = value.data[1];\r\n                                v.data[idx * 3 + 2] = value.data[2];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat3x4\" || typeName === \"mat3x4f\" || typeName === \"mat3x4h\") {\r\n                            if (idx < 3 && value.data.length === 4) {\r\n                                v.data[idx * 4] = value.data[0];\r\n                                v.data[idx * 4 + 1] = value.data[1];\r\n                                v.data[idx * 4 + 2] = value.data[2];\r\n                                v.data[idx * 4 + 3] = value.data[3];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat4x2\" || typeName === \"mat4x2f\" || typeName === \"mat4x2h\") {\r\n                            if (idx < 4 && value.data.length === 2) {\r\n                                v.data[idx * 2] = value.data[0];\r\n                                v.data[idx * 2 + 1] = value.data[1];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat4x3\" || typeName === \"mat4x3f\" || typeName === \"mat4x3h\") {\r\n                            if (idx < 4 && value.data.length === 3) {\r\n                                v.data[idx * 3] = value.data[0];\r\n                                v.data[idx * 3 + 1] = value.data[1];\r\n                                v.data[idx * 3 + 2] = value.data[2];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat4x4\" || typeName === \"mat4x4f\" || typeName === \"mat4x4h\") {\r\n                            if (idx < 4 && value.data.length === 4) {\r\n                                v.data[idx * 4] = value.data[0];\r\n                                v.data[idx * 4 + 1] = value.data[1];\r\n                                v.data[idx * 4 + 2] = value.data[2];\r\n                                v.data[idx * 4 + 3] = value.data[3];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else {\r\n                            console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                            return;\r\n                        }\r\n                    } else {\r\n                        console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                        return;\r\n                    }\r\n                } else {\r\n                    console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                    return;\r\n                }\r\n            } else if (postfix instanceof StringExpr) {\r\n                const member = postfix.value;\r\n                if (!(v instanceof VectorData)) {\r\n                    console.error(`Invalid assignment to ${member}. Variable ${name} is not a vector. Line ${node.line}`);\r\n                    return;\r\n                }\r\n                if (value instanceof ScalarData) {\r\n                    if (member.length > 1) {\r\n                        console.error(`Invalid assignment to ${member} for variable ${name}. Line ${node.line}`);\r\n                        return;\r\n                    }\r\n                    if (member === \"x\") {\r\n                        v.data[0] = value.value;\r\n                    } else if (member === \"y\") {\r\n                        if (v.data.length < 2) {\r\n                            console.error(`Invalid assignment to ${member} for variable ${name}. Line ${node.line}`);\r\n                            return;\r\n                        }\r\n                        v.data[1] = value.value;\r\n                    } else if (member === \"z\") {\r\n                        if (v.data.length < 3) {\r\n                            console.error(`Invalid assignment to ${member} for variable ${name}. Line ${node.line}`);\r\n                            return;\r\n                        }\r\n                        v.data[2] = value.value;\r\n                    } else if (member === \"w\") {\r\n                        if (v.data.length < 4) {\r\n                            console.error(`Invalid assignment to ${member} for variable ${name}. Line ${node.line}`);\r\n                            return;\r\n                        }\r\n                        v.data[3] = value.value;\r\n                    }\r\n                } else if (value instanceof VectorData) {\r\n                    if (member.length !== value.data.length) {\r\n                        console.error(`Invalid assignment to ${member} for variable ${name}. Line ${node.line}`);\r\n                        return;\r\n                    }\r\n                    for (let i = 0; i < member.length; ++i) {\r\n                        const m = member[i];\r\n                        if (m === \"x\" || m === \"r\") {\r\n                            v.data[0] = value.data[i];\r\n                        } else if (m === \"y\" || m === \"g\") {\r\n                            if (value.data.length < 2) {\r\n                                console.error(`Invalid assignment to ${m} for variable ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                            v.data[1] = value.data[i];\r\n                        } else if (m === \"z\" || m === \"b\") {\r\n                            if (value.data.length < 3) {\r\n                                console.error(`Invalid assignment to ${m} for variable ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                            v.data[2] = value.data[i];\r\n                        } else if (m === \"w\" || m === \"a\") {\r\n                            if (value.data.length < 4) {\r\n                                console.error(`Invalid assignment to ${m} for variable ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                            v.data[3] = value.data[i];\r\n                        } else {\r\n                            console.error(`Invalid assignment to ${m} for variable ${name}. Line ${node.line}`);\r\n                            return;\r\n                        }\r\n                    }\r\n                } else {\r\n                    console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                    return;\r\n                }\r\n            }\r\n        } else {\r\n            if (v instanceof ScalarData && value instanceof ScalarData) {\r\n                v.value = value.value;\r\n            } else if (v instanceof VectorData && value instanceof VectorData) {\r\n                v.data.set(value.data);\r\n            } else if (v instanceof MatrixData && value instanceof MatrixData) {\r\n                v.data.set(value.data);\r\n            } else {\r\n                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n            }\r\n            //v.value = value;\r\n        }\r\n        return;\r\n    }\r\n\r\n    _function(node: Function, context: ExecContext): void {\r\n        const f = new FunctionRef(node);\r\n        context.functions.set(node.name, f);\r\n    }\r\n\r\n    _const(node: Const, context: ExecContext): void {\r\n        let value = null;\r\n        if (node.value !== null) {\r\n            value = this.evalExpression(node.value, context);\r\n        }\r\n        context.createVariable(node.name, value, node);\r\n    }\r\n\r\n    _let(node: Let, context: ExecContext): void {\r\n        let value: Data | null = null;\r\n        if (node.value !== null) {\r\n            value = this.evalExpression(node.value, context);\r\n            if (value === null) {\r\n                console.error(`Invalid value for variable ${node.name}. Line ${node.line}`);\r\n                return;\r\n            }\r\n            if (!(node.value instanceof UnaryOperator)) {\r\n                value = value.clone();\r\n            }\r\n        } else {\r\n            const typeName = node.type.name;\r\n            if (typeName === \"f32\" || typeName === \"i32\" || typeName === \"u32\" ||\r\n                typeName === \"bool\" || typeName === \"f16\" ||\r\n                typeName === \"vec2\" || typeName === \"vec3\" || typeName === \"vec4\" ||\r\n                typeName === \"vec2f\" || typeName === \"vec3f\" || typeName === \"vec4f\" ||\r\n                typeName === \"vec2i\" || typeName === \"vec3i\" || typeName === \"vec4i\" ||\r\n                typeName === \"vec2u\" || typeName === \"vec3u\" || typeName === \"vec4u\" ||\r\n                typeName === \"vec2h\" || typeName === \"vec3h\" || typeName === \"vec4h\" ||\r\n                typeName === \"vec2b\" || typeName === \"vec3b\" || typeName === \"vec4b\" ||\r\n                typeName === \"mat2x2\" || typeName === \"mat2x3\" || typeName === \"mat2x4\" ||\r\n                typeName === \"mat3x2\" || typeName === \"mat3x3\" || typeName === \"mat3x4\" ||\r\n                typeName === \"mat4x2\" || typeName === \"mat4x3\" || typeName === \"mat4x4\" ||\r\n                typeName === \"mat2x2f\" || typeName === \"mat2x3f\" || typeName === \"mat2x4f\" ||\r\n                typeName === \"mat3x2f\" || typeName === \"mat3x3f\" || typeName === \"mat3x4f\" ||\r\n                typeName === \"mat4x2f\" || typeName === \"mat4x3f\" || typeName === \"mat4x4f\" ||\r\n                typeName === \"mat2x2h\" || typeName === \"mat2x3h\" || typeName === \"mat2x4h\" ||\r\n                typeName === \"mat3x2h\" || typeName === \"mat3x3h\" || typeName === \"mat3x4h\" ||\r\n                typeName === \"mat4x2h\" || typeName === \"mat4x3h\" || typeName === \"mat4x4h\" ||\r\n                typeName === \"array\") {\r\n                const defType = new CreateExpr(node.type, []);\r\n                value = this._evalCreate(defType, context);\r\n            }\r\n        }\r\n        context.createVariable(node.name, value, node);\r\n    }\r\n\r\n    _var(node: Var, context: ExecContext): void {\r\n        let value = null;\r\n        if (node.value !== null) {\r\n            value = this.evalExpression(node.value, context);\r\n            if (value === null) {\r\n                console.error(`Invalid value for variable ${node.name}. Line ${node.line}`);\r\n                return;\r\n            }\r\n            if (!(node.value instanceof UnaryOperator)) {\r\n                value = value.clone();\r\n            }\r\n        } else {\r\n            if (node.type === null) {\r\n                console.error(`Variable ${node.name} has no type. Line ${node.line}`);\r\n                return;\r\n            }\r\n\r\n            const typeName = node.type.name;\r\n            if (typeName === \"f32\" || typeName === \"i32\" || typeName === \"u32\" ||\r\n                typeName === \"bool\" || typeName === \"f16\" ||\r\n                typeName === \"vec2\" || typeName === \"vec3\" || typeName === \"vec4\" ||\r\n                typeName === \"vec2f\" || typeName === \"vec3f\" || typeName === \"vec4f\" ||\r\n                typeName === \"vec2i\" || typeName === \"vec3i\" || typeName === \"vec4i\" ||\r\n                typeName === \"vec2u\" || typeName === \"vec3u\" || typeName === \"vec4u\" ||\r\n                typeName === \"vec2h\" || typeName === \"vec3h\" || typeName === \"vec4h\" ||\r\n                typeName === \"vec2b\" || typeName === \"vec3b\" || typeName === \"vec4b\" ||\r\n                typeName === \"mat2x2\" || typeName === \"mat2x3\" || typeName === \"mat2x4\" ||\r\n                typeName === \"mat3x2\" || typeName === \"mat3x3\" || typeName === \"mat3x4\" ||\r\n                typeName === \"mat4x2\" || typeName === \"mat4x3\" || typeName === \"mat4x4\" ||\r\n                typeName === \"mat2x2f\" || typeName === \"mat2x3f\" || typeName === \"mat2x4f\" ||\r\n                typeName === \"mat3x2f\" || typeName === \"mat3x3f\" || typeName === \"mat3x4f\" ||\r\n                typeName === \"mat4x2f\" || typeName === \"mat4x3f\" || typeName === \"mat4x4f\" ||\r\n                typeName === \"mat2x2h\" || typeName === \"mat2x3h\" || typeName === \"mat2x4h\" ||\r\n                typeName === \"mat3x2h\" || typeName === \"mat3x3h\" || typeName === \"mat3x4h\" ||\r\n                typeName === \"mat4x2h\" || typeName === \"mat4x3h\" || typeName === \"mat4x4h\" ||\r\n                node.type instanceof ArrayType || node.type instanceof Struct || node.type instanceof TemplateType) {\r\n                const defType = new CreateExpr(node.type, []);\r\n                value = this._evalCreate(defType, context);\r\n            }\r\n        }\r\n\r\n        context.createVariable(node.name, value, node);\r\n    }\r\n\r\n    _switch(node: Switch, context: ExecContext) : Data | null {\r\n        context = context.clone();\r\n        const condition = this.evalExpression(node.condition, context);\r\n        if (!(condition instanceof ScalarData)) {\r\n            console.error(`Invalid if condition. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        let defaultCase: SwitchCase | null = null;\r\n\r\n        for (const c of node.cases) {\r\n            if (c instanceof Case) {\r\n                for (const selector of c.selectors) {\r\n                    if (selector instanceof DefaultSelector) {\r\n                        defaultCase = c;\r\n                        continue;\r\n                    }\r\n\r\n                    const selectorValue = this.evalExpression(selector, context);\r\n                    if (!(selectorValue instanceof ScalarData)) {\r\n                        console.error(`Invalid case selector. Line ${node.line}`);\r\n                        return null;\r\n                    }\r\n\r\n                    if (selectorValue.value === condition.value) {\r\n                        return this._execStatements(c.body, context);\r\n                    }\r\n                }\r\n            } else if (c instanceof Default) {\r\n                defaultCase = c;\r\n            }\r\n        }\r\n\r\n        if (defaultCase) {\r\n            return this._execStatements(defaultCase.body, context);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _if(node: If, context: ExecContext): Data | null {\r\n        context = context.clone();\r\n        const condition = this.evalExpression(node.condition, context);\r\n        if (!(condition instanceof ScalarData)) {\r\n            console.error(`Invalid if condition. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        if (condition.value) {\r\n            return this._execStatements(node.body, context);\r\n        }\r\n\r\n        for (const e of node.elseif) {\r\n            const condition = this.evalExpression(e.condition, context);\r\n            if (!(condition instanceof ScalarData)) {\r\n                console.error(`Invalid if condition. Line ${node.line}`);\r\n                return null;\r\n            }\r\n            if (condition.value) {\r\n                return this._execStatements(e.body, context);\r\n            }\r\n        }\r\n\r\n        if (node.else) {\r\n            return this._execStatements(node.else, context);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _getScalarValue(v: Data | null): number {\r\n        if (v instanceof ScalarData) {\r\n            return v.value;\r\n        }\r\n        console.error(`Expected scalar value.`, v);\r\n        return 0;\r\n    }\r\n\r\n    _for(node: For, context: ExecContext): Data | null {\r\n        context = context.clone();\r\n        this.execStatement(node.init, context);\r\n        while (this._getScalarValue(this.evalExpression(node.condition, context))) {\r\n            const res = this._execStatements(node.body, context);\r\n            if (res === WgslExec._breakObj) {\r\n                break;\r\n            }\r\n            if (res !== null && res !== WgslExec._continueObj) {\r\n                return res;\r\n            }\r\n            this.execStatement(node.increment, context);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _loop(node: Loop, context: ExecContext): Data | null {\r\n        context = context.clone();\r\n\r\n        while (true) {\r\n            const res = this._execStatements(node.body, context);\r\n            if (res === WgslExec._breakObj) {\r\n                break;\r\n            } else if (res === WgslExec._continueObj) {\r\n                if (node.continuing) {\r\n                    const cres = this._execStatements(node.continuing.body, context);\r\n                    if (cres === WgslExec._breakObj) {\r\n                        break;\r\n                    }\r\n                }\r\n            } else if (res !== null) {\r\n                return res;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _while(node: While, context: ExecContext): Data | null {\r\n        context = context.clone();\r\n        while (this._getScalarValue(this.evalExpression(node.condition, context))) {\r\n            const res = this._execStatements(node.body, context);\r\n            if (res === WgslExec._breakObj) {\r\n                break;\r\n            } else if (res === WgslExec._continueObj) {\r\n                continue;\r\n            } else if (res !== null) {\r\n                return res;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    _evalBitcast(node: BitcastExpr, context: ExecContext): Data | null {\r\n        const value = this.evalExpression(node.value, context);\r\n        const type = node.type;\r\n\r\n        if (value instanceof ScalarData) {\r\n            const v = castScalar(value.value, value.typeInfo.name, type.name);\r\n            return new ScalarData(v, this.getTypeInfo(type));\r\n        }\r\n\r\n        if (value instanceof VectorData) {\r\n            const fromType = value.typeInfo.getTypeName();\r\n            let fromCast = \"\";\r\n            if (fromType.endsWith(\"f\")) {\r\n                fromCast = \"f32\";\r\n            } else if (fromType.endsWith(\"i\")) {\r\n                fromCast = \"i32\";\r\n            } else if (fromType.endsWith(\"u\")) {\r\n                fromCast = \"u32\";\r\n            } else if (fromType.endsWith(\"b\")) {\r\n                fromCast = \"bool\";\r\n            } else if (fromType.endsWith(\"h\")) {\r\n                fromCast = \"f16\";\r\n            } else {\r\n                console.error(`Unknown vector type ${fromType}. Line ${node.line}`);\r\n                return null;\r\n            }\r\n\r\n            const toType = type.getTypeName();\r\n            let toCast = \"\";\r\n            if (toType.endsWith(\"f\")) {\r\n                toCast = \"f32\";\r\n            } else if (toType.endsWith(\"i\")) {\r\n                toCast = \"i32\";\r\n            } else if (toType.endsWith(\"u\")) {\r\n                toCast = \"u32\";\r\n            } else if (toType.endsWith(\"b\")) {\r\n                toCast = \"bool\";\r\n            } else if (toType.endsWith(\"h\")) {\r\n                toCast = \"f16\";\r\n            } else {\r\n                console.error(`Unknown vector type ${toCast}. Line ${node.line}`);\r\n                return null;\r\n            }\r\n\r\n            const v = castVector(Array.from(value.data), fromCast, toCast);\r\n            return new VectorData(v, this.getTypeInfo(type));\r\n        }\r\n\r\n        console.error(`TODO: bitcast for ${value.typeInfo.name}. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    _evalConst(node: ConstExpr, context: ExecContext): Data | null {\r\n        const data = context.getVariableValue(node.name).clone();\r\n        return data.getSubData(this, node.postfix, context);\r\n    }\r\n\r\n    _evalCreate(node: CreateExpr | CallExpr | Call, context: ExecContext): Data | null {\r\n        if (node instanceof CreateExpr) {\r\n            if (node.type === null) {\r\n                return VoidData.void;\r\n            }\r\n\r\n            const typeName = node.type.getTypeName();\r\n\r\n            switch (typeName) {\r\n                // Constructor Built-in Functions\r\n                // Value Constructor Built-in Functions\r\n                case \"bool\":\r\n                case \"i32\":\r\n                case \"u32\":\r\n                case \"f32\":\r\n                case \"f16\":\r\n                    return this._callConstructorValue(node, context);\r\n                case \"vec2\":\r\n                case \"vec3\":\r\n                case \"vec4\":\r\n                case \"vec2f\":\r\n                case \"vec3f\":\r\n                case \"vec4f\":\r\n                case \"vec2h\":\r\n                case \"vec3h\":\r\n                case \"vec4h\":\r\n                case \"vec2i\":\r\n                case \"vec3i\":\r\n                case \"vec4i\":\r\n                case \"vec2u\":\r\n                case \"vec3u\":\r\n                case \"vec4u\":\r\n                case \"vec2b\":\r\n                case \"vec3b\":\r\n                case \"vec4b\":\r\n                    return this._callConstructorVec(node, context);\r\n                case \"mat2x2\":\r\n                case \"mat2x2f\":\r\n                case \"mat2x2h\":\r\n                case \"mat2x3\":\r\n                case \"mat2x3f\":\r\n                case \"mat2x3h\":\r\n                case \"mat2x4\":\r\n                case \"mat2x4f\":\r\n                case \"mat2x4h\":\r\n                case \"mat3x2\":\r\n                case \"mat3x2f\":\r\n                case \"mat3x2h\":\r\n                case \"mat3x3\":\r\n                case \"mat3x3f\":\r\n                case \"mat3x3h\":\r\n                case \"mat3x4\":\r\n                case \"mat3x4f\":\r\n                case \"mat3x4h\":\r\n                case \"mat4x2\":\r\n                case \"mat4x2f\":\r\n                case \"mat4x2h\":\r\n                case \"mat4x3\":\r\n                case \"mat4x3f\":\r\n                case \"mat4x3h\":\r\n                case \"mat4x4\":\r\n                case \"mat4x4f\":\r\n                case \"mat4x4h\":\r\n                    return this._callConstructorMatrix(node, context);\r\n            }\r\n        }\r\n\r\n        const typeName = (node instanceof CreateExpr) ? node.type.name : node.name;\r\n        const typeInfo = (node instanceof CreateExpr) ? this.getTypeInfo(node.type) : this.getTypeInfo(node.name);\r\n        if (typeInfo === null) {\r\n            console.error(`Unknown type ${typeName}. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        if (typeInfo.size === 0) {\r\n            return null;\r\n        }\r\n\r\n        const data = new TypedData(new ArrayBuffer(typeInfo.size), typeInfo, 0);\r\n\r\n        // Assign the values in node.args to the data.\r\n        if (typeInfo instanceof StructInfo) {\r\n            if (node.args) {\r\n                for (let i = 0; i < node.args.length; ++i) {\r\n                    const memberInfo = typeInfo.members[i];\r\n                    const arg = node.args[i];\r\n                    const value = this.evalExpression(arg, context);\r\n                    data.setData(this, value, memberInfo.type, memberInfo.offset, context);\r\n                }\r\n            }\r\n        } else if (typeInfo instanceof ArrayInfo) {\r\n            let offset = 0;\r\n            if (node.args) {\r\n                for (let i = 0; i < node.args.length; ++i) {\r\n                    const arg = node.args[i];\r\n                    const value = this.evalExpression(arg, context);\r\n                    if (typeInfo.format === null) {\r\n                        if (value.typeInfo?.name === \"x32\") {\r\n                            typeInfo.format = this.getTypeInfo(\"i32\");\r\n                        } else {\r\n                            typeInfo.format = value.typeInfo;\r\n                        }\r\n                    }\r\n                    data.setData(this, value, typeInfo.format, offset, context);\r\n                    offset += typeInfo.stride;\r\n                }\r\n            }\r\n        } else {\r\n            console.error(`Unknown type \"${typeName}\". Line ${node.line}`);\r\n        }\r\n\r\n        if (node instanceof CreateExpr) {\r\n            return data.getSubData(this, node.postfix, context);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    _evalLiteral(node: LiteralExpr, context: ExecContext): Data | null {\r\n        const typeInfo = this.getTypeInfo(node.type);\r\n        const typeName = typeInfo.name;\r\n        if (typeName === \"x32\" || typeName === \"u32\" || typeName === \"f32\" || typeName === \"f16\" ||\r\n            typeName === \"i32\" || typeName === \"bool\") {\r\n            const data = new ScalarData(node.scalarValue, typeInfo);\r\n            return data;\r\n        }\r\n        if (typeName === \"vec2\" || typeName === \"vec3\" || typeName === \"vec4\" ||\r\n            typeName === \"vec2f\" || typeName === \"vec3f\" || typeName === \"vec4f\" ||\r\n            typeName === \"vec2h\" || typeName === \"vec3h\" || typeName === \"vec4h\" ||\r\n            typeName === \"vec2i\" || typeName === \"vec3i\" || typeName === \"vec4i\" ||\r\n            typeName === \"vec2u\" || typeName === \"vec3u\" || typeName === \"vec4u\") {\r\n            return this._callConstructorVec(node, context);\r\n        }\r\n        if (typeName === \"mat2x2\" || typeName === \"mat2x3\" || typeName === \"mat2x4\" ||\r\n            typeName === \"mat3x2\" || typeName === \"mat3x3\" || typeName === \"mat3x4\" ||\r\n            typeName === \"mat4x2\" || typeName === \"mat4x3\" || typeName === \"mat4x4\" ||\r\n            typeName === \"mat2x2f\" || typeName === \"mat2x3f\" || typeName === \"mat2x4f\" ||\r\n            typeName === \"mat3x2f\" || typeName === \"mat3x3f\" || typeName === \"mat3x4f\" ||\r\n            typeName === \"mat4x2f\" || typeName === \"mat4x3f\" || typeName === \"mat4x4f\" ||\r\n            typeName === \"mat2x2h\" || typeName === \"mat2x3h\" || typeName === \"mat2x4h\" ||\r\n            typeName === \"mat3x2h\" || typeName === \"mat3x3h\" || typeName === \"mat3x4h\" ||\r\n            typeName === \"mat4x2h\" || typeName === \"mat4x3h\" || typeName === \"mat4x4h\") {\r\n            return this._callConstructorMatrix(node, context);\r\n        }\r\n        return node.value;\r\n    }\r\n\r\n    _evalVariable(node: VariableExpr, context: ExecContext): Data | null {\r\n        const value = context.getVariableValue(node.name);\r\n        if (value === null) {\r\n            return value;\r\n        }\r\n        return value.getSubData(this, node.postfix, context);\r\n    }\r\n\r\n    static _priority = new Map<string, number>([[\"f32\", 0], [\"f16\", 1], [\"u32\", 2], [\"i32\", 3], [\"x32\", 3]]);\r\n    _maxFormatTypeInfo(x: TypeInfo[]): TypeInfo | null {\r\n        let t = x[0];\r\n        if (t.name === \"f32\") {\r\n            return t;\r\n        }\r\n        for (let i = 1; i < x.length; ++i) {\r\n            const tv = WgslExec._priority.get(t.name);\r\n            const xv = WgslExec._priority.get(x[i].name);\r\n            if (xv < tv) {\r\n                t = x[i];\r\n            }\r\n        }\r\n\r\n        if (t.name === \"x32\") {\r\n            return this.getTypeInfo(\"i32\");\r\n        }\r\n\r\n        return t;\r\n    }\r\n\r\n    _evalUnaryOp(node: UnaryOperator, context: ExecContext): Data | null {\r\n        const _r = this.evalExpression(node.right, context);\r\n\r\n        if (node.operator === \"&\") { \r\n            return new PointerData(_r);\r\n        } else if (node.operator === \"*\") {\r\n            if (_r instanceof PointerData) {\r\n                return _r.reference.getSubData(this, node.postfix, context);\r\n            }\r\n            console.error(`Invalid dereference. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        const r = _r instanceof ScalarData ? _r.value : \r\n            _r instanceof VectorData ? Array.from(_r.data) : null;\r\n\r\n        switch (node.operator) {\r\n            case \"+\": {\r\n                if (isArray(r)) {\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => +x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_r.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(+rn, t);\r\n            }\r\n            case \"-\": {\r\n                if (isArray(r)) {\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => -x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_r.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(-rn, t);\r\n            }\r\n            case \"!\": {\r\n                if (isArray(r)) {\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => !x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_r.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(!rn ? 1 : 0, t);\r\n            }\r\n            case \"~\": {\r\n                if (isArray(r)) {\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ~x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_r.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(~rn, t);\r\n            }\r\n        }\r\n        console.error(`Invalid unary operator ${node.operator}. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    _evalBinaryOp(node: BinaryOperator, context: ExecContext): Data | null {\r\n        const _l = this.evalExpression(node.left, context);\r\n        const _r = this.evalExpression(node.right, context);\r\n\r\n        const l = _l instanceof ScalarData ? _l.value : \r\n            _l instanceof VectorData ? Array.from(_l.data) :\r\n            _l instanceof MatrixData ? Array.from(_l.data) : null;\r\n        const r = _r instanceof ScalarData ? _r.value : \r\n            _r instanceof VectorData ? Array.from(_r.data) : \r\n            _r instanceof MatrixData ? Array.from(_r.data) :\r\n            null;\r\n\r\n        switch (node.operator) {\r\n            case \"+\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x + ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x + rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln + x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln + rn, t);\r\n            }\r\n            case \"-\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x - ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x - rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln - x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln - rn, t);\r\n            }\r\n            case \"*\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n\r\n                    if (_l instanceof MatrixData && _r instanceof MatrixData) {\r\n                        const result = matrixMultiply(la, _l.typeInfo, ra, _r.typeInfo);\r\n                        if (result === null) {\r\n                            console.error(`Matrix multiplication failed. Line ${node.line}.`);\r\n                            return null;\r\n                        }\r\n                        const colsB = MatrixTypeSize[_r.typeInfo.name][0];\r\n                        const rowsA = MatrixTypeSize[_l.typeInfo.name][1];\r\n                        const type = this.getTypeInfo(`mat${colsB}x${rowsA}f`);\r\n                        return new MatrixData(result, type);\r\n                    } else if (_l instanceof MatrixData && _r instanceof VectorData) {\r\n                        const result = matrixVectorMultiply(la, _l.typeInfo, ra, _r.typeInfo);\r\n                        if (result === null) {\r\n                            console.error(`Matrix vector multiplication failed. Line ${node.line}.`);\r\n                            return null;\r\n                        }\r\n                        return new VectorData(result, _r.typeInfo);\r\n                    } else if (_l instanceof VectorData && _r instanceof MatrixData) {\r\n                        const result = vectorMatrixMultiply(la, _l.typeInfo, ra, _r.typeInfo);\r\n                        if (result === null) {\r\n                            console.error(`Matrix vector multiplication failed. Line ${node.line}.`);\r\n                            return null;\r\n                        }\r\n                        return new VectorData(result, _l.typeInfo);\r\n                    } else {\r\n                        if (la.length !== ra.length) {\r\n                            console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                            return null;\r\n                        }\r\n                        const result = la.map((x: number, i: number) => x * ra[i]);\r\n                        return new VectorData(result, _l.typeInfo);\r\n                    }\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x * rn);\r\n                    if (_l instanceof MatrixData) {\r\n                        return new MatrixData(result, _l.typeInfo);\r\n                    }\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln * x);\r\n                    if (_r instanceof MatrixData) {\r\n                        return new MatrixData(result, _r.typeInfo);\r\n                    }\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln * rn, t);\r\n            }\r\n            case \"%\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x % ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x % rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln % x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln % rn, t);\r\n            }\r\n            case \"/\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x / ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x / rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln / x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln / rn, t);\r\n            }\r\n            case \"&\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x & ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x & rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln & x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln & rn, t);\r\n            }\r\n            case \"|\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x | ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x | rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln | x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln | rn, t);\r\n            }\r\n            case \"^\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x ^ ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x ^ rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln ^ x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln ^ rn, t);\r\n            }\r\n            case \"<<\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x << ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x << rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln << x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln << rn, t);\r\n            }\r\n            case \">>\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x >> ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x >> rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln >> x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln >> rn, t);\r\n            }\r\n            case \">\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x > ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x > rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln > x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln > rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            }\r\n            case \"<\":\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x < ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x < rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln < x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln < rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            case \"==\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x === ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x == rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln == x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln === rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            }\r\n            case \"!=\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x !== ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x !== rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln !== x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln !== rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            }\r\n            case \">=\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x >= ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x >= rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln >= x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln >= rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            }\r\n            case \"<=\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x <= ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x <= rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln <= x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln <= rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            }\r\n            case \"&&\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x && ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x && rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln && x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln && rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            }\r\n            case \"||\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x || ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x || rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln || x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln || rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            }\r\n        }\r\n        console.error(`Unknown operator ${node.operator}. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    _evalCall(node: CallExpr, context: ExecContext): Data | null {\r\n        if (node.cachedReturnValue !== null) {\r\n            return node.cachedReturnValue;\r\n        }\r\n\r\n        const subContext = context.clone();\r\n        subContext.currentFunctionName = node.name;\r\n\r\n        const f = context.getFunction(node.name);\r\n        if (!f) {\r\n            if (node.isBuiltin) {\r\n                return this._callBuiltinFunction(node, subContext);\r\n            }\r\n\r\n            const typeInfo = this.getTypeInfo(node.name);\r\n            if (typeInfo) {\r\n                return this._evalCreate(node, context);\r\n            }\r\n\r\n            console.error(`Unknown function \"${node.name}\". Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        for (let ai = 0; ai < f.node.args.length; ++ai) {\r\n            const arg = f.node.args[ai];\r\n            const value = this.evalExpression(node.args[ai], subContext);\r\n            subContext.createVariable(arg.name, value, arg);\r\n        }\r\n\r\n        return this._execStatements(f.node.body, subContext);\r\n    }\r\n\r\n    _callBuiltinFunction(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        switch (node.name) {\r\n            // Logical Built-in Functions\r\n            case \"all\":\r\n                return this.builtins.All(node, context);\r\n            case \"any\":\r\n                return this.builtins.Any(node, context);\r\n            case \"select\":\r\n                return this.builtins.Select(node, context);\r\n\r\n            // Array Built-in Functions\r\n            case \"arrayLength\":\r\n                return this.builtins.ArrayLength(node, context);\r\n\r\n            // Numeric Built-in Functions\r\n            case \"abs\":\r\n                return this.builtins.Abs(node, context);\r\n            case \"acos\":\r\n                return this.builtins.Acos(node, context);\r\n            case \"acosh\":\r\n                return this.builtins.Acosh(node, context);\r\n            case \"asin\":\r\n                return this.builtins.Asin(node, context);\r\n            case \"asinh\":\r\n                return this.builtins.Asinh(node, context);\r\n            case \"atan\":\r\n                return this.builtins.Atan(node, context);\r\n            case \"atanh\":\r\n                return this.builtins.Atanh(node, context);\r\n            case \"atan2\":\r\n                return this.builtins.Atan2(node, context);\r\n            case \"ceil\":\r\n                return this.builtins.Ceil(node, context);\r\n            case \"clamp\":\r\n                return this.builtins.Clamp(node, context);\r\n            case \"cos\":\r\n                return this.builtins.Cos(node, context);\r\n            case \"cosh\":\r\n                return this.builtins.Cosh(node, context);\r\n            case \"countLeadingZeros\":\r\n                return this.builtins.CountLeadingZeros(node, context);\r\n            case \"countOneBits\":\r\n                return this.builtins.CountOneBits(node, context);\r\n            case \"countTrailingZeros\":\r\n                return this.builtins.CountTrailingZeros(node, context);\r\n            case \"cross\":\r\n                return this.builtins.Cross(node, context);\r\n            case \"degrees\":\r\n                return this.builtins.Degrees(node, context);\r\n            case \"determinant\":\r\n                return this.builtins.Determinant(node, context);\r\n            case \"distance\":\r\n                return this.builtins.Distance(node, context);\r\n            case \"dot\":\r\n                return this.builtins.Dot(node, context);\r\n            case \"dot4U8Packed\":\r\n                return this.builtins.Dot4U8Packed(node, context);\r\n            case \"dot4I8Packed\":\r\n                return this.builtins.Dot4I8Packed(node, context);\r\n            case \"exp\":\r\n                return this.builtins.Exp(node, context);\r\n            case \"exp2\":\r\n                return this.builtins.Exp2(node, context);\r\n            case \"extractBits\":\r\n                return this.builtins.ExtractBits(node, context);\r\n            case \"faceForward\":\r\n                return this.builtins.FaceForward(node, context);\r\n            case \"firstLeadingBit\":\r\n                return this.builtins.FirstLeadingBit(node, context);\r\n            case \"firstTrailingBit\":\r\n                return this.builtins.FirstTrailingBit(node, context);\r\n            case \"floor\":\r\n                return this.builtins.Floor(node, context);\r\n            case \"fma\":\r\n                return this.builtins.Fma(node, context);\r\n            case \"fract\":\r\n                return this.builtins.Fract(node, context);\r\n            case \"frexp\":\r\n                return this.builtins.Frexp(node, context);\r\n            case \"insertBits\":\r\n                return this.builtins.InsertBits(node, context);\r\n            case \"inverseSqrt\":\r\n                return this.builtins.InverseSqrt(node, context);\r\n            case \"ldexp\":\r\n                return this.builtins.Ldexp(node, context);\r\n            case \"length\":\r\n                return this.builtins.Length(node, context);\r\n            case \"log\":\r\n                return this.builtins.Log(node, context);\r\n            case \"log2\":\r\n                return this.builtins.Log2(node, context);\r\n            case \"max\":\r\n                return this.builtins.Max(node, context);\r\n            case \"min\":\r\n                return this.builtins.Min(node, context);\r\n            case \"mix\":\r\n                return this.builtins.Mix(node, context);\r\n            case \"modf\":\r\n                return this.builtins.Modf(node, context);\r\n            case \"normalize\":\r\n                return this.builtins.Normalize(node, context);\r\n            case \"pow\":\r\n                return this.builtins.Pow(node, context);\r\n            case \"quantizeToF16\":\r\n                return this.builtins.QuantizeToF16(node, context);\r\n            case \"radians\":\r\n                return this.builtins.Radians(node, context);\r\n            case \"reflect\":\r\n                return this.builtins.Reflect(node, context);\r\n            case \"refract\":\r\n                return this.builtins.Refract(node, context);\r\n            case \"reverseBits\":\r\n                return this.builtins.ReverseBits(node, context);\r\n            case \"round\":\r\n                return this.builtins.Round(node, context);\r\n            case \"saturate\":\r\n                return this.builtins.Saturate(node, context);\r\n            case \"sign\":\r\n                return this.builtins.Sign(node, context);\r\n            case \"sin\":\r\n                return this.builtins.Sin(node, context);\r\n            case \"sinh\":\r\n                return this.builtins.Sinh(node, context);\r\n            case \"smoothstep\":\r\n                return this.builtins.SmoothStep(node, context);\r\n            case \"sqrt\":\r\n                return this.builtins.Sqrt(node, context);\r\n            case \"step\":\r\n                return this.builtins.Step(node, context);\r\n            case \"tan\":\r\n                return this.builtins.Tan(node, context);\r\n            case \"tanh\":\r\n                return this.builtins.Tanh(node, context);\r\n            case \"transpose\":\r\n                return this.builtins.Transpose(node, context);\r\n            case \"trunc\":\r\n                return this.builtins.Trunc(node, context);\r\n\r\n            // Derivative Built-in Functions\r\n            case \"dpdx\":\r\n                return this.builtins.Dpdx(node, context);\r\n            case \"dpdxCoarse\":\r\n                return this.builtins.DpdxCoarse(node, context);\r\n            case \"dpdxFine\":\r\n                return this.builtins.DpdxFine(node, context);\r\n            case \"dpdy\":\r\n                return this.builtins.Dpdy(node, context);\r\n            case \"dpdyCoarse\":\r\n                return this.builtins.DpdyCoarse(node, context);\r\n            case \"dpdyFine\":\r\n                return this.builtins.DpdyFine(node, context);\r\n            case \"fwidth\":\r\n                return this.builtins.Fwidth(node, context);\r\n            case \"fwidthCoarse\":\r\n                return this.builtins.FwidthCoarse(node, context);\r\n            case \"fwidthFine\":\r\n                return this.builtins.FwidthFine(node, context);\r\n\r\n            // Texture Built-in Functions\r\n            case \"textureDimensions\":\r\n                return this.builtins.TextureDimensions(node, context);\r\n            case \"textureGather\":\r\n                return this.builtins.TextureGather(node, context);\r\n            case \"textureGatherCompare\":\r\n                return this.builtins.TextureGatherCompare(node, context);\r\n            case \"textureLoad\":\r\n                return this.builtins.TextureLoad(node, context);\r\n            case \"textureNumLayers\":\r\n                return this.builtins.TextureNumLayers(node, context);\r\n            case \"textureNumLevels\":\r\n                return this.builtins.TextureNumLevels(node, context);\r\n            case \"textureNumSamples\":\r\n                return this.builtins.TextureNumSamples(node, context);\r\n            case \"textureSample\":\r\n                return this.builtins.TextureSample(node, context);\r\n            case \"textureSampleBias\":\r\n                return this.builtins.TextureSampleBias(node, context);\r\n            case \"textureSampleCompare\":\r\n                return this.builtins.TextureSampleCompare(node, context);\r\n            case \"textureSampleCompareLevel\":\r\n                return this.builtins.TextureSampleCompareLevel(node, context);\r\n            case \"textureSampleGrad\":\r\n                return this.builtins.TextureSampleGrad(node, context);\r\n            case \"textureSampleLevel\":\r\n                return this.builtins.TextureSampleLevel(node, context);\r\n            case \"textureSampleBaseClampToEdge\":\r\n                return this.builtins.TextureSampleBaseClampToEdge(node, context);\r\n            case \"textureStore\":\r\n                return this.builtins.TextureStore(node, context);\r\n\r\n            // Atomic Built-in Functions\r\n            case \"atomicLoad\":\r\n                return this.builtins.AtomicLoad(node, context);\r\n            case \"atomicStore\":\r\n                return this.builtins.AtomicStore(node, context);\r\n            case \"atomicAdd\":\r\n                return this.builtins.AtomicAdd(node, context);\r\n            case \"atomicSub\":\r\n                return this.builtins.AtomicSub(node, context);\r\n            case \"atomicMax\":\r\n                return this.builtins.AtomicMax(node, context);\r\n            case \"atomicMin\":\r\n                return this.builtins.AtomicMin(node, context);\r\n            case \"atomicAnd\":\r\n                return this.builtins.AtomicAnd(node, context);\r\n            case \"atomicOr\":\r\n                return this.builtins.AtomicOr(node, context);\r\n            case \"atomicXor\":\r\n                return this.builtins.AtomicXor(node, context);\r\n            case \"atomicExchange\":\r\n                return this.builtins.AtomicExchange(node, context);\r\n            case \"atomicCompareExchangeWeak\":\r\n                return this.builtins.AtomicCompareExchangeWeak(node, context);\r\n\r\n            // Data Packing Built-in Functions\r\n            case \"pack4x8snorm\":\r\n                return this.builtins.Pack4x8snorm(node, context);\r\n            case \"pack4x8unorm\":\r\n                return this.builtins.Pack4x8unorm(node, context);\r\n            case \"pack4xI8\":\r\n                return this.builtins.Pack4xI8(node, context);\r\n            case \"pack4xU8\":\r\n                return this.builtins.Pack4xU8(node, context);\r\n            case \"pack4x8Clamp\":\r\n                return this.builtins.Pack4x8Clamp(node, context);\r\n            case \"pack4xU8Clamp\":\r\n                return this.builtins.Pack4xU8Clamp(node, context);\r\n            case \"pack2x16snorm\":\r\n                return this.builtins.Pack2x16snorm(node, context);\r\n            case \"pack2x16unorm\":\r\n                return this.builtins.Pack2x16unorm(node, context);\r\n            case \"pack2x16float\":\r\n                return this.builtins.Pack2x16float(node, context);\r\n\r\n            // Data Unpacking Built-in Functions\r\n            case \"unpack4x8snorm\":\r\n                return this.builtins.Unpack4x8snorm(node, context);\r\n            case \"unpack4x8unorm\":\r\n                return this.builtins.Unpack4x8unorm(node, context);\r\n            case \"unpack4xI8\":\r\n                return this.builtins.Unpack4xI8(node, context);\r\n            case \"unpack4xU8\":\r\n                return this.builtins.Unpack4xU8(node, context);\r\n            case \"unpack2x16snorm\":\r\n                return this.builtins.Unpack2x16snorm(node, context);\r\n            case \"unpack2x16unorm\":\r\n                return this.builtins.Unpack2x16unorm(node, context);\r\n            case \"unpack2x16float\":\r\n                return this.builtins.Unpack2x16float(node, context);\r\n\r\n            // Synchronization Built-in Functions\r\n            case \"storageBarrier\":\r\n                return this.builtins.StorageBarrier(node, context);\r\n            case \"textureBarrier\":\r\n                return this.builtins.TextureBarrier(node, context);\r\n            case \"workgroupBarrier\":\r\n                return this.builtins.WorkgroupBarrier(node, context);\r\n            case \"workgroupUniformLoad\":\r\n                return this.builtins.WorkgroupUniformLoad(node, context);\r\n\r\n            // Subgroup Built-in Functions\r\n            case \"subgroupAdd\":\r\n                return this.builtins.SubgroupAdd(node, context);\r\n            case \"subgroupExclusiveAdd\":\r\n                return this.builtins.SubgroupExclusiveAdd(node, context);\r\n            case \"subgroupInclusiveAdd\":\r\n                return this.builtins.SubgroupInclusiveAdd(node, context);\r\n            case \"subgroupAll\":\r\n                return this.builtins.SubgroupAll(node, context);\r\n            case \"subgroupAnd\":\r\n                return this.builtins.SubgroupAnd(node, context);\r\n            case \"subgroupAny\":\r\n                return this.builtins.SubgroupAny(node, context);\r\n            case \"subgroupBallot\":\r\n                return this.builtins.SubgroupBallot(node, context);\r\n            case \"subgroupBroadcast\":\r\n                return this.builtins.SubgroupBroadcast(node, context);\r\n            case \"subgroupBroadcastFirst\":\r\n                return this.builtins.SubgroupBroadcastFirst(node, context);\r\n            case \"subgroupElect\":\r\n                return this.builtins.SubgroupElect(node, context);\r\n            case \"subgroupMax\":\r\n                return this.builtins.SubgroupMax(node, context);\r\n            case \"subgroupMin\":\r\n                return this.builtins.SubgroupMin(node, context);\r\n            case \"subgroupMul\":\r\n                return this.builtins.SubgroupMul(node, context);\r\n            case \"subgroupExclusiveMul\":\r\n                return this.builtins.SubgroupExclusiveMul(node, context);\r\n            case \"subgroupInclusiveMul\":\r\n                return this.builtins.SubgroupInclusiveMul(node, context);\r\n            case \"subgroupOr\":\r\n                return this.builtins.SubgroupOr(node, context);\r\n            case \"subgroupShuffle\":\r\n                return this.builtins.SubgroupShuffle(node, context);\r\n            case \"subgroupShuffleDown\":\r\n                return this.builtins.SubgroupShuffleDown(node, context);\r\n            case \"subgroupShuffleUp\":\r\n                return this.builtins.SubgroupShuffleUp(node, context);\r\n            case \"subgroupShuffleXor\":\r\n                return this.builtins.SubgroupShuffleXor(node, context);\r\n            case \"subgroupXor\":\r\n                return this.builtins.SubgroupXor(node, context);\r\n\r\n            // Quad Operations\r\n            case \"quadBroadcast\":\r\n                return this.builtins.QuadBroadcast(node, context);\r\n            case \"quadSwapDiagonal\":\r\n                return this.builtins.QuadSwapDiagonal(node, context);\r\n            case \"quadSwapX\":\r\n                return this.builtins.QuadSwapX(node, context);\r\n            case \"quadSwapY\":\r\n                return this.builtins.QuadSwapY(node, context);\r\n        }\r\n\r\n        const f = context.getFunction(node.name);\r\n        if (f) {\r\n            const subContext = context.clone();\r\n            for (let ai = 0; ai < f.node.args.length; ++ai) {\r\n                const arg = f.node.args[ai];\r\n                const value = this.evalExpression(node.args[ai], subContext);\r\n                subContext.setVariable(arg.name, value, arg);\r\n            }\r\n            return this._execStatements(f.node.body, subContext);\r\n        }\r\n\r\n        //console.error(`Function ${node.name} not found. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    _callConstructorValue(node: CreateExpr, context: ExecContext): Data | null {\r\n        if (!node.args || node.args.length === 0) {\r\n            return new ScalarData(0, this.getTypeInfo(node.type));\r\n        }\r\n        const v = this.evalExpression(node.args[0], context);\r\n        v.typeInfo = this.getTypeInfo(node.type);\r\n        return v.getSubData(this, node.postfix, context).clone();\r\n    }\r\n\r\n    _callConstructorVec(node: CreateExpr | LiteralExpr, context: ExecContext): Data | null {\r\n        const typeInfo = this.getTypeInfo(node.type);\r\n        const typeName = node.type.getTypeName();\r\n\r\n        const count = VectorTypeSize[typeName];\r\n        if (count === undefined) {\r\n            console.error(`Invalid vec constructor ${typeName}. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        const values: number[] = [];\r\n        if (node instanceof LiteralExpr) {\r\n            if (node.isVector) {\r\n                const a = node.vectorValue;\r\n                for (const v of a) {\r\n                    values.push(v);\r\n                }\r\n            } else {\r\n                values.push(node.scalarValue);\r\n            }\r\n        } else {\r\n            if (node.args) {\r\n                for (const arg of node.args) {\r\n                    const argValue = this.evalExpression(arg, context) ;\r\n                    if (argValue instanceof VectorData) {\r\n                        const vd = argValue.data;\r\n                        for (let i = 0; i < vd.length; ++i) {\r\n                            let e = vd[i];\r\n                            values.push(e);\r\n                        }\r\n                    } else if (argValue instanceof ScalarData) {\r\n                        let v = argValue.value;\r\n                        values.push(v);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (node.type instanceof TemplateType && node.type.format === null) {\r\n            node.type.format = TemplateType.f32; // TODO: get the format from the type of the arg.\r\n        }\r\n\r\n        if (values.length === 0) {\r\n            const values = new Array(count).fill(0);\r\n            return new VectorData(values, typeInfo).getSubData(this, node.postfix, context);\r\n        }\r\n\r\n        if (values.length === 1) {\r\n            while (values.length < count) {\r\n                values.push(values[0]);\r\n            }\r\n        }\r\n\r\n        if (values.length < count) {\r\n            console.error(`Invalid vec constructor. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        const data = new VectorData(values.length > count ? values.slice(0, count) : values, typeInfo);\r\n        return data.getSubData(this, node.postfix, context);\r\n    }\r\n\r\n    _callConstructorMatrix(node: CreateExpr | LiteralExpr, context: ExecContext): Data | null {\r\n        const typeInfo = this.getTypeInfo(node.type);\r\n        const typeName = node.type.getTypeName();\r\n\r\n        const count = MatrixTypeSize[typeName];\r\n        if (count === undefined) {\r\n            console.error(`Invalid matrix constructor ${typeName}. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        const values = [];\r\n        if (node instanceof LiteralExpr) {\r\n            if (node.isVector) {\r\n                const a = node.vectorValue;\r\n                for (const v of a) {\r\n                    values.push(v);\r\n                }\r\n            } else {\r\n                values.push(node.scalarValue);\r\n            }\r\n        } else {\r\n            if (node.args) {\r\n                for (const arg of node.args) {\r\n                    const argValue = this.evalExpression(arg, context) ;\r\n                    if (argValue instanceof VectorData) {\r\n                        values.push(...argValue.data);\r\n                    } else if (argValue instanceof ScalarData) {\r\n                        values.push(argValue.value);\r\n                    } else if (argValue instanceof MatrixData) {\r\n                        values.push(...argValue.data);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if ((typeInfo instanceof TemplateInfo) && typeInfo.format === null) {\r\n            typeInfo.format = this.getTypeInfo(\"f32\");\r\n        }\r\n\r\n        if (values.length === 0) {\r\n            const values = new Array(count[2]).fill(0);\r\n            return new MatrixData(values, typeInfo).getSubData(this, node.postfix, context);\r\n        }\r\n\r\n        if (values.length !== count[2]) {\r\n            console.error(`Invalid matrix constructor. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        return new MatrixData(values, typeInfo).getSubData(this, node.postfix, context);\r\n    }\r\n}\r\n", "import { Const, Alias, Struct } from \"../wgsl_ast.js\";\r\n\r\nexport class ParseContext {\r\n  constants: Map<string, Const> = new Map();\r\n  aliases: Map<string, Alias> = new Map();\r\n  structs: Map<string, Struct> = new Map();\r\n}\r\n", "import { WgslScanner, Token, TokenType, TokenTypes } from \"./wgsl_scanner.js\";\r\nimport * as AST from \"./wgsl_ast.js\";\r\nimport { WgslExec } from \"./wgsl_exec.js\";\r\nimport { TemplateInfo } from \"./reflect/info.js\";\r\nimport { ScalarData } from \"./wgsl_ast.js\";\r\nimport { ParseContext } from \"./ast/parse_context.js\";\r\n\r\n/// Parse a sequence of tokens from the WgslScanner into an Abstract Syntax Tree (AST).\r\nexport class WgslParser {\r\n  _tokens: Token[] = [];\r\n  _current: number = 0;\r\n  _currentLine: number = 1;\r\n  _deferArrayCountEval: Object[] = [];\r\n  _currentLoop: AST.Statement[] = [];\r\n  _context = new ParseContext();\r\n  _exec = new WgslExec();\r\n  _forwardTypeCount: number = 0;;\r\n\r\n  parse(tokensOrCode: Token[] | string): AST.Statement[] {\r\n    this._initialize(tokensOrCode);\r\n\r\n    this._deferArrayCountEval.length = 0;\r\n\r\n    const statements: AST.Statement[] = [];\r\n    while (!this._isAtEnd()) {\r\n      const statement = this._global_decl_or_directive();\r\n      if (!statement) {\r\n        break;\r\n      }\r\n      statements.push(statement);\r\n    }\r\n\r\n    // Since constants can be declared after they are used, and\r\n    // constants can be used to size arrays, defer calculating the\r\n    // size until after the shader has finished parsing.\r\n    if (this._deferArrayCountEval.length > 0) {\r\n      for (const arrayDecl of this._deferArrayCountEval) {\r\n        const arrayType = arrayDecl[\"arrayType\"];\r\n        const countNode = arrayDecl[\"countNode\"];\r\n\r\n        if (countNode instanceof AST.VariableExpr) {\r\n          const variable = countNode as AST.VariableExpr;\r\n          const name = variable.name;\r\n          const constant = this._context.constants.get(name);\r\n          if (constant) {\r\n            try {\r\n              const count = constant.constEvaluate(this._exec);\r\n              arrayType.count = count;\r\n            } catch (e) {\r\n            }\r\n          }\r\n        }\r\n      }\r\n      this._deferArrayCountEval.length = 0;\r\n    }\r\n\r\n    if (this._forwardTypeCount > 0) {\r\n      for (const statement of statements) {\r\n        statement.search((node) => {\r\n          if (node instanceof AST.Member) {\r\n            node.type = this._forwardType(node.type);\r\n          } else if (node instanceof AST.PointerType) {\r\n            node.type = this._forwardType(node.type);\r\n          } else if (node instanceof AST.ArrayType) {\r\n            node.format = this._forwardType(node.format);\r\n          } else if (node instanceof AST.Var || node instanceof AST.Let || node instanceof AST.Const) {\r\n            node.type = this._forwardType(node.type);\r\n          } else if (node instanceof AST.Function) {\r\n            node.returnType = this._forwardType(node.returnType);\r\n          } else if (node instanceof AST.Argument) {\r\n            node.type = this._forwardType(node.type);\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    return statements;\r\n  }\r\n\r\n  _forwardType(t: AST.Type | null): AST.Type | null {\r\n    if (t instanceof AST.ForwardType) {\r\n      const ft = this._getType(t.name);\r\n      if (ft) {\r\n        return ft;\r\n      }\r\n    } else if (t instanceof AST.PointerType) {\r\n      t.type = this._forwardType(t.type);\r\n    } else if (t instanceof AST.ArrayType) {\r\n      t.format = this._forwardType(t.format);\r\n    }\r\n    return t;\r\n  }\r\n\r\n  _initialize(tokensOrCode: Token[] | string) {\r\n    if (tokensOrCode) {\r\n      if (typeof tokensOrCode == \"string\") {\r\n        const scanner = new WgslScanner(tokensOrCode);\r\n        this._tokens = scanner.scanTokens();\r\n      } else {\r\n        this._tokens = tokensOrCode;\r\n      }\r\n    } else {\r\n      this._tokens = [];\r\n    }\r\n    this._current = 0;\r\n  }\r\n\r\n  _updateNode<T extends AST.Node>(n: T, l?: number): T {\r\n    n.line = l ?? this._currentLine;\r\n    return n;\r\n  }\r\n\r\n  _error(token: Token, message: string | null): Object {\r\n    return {\r\n      token,\r\n      message,\r\n      toString: function () {\r\n        return `${message}`;\r\n      },\r\n    };\r\n  }\r\n\r\n  _isAtEnd(): boolean {\r\n    return (\r\n      this._current >= this._tokens.length ||\r\n      this._peek().type == TokenTypes.eof\r\n    );\r\n  }\r\n\r\n  _match(types: TokenType | TokenType[]): boolean {\r\n    if (types instanceof TokenType) {\r\n      if (this._check(types)) {\r\n        this._advance();\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    for (let i = 0, l = types.length; i < l; ++i) {\r\n      const type = types[i];\r\n      if (this._check(type)) {\r\n        this._advance();\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  _consume(types: TokenType | TokenType[], message: string | null): Token {\r\n    if (this._check(types)) {\r\n      return this._advance();\r\n    }\r\n    throw this._error(this._peek(), `${message}. Line:${this._currentLine}`);\r\n  }\r\n\r\n  _check(types: TokenType | TokenType[]): boolean {\r\n    if (this._isAtEnd()) {\r\n      return false;\r\n    }\r\n    const tk = this._peek();\r\n    if (types instanceof Array) {\r\n      const t = tk.type;\r\n      let hasNameType = false;\r\n      for (const type of types) {\r\n        if (t === type) {\r\n          return true;\r\n        }\r\n        if (type === TokenTypes.tokens.name) {\r\n          hasNameType =  true;\r\n        }\r\n      }\r\n      if (hasNameType) {\r\n        // ident can include any of the other keywords, so special case it.\r\n        const match = (TokenTypes.tokens.name.rule as RegExp).exec(tk.lexeme);\r\n        if (match && match.index == 0 && match[0] == tk.lexeme) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    if (tk.type === types) {\r\n      return true;\r\n    }\r\n\r\n    // ident can include any of the other keywords, so special case it.\r\n    if (types === TokenTypes.tokens.name) {\r\n      const match = (TokenTypes.tokens.name.rule as RegExp).exec(tk.lexeme);\r\n      return match && match.index == 0 && match[0] == tk.lexeme;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  _advance(): Token {\r\n    this._currentLine = this._peek()?.line ?? -1;\r\n    if (!this._isAtEnd()) {\r\n      this._current++;\r\n    }\r\n    return this._previous();\r\n  }\r\n\r\n  _peek(): Token {\r\n    return this._tokens[this._current];\r\n  }\r\n\r\n  _previous(): Token {\r\n    return this._tokens[this._current - 1];\r\n  }\r\n\r\n  _global_decl_or_directive(): AST.Statement | null {\r\n    // semicolon\r\n    // global_variable_decl semicolon\r\n    // global_constant_decl semicolon\r\n    // type_alias semicolon\r\n    // struct_decl\r\n    // function_decl\r\n    // enable_directive\r\n\r\n    // Ignore any stand-alone semicolons\r\n    while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd());\r\n\r\n    if (this._match(TokenTypes.keywords.alias)) {\r\n      const type = this._type_alias();\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\r\n      this._exec.reflection.updateAST([type]);\r\n      return type;\r\n    }\r\n\r\n    if (this._match(TokenTypes.keywords.diagnostic)) {\r\n      const directive = this._diagnostic();\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\r\n      this._exec.reflection.updateAST([directive]);\r\n      return directive;\r\n    }\r\n\r\n    if (this._match(TokenTypes.keywords.requires)) {\r\n      const requires = this._requires_directive();\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\r\n      this._exec.reflection.updateAST([requires]);\r\n      return requires;\r\n    }\r\n\r\n    if (this._match(TokenTypes.keywords.enable)) {\r\n      const enable = this._enable_directive();\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\r\n      this._exec.reflection.updateAST([enable]);\r\n      return enable;\r\n    }\r\n\r\n    // The following statements have an optional attribute*\r\n    const attrs = this._attribute();\r\n\r\n    if (this._check(TokenTypes.keywords.var)) {\r\n      const _var = this._global_variable_decl();\r\n      if (_var != null) {\r\n        _var.attributes = attrs;\r\n      }\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\r\n      this._exec.reflection.updateAST([_var]);\r\n      return _var;\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.override)) {\r\n      const _override = this._override_variable_decl();\r\n      if (_override != null) {\r\n        _override.attributes = attrs;\r\n      }\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\r\n      this._exec.reflection.updateAST([_override]);\r\n      return _override;\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.let)) {\r\n      const _let = this._global_let_decl();\r\n      if (_let != null) {\r\n        _let.attributes = attrs;\r\n      }\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\r\n      this._exec.reflection.updateAST([_let]);\r\n      return _let;\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.const)) {\r\n      const _const = this._global_const_decl();\r\n      if (_const != null) {\r\n        _const.attributes = attrs;\r\n      }\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\r\n      this._exec.reflection.updateAST([_const]);\r\n      return _const;\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.struct)) {\r\n      const _struct = this._struct_decl();\r\n      if (_struct != null) {\r\n        _struct.attributes = attrs;\r\n      }\r\n      this._exec.reflection.updateAST([_struct]);\r\n      return _struct;\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.fn)) {\r\n      const _fn = this._function_decl();\r\n      if (_fn != null) {\r\n        _fn.attributes = attrs;\r\n      }\r\n      this._exec.reflection.updateAST([_fn]);\r\n      return _fn;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _function_decl(): AST.Function | null {\r\n    // attribute* function_header compound_statement\r\n    // function_header: fn ident paren_left param_list? paren_right (arrow attribute* type_decl)?\r\n    if (!this._match(TokenTypes.keywords.fn)) {\r\n      return null;\r\n    }\r\n\r\n    const startLine = this._currentLine;\r\n\r\n    const name = this._consume(\r\n      TokenTypes.tokens.ident,\r\n      \"Expected function name.\"\r\n    ).toString();\r\n\r\n    this._consume(\r\n      TokenTypes.tokens.paren_left,\r\n      \"Expected '(' for function arguments.\"\r\n    );\r\n\r\n    const args: AST.Argument[] = [];\r\n    if (!this._check(TokenTypes.tokens.paren_right)) {\r\n      do {\r\n        if (this._check(TokenTypes.tokens.paren_right)) {\r\n          break;\r\n        }\r\n        const argAttrs = this._attribute();\r\n\r\n        const name = this._consume(\r\n          TokenTypes.tokens.name,\r\n          \"Expected argument name.\"\r\n        ).toString();\r\n\r\n        this._consume(\r\n          TokenTypes.tokens.colon,\r\n          \"Expected ':' for argument type.\"\r\n        );\r\n\r\n        const typeAttrs = this._attribute();\r\n        const type = this._type_decl();\r\n        if (type != null) {\r\n          type.attributes = typeAttrs;\r\n\r\n          args.push(this._updateNode(new AST.Argument(name, type, argAttrs)));\r\n        }\r\n      } while (this._match(TokenTypes.tokens.comma));\r\n    }\r\n\r\n    this._consume(\r\n      TokenTypes.tokens.paren_right,\r\n      \"Expected ')' after function arguments.\"\r\n    );\r\n\r\n    let _return: AST.Type | null = null;\r\n    if (this._match(TokenTypes.tokens.arrow)) {\r\n      const attrs = this._attribute();\r\n      _return = this._type_decl();\r\n      if (_return != null) {\r\n        _return.attributes = attrs;\r\n      }\r\n    }\r\n\r\n    const body = this._compound_statement();\r\n\r\n    const endLine = this._currentLine;\r\n\r\n    return this._updateNode(new AST.Function(name, args, _return, body, startLine, endLine), startLine);\r\n  }\r\n\r\n  _compound_statement(): AST.Statement[] {\r\n    // brace_left statement* brace_right\r\n    const statements: AST.Statement[] = [];\r\n\r\n    this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for block.\");\r\n    while (!this._check(TokenTypes.tokens.brace_right)) {\r\n      const statement = this._statement();\r\n      if (statement !== null) {\r\n        statements.push(statement as AST.Statement);\r\n      }\r\n    }\r\n    this._consume(TokenTypes.tokens.brace_right, \"Expected '}' for block.\");\r\n\r\n    return statements;\r\n  }\r\n\r\n  _statement(): AST.Statement | AST.Statement[] | null {\r\n    // semicolon\r\n    // return_statement semicolon\r\n    // if_statement\r\n    // switch_statement\r\n    // loop_statement\r\n    // for_statement\r\n    // func_call_statement semicolon\r\n    // variable_statement semicolon\r\n    // break_statement semicolon\r\n    // continue_statement semicolon\r\n    // continuing_statement compound_statement\r\n    // discard semicolon\r\n    // assignment_statement semicolon\r\n    // compound_statement\r\n    // increment_statement semicolon\r\n    // decrement_statement semicolon\r\n    // static_assert_statement semicolon\r\n\r\n    // Ignore any stand-alone semicolons\r\n    while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd());\r\n\r\n    let attributes = null;\r\n    if (this._check(TokenTypes.tokens.attr)) {\r\n      attributes = this._attribute();\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.if)) {\r\n      return this._if_statement();\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.switch)) {\r\n      return this._switch_statement();\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.loop)) {\r\n      return this._loop_statement();\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.for)) {\r\n      return this._for_statement();\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.while)) {\r\n      return this._while_statement();\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.continuing)) {\r\n      return this._continuing_statement();\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.static_assert)) {\r\n      return this._static_assert_statement();\r\n    }\r\n\r\n    if (this._check(TokenTypes.tokens.brace_left)) {\r\n      return this._compound_statement();\r\n    }\r\n\r\n    let result: AST.Statement | null = null;\r\n    if (this._check(TokenTypes.keywords.return)) {\r\n      result = this._return_statement();\r\n    } else if (this._check([TokenTypes.keywords.var, TokenTypes.keywords.let, TokenTypes.keywords.const])) {\r\n      result = this._variable_statement();\r\n    } else if (this._match(TokenTypes.keywords.discard)) {\r\n      result = this._updateNode(new AST.Discard());\r\n    } else if (this._match(TokenTypes.keywords.break)) {\r\n      const breakStmt = this._updateNode(new AST.Break());\r\n      if (this._currentLoop.length > 0) {\r\n        const loop = this._currentLoop[this._currentLoop.length - 1];\r\n        breakStmt.loopId = loop.id;\r\n      } else {\r\n        // This break statement is not inside a loop.\r\n        //throw this._error(this._peek(), `Break statement must be inside a loop. Line: ${breakStmt.line}`);\r\n      }\r\n      result = breakStmt;\r\n      if (this._check(TokenTypes.keywords.if)) {\r\n        // break-if\r\n        this._advance();\r\n        breakStmt.condition = this._optional_paren_expression();\r\n      }\r\n    } else if (this._match(TokenTypes.keywords.continue)) {\r\n      const continueStmt = this._updateNode(new AST.Continue());\r\n      if (this._currentLoop.length > 0) {\r\n        const loop = this._currentLoop[this._currentLoop.length - 1];\r\n        continueStmt.loopId = loop.id;\r\n      } else {\r\n        // This continue statement is not inside a loop.\r\n        throw this._error(this._peek(), `Continue statement must be inside a loop. Line: ${continueStmt.line}`);\r\n      }\r\n      result = continueStmt;\r\n    } else {\r\n      result =\r\n        this._increment_decrement_statement() ||\r\n        this._func_call_statement() ||\r\n        this._assignment_statement();\r\n    }\r\n\r\n    if (result != null) {\r\n      this._consume(\r\n        TokenTypes.tokens.semicolon,\r\n        \"Expected ';' after statement.\"\r\n      );\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  _static_assert_statement(): AST.StaticAssert | null {\r\n    if (!this._match(TokenTypes.keywords.static_assert)) {\r\n      return null;\r\n    }\r\n    const line = this._currentLine;\r\n    const expression = this._optional_paren_expression();\r\n    return this._updateNode(new AST.StaticAssert(expression), line);\r\n  }\r\n\r\n  _while_statement(): AST.While | null {\r\n    if (!this._match(TokenTypes.keywords.while)) {\r\n      return null;\r\n    }\r\n\r\n    const whileLoop = this._updateNode(new AST.While(null, null));\r\n    this._currentLoop.push(whileLoop);\r\n\r\n    whileLoop.condition = this._optional_paren_expression();\r\n\r\n    let attributes = null;\r\n    if (this._check(TokenTypes.tokens.attr)) {\r\n      attributes = this._attribute();\r\n    }\r\n\r\n    whileLoop.body = this._compound_statement();\r\n\r\n    this._currentLoop.pop();\r\n\r\n    return whileLoop;\r\n  }\r\n\r\n  _continuing_statement(): AST.Continuing | null {\r\n    const loopId = this._currentLoop.length > 0 ? this._currentLoop[this._currentLoop.length - 1].id : -1;\r\n    if (!this._match(TokenTypes.keywords.continuing)) {\r\n      return null;\r\n    }\r\n    const line = this._currentLine;\r\n    const block = this._compound_statement();\r\n    return this._updateNode(new AST.Continuing(block, loopId), line);\r\n  }\r\n\r\n  _for_statement(): AST.For | null {\r\n    // for paren_left for_header paren_right compound_statement\r\n    if (!this._match(TokenTypes.keywords.for)) {\r\n      return null;\r\n    }\r\n\r\n    this._consume(TokenTypes.tokens.paren_left, \"Expected '('.\");\r\n\r\n    const forLoop = this._updateNode(new AST.For(null, null, null, null));\r\n\r\n    this._currentLoop.push(forLoop);\r\n\r\n    // for_header: (variable_statement assignment_statement func_call_statement)? semicolon short_circuit_or_expression? semicolon (assignment_statement func_call_statement)?\r\n    forLoop.init = !this._check(TokenTypes.tokens.semicolon)\r\n      ? this._for_init()\r\n      : null;\r\n    this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\r\n    forLoop.condition = !this._check(TokenTypes.tokens.semicolon)\r\n      ? this._short_circuit_or_expression()\r\n      : null;\r\n    this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\r\n    forLoop.increment = !this._check(TokenTypes.tokens.paren_right)\r\n      ? this._for_increment()\r\n      : null;\r\n\r\n    this._consume(TokenTypes.tokens.paren_right, \"Expected ')'.\");\r\n\r\n    let attributes = null;\r\n    if (this._check(TokenTypes.tokens.attr)) {\r\n      attributes = this._attribute();\r\n    }\r\n\r\n    forLoop.body = this._compound_statement();\r\n\r\n    this._currentLoop.pop();\r\n\r\n    return forLoop;\r\n  }\r\n\r\n  _for_init(): AST.Statement | null {\r\n    // (variable_statement assignment_statement func_call_statement)?\r\n    return (\r\n      this._variable_statement() ||\r\n      this._func_call_statement() ||\r\n      this._assignment_statement()\r\n    );\r\n  }\r\n\r\n  _for_increment(): AST.Statement | null {\r\n    // (assignment_statement func_call_statement increment_statement)?\r\n    return (\r\n      this._func_call_statement() ||\r\n      this._increment_decrement_statement() ||\r\n      this._assignment_statement()\r\n    );\r\n  }\r\n\r\n  _variable_statement(): AST.Var | AST.Let | AST.Const | null {\r\n    // variable_decl\r\n    // variable_decl equal short_circuit_or_expression\r\n    // let (ident variable_ident_decl) equal short_circuit_or_expression\r\n    // const (ident variable_ident_decl) equal short_circuit_or_expression\r\n    if (this._check(TokenTypes.keywords.var)) {\r\n      const _var = this._variable_decl();\r\n      if (_var === null) {\r\n        throw this._error(this._peek(), \"Variable declaration expected.\");\r\n      }\r\n      let value: AST.Expression | null = null;\r\n      if (this._match(TokenTypes.tokens.equal)) {\r\n        value = this._short_circuit_or_expression();\r\n      }\r\n\r\n      return this._updateNode(new AST.Var(\r\n        _var.name,\r\n        _var.type,\r\n        _var.storage,\r\n        _var.access,\r\n        value\r\n      ), _var.line);\r\n    }\r\n\r\n    if (this._match(TokenTypes.keywords.let)) {\r\n      const line = this._currentLine;\r\n      const name = this._consume(\r\n        TokenTypes.tokens.name,\r\n        \"Expected name for let.\"\r\n      ).toString();\r\n      let type: AST.Type | null = null;\r\n      if (this._match(TokenTypes.tokens.colon)) {\r\n        const typeAttrs = this._attribute();\r\n        type = this._type_decl();\r\n        if (type != null) {\r\n          type.attributes = typeAttrs;\r\n        }\r\n      }\r\n      this._consume(TokenTypes.tokens.equal, \"Expected '=' for let.\");\r\n      const value = this._short_circuit_or_expression();\r\n      return this._updateNode(new AST.Let(name, type, null, null, value), line);\r\n    }\r\n\r\n    if (this._match(TokenTypes.keywords.const)) {\r\n      const line = this._currentLine;\r\n      const name = this._consume(\r\n        TokenTypes.tokens.name,\r\n        \"Expected name for const.\"\r\n      ).toString();\r\n      let type: AST.Type | null = null;\r\n      if (this._match(TokenTypes.tokens.colon)) {\r\n        const typeAttrs = this._attribute();\r\n        type = this._type_decl();\r\n        if (type != null) {\r\n          type.attributes = typeAttrs;\r\n        }\r\n      }\r\n      this._consume(TokenTypes.tokens.equal, \"Expected '=' for const.\");\r\n      const value = this._short_circuit_or_expression();\r\n      if (type === null && value instanceof AST.LiteralExpr) {\r\n        type = value.type;\r\n      }\r\n      return this._updateNode(new AST.Const(name, type, null, null, value), line);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _increment_decrement_statement(): AST.Statement | null {\r\n    const savedPos = this._current;\r\n\r\n    const _var = this._unary_expression();\r\n    if (_var == null) {\r\n      return null;\r\n    }\r\n\r\n    if (!this._check(TokenTypes.increment_operators)) {\r\n      this._current = savedPos;\r\n      return null;\r\n    }\r\n\r\n    const token = this._consume(\r\n      TokenTypes.increment_operators,\r\n      \"Expected increment operator\"\r\n    );\r\n\r\n    return this._updateNode(new AST.Increment(\r\n      token.type === TokenTypes.tokens.plus_plus\r\n        ? AST.IncrementOperator.increment\r\n        : AST.IncrementOperator.decrement,\r\n      _var));\r\n  }\r\n\r\n  _assignment_statement(): AST.Assign | null {\r\n    // (unary_expression underscore) equal short_circuit_or_expression\r\n    let _var: AST.Expression | null = null;\r\n    const line = this._currentLine;\r\n\r\n    if (this._check(TokenTypes.tokens.brace_right)) {\r\n      return null;\r\n    }\r\n\r\n    let isUnderscore = this._match(TokenTypes.tokens.underscore);\r\n    if (!isUnderscore) {\r\n      _var = this._unary_expression();\r\n    }\r\n\r\n    if (!isUnderscore && _var == null) {\r\n      return null;\r\n    }\r\n\r\n    const type = this._consume(\r\n      TokenTypes.assignment_operators,\r\n      \"Expected assignment operator.\");\r\n\r\n    const value = this._short_circuit_or_expression();\r\n\r\n    return this._updateNode(new AST.Assign(\r\n      AST.AssignOperator.parse(type.lexeme),\r\n      _var as AST.Expression,\r\n      value), line);\r\n  }\r\n\r\n  _func_call_statement(): AST.Call | null {\r\n    // ident argument_expression_list\r\n    if (!this._check(TokenTypes.tokens.ident)) {\r\n      return null;\r\n    }\r\n\r\n    const line = this._currentLine;\r\n\r\n    const savedPos = this._current;\r\n    const name = this._consume(\r\n      TokenTypes.tokens.ident,\r\n      \"Expected function name.\"\r\n    );\r\n    const args = this._argument_expression_list();\r\n\r\n    if (args === null) {\r\n      this._current = savedPos;\r\n      return null;\r\n    }\r\n\r\n    return this._updateNode(new AST.Call(name.lexeme, args), line);\r\n  }\r\n\r\n  _loop_statement(): AST.Loop | null {\r\n    // loop brace_left statement* continuing_statement? brace_right\r\n    if (!this._match(TokenTypes.keywords.loop)) {\r\n      return null;\r\n    }\r\n\r\n    let attributes = null;\r\n    if (this._check(TokenTypes.tokens.attr)) {\r\n      attributes = this._attribute();\r\n    }\r\n\r\n    this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for loop.\");\r\n\r\n    const loop = this._updateNode(new AST.Loop([], null));\r\n    this._currentLoop.push(loop);\r\n\r\n    // statement*\r\n    let statement = this._statement();\r\n    while (statement !== null) {\r\n      if (Array.isArray(statement)) {\r\n        for (let s of statement) {\r\n          loop.body.push(s);\r\n        }\r\n      } else {\r\n        loop.body.push(statement);\r\n      }\r\n      // Keep continuing in the loop body statements so it can be\r\n      // executed in the stackframe of the body statements.\r\n      if (statement instanceof AST.Continuing) {\r\n        loop.continuing = statement;\r\n        // Continuing should be the last statement in the loop.\r\n        break;\r\n      }\r\n      statement = this._statement();\r\n    }\r\n\r\n    this._currentLoop.pop();\r\n\r\n    this._consume(TokenTypes.tokens.brace_right, \"Expected '}' for loop.\");\r\n\r\n    return loop;\r\n  }\r\n\r\n  _switch_statement(): AST.Switch | null {\r\n    // switch optional_paren_expression brace_left switch_body+ brace_right\r\n    if (!this._match(TokenTypes.keywords.switch)) {\r\n      return null;\r\n    }\r\n\r\n    const switchStmt = this._updateNode(new AST.Switch(null, []));\r\n\r\n    this._currentLoop.push(switchStmt);\r\n\r\n    switchStmt.condition = this._optional_paren_expression();\r\n\r\n    let attributes = null;\r\n    if (this._check(TokenTypes.tokens.attr)) {\r\n      attributes = this._attribute();\r\n    }\r\n\r\n    this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for switch.\");\r\n    switchStmt.cases = this._switch_body();\r\n    if (switchStmt.cases == null || switchStmt.cases.length == 0) {\r\n      throw this._error(this._previous(), \"Expected 'case' or 'default'.\");\r\n    }\r\n    this._consume(TokenTypes.tokens.brace_right, \"Expected '}' for switch.\");\r\n\r\n    this._currentLoop.pop();\r\n\r\n    return switchStmt;\r\n  }\r\n\r\n  _switch_body(): AST.SwitchCase[] {\r\n    // case case_selectors optional_colon brace_left case_body? brace_right\r\n    // default optional_colon brace_left case_body? brace_right\r\n    const cases: AST.SwitchCase[] = [];\r\n\r\n    let hasDefault = false;\r\n    while (this._check([TokenTypes.keywords.default, TokenTypes.keywords.case])) {\r\n      if (this._match(TokenTypes.keywords.case)) {\r\n        const selectors = this._case_selectors();\r\n        for (const selector of selectors) {\r\n          if (selector instanceof AST.DefaultSelector) {\r\n            if (hasDefault) {\r\n              throw this._error(this._previous(), \"Multiple default cases in switch statement.\");\r\n            }\r\n            hasDefault = true;\r\n            break;\r\n          }\r\n        }\r\n\r\n        this._match(TokenTypes.tokens.colon); // colon is optional\r\n\r\n        let attributes = null;\r\n        if (this._check(TokenTypes.tokens.attr)) {\r\n          attributes = this._attribute();\r\n        }\r\n\r\n        this._consume(TokenTypes.tokens.brace_left, \"Exected '{' for switch case.\");\r\n\r\n        const body = this._case_body();\r\n\r\n        this._consume(TokenTypes.tokens.brace_right, \"Exected '}' for switch case.\");\r\n\r\n        cases.push(this._updateNode(new AST.Case(selectors, body)));\r\n      }\r\n\r\n      if (this._match(TokenTypes.keywords.default)) {\r\n        if (hasDefault) {\r\n          throw this._error(this._previous(), \"Multiple default cases in switch statement.\");\r\n        }\r\n        this._match(TokenTypes.tokens.colon); // colon is optional\r\n\r\n        let attributes = null;\r\n        if (this._check(TokenTypes.tokens.attr)) {\r\n          attributes = this._attribute();\r\n        }\r\n\r\n        this._consume(TokenTypes.tokens.brace_left, \"Exected '{' for switch default.\");\r\n\r\n        const body = this._case_body();\r\n\r\n        this._consume(TokenTypes.tokens.brace_right, \"Exected '}' for switch default.\");\r\n\r\n        cases.push(this._updateNode(new AST.Default(body)));\r\n      }\r\n    }\r\n\r\n    return cases;\r\n  }\r\n\r\n  _case_selectors(): AST.Expression[] {\r\n    // case_selector (comma case_selector)* comma?\r\n    // case_selector: expression | default\r\n    const selectors = [];\r\n\r\n    if (this._match(TokenTypes.keywords.default)) {\r\n      selectors.push(this._updateNode(new AST.DefaultSelector()));\r\n    } else {\r\n      selectors.push(this._shift_expression());\r\n    }\r\n\r\n    while (this._match(TokenTypes.tokens.comma)) {\r\n      if (this._match(TokenTypes.keywords.default)) {\r\n        selectors.push(this._updateNode(new AST.DefaultSelector()));\r\n      } else {\r\n        selectors.push(this._shift_expression());\r\n      }\r\n    }\r\n\r\n    return selectors;\r\n  }\r\n\r\n  _case_body(): AST.Statement[] {\r\n    // statement case_body?\r\n    // fallthrough semicolon\r\n    if (this._match(TokenTypes.keywords.fallthrough)) {\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\r\n      return [];\r\n    }\r\n\r\n    let statement = this._statement();\r\n    if (statement == null) {\r\n      return [];\r\n    }\r\n\r\n    if (!(statement instanceof Array)) {\r\n      statement = [statement];\r\n    }\r\n\r\n    const nextStatement = this._case_body();\r\n    if (nextStatement.length == 0) {\r\n      return statement;\r\n    }\r\n\r\n    return [...statement, nextStatement[0]];\r\n  }\r\n\r\n  _if_statement(): AST.If | null {\r\n    // if optional_paren_expression compound_statement elseif_statement? else_statement?\r\n    if (!this._match(TokenTypes.keywords.if)) {\r\n      return null;\r\n    }\r\n\r\n    const line = this._currentLine;\r\n\r\n    const condition = this._optional_paren_expression();\r\n\r\n    let attributes = null;\r\n    if (this._check(TokenTypes.tokens.attr)) {\r\n      attributes = this._attribute();\r\n    }\r\n\r\n    const block = this._compound_statement();\r\n\r\n    let elseif: AST.ElseIf[] | null = [];\r\n    if (this._match_elseif()) {\r\n      let attributes = null;\r\n      if (this._check(TokenTypes.tokens.attr)) {\r\n        attributes = this._attribute();\r\n      }\r\n      elseif = this._elseif_statement(elseif);\r\n    }\r\n\r\n    let _else: AST.Statement[] | null = null;\r\n    if (this._match(TokenTypes.keywords.else)) {\r\n      let attributes = null;\r\n      if (this._check(TokenTypes.tokens.attr)) {\r\n        attributes = this._attribute();\r\n      }\r\n      _else = this._compound_statement();\r\n    }\r\n\r\n    return this._updateNode(new AST.If(condition, block, elseif, _else), line);\r\n  }\r\n\r\n  _match_elseif(): boolean {\r\n    if (this._tokens[this._current].type === TokenTypes.keywords.else &&\r\n      this._tokens[this._current + 1].type === TokenTypes.keywords.if) {\r\n      this._advance();\r\n      this._advance();\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  _elseif_statement(elseif: AST.ElseIf[] = []): AST.ElseIf[] {\r\n    // else_if optional_paren_expression compound_statement elseif_statement?\r\n    const condition = this._optional_paren_expression();\r\n    const block = this._compound_statement();\r\n    elseif.push(this._updateNode(new AST.ElseIf(condition, block)));\r\n    if (this._match_elseif()) {\r\n      let attributes = null;\r\n      if (this._check(TokenTypes.tokens.attr)) {\r\n        attributes = this._attribute();\r\n      }\r\n      this._elseif_statement(elseif);\r\n    }\r\n    return elseif;\r\n  }\r\n\r\n  _return_statement(): AST.Return | null {\r\n    // return short_circuit_or_expression?\r\n    if (!this._match(TokenTypes.keywords.return)) {\r\n      return null;\r\n    }\r\n    const value = this._short_circuit_or_expression();\r\n    return this._updateNode(new AST.Return(value));\r\n  }\r\n\r\n  _short_circuit_or_expression(): AST.Expression {\r\n    // short_circuit_and_expression\r\n    // short_circuit_or_expression or_or short_circuit_and_expression\r\n    let expr = this._short_circuit_and_expr();\r\n    while (this._match(TokenTypes.tokens.or_or)) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._short_circuit_and_expr()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _short_circuit_and_expr(): AST.Expression {\r\n    // inclusive_or_expression\r\n    // short_circuit_and_expression and_and inclusive_or_expression\r\n    let expr = this._inclusive_or_expression();\r\n    while (this._match(TokenTypes.tokens.and_and)) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._inclusive_or_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _inclusive_or_expression(): AST.Expression {\r\n    // exclusive_or_expression\r\n    // inclusive_or_expression or exclusive_or_expression\r\n    let expr = this._exclusive_or_expression();\r\n    while (this._match(TokenTypes.tokens.or)) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._exclusive_or_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _exclusive_or_expression(): AST.Expression {\r\n    // and_expression\r\n    // exclusive_or_expression xor and_expression\r\n    let expr = this._and_expression();\r\n    while (this._match(TokenTypes.tokens.xor)) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._and_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _and_expression(): AST.Expression {\r\n    // equality_expression\r\n    // and_expression and equality_expression\r\n    let expr = this._equality_expression();\r\n    while (this._match(TokenTypes.tokens.and)) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._equality_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _equality_expression(): AST.Expression {\r\n    // relational_expression\r\n    // relational_expression equal_equal relational_expression\r\n    // relational_expression not_equal relational_expression\r\n    const expr = this._relational_expression();\r\n    if (this._match([TokenTypes.tokens.equal_equal, TokenTypes.tokens.not_equal])) {\r\n      return this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._relational_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _relational_expression(): AST.Expression {\r\n    // shift_expression\r\n    // relational_expression less_than shift_expression\r\n    // relational_expression greater_than shift_expression\r\n    // relational_expression less_than_equal shift_expression\r\n    // relational_expression greater_than_equal shift_expression\r\n    let expr = this._shift_expression();\r\n    while (this._match([\r\n        TokenTypes.tokens.less_than,\r\n        TokenTypes.tokens.greater_than,\r\n        TokenTypes.tokens.less_than_equal,\r\n        TokenTypes.tokens.greater_than_equal,\r\n      ])) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._shift_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _shift_expression(): AST.Expression {\r\n    // additive_expression\r\n    // shift_expression shift_left additive_expression\r\n    // shift_expression shift_right additive_expression\r\n    let expr = this._additive_expression();\r\n    while (this._match([TokenTypes.tokens.shift_left, TokenTypes.tokens.shift_right])) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._additive_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _additive_expression(): AST.Expression {\r\n    // multiplicative_expression\r\n    // additive_expression plus multiplicative_expression\r\n    // additive_expression minus multiplicative_expression\r\n    let expr = this._multiplicative_expression();\r\n    while (this._match([TokenTypes.tokens.plus, TokenTypes.tokens.minus])) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._multiplicative_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _multiplicative_expression(): AST.Expression {\r\n    // unary_expression\r\n    // multiplicative_expression star unary_expression\r\n    // multiplicative_expression forward_slash unary_expression\r\n    // multiplicative_expression modulo unary_expression\r\n    let expr = this._unary_expression();\r\n    while (this._match([\r\n        TokenTypes.tokens.star,\r\n        TokenTypes.tokens.forward_slash,\r\n        TokenTypes.tokens.modulo,\r\n      ])) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._unary_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _unary_expression(): AST.Expression {\r\n    // singular_expression\r\n    // minus unary_expression\r\n    // bang unary_expression\r\n    // tilde unary_expression\r\n    // star unary_expression\r\n    // and unary_expression\r\n    if (this._match([\r\n        TokenTypes.tokens.minus,\r\n        TokenTypes.tokens.bang,\r\n        TokenTypes.tokens.tilde,\r\n        TokenTypes.tokens.star,\r\n        TokenTypes.tokens.and,\r\n      ])) {\r\n      return this._updateNode(new AST.UnaryOperator(\r\n        this._previous().toString(),\r\n        this._unary_expression()\r\n      ));\r\n    }\r\n    return this._singular_expression();\r\n  }\r\n\r\n  _singular_expression(): AST.Expression {\r\n    // primary_expression postfix_expression ?\r\n    const expr = this._primary_expression();\r\n    const p = this._postfix_expression();\r\n    if (p) {\r\n      expr.postfix = p;\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _postfix_expression(): AST.Expression | null {\r\n    // bracket_left short_circuit_or_expression bracket_right postfix_expression?\r\n    if (this._match(TokenTypes.tokens.bracket_left)) {\r\n      const expr = this._short_circuit_or_expression();\r\n      this._consume(TokenTypes.tokens.bracket_right, \"Expected ']'.\");\r\n      const arrayIndex = this._updateNode(new AST.ArrayIndex(expr));\r\n      const p = this._postfix_expression();\r\n      if (p) {\r\n        arrayIndex.postfix = p;\r\n      }\r\n      return arrayIndex;\r\n    }\r\n\r\n    // period ident postfix_expression?\r\n    if (this._match(TokenTypes.tokens.period)) {\r\n      const name = this._consume(TokenTypes.tokens.name, \"Expected member name.\");\r\n      const p = this._postfix_expression();\r\n      const expr = this._updateNode(new AST.StringExpr(name.lexeme));\r\n      if (p) {\r\n        expr.postfix = p;\r\n      }\r\n      return expr;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _getStruct(name: string): AST.Type | null {\r\n    if (this._context.aliases.has(name)) {\r\n      const alias = this._context.aliases.get(name).type;\r\n      return alias;\r\n    }\r\n    if (this._context.structs.has(name)) {\r\n      const struct = this._context.structs.get(name);\r\n      return struct;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _getType(name: string): AST.Type {\r\n    const struct = this._getStruct(name);\r\n    if (struct !== null) {\r\n      return struct;\r\n    }\r\n    switch (name) {\r\n      case \"void\":\r\n        return AST.Type.void;\r\n      case \"bool\":\r\n        return AST.Type.bool;\r\n      case \"i32\":\r\n        return AST.Type.i32;\r\n      case \"u32\":\r\n        return AST.Type.u32;\r\n      case \"f32\":\r\n        return AST.Type.f32;\r\n      case \"f16\":\r\n        return AST.Type.f16;\r\n      case \"vec2f\":\r\n        return AST.TemplateType.vec2f;\r\n      case \"vec3f\":\r\n        return AST.TemplateType.vec3f;\r\n      case \"vec4f\":\r\n        return AST.TemplateType.vec4f;\r\n      case \"vec2i\":\r\n        return AST.TemplateType.vec2i;\r\n      case \"vec3i\":\r\n        return AST.TemplateType.vec3i;\r\n      case \"vec4i\":\r\n        return AST.TemplateType.vec4i;\r\n      case \"vec2u\":\r\n        return AST.TemplateType.vec2u;\r\n      case \"vec3u\":\r\n        return AST.TemplateType.vec3u;\r\n      case \"vec4u\":\r\n        return AST.TemplateType.vec4u;\r\n      case \"vec2h\":\r\n        return AST.TemplateType.vec2h;\r\n      case \"vec3h\":\r\n        return AST.TemplateType.vec3h;\r\n      case \"vec4h\":\r\n        return AST.TemplateType.vec4h;\r\n      case \"mat2x2f\":\r\n        return AST.TemplateType.mat2x2f;\r\n      case \"mat2x3f\":\r\n        return AST.TemplateType.mat2x3f;\r\n      case \"mat2x4f\":\r\n        return AST.TemplateType.mat2x4f;\r\n      case \"mat3x2f\":\r\n        return AST.TemplateType.mat3x2f;\r\n      case \"mat3x3f\":\r\n        return AST.TemplateType.mat3x3f;\r\n      case \"mat3x4f\":\r\n        return AST.TemplateType.mat3x4f;\r\n      case \"mat4x2f\":\r\n        return AST.TemplateType.mat4x2f;\r\n      case \"mat4x3f\":\r\n        return AST.TemplateType.mat4x3f;\r\n      case \"mat4x4f\":\r\n        return AST.TemplateType.mat4x4f;\r\n      case \"mat2x2h\":\r\n        return AST.TemplateType.mat2x2h;\r\n      case \"mat2x3h\":\r\n        return AST.TemplateType.mat2x3h;\r\n      case \"mat2x4h\":\r\n        return AST.TemplateType.mat2x4h;\r\n      case \"mat3x2h\":\r\n        return AST.TemplateType.mat3x2h;\r\n      case \"mat3x3h\":\r\n        return AST.TemplateType.mat3x3h;\r\n      case \"mat3x4h\":\r\n        return AST.TemplateType.mat3x4h;\r\n      case \"mat4x2h\":\r\n        return AST.TemplateType.mat4x2h;\r\n      case \"mat4x3h\":\r\n        return AST.TemplateType.mat4x3h;\r\n      case \"mat4x4h\":\r\n        return AST.TemplateType.mat4x4h;\r\n\r\n      case \"mat2x2i\":\r\n        return AST.TemplateType.mat2x2i;\r\n      case \"mat2x3i\":\r\n        return AST.TemplateType.mat2x3i;\r\n      case \"mat2x4i\":\r\n        return AST.TemplateType.mat2x4i;\r\n      case \"mat3x2i\":\r\n        return AST.TemplateType.mat3x2i;\r\n      case \"mat3x3i\":\r\n        return AST.TemplateType.mat3x3i;\r\n      case \"mat3x4i\":\r\n        return AST.TemplateType.mat3x4i;\r\n      case \"mat4x2i\":\r\n        return AST.TemplateType.mat4x2i;\r\n      case \"mat4x3i\":\r\n        return AST.TemplateType.mat4x3i;\r\n      case \"mat4x4i\":\r\n        return AST.TemplateType.mat4x4i;\r\n\r\n      case \"mat2x2u\":\r\n        return AST.TemplateType.mat2x2u;\r\n      case \"mat2x3u\":\r\n        return AST.TemplateType.mat2x3u;\r\n      case \"mat2x4u\":\r\n        return AST.TemplateType.mat2x4u;\r\n      case \"mat3x2u\":\r\n        return AST.TemplateType.mat3x2u;\r\n      case \"mat3x3u\":\r\n        return AST.TemplateType.mat3x3u;\r\n      case \"mat3x4u\":\r\n        return AST.TemplateType.mat3x4u;\r\n      case \"mat4x2u\":\r\n        return AST.TemplateType.mat4x2u;\r\n      case \"mat4x3u\":\r\n        return AST.TemplateType.mat4x3u;\r\n      case \"mat4x4u\":\r\n        return AST.TemplateType.mat4x4u;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _validateTypeRange(value: number, type: AST.Type) {\r\n    if (type.name === \"i32\") {\r\n      if (value < -2147483648 || value > 2147483647) {\r\n        throw this._error(this._previous(), `Value out of range for i32: ${value}. Line: ${this._currentLine}.`);\r\n      }\r\n    } else if (type.name === \"u32\") {\r\n      if (value < 0 || value > 4294967295) {\r\n        throw this._error(this._previous(), `Value out of range for u32: ${value}. Line: ${this._currentLine}.`);\r\n      }\r\n    }\r\n  }\r\n\r\n  _primary_expression(): AST.Expression {\r\n    // ident argument_expression_list?\r\n    if (this._match(TokenTypes.tokens.ident)) {\r\n      const name = this._previous().toString();\r\n      if (this._check(TokenTypes.tokens.paren_left)) {\r\n        const args = this._argument_expression_list();\r\n        const type = this._getType(name);\r\n        if (type !== null) {\r\n          return this._updateNode(new AST.CreateExpr(type, args));\r\n        }\r\n        return this._updateNode(new AST.CallExpr(name, args));\r\n      }\r\n      if (this._context.constants.has(name)) {\r\n        const c = this._context.constants.get(name);\r\n        return this._updateNode(new AST.ConstExpr(name, c.value));\r\n      }\r\n      return this._updateNode(new AST.VariableExpr(name));\r\n    }\r\n\r\n    // const_literal\r\n    if (this._match(TokenTypes.tokens.int_literal)) {\r\n      const s = this._previous().toString();\r\n      let type = s.endsWith(\"i\") || s.endsWith(\"i\") ? AST.Type.i32 :\r\n          s.endsWith(\"u\") || s.endsWith(\"U\") ? AST.Type.u32 : AST.Type.x32;\r\n      const i = parseInt(s);\r\n      this._validateTypeRange(i, type);\r\n      return this._updateNode(new AST.LiteralExpr(new ScalarData(i, this._exec.getTypeInfo(type)), type));\r\n    } else if (this._match(TokenTypes.tokens.uint_literal)) {\r\n      const u = parseInt(this._previous().toString());\r\n      this._validateTypeRange(u, AST.Type.u32);\r\n      return this._updateNode(new AST.LiteralExpr(new ScalarData(u, this._exec.getTypeInfo(AST.Type.u32)), AST.Type.u32));\r\n    } else if (this._match([TokenTypes.tokens.decimal_float_literal, TokenTypes.tokens.hex_float_literal])) {\r\n      let fs = this._previous().toString();\r\n      let isF16 = fs.endsWith(\"h\");\r\n      if (isF16) {\r\n        fs = fs.substring(0, fs.length - 1);\r\n      }\r\n      const f = parseFloat(fs);\r\n      this._validateTypeRange(f, isF16 ? AST.Type.f16 : AST.Type.f32);\r\n      const type = isF16 ? AST.Type.f16 : AST.Type.f32;\r\n      return this._updateNode(new AST.LiteralExpr(new ScalarData(f, this._exec.getTypeInfo(type)), type));\r\n    } else if (this._match([TokenTypes.keywords.true, TokenTypes.keywords.false])) {\r\n      let b = this._previous().toString() === TokenTypes.keywords.true.rule;\r\n      return this._updateNode(new AST.LiteralExpr(new ScalarData(b ? 1 : 0, this._exec.getTypeInfo(AST.Type.bool)), AST.Type.bool));\r\n    }\r\n\r\n    // paren_expression\r\n    if (this._check(TokenTypes.tokens.paren_left)) {\r\n      return this._paren_expression();\r\n    }\r\n\r\n    // bitcast less_than type_decl greater_than paren_expression\r\n    if (this._match(TokenTypes.keywords.bitcast)) {\r\n      this._consume(TokenTypes.tokens.less_than, \"Expected '<'.\");\r\n      const type = this._type_decl();\r\n      this._consume(TokenTypes.tokens.greater_than, \"Expected '>'.\");\r\n      const value = this._paren_expression();\r\n      return this._updateNode(new AST.BitcastExpr(type, value));\r\n    }\r\n\r\n    // type_decl argument_expression_list\r\n    const type = this._type_decl();\r\n    const args = this._argument_expression_list();\r\n    return this._updateNode(new AST.CreateExpr(type, args));\r\n  }\r\n\r\n  _argument_expression_list(): AST.Expression[] | null {\r\n    // paren_left ((short_circuit_or_expression comma)* short_circuit_or_expression comma?)? paren_right\r\n    if (!this._match(TokenTypes.tokens.paren_left)) {\r\n      return null;\r\n    }\r\n\r\n    const args: AST.Expression[] = [];\r\n    do {\r\n      if (this._check(TokenTypes.tokens.paren_right)) {\r\n        break;\r\n      }\r\n      const arg = this._short_circuit_or_expression();\r\n      args.push(arg);\r\n    } while (this._match(TokenTypes.tokens.comma));\r\n    this._consume(\r\n      TokenTypes.tokens.paren_right,\r\n      \"Expected ')' for agument list\"\r\n    );\r\n\r\n    return args;\r\n  }\r\n\r\n  _optional_paren_expression(): AST.Expression {\r\n    // [paren_left] short_circuit_or_expression [paren_right]\r\n    this._match(TokenTypes.tokens.paren_left);\r\n    const expr = this._short_circuit_or_expression();\r\n    this._match(TokenTypes.tokens.paren_right);\r\n    return expr;\r\n  }\r\n\r\n  _paren_expression(): AST.Expression {\r\n    // paren_left short_circuit_or_expression paren_right\r\n    this._consume(TokenTypes.tokens.paren_left, \"Expected '('.\");\r\n    const expr = this._short_circuit_or_expression();\r\n    this._consume(TokenTypes.tokens.paren_right, \"Expected ')'.\");\r\n    return expr;\r\n  }\r\n\r\n  _struct_decl(): AST.Struct | null {\r\n    // attribute* struct ident struct_body_decl\r\n    if (!this._match(TokenTypes.keywords.struct)) {\r\n      return null;\r\n    }\r\n\r\n    const startLine = this._currentLine;\r\n\r\n    const name = this._consume(TokenTypes.tokens.ident, \"Expected name for struct.\").toString();\r\n\r\n    // struct_body_decl: brace_left (struct_member comma)* struct_member comma? brace_right\r\n    this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for struct body.\");\r\n    const members: AST.Member[] = [];\r\n    while (!this._check(TokenTypes.tokens.brace_right)) {\r\n      // struct_member: attribute* variable_ident_decl\r\n      const memberAttrs = this._attribute();\r\n\r\n      const memberName = this._consume(TokenTypes.tokens.name, \"Expected variable name.\").toString();\r\n\r\n      this._consume(TokenTypes.tokens.colon, \"Expected ':' for struct member type.\");\r\n\r\n      const typeAttrs = this._attribute();\r\n      const memberType = this._type_decl();\r\n      if (memberType != null) {\r\n        memberType.attributes = typeAttrs;\r\n      }\r\n\r\n      if (!this._check(TokenTypes.tokens.brace_right)) {\r\n        this._consume(TokenTypes.tokens.comma, \"Expected ',' for struct member.\");\r\n      } else {\r\n        this._match(TokenTypes.tokens.comma); // trailing comma optional.\r\n      }\r\n\r\n      members.push(this._updateNode(new AST.Member(memberName, memberType, memberAttrs)));\r\n    }\r\n\r\n    this._consume(TokenTypes.tokens.brace_right, \"Expected '}' after struct body.\");\r\n\r\n    const endLine = this._currentLine;\r\n\r\n    const structNode = this._updateNode(new AST.Struct(name, members, startLine, endLine), startLine);\r\n    this._context.structs.set(name, structNode);\r\n    return structNode;\r\n  }\r\n\r\n  _global_variable_decl(): AST.Var | null {\r\n    // attribute* variable_decl (equal const_expression)?\r\n    const _var = this._variable_decl();\r\n    if (!_var) {\r\n      return null;\r\n    }\r\n\r\n    if (this._match(TokenTypes.tokens.equal)) {\r\n      const expr = this._const_expression();\r\n      _var.value = expr;\r\n    }\r\n\r\n    if (_var.type !== null && _var.value instanceof AST.LiteralExpr) {\r\n      if (_var.value.type.name !== \"x32\") {\r\n        const t1 = _var.type.getTypeName();\r\n        const t2 = _var.value.type.getTypeName();\r\n        if (t1 !== t2) {\r\n          throw this._error(this._peek(), `Invalid cast from ${_var.value.type.name} to ${_var.type.name}. Line:${this._currentLine}`);\r\n        }\r\n      }\r\n      if (_var.value.isScalar) {\r\n        this._validateTypeRange(_var.value.scalarValue, _var.type);\r\n      }\r\n      _var.value.type = _var.type;\r\n    } else if (_var.type === null && _var.value instanceof AST.LiteralExpr) {\r\n      _var.type = _var.value.type.name === \"x32\" ? AST.Type.i32 : _var.value.type;\r\n      if (_var.value.isScalar) {\r\n        this._validateTypeRange(_var.value.scalarValue, _var.type);\r\n      }\r\n    }\r\n    return _var;\r\n  }\r\n\r\n  _override_variable_decl(): AST.Override | null {\r\n    // attribute* override_decl (equal const_expression)?\r\n    const _override = this._override_decl();\r\n    if (_override && this._match(TokenTypes.tokens.equal)) {\r\n      _override.value = this._const_expression();\r\n    }\r\n\r\n    return _override;\r\n  }\r\n\r\n  _global_const_decl(): AST.Const | null {\r\n    // attribute* const (ident variable_ident_decl) global_const_initializer?\r\n    if (!this._match(TokenTypes.keywords.const)) {\r\n      return null;\r\n    }\r\n\r\n    const name = this._consume(\r\n      TokenTypes.tokens.name,\r\n      \"Expected variable name\"\r\n    );\r\n\r\n    const line = this._currentLine;\r\n\r\n    let type: AST.Type | null = null;\r\n    if (this._match(TokenTypes.tokens.colon)) {\r\n      const attrs = this._attribute();\r\n      type = this._type_decl();\r\n      if (type != null) {\r\n        type.attributes = attrs;\r\n      }\r\n    }\r\n    let value: AST.Expression | null = null;\r\n\r\n    this._consume(TokenTypes.tokens.equal, \"const declarations require an assignment\")\r\n\r\n    const valueExpr = this._short_circuit_or_expression();\r\n    try {\r\n      let type = [AST.Type.f32];\r\n      let constValue = valueExpr.constEvaluate(this._exec, type);\r\n\r\n      if (constValue instanceof ScalarData) {\r\n        this._validateTypeRange(constValue.value, type[0]);\r\n      }\r\n\r\n      if (type[0] instanceof AST.TemplateType && type[0].format === null &&\r\n        constValue.typeInfo instanceof TemplateInfo && constValue.typeInfo.format !== null) {\r\n        if (constValue.typeInfo.format.name === \"f16\") {\r\n          type[0].format = AST.Type.f16;\r\n        } else if (constValue.typeInfo.format.name === \"f32\") {\r\n          type[0].format = AST.Type.f32;\r\n        } else if (constValue.typeInfo.format.name === \"i32\") {\r\n          type[0].format = AST.Type.i32;\r\n        } else if (constValue.typeInfo.format.name === \"u32\") {\r\n          type[0].format = AST.Type.u32;\r\n        } else if (constValue.typeInfo.format.name === \"bool\") {\r\n          type[0].format = AST.Type.bool;\r\n        } else {\r\n          console.error(`TODO: impelement template format type ${constValue.typeInfo.format.name}`);\r\n        }\r\n      }\r\n\r\n      value = this._updateNode(new AST.LiteralExpr(constValue, type[0]));\r\n      this._exec.context.setVariable(name.toString(), constValue);\r\n    } catch {\r\n      value = valueExpr;\r\n    }\r\n\r\n    if (type !== null && value instanceof AST.LiteralExpr) {\r\n      if (value.type.name !== \"x32\") {\r\n        const t1 = type.getTypeName();\r\n        const t2 = value.type.getTypeName();\r\n        if (t1 !== t2) {\r\n          throw this._error(this._peek(), `Invalid cast from ${value.type.name} to ${type.name}. Line:${this._currentLine}`);\r\n        }\r\n      }\r\n      value.type = type;\r\n      if (value.isScalar) {\r\n        this._validateTypeRange(value.scalarValue, value.type);\r\n      }\r\n    } else if (type === null && value instanceof AST.LiteralExpr) {\r\n      type = value?.type ?? AST.Type.f32;\r\n      if (type === AST.Type.x32) {\r\n        type = AST.Type.i32;\r\n      }\r\n    }\r\n\r\n    const c = this._updateNode(new AST.Const(name.toString(), type, \"\", \"\", value), line);\r\n    this._context.constants.set(c.name, c);\r\n    return c;\r\n  }\r\n\r\n  _global_let_decl(): AST.Let | null {\r\n    // attribute* let (ident variable_ident_decl) global_const_initializer?\r\n    if (!this._match(TokenTypes.keywords.let)) {\r\n      return null;\r\n    }\r\n\r\n    const line = this._currentLine;\r\n\r\n    const name = this._consume(\r\n      TokenTypes.tokens.name,\r\n      \"Expected variable name\"\r\n    );\r\n\r\n    let type: AST.Type | null = null;\r\n    if (this._match(TokenTypes.tokens.colon)) {\r\n      const attrs = this._attribute();\r\n      type = this._type_decl();\r\n      if (type != null) {\r\n        type.attributes = attrs;\r\n      }\r\n    }\r\n\r\n    let value: AST.Expression | null = null;\r\n    if (this._match(TokenTypes.tokens.equal)) {\r\n      value = this._const_expression();\r\n    }\r\n\r\n    if (type !== null && value instanceof AST.LiteralExpr) {\r\n      if (value.type.name !== \"x32\") {\r\n        const t1 = type.getTypeName();\r\n        const t2 = value.type.getTypeName();\r\n        if (t1 !== t2) {\r\n          throw this._error(this._peek(), `Invalid cast from ${value.type.name} to ${type.name}. Line:${this._currentLine}`);\r\n        }\r\n      }\r\n      value.type = type;\r\n    } else if (type === null && value instanceof AST.LiteralExpr) {\r\n      type = value.type.name === \"x32\" ? AST.Type.i32 : value.type;\r\n    }\r\n\r\n    if (value instanceof AST.LiteralExpr) {\r\n      if (value.isScalar) {\r\n        this._validateTypeRange(value.scalarValue, type);\r\n      }\r\n    }\r\n    return this._updateNode(new AST.Let(name.toString(), type, \"\", \"\", value), line);\r\n  }\r\n\r\n  _const_expression(): AST.Expression {\r\n    // type_decl paren_left ((const_expression comma)* const_expression comma?)? paren_right\r\n    // const_literal\r\n    return this._short_circuit_or_expression();\r\n  }\r\n\r\n  _variable_decl(): AST.Var | null {\r\n    // var variable_qualifier? (ident variable_ident_decl)\r\n    if (!this._match(TokenTypes.keywords.var)) {\r\n      return null;\r\n    }\r\n\r\n    const line = this._currentLine;\r\n\r\n    // variable_qualifier: less_than storage_class (comma access_mode)? greater_than\r\n    let storage: string = \"\";\r\n    let access: string = \"\";\r\n    if (this._match(TokenTypes.tokens.less_than)) {\r\n      storage = this._consume(TokenTypes.storage_class, \"Expected storage_class.\").toString();\r\n      if (this._match(TokenTypes.tokens.comma))\r\n        access = this._consume(TokenTypes.access_mode, \"Expected access_mode.\").toString();\r\n      this._consume(TokenTypes.tokens.greater_than, \"Expected '>'.\");\r\n    }\r\n\r\n    const name = this._consume(\r\n      TokenTypes.tokens.name,\r\n      \"Expected variable name\"\r\n    );\r\n\r\n    let type: AST.Type | null = null;\r\n    if (this._match(TokenTypes.tokens.colon)) {\r\n      const attrs = this._attribute();\r\n      type = this._type_decl();\r\n      if (type != null) {\r\n        type.attributes = attrs;\r\n      }\r\n    }\r\n\r\n    return this._updateNode(new AST.Var(name.toString(), type, storage, access, null), line);\r\n  }\r\n\r\n  _override_decl(): AST.Override | null {\r\n    // override (ident variable_ident_decl)\r\n    if (!this._match(TokenTypes.keywords.override)) {\r\n      return null;\r\n    }\r\n\r\n    const name = this._consume(TokenTypes.tokens.name, \"Expected variable name\");\r\n    let type: AST.Type | null = null;\r\n    if (this._match(TokenTypes.tokens.colon)) {\r\n      const attrs = this._attribute();\r\n      type = this._type_decl();\r\n      if (type != null) {\r\n        type.attributes = attrs;\r\n      }\r\n    }\r\n\r\n    return this._updateNode(new AST.Override(name.toString(), type, null));\r\n  }\r\n\r\n  _diagnostic(): AST.Diagnostic | null {\r\n    // diagnostic(severity_control_name, diagnostic_rule_name)\r\n    this._consume(TokenTypes.tokens.paren_left, \"Expected '('\");\r\n    const severity = this._consume(\r\n      TokenTypes.tokens.ident,\r\n      \"Expected severity control name.\"\r\n    );\r\n    this._consume(TokenTypes.tokens.comma, \"Expected ','\");\r\n    const rule = this._consume(\r\n      TokenTypes.tokens.ident,\r\n      \"Expected diagnostic rule name.\"\r\n    );\r\n    let ruleMessage = rule.toString();\r\n    if (this._match(TokenTypes.tokens.period)) {\r\n      const message = this._consume(\r\n        TokenTypes.tokens.ident,\r\n        \"Expected diagnostic message.\"\r\n      );\r\n      ruleMessage += `.${message.toString()}`;\r\n    }\r\n\r\n    this._consume(TokenTypes.tokens.paren_right, \"Expected ')'\");\r\n    return this._updateNode(new AST.Diagnostic(severity.toString(), ruleMessage));\r\n  }\r\n\r\n  _enable_directive(): AST.Enable {\r\n    // enable ident semicolon\r\n    const name = this._consume(TokenTypes.tokens.ident, \"identity expected.\");\r\n    return this._updateNode(new AST.Enable(name.toString()));\r\n  }\r\n\r\n  _requires_directive(): AST.Requires {\r\n    // requires extension [, extension]* semicolon\r\n    const extensions: string[] = [this._consume(TokenTypes.tokens.ident, \"identity expected.\").toString()];\r\n    while (this._match(TokenTypes.tokens.comma)) {\r\n      const name = this._consume(TokenTypes.tokens.ident, \"identity expected.\");\r\n      extensions.push(name.toString());\r\n    }\r\n    return this._updateNode(new AST.Requires(extensions));\r\n  }\r\n\r\n  _type_alias(): AST.Alias {\r\n    // type ident equal type_decl\r\n    const name = this._consume(TokenTypes.tokens.ident, \"identity expected.\");\r\n    this._consume(TokenTypes.tokens.equal, \"Expected '=' for type alias.\");\r\n\r\n    let aliasType = this._type_decl();\r\n    if (aliasType === null) {\r\n      throw this._error(this._peek(), \"Expected Type for Alias.\");\r\n    }\r\n    if (this._context.aliases.has(aliasType.name)) {\r\n      aliasType = this._context.aliases.get(aliasType.name).type;\r\n    }\r\n\r\n    const aliasNode = this._updateNode(new AST.Alias(name.toString(), aliasType));\r\n    this._context.aliases.set(aliasNode.name, aliasNode);\r\n\r\n    return aliasNode;\r\n  }\r\n\r\n  _type_decl(): AST.Type | null {\r\n    // ident\r\n    // bool\r\n    // float32\r\n    // int32\r\n    // uint32\r\n    // vec2 less_than type_decl greater_than\r\n    // vec3 less_than type_decl greater_than\r\n    // vec4 less_than type_decl greater_than\r\n    // mat2x2 less_than type_decl greater_than\r\n    // mat2x3 less_than type_decl greater_than\r\n    // mat2x4 less_than type_decl greater_than\r\n    // mat3x2 less_than type_decl greater_than\r\n    // mat3x3 less_than type_decl greater_than\r\n    // mat3x4 less_than type_decl greater_than\r\n    // mat4x2 less_than type_decl greater_than\r\n    // mat4x3 less_than type_decl greater_than\r\n    // mat4x4 less_than type_decl greater_than\r\n    // atomic less_than type_decl greater_than\r\n    // pointer less_than storage_class comma type_decl (comma access_mode)? greater_than\r\n    // array_type_decl\r\n    // texture_sampler_types\r\n\r\n    if (this._check([\r\n        TokenTypes.tokens.ident,\r\n        ...TokenTypes.texel_format,\r\n        TokenTypes.keywords.bool,\r\n        TokenTypes.keywords.f32,\r\n        TokenTypes.keywords.i32,\r\n        TokenTypes.keywords.u32,\r\n      ])) {\r\n      const type = this._advance();\r\n      const typeName = type.toString();\r\n      if (this._context.structs.has(typeName)) {\r\n        return this._context.structs.get(typeName);\r\n      }\r\n      if (this._context.aliases.has(typeName)) {\r\n        return this._context.aliases.get(typeName).type;\r\n      }\r\n\r\n      const t = this._getType(typeName);\r\n      // Don't \"forward declare\" built-in types\r\n      if (!t) {\r\n        const node = this._updateNode(new AST.ForwardType(typeName));\r\n        this._forwardTypeCount++;\r\n        return node;\r\n      }\r\n\r\n      return this._updateNode(new AST.Type(typeName));\r\n    }\r\n\r\n    // texture_sampler_types\r\n    let type = this._texture_sampler_types();\r\n    if (type) {\r\n      return type;\r\n    }\r\n\r\n    if (this._check(TokenTypes.template_types)) {\r\n      let type = this._advance().toString();\r\n      let format: AST.Type | null = null;\r\n      let access: string | null = null;\r\n      if (this._match(TokenTypes.tokens.less_than)) {\r\n        format = this._type_decl();\r\n        access = null;\r\n        if (this._match(TokenTypes.tokens.comma)) {\r\n          access = this._consume(TokenTypes.access_mode, \"Expected access_mode for pointer\").toString();\r\n        }\r\n        this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for type.\");\r\n      }\r\n      const node = this._updateNode(new AST.TemplateType(type, format, access));\r\n      return node;\r\n    }\r\n\r\n    // pointer less_than storage_class comma type_decl (comma access_mode)? greater_than\r\n    if (this._match(TokenTypes.keywords.ptr)) {\r\n      let pointer = this._previous().toString();\r\n      this._consume(TokenTypes.tokens.less_than, \"Expected '<' for pointer.\");\r\n      const storage = this._consume(TokenTypes.storage_class, \"Expected storage_class for pointer\");\r\n      this._consume(TokenTypes.tokens.comma, \"Expected ',' for pointer.\");\r\n      const decl = this._type_decl();\r\n      let access: string | null = null;\r\n      if (this._match(TokenTypes.tokens.comma)) {\r\n        access = this._consume(TokenTypes.access_mode, \"Expected access_mode for pointer\").toString();\r\n      }\r\n      this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for pointer.\");\r\n      const node = this._updateNode(new AST.PointerType(pointer, storage.toString(), decl, access));\r\n      return node;\r\n    }\r\n\r\n    // The following type_decl's have an optional attribyte_list*\r\n    const attrs = this._attribute();\r\n\r\n    // attribute* array\r\n    // attribute* array less_than type_decl (comma element_count_expression)? greater_than\r\n    if (this._match(TokenTypes.keywords.array)) {\r\n      let format = null;\r\n      let countInt = -1;\r\n      const array = this._previous();\r\n      let countNode: AST.Expression | null = null;\r\n      if (this._match(TokenTypes.tokens.less_than)) {\r\n        format = this._type_decl();\r\n        if (this._context.aliases.has(format.name)) {\r\n          format = this._context.aliases.get(format.name).type;\r\n        }\r\n        let count: string = \"\";\r\n        if (this._match(TokenTypes.tokens.comma)) {\r\n          countNode = this._shift_expression();\r\n          // If we can't evaluate the node, defer evaluating it until after the shader has\r\n          // finished being parsed, because const statements can be declared **after** they\r\n          // are used.\r\n          try {\r\n            count = countNode.constEvaluate(this._exec).toString();\r\n            countNode = null;\r\n          } catch (e) {\r\n            count = \"1\";\r\n          }\r\n        }\r\n        this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for array.\");\r\n        countInt = count ? parseInt(count) : 0;\r\n      }\r\n      const arrayType = this._updateNode(new AST.ArrayType(array.toString(), attrs, format, countInt));\r\n      if (countNode) {\r\n        this._deferArrayCountEval.push({ arrayType, countNode });\r\n      }\r\n      return arrayType;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _texture_sampler_types(): AST.SamplerType | null {\r\n    // sampler_type\r\n    if (this._match(TokenTypes.sampler_type)) {\r\n      return this._updateNode(new AST.SamplerType(this._previous().toString(), null, null));\r\n    }\r\n\r\n    // depth_texture_type\r\n    if (this._match(TokenTypes.depth_texture_type)) {\r\n      return this._updateNode(new AST.SamplerType(this._previous().toString(), null, null));\r\n    }\r\n\r\n    // sampled_texture_type less_than type_decl greater_than\r\n    // multisampled_texture_type less_than type_decl greater_than\r\n    if (this._match(TokenTypes.sampled_texture_type) ||\r\n      this._match(TokenTypes.multisampled_texture_type)) {\r\n      const sampler = this._previous();\r\n      this._consume(\r\n        TokenTypes.tokens.less_than,\r\n        \"Expected '<' for sampler type.\"\r\n      );\r\n      const format = this._type_decl();\r\n      this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for sampler type.\");\r\n      return this._updateNode(new AST.SamplerType(sampler.toString(), format, null));\r\n    }\r\n\r\n    // storage_texture_type less_than texel_format comma access_mode greater_than\r\n    if (this._match(TokenTypes.storage_texture_type)) {\r\n      const sampler = this._previous();\r\n      this._consume(TokenTypes.tokens.less_than, \"Expected '<' for sampler type.\");\r\n      const format = this._consume(TokenTypes.texel_format, \"Invalid texel format.\").toString();\r\n      this._consume(TokenTypes.tokens.comma, \"Expected ',' after texel format.\");\r\n      const access = this._consume(TokenTypes.access_mode, \"Expected access mode for storage texture type.\").toString();\r\n      this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for sampler type.\");\r\n      return this._updateNode(new AST.SamplerType(sampler.toString(), format, access));\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _attribute(): AST.Attribute[] | null {\r\n    // attr ident paren_left (literal_or_ident comma)* literal_or_ident paren_right\r\n    // attr ident\r\n\r\n    let attributes: AST.Attribute[] = [];\r\n\r\n    while (this._match(TokenTypes.tokens.attr)) {\r\n      const name = this._consume(\r\n        TokenTypes.attribute_name,\r\n        \"Expected attribute name\"\r\n      );\r\n      const attr = this._updateNode(new AST.Attribute(name.toString(), null));\r\n      if (this._match(TokenTypes.tokens.paren_left)) {\r\n        // literal_or_ident\r\n        attr.value = this._consume(TokenTypes.literal_or_ident, \"Expected attribute value\").toString();\r\n        if (this._check(TokenTypes.tokens.comma)) {\r\n          this._advance();\r\n          do {\r\n            const v = this._consume(TokenTypes.literal_or_ident, \"Expected attribute value\").toString();\r\n            if (!(attr.value instanceof Array)) {\r\n              attr.value = [attr.value as string];\r\n            }\r\n            attr.value.push(v);\r\n          } while (this._match(TokenTypes.tokens.comma));\r\n        }\r\n        this._consume(TokenTypes.tokens.paren_right, \"Expected ')'\");\r\n      }\r\n      attributes.push(attr);\r\n    }\r\n\r\n    if (attributes.length == 0) {\r\n      return null;\r\n    }\r\n\r\n    return attributes;\r\n  }\r\n}\r\n", "import { WgslParser } from \"./wgsl_parser.js\";\r\nimport { Reflect } from \"./reflect/reflect.js\";\r\n\r\nexport * from \"./reflect/info.js\";\r\n\r\nexport class WgslReflect extends Reflect {\r\n  constructor(code?: string) {\r\n    super();\r\n    if (code) {\r\n      this.update(code);\r\n    }\r\n  }\r\n\r\n  update(code: string): void {\r\n    const parser = new WgslParser();\r\n    const ast = parser.parse(code);\r\n    this.updateAST(ast);\r\n  }\r\n}\r\n", "import { Node, CallExpr, Continue, Expression, Break } from \"../wgsl_ast.js\";\n\nexport class Command {\n    get line(): number { return -1; }\n}\n\nexport class StatementCommand extends Command {\n    node: Node;\n\n    constructor(node: Node) {\n        super();\n        this.node = node;\n    }\n\n    get line(): number { return this.node.line; }\n}\n\nexport class CallExprCommand extends Command {\n    node: CallExpr;\n    statement: Node;\n\n    constructor(node: CallExpr, statement: Node) {\n        super();\n        this.node = node;\n        this.statement = statement;\n    }\n\n    get line(): number { return this.statement.line; }\n}\n\nexport class ContinueTargetCommand extends Command {\n    id: number;\n\n    constructor(id: number) {\n        super();\n        this.id = id;\n    }\n}\n\nexport class BreakTargetCommand extends Command {\n    id: number;\n\n    constructor(id: number) {\n        super();\n        this.id = id;\n    }\n}\n\nexport class ContinueCommand extends Command {\n    id: number;\n    node: Continue;\n\n    constructor(id: number, node: Continue) {\n        super();\n        this.id = id;\n        this.node = node;\n    }\n\n    get line(): number { return this.node.line; }\n}\n\nexport class BreakCommand extends Command {\n    id: number;\n    condition: Expression | null;\n    node: Break;\n\n    constructor(id: number, condition: Expression | null, node: Break) {\n        super();\n        this.id = id;\n        this.condition = condition;\n        this.node = node;\n    }\n\n    get line(): number { return this.node.line; }\n}\n\n\nexport class GotoCommand extends Command {\n    condition: Node | null;\n    position: number;\n    lineNo: number = -1;\n\n    constructor(condition: Node | null, position: number, line: number) {\n        super();\n        this.condition = condition;\n        this.position = position;\n        this.lineNo = line;\n    }\n\n    get line(): number {\n        return this.condition?.line ?? this.lineNo;\n    }\n}\n\nexport class BlockCommand extends Command {\n    statements: Array<Node> = [];\n\n    constructor(statements: Array<Node>) {\n      super();\n      this.statements = statements;\n    }\n\n    get line(): number {\n      return this.statements.length > 0 ? this.statements[0].line : -1;\n    }\n}\n", "import { Command } from \"./command.js\";\r\nimport { CallExpr } from \"../wgsl_ast.js\";\r\nimport { ExecContext } from \"./exec_context.js\";\r\n\r\nexport class StackFrame {\r\n    parent: StackFrame | null = null;\r\n    context: ExecContext;\r\n    commands: Command[] = [];\r\n    current: number = 0;\r\n    parentCallExpr: CallExpr | null = null;\r\n\r\n    constructor(context: ExecContext, parent?: StackFrame) {\r\n        this.context = context;\r\n        this.parent = parent ?? null;\r\n    }\r\n\r\n    get isAtEnd(): boolean { return this.current >= this.commands.length; }\r\n\r\n    getNextCommand(): Command | null {\r\n        if (this.current >= this.commands.length) {\r\n            return null;\r\n        }\r\n        const command = this.commands[this.current];\r\n        this.current++;\r\n        return command;\r\n    }\r\n\r\n    getCurrentCommand(): Command | null {\r\n        if (this.current >= this.commands.length) {\r\n            return null;\r\n        }\r\n        return this.commands[this.current];\r\n    }\r\n}\r\n", "import { StackFrame } from \"./stack_frame.js\";\r\n\r\nexport class ExecStack {\r\n    states: StackFrame[] = [];\r\n\r\n    get isEmpty(): boolean { return this.states.length == 0; }\r\n\r\n    get last(): StackFrame | null { return this.states[this.states.length - 1] ?? null; }\r\n\r\n    pop(): void {\r\n        this.states.pop();\r\n    }\r\n}\r\n", "import * as AST from \"./wgsl_ast.js\";\r\nimport { WgslExec } from \"./wgsl_exec.js\";\r\nimport { WgslParser } from \"./wgsl_parser.js\";\r\nimport { ExecContext, FunctionRef } from \"./exec/exec_context.js\";\r\nimport { Command, StatementCommand, CallExprCommand, GotoCommand, BlockCommand,\r\n        ContinueTargetCommand, ContinueCommand, BreakCommand, BreakTargetCommand } from \"./exec/command.js\";\r\nimport { StackFrame } from \"./exec/stack_frame.js\";\r\nimport { ExecStack } from \"./exec/exec_stack.js\";\r\nimport { ScalarData, VectorData, MatrixData, TextureData, TypedData, VoidData } from \"./wgsl_ast.js\";\r\n\r\ntype RuntimeStateCallbackType = () => void;\r\n\r\nexport class WgslDebug {\r\n    _code: string;\r\n    _exec: WgslExec;\r\n    _execStack: ExecStack;\r\n    _dispatchId: number[];\r\n    _runTimer: any = null;\r\n    breakpoints: Set<number> = new Set();\r\n    runStateCallback: RuntimeStateCallbackType | null = null;\r\n\r\n    constructor(code: string, runStateCallback?: RuntimeStateCallbackType) {\r\n        this._code = code;\r\n        const parser = new WgslParser();\r\n        const ast = parser.parse(code);\r\n        this._exec = new WgslExec(ast);\r\n        this.runStateCallback = runStateCallback ?? null\r\n    }\r\n\r\n    getVariableValue(name: string): number | number[] | null {\r\n        const context = this.context;\r\n        const v = context.getVariable(name)?.value ?? null;\r\n        if (v === null) {\r\n            return null;\r\n        }\r\n        if (v instanceof ScalarData) {\r\n            return v.value;\r\n        }\r\n        if (v instanceof VectorData) {\r\n            return Array.from(v.data);\r\n        }\r\n        if (v instanceof MatrixData) {\r\n            return Array.from(v.data);\r\n        }\r\n        console.error(`Unsupported return variable type ${v.typeInfo.name}`);\r\n        return null;\r\n    }\r\n\r\n    reset(): void {\r\n        this._exec = new WgslExec(this._exec.ast);\r\n        this.startDebug();\r\n    }\r\n\r\n    startDebug(): void {\r\n        this._execStack = new ExecStack();\r\n        const state = this._createState(this._exec.ast, this._exec.context);\r\n        this._execStack.states.push(state);\r\n    }\r\n\r\n    get context(): ExecContext {\r\n        const state = this.currentState;\r\n        if (state === null) {\r\n            return this._exec.context;\r\n        }\r\n        return state.context;\r\n    }\r\n\r\n    get currentState(): StackFrame | null {\r\n        while (true) {\r\n            if (this._execStack.isEmpty) {\r\n                return null;\r\n            }\r\n\r\n            let state = this._execStack.last;\r\n            if (state === null) {\r\n                return null;\r\n            }\r\n\r\n            if (state.isAtEnd) {\r\n                this._execStack.pop();\r\n                if (this._execStack.isEmpty) {\r\n                    return null;\r\n                }\r\n                state = this._execStack.last;\r\n            }\r\n\r\n            return state;\r\n        }\r\n    }\r\n\r\n    get currentCommand(): Command | null {\r\n        while (true) {\r\n            if (this._execStack.isEmpty) {\r\n                return null;\r\n            }\r\n\r\n            let state = this._execStack.last;\r\n            if (state === null) {\r\n                return null;\r\n            }\r\n\r\n            if (state.isAtEnd) {\r\n                this._execStack.pop();\r\n                if (this._execStack.isEmpty) {\r\n                    return null;\r\n                }\r\n                state = this._execStack.last;\r\n            }\r\n\r\n            const command = state.getCurrentCommand();\r\n            if (command === null) {\r\n                continue;\r\n            }\r\n\r\n            return command;\r\n        }\r\n    }\r\n\r\n    toggleBreakpoint(line: number) {\r\n        if (this.breakpoints.has(line)) {\r\n            this.breakpoints.delete(line);\r\n        } else {\r\n            this.breakpoints.add(line);\r\n        }\r\n    }\r\n\r\n    clearBreakpoints() {\r\n        this.breakpoints.clear();\r\n    }\r\n\r\n    get isRunning() {\r\n        return this._runTimer !== null;\r\n    }\r\n\r\n    run() {\r\n        if (this.isRunning) {\r\n            return;\r\n        }\r\n        this._runTimer = setInterval(() => {\r\n            const command = this.currentCommand;\r\n            if (command) {\r\n                if (this.breakpoints.has(command.line)) {\r\n                    clearInterval(this._runTimer!);\r\n                    this._runTimer = null;\r\n                    if (this.runStateCallback !== null) {\r\n                        this.runStateCallback();\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n            if (!this.stepNext(true)) {\r\n                clearInterval(this._runTimer!);\r\n                this._runTimer = null;\r\n                if (this.runStateCallback !== null) {\r\n                    this.runStateCallback();\r\n                }\r\n            }\r\n        }, 0);\r\n        if (this.runStateCallback !== null) {\r\n            this.runStateCallback();\r\n        }\r\n    }\r\n\r\n    pause() {\r\n        if (this._runTimer !== null) {\r\n            clearInterval(this._runTimer);\r\n            this._runTimer = null;\r\n            if (this.runStateCallback !== null) {\r\n                this.runStateCallback();\r\n            }\r\n        }\r\n    }\r\n\r\n    _setOverrides(constants: Object, context: ExecContext): void {\r\n        for (const k in constants) {\r\n            const v = constants[k];\r\n            const override = this._exec.reflection.getOverrideInfo(k);\r\n            if (override !== null) {\r\n                if (override.type === null) {\r\n                    override.type = this._exec.getTypeInfo(\"u32\");\r\n                }\r\n                if (override.type.name === \"u32\" || override.type.name === \"i32\" || override.type.name === \"f32\" || override.type.name === \"f16\") {\r\n                    context.setVariable(k, new ScalarData(v, override.type));\r\n                } else if (override.type.name === \"bool\") {\r\n                    context.setVariable(k, new ScalarData(v ? 1 : 0, override.type));\r\n                } else if (override.type.name === \"vec2\" || override.type.name === \"vec3\" || override.type.name === \"vec4\" ||\r\n                    override.type.name === \"vec2f\" || override.type.name === \"vec3f\" || override.type.name === \"vec4f\" ||\r\n                    override.type.name === \"vec2i\" || override.type.name === \"vec3i\" || override.type.name === \"vec4i\" ||\r\n                    override.type.name === \"vec2u\" || override.type.name === \"vec3u\" || override.type.name === \"vec4u\" ||\r\n                    override.type.name === \"vec2h\" || override.type.name === \"vec3h\" || override.type.name === \"vec4h\") {\r\n                    context.setVariable(k, new VectorData(v, override.type));\r\n                } else {\r\n                    console.error(`Invalid constant type for ${k}`);\r\n                }\r\n            } else {\r\n                console.error(`Override ${k} does not exist in the shader.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    debugWorkgroup(kernel: string, dispatchId: number[], \r\n        dispatchCount: number | number[], bindGroups: Object, config?: Object): boolean {\r\n\r\n        this._execStack = new ExecStack();\r\n\r\n        const context = this._exec.context;\r\n        context.currentFunctionName = kernel;\r\n\r\n        this._dispatchId = dispatchId;\r\n\r\n        config = config ?? {};\r\n        if (config[\"constants\"]) {\r\n            this._setOverrides(config[\"constants\"], context);\r\n        }\r\n\r\n        // Use this to debug the top level statements, otherwise call _execStatements.\r\n        /*const state = new _ExecState(this._exec.context);\r\n        this._execStack.states.push(state);\r\n        for (const statement of this._exec.ast) {\r\n            state.commands.push(new Command(CommandType.Statement, statement));\r\n        }*/\r\n        this._exec._execStatements(this._exec.ast, context);\r\n\r\n        const kernelFn = context.getFunction(kernel);\r\n        if (!kernelFn) {\r\n            console.error(`Function ${kernel} not found`);\r\n            return false;\r\n        }\r\n\r\n        const kernelRefl = this._exec.reflection.getFunctionInfo(kernel);\r\n\r\n        if (typeof dispatchCount === \"number\") {\r\n            dispatchCount = [dispatchCount, 1, 1];\r\n        } else if (dispatchCount.length === 0) {\r\n            console.error(`Invalid dispatch count`);\r\n            return false;\r\n        } else if (dispatchCount.length === 1) {\r\n            dispatchCount = [dispatchCount[0], 1, 1];\r\n        } else if (dispatchCount.length === 2) {\r\n            dispatchCount = [dispatchCount[0], dispatchCount[1], 1];\r\n        } else if (dispatchCount.length > 3) {\r\n            dispatchCount = [dispatchCount[0], dispatchCount[1], dispatchCount[2]];\r\n        }\r\n\r\n        const depth = dispatchCount[2];\r\n        const height = dispatchCount[1];\r\n        const width = dispatchCount[0];\r\n\r\n        const vec3u = this._exec.typeInfo[\"vec3u\"];\r\n        context.setVariable(\"@num_workgroups\", new VectorData(dispatchCount, vec3u));\r\n\r\n        for (const set in bindGroups) {\r\n            for (const binding in bindGroups[set]) {\r\n                const entry = bindGroups[set][binding];\r\n\r\n                context.variables.forEach((v) => {\r\n                    const node = v.node;\r\n                    if (node?.attributes) {\r\n                        let b = null;\r\n                        let s = null;\r\n                        for (const attr of node.attributes) {\r\n                            if (attr.name === \"binding\") {\r\n                                b = attr.value;\r\n                            } else if (attr.name === \"group\") {\r\n                                s = attr.value;\r\n                            }\r\n                        }\r\n                        if (binding == b && set == s) {\r\n                            let found = false;\r\n                            for (const resource of kernelRefl.resources) {\r\n                                if (resource.name === v.name && resource.group === parseInt(set) && resource.binding === parseInt(binding)) {\r\n                                    found = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (found) {\r\n                                if (entry.texture !== undefined && entry.descriptor !== undefined) {\r\n                                    // Texture\r\n                                    const textureData = new TextureData(entry.texture, this._exec.getTypeInfo(node.type), entry.descriptor,\r\n                                                                        entry.texture.view ?? null);\r\n                                    v.value = textureData;\r\n                                } else if (entry.uniform !== undefined) {\r\n                                    // Uniform buffer\r\n                                    v.value = new TypedData(entry.uniform, this._exec.getTypeInfo(node.type));\r\n                                } else {\r\n                                    // Storage buffer\r\n                                    v.value = new TypedData(entry, this._exec.getTypeInfo(node.type));\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        let found = false;\r\n        for (let z = 0; z < depth && !found; ++z) {\r\n            for (let y = 0; y < height && !found; ++y) {\r\n                for (let x = 0; x < width && !found; ++x) {\r\n                    context.setVariable(\"@workgroup_id\", new VectorData([x, y, z], vec3u));\r\n                    if (this._dispatchWorkgroup(kernelFn, [x, y, z], context)) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return found;\r\n    }\r\n\r\n    _shouldExecuteNextCommand(): boolean {\r\n        const command = this.currentCommand;\r\n        if (command === null) {\r\n            return false;\r\n        }\r\n        if (command instanceof GotoCommand) {\r\n            if (command.condition === null) {\r\n                return true;\r\n            }\r\n        } else if (command instanceof ContinueTargetCommand || command instanceof BreakTargetCommand) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    stepInto() {\r\n        if (this.isRunning) {\r\n            return;\r\n        }\r\n        this.stepNext(true);\r\n    }\r\n\r\n    stepOver() {\r\n        if (this.isRunning) {\r\n            return;\r\n        }\r\n        this.stepNext(false);\r\n    }\r\n\r\n    stepOut() {\r\n        const state = this.currentState;\r\n        if (state === null) {\r\n            return;\r\n        }\r\n        const parentState = state.parent;\r\n\r\n        if (this.isRunning) {\r\n            clearInterval(this._runTimer);\r\n            this._runTimer = null;\r\n        }\r\n\r\n        this._runTimer = setInterval(() => {\r\n            const command = this.currentCommand;\r\n            if (command) {\r\n                if (this.breakpoints.has(command.line)) {\r\n                    clearInterval(this._runTimer!);\r\n                    this._runTimer = null;\r\n                    if (this.runStateCallback !== null) {\r\n                        this.runStateCallback();\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n            if (!this.stepNext(true)) {\r\n                clearInterval(this._runTimer!);\r\n                this._runTimer = null;\r\n                if (this.runStateCallback !== null) {\r\n                    this.runStateCallback();\r\n                }\r\n            }\r\n\r\n            const state = this.currentState;\r\n            if (state === parentState) {\r\n                clearInterval(this._runTimer!);\r\n                this._runTimer = null;\r\n                if (this.runStateCallback !== null) {\r\n                    this.runStateCallback();\r\n                }\r\n            }\r\n        }, 0);\r\n        if (this.runStateCallback !== null) {\r\n            this.runStateCallback();\r\n        }\r\n    }\r\n\r\n    // Returns true if execution is not finished, false if execution is complete.\r\n    stepNext(stepInto = true): boolean {\r\n        if (!this._execStack) {\r\n            this._execStack = new ExecStack();\r\n            const state = this._createState(this._exec.ast, this._exec.context);\r\n            this._execStack.states.push(state);\r\n        }\r\n\r\n        while (true) {\r\n            if (this._execStack.isEmpty) {\r\n                return false;\r\n            }\r\n\r\n            let state = this._execStack.last;\r\n            if (state === null) {\r\n                return false;\r\n            }\r\n\r\n            if (state.isAtEnd) {\r\n                this._execStack.pop();\r\n                if (this._execStack.isEmpty) {\r\n                    return false;\r\n                }\r\n                state = this._execStack.last;\r\n            }\r\n\r\n            const command = state!.getNextCommand();\r\n            if (command === null) {\r\n                continue;\r\n            }\r\n\r\n            if (stepInto && command instanceof CallExprCommand) {\r\n                const node = command.node;\r\n                const fn = state.context.getFunction(node.name);\r\n                if (!fn) {\r\n                    continue; // it's not a custom function, step over it\r\n                }\r\n                const fnState = this._createState(fn.node.body, state.context.clone(), state);\r\n\r\n                for (let ai = 0; ai < fn.node.args.length; ++ai) {\r\n                    const arg = fn.node.args[ai];\r\n                    const value = this._exec.evalExpression(node.args[ai], fnState.context);\r\n                    fnState.context.createVariable(arg.name, value, arg);\r\n                }\r\n\r\n                fnState.parentCallExpr = node;\r\n                this._execStack.states.push(fnState);\r\n                fnState.context.currentFunctionName = fn.name;\r\n\r\n                if (this._shouldExecuteNextCommand()) {\r\n                    continue;\r\n                }\r\n                return true;\r\n            } else if (command instanceof StatementCommand) {\r\n                const node = command.node;\r\n                if (stepInto && node instanceof AST.Call) {\r\n                    const fn = state.context.getFunction(node.name);\r\n                    // We want to step into custom functions, not directly execute them\r\n                    if (fn) {\r\n                        const fnState = this._createState(fn.node.body, state.context.clone(), state);\r\n\r\n                        for (let ai = 0; ai < fn.node.args.length; ++ai) {\r\n                            const arg = fn.node.args[ai];\r\n                            const value = this._exec.evalExpression(node.args[ai], fnState.context);\r\n                            fnState.context.createVariable(arg.name, value, arg);\r\n                        }\r\n\r\n                        this._execStack.states.push(fnState);\r\n                        fnState.context.currentFunctionName = fn.name;\r\n\r\n                        if (this._shouldExecuteNextCommand()) {\r\n                            continue;\r\n                        }\r\n                        return true;\r\n                    }\r\n                }\r\n\r\n                const res = this._exec.execStatement(node, state.context);\r\n                if (res !== null && res !== undefined && !(res instanceof VoidData)) {\r\n                    let s = state;\r\n                    // Find the CallExpr to store the return value in.\r\n                    while (s) {\r\n                        if (s.parentCallExpr) {\r\n                            s.parentCallExpr.setCachedReturnValue(res);\r\n                            break;\r\n                        }\r\n                        s = s.parent;\r\n                    }\r\n                    if (s === null) {\r\n                        console.error(\"Could not find CallExpr to store return value in\");\r\n                    }\r\n                    if (this._shouldExecuteNextCommand()) {\r\n                        continue;\r\n                    }\r\n                    return true;\r\n                }\r\n            } else if (command instanceof ContinueTargetCommand) {\r\n                continue;\r\n            } else if (command instanceof BreakTargetCommand) {\r\n                continue;\r\n            } else if (command instanceof ContinueCommand) {\r\n                const targetId = command.id;\r\n                while (!this._execStack.isEmpty) {\r\n                    state = this._execStack.last;\r\n                    for (let i = state.commands.length - 1; i >= 0; --i) {\r\n                        const cmd = state.commands[i];\r\n                        if (cmd instanceof ContinueTargetCommand) {\r\n                            if (cmd.id === targetId) {\r\n                                state.current = i + 1;\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                    // No Goto -1 found (loop), pop the current state and continue searching.\r\n                    this._execStack.pop();\r\n                }\r\n                // If we got here, we've reached the end of the stack and didn't find a -1.\r\n                // That means a continue was used outside of a loop, so we're done.\r\n                console.error(\"Continue statement used outside of a loop\");\r\n                return false;\r\n            } else if (command instanceof BreakCommand) {\r\n                const targetId = command.id;\r\n                // break-if conditional break \r\n                if (command.condition) {\r\n                    const res = this._exec.evalExpression(command.condition, state.context);\r\n                    if (!(res instanceof ScalarData)) {\r\n                        console.error(\"Condition must be a scalar\");\r\n                        return false;\r\n                    }\r\n                    // If the condition is false, then we should not the break.\r\n                    if (!res.value) {\r\n                        if (this._shouldExecuteNextCommand()) {\r\n                            continue;\r\n                        }\r\n                        return true;\r\n                    }\r\n                }\r\n\r\n                while (!this._execStack.isEmpty) {\r\n                    state = this._execStack.last;\r\n                    for (let i = state.commands.length - 1; i >= 0; --i) {\r\n                        const cmd = state.commands[i];\r\n                        if (cmd instanceof BreakTargetCommand) {\r\n                            if (cmd.id === targetId) {\r\n                                state.current = i + 1;\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                    // No Goto -2 found (loop), pop the current state and continue searching.\r\n                    this._execStack.pop();\r\n                }\r\n                // If we got here, we've reached the end of the stack and didn't find a BreakTarget.\r\n                // That means a break was used outside of a loop, so we're done.\r\n                console.error(\"Break statement used outside of a loop\");\r\n                return false;\r\n            } else if (command instanceof GotoCommand) {\r\n                if (command.condition) {\r\n                    const res = this._exec.evalExpression(command.condition, state.context);\r\n                    if (!(res instanceof ScalarData)) {\r\n                        console.error(\"Condition must be a scalar\");\r\n                        return false;\r\n                    }\r\n                    // If the GOTO condition value is true, then continue to the next command.\r\n                    // Otherwise, jump to the specified position.\r\n                    if (res.value) {\r\n                        if (this._shouldExecuteNextCommand()) {\r\n                            continue;\r\n                        }\r\n                        return true;\r\n                    }\r\n                }\r\n                state.current = command.position;\r\n                if (this._shouldExecuteNextCommand()) {\r\n                    continue;\r\n                }\r\n                return true;\r\n            } else if (command instanceof BlockCommand) {\r\n                const blockState = this._createState(command.statements, state.context.clone(), state);\r\n                this._execStack.states.push(blockState);\r\n                continue; // step into the first statement of the block\r\n            }\r\n\r\n            if (state.isAtEnd) {\r\n                this._execStack.pop();\r\n                if (this._execStack.isEmpty) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            if (this._shouldExecuteNextCommand()) {\r\n                continue;\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    _dispatchWorkgroup(f: FunctionRef, workgroup_id: number[], context: ExecContext): boolean {\r\n        const workgroupSize = [1, 1, 1];\r\n        for (const attr of f.node.attributes) {\r\n            if (attr.name === \"workgroup_size\") {\r\n                if (Array.isArray(attr.value)) {\r\n                    if (attr.value.length > 0) {\r\n                        // The value could be an override constant\r\n                        const v = context.getVariableValue(attr.value[0]);\r\n                        if (v instanceof ScalarData) {\r\n                            workgroupSize[0] = v.value;\r\n                        } else {\r\n                            workgroupSize[0] = parseInt(attr.value[0]);\r\n                        }\r\n                    }\r\n                    if (attr.value.length > 1) {\r\n                        const v = context.getVariableValue(attr.value[1]);\r\n                        if (v instanceof ScalarData) {\r\n                            workgroupSize[1] = v.value;\r\n                        } else {\r\n                            workgroupSize[1] = parseInt(attr.value[1]);\r\n                        }\r\n                    }\r\n                    if (attr.value.length > 2) {\r\n                        const v = context.getVariableValue(attr.value[2]);\r\n                        if (v instanceof ScalarData) {\r\n                            workgroupSize[2] = v.value;\r\n                        } else {\r\n                            workgroupSize[2] = parseInt(attr.value[2]);\r\n                        }\r\n                    }\r\n                } else {\r\n                    const v = context.getVariableValue(attr.value);\r\n                    if (v instanceof ScalarData) {\r\n                        workgroupSize[0] = v.value;\r\n                    } else if (v instanceof VectorData) {\r\n                        workgroupSize[0] = v.data[0];\r\n                        workgroupSize[1] = v.data.length > 1 ? v.data[1] : 1;\r\n                        workgroupSize[2] = v.data.length > 2 ? v.data[2] : 1;\r\n                    } else {\r\n                        workgroupSize[0] = parseInt(attr.value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const vec3u = this._exec.typeInfo[\"vec3u\"];\r\n        const u32 = this._exec.typeInfo[\"u32\"];\r\n        context.setVariable(\"@workgroup_size\", new VectorData(workgroupSize, vec3u));\r\n\r\n        const width = workgroupSize[0];\r\n        const height = workgroupSize[1];\r\n        const depth = workgroupSize[2];\r\n\r\n        let found = false;\r\n        for (let z = 0, li = 0; z < depth && !found; ++z) {\r\n            for (let y = 0; y < height && !found; ++y) {\r\n                for (let x = 0; x < width && !found; ++x, ++li) {\r\n                    const local_invocation_id = [x, y, z];\r\n                    const global_invocation_id = [\r\n                        x + workgroup_id[0] * workgroupSize[0],\r\n                        y + workgroup_id[1] * workgroupSize[1],\r\n                        z + workgroup_id[2] * workgroupSize[2]];\r\n\r\n                    context.setVariable(\"@local_invocation_id\", new VectorData(local_invocation_id, vec3u));\r\n                    context.setVariable(\"@global_invocation_id\", new VectorData(global_invocation_id, vec3u));\r\n                    context.setVariable(\"@local_invocation_index\", new ScalarData(li, u32));\r\n\r\n                    if (global_invocation_id[0] === this._dispatchId[0] &&\r\n                        global_invocation_id[1] === this._dispatchId[1] &&\r\n                        global_invocation_id[2] === this._dispatchId[2]) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (found) {\r\n            this._dispatchExec(f, context);\r\n        }\r\n\r\n        return found;\r\n    }\r\n\r\n    _dispatchExec(f: FunctionRef, context: ExecContext) {\r\n        // Update any built-in input args.\r\n        // TODO: handle input structs.\r\n        for (const arg of f.node.args) {\r\n            for (const attr of arg.attributes) {\r\n                if (attr.name === \"builtin\") {\r\n                    const globalName = `@${attr.value}`;\r\n                    const globalVar = context.getVariable(globalName);\r\n                    if (globalVar !== null) {\r\n                        context.variables.set(arg.name, globalVar);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const state = this._createState(f.node.body, context);\r\n        this._execStack.states.push(state);\r\n    }\r\n\r\n    _createState(ast: AST.Node[], context: ExecContext, parent?: StackFrame): StackFrame {\r\n        const state = new StackFrame(context, parent ?? null);\r\n\r\n        for (const statement of ast) {\r\n            // A statement may have expressions that include function calls.\r\n            // Gather all of the internal function calls from the statement.\r\n            // We can then include them as commands to step through, storing their\r\n            // values with the call node so that when it is evaluated, it uses that\r\n            // already computed value. This allows us to step into the function\r\n            if (statement instanceof AST.Let ||\r\n                statement instanceof AST.Var ||\r\n                statement instanceof AST.Const ||\r\n                statement instanceof AST.Assign) {\r\n                const functionCalls = [];\r\n                this._collectFunctionCalls(statement.value, functionCalls);\r\n                for (const call of functionCalls) {\r\n                    state.commands.push(new CallExprCommand(call, statement));\r\n                }\r\n                state.commands.push(new StatementCommand(statement));\r\n            } else if (statement instanceof AST.Call) {\r\n                const functionCalls = [];\r\n                for (const arg of statement.args) {\r\n                    this._collectFunctionCalls(arg, functionCalls);\r\n                }\r\n                for (const call of functionCalls) {\r\n                    state.commands.push(new CallExprCommand(call, statement));\r\n                }\r\n                state.commands.push(new StatementCommand(statement));\r\n            } else if (statement instanceof AST.Return) {\r\n                const functionCalls = [];\r\n                this._collectFunctionCalls(statement.value, functionCalls);\r\n                for (const call of functionCalls) {\r\n                    state.commands.push(new CallExprCommand(call, statement));\r\n                }\r\n                state.commands.push(new StatementCommand(statement));\r\n            } else if (statement instanceof AST.Increment) {\r\n                state.commands.push(new StatementCommand(statement));\r\n            } else if (statement instanceof AST.Function) {\r\n                const f = new FunctionRef(statement);\r\n                state.context.functions.set(statement.name, f);\r\n                continue;\r\n            } else if (statement instanceof AST.If) {\r\n                const functionCalls = [];\r\n                this._collectFunctionCalls(statement.condition, functionCalls);\r\n                for (const call of functionCalls) {\r\n                    state.commands.push(new CallExprCommand(call, statement));\r\n                }\r\n\r\n                let conditionCmd = new GotoCommand(statement.condition, 0, statement.line);\r\n                state.commands.push(conditionCmd);\r\n                if (statement.body.length > 0) {\r\n                    state.commands.push(new BlockCommand(statement.body));\r\n                }\r\n                const gotoEnd = new GotoCommand(null, 0, statement.line);\r\n                state.commands.push(gotoEnd);\r\n\r\n                for (const elseIf of statement.elseif) {\r\n                    conditionCmd.position = state.commands.length;\r\n\r\n                    const functionCalls = [];\r\n                    this._collectFunctionCalls(elseIf.condition, functionCalls);\r\n                    for (const call of functionCalls) {\r\n                        state.commands.push(new CallExprCommand(call, statement));\r\n                    }\r\n\r\n                    conditionCmd = new GotoCommand(elseIf.condition, 0, elseIf.line);\r\n                    state.commands.push(conditionCmd);\r\n                    if (elseIf.body.length > 0) {\r\n                        state.commands.push(new BlockCommand(elseIf.body));\r\n                    }\r\n                    state.commands.push(gotoEnd);\r\n                }\r\n\r\n                conditionCmd.position = state.commands.length;\r\n                if (statement.else) {\r\n                    state.commands.push(new BlockCommand(statement.else));\r\n                }\r\n\r\n                gotoEnd.position = state.commands.length;\r\n            } else if (statement instanceof AST.Switch) {\r\n                const functionCalls = [];\r\n                this._collectFunctionCalls(statement.condition, functionCalls);\r\n                for (const call of functionCalls) {\r\n                    state.commands.push(new CallExprCommand(call, statement));\r\n                }\r\n\r\n                let defaultCase: AST.SwitchCase | null = null;\r\n                for (const c of statement.cases) {\r\n                    if (c instanceof AST.Default) {\r\n                        defaultCase = c;\r\n                        break;\r\n                    } else if (c instanceof AST.Case) {\r\n                        for (const selector of c.selectors) {\r\n                            if (selector instanceof AST.DefaultSelector) {\r\n                                defaultCase = c;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const gotoEndCommands: GotoCommand[] = [];\r\n\r\n                for (const c of statement.cases) {\r\n                    if (c === defaultCase) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (!(c instanceof AST.Case)) {\r\n                        continue;\r\n                    }\r\n\r\n                    let lastCondition = null;\r\n                    for (const selector of c.selectors) {\r\n                        let conditionExpr = new AST.BinaryOperator(\"==\", statement.condition, selector);\r\n                        if (lastCondition) {\r\n                            conditionExpr = new AST.BinaryOperator(\"||\", lastCondition, conditionExpr);\r\n                        }\r\n                        lastCondition = conditionExpr;\r\n                    }\r\n\r\n                    const gotoCommand = new GotoCommand(lastCondition, 0, c.line);\r\n                    state.commands.push(gotoCommand);\r\n\r\n                    if (c.body.length > 0) {\r\n                        state.commands.push(new BlockCommand(c.body));\r\n                    }\r\n\r\n                    const gotoEndCommand = new GotoCommand(null, 0, c.line);\r\n                    gotoEndCommands.push(gotoEndCommand);\r\n                    state.commands.push(gotoEndCommand);\r\n\r\n                    gotoCommand.position = state.commands.length;\r\n                }\r\n\r\n                if (defaultCase) {\r\n                    state.commands.push(new BlockCommand(defaultCase.body));\r\n                }\r\n\r\n                state.commands.push(new BreakTargetCommand(statement.id));\r\n\r\n                const commandPos = state.commands.length;\r\n                for (let i = 0; i < gotoEndCommands.length; ++i) {\r\n                    gotoEndCommands[i].position = commandPos;\r\n                }\r\n            } else if (statement instanceof AST.While) {\r\n                const functionCalls = [];\r\n                state.commands.push(new ContinueTargetCommand(statement.id));\r\n                this._collectFunctionCalls(statement.condition, functionCalls);\r\n                for (const call of functionCalls) {\r\n                    state.commands.push(new CallExprCommand(call, statement));\r\n                }\r\n                const conditionCmd = new GotoCommand(statement.condition, 0, statement.line);\r\n                state.commands.push(conditionCmd);\r\n                let lastLine = statement.line;\r\n\r\n                if (statement.body.length > 0) {\r\n                    state.commands.push(new BlockCommand(statement.body));\r\n                    lastLine = statement.body[statement.body.length - 1].line;\r\n                }\r\n\r\n                state.commands.push(new GotoCommand(statement.condition, 0, lastLine));\r\n                state.commands.push(new BreakTargetCommand(statement.id));\r\n                conditionCmd.position = state.commands.length;\r\n            } else if (statement instanceof AST.For) {\r\n                if (statement.init) {\r\n                    state.commands.push(new StatementCommand(statement.init));\r\n                }\r\n\r\n                let conditionPos = state.commands.length;\r\n\r\n                if (statement.increment === null) {\r\n                    state.commands.push(new ContinueTargetCommand(statement.id));\r\n                }\r\n                let conditionCmd = null;\r\n                if (statement.condition) {\r\n                    const functionCalls = [];\r\n                    this._collectFunctionCalls(statement.condition!, functionCalls);\r\n                    for (const call of functionCalls) {\r\n                        state.commands.push(new CallExprCommand(call, statement));\r\n                    }\r\n                    conditionCmd = new GotoCommand(statement.condition, 0, statement.line);\r\n                    state.commands.push(conditionCmd);\r\n                }\r\n\r\n                let lastLine = statement.line;\r\n                if (statement.body.length > 0) {\r\n                    state.commands.push(new BlockCommand(statement.body));\r\n                    lastLine = statement.body[statement.body.length - 1].line;\r\n                }\r\n\r\n                if (statement.increment) {\r\n                    state.commands.push(new ContinueTargetCommand(statement.id));\r\n                    state.commands.push(new StatementCommand(statement.increment));\r\n                }\r\n                state.commands.push(new GotoCommand(null, conditionPos, lastLine));\r\n                state.commands.push(new BreakTargetCommand(statement.id));\r\n                conditionCmd.position = state.commands.length;\r\n            } else if (statement instanceof AST.Loop) {\r\n                let loopStartPos = state.commands.length;\r\n                if (!statement.continuing) {\r\n                    state.commands.push(new ContinueTargetCommand(statement.id));\r\n                }\r\n                let lastLine = statement.line;\r\n                if (statement.body.length > 0) {\r\n                    state.commands.push(new BlockCommand(statement.body));\r\n                    lastLine = statement.body[statement.body.length - 1].line;\r\n                }\r\n                state.commands.push(new GotoCommand(null, loopStartPos, lastLine));\r\n                state.commands.push(new BreakTargetCommand(statement.id));\r\n            } else if (statement instanceof AST.Continuing) {\r\n                state.commands.push(new ContinueTargetCommand(statement.loopId));\r\n                state.commands.push(new BlockCommand(statement.body));\r\n            } else if (statement instanceof AST.Continue) {\r\n                state.commands.push(new ContinueCommand(statement.loopId, statement));\r\n            } else if (statement instanceof AST.Break) {\r\n                state.commands.push(new BreakCommand(statement.loopId, statement.condition, statement));\r\n            } else if (statement instanceof AST.StaticAssert) {\r\n                state.commands.push(new StatementCommand(statement));\r\n            } else if (statement instanceof AST.Struct) {\r\n                // nothing to do\r\n            } else {\r\n                console.error(`TODO: statement type ${statement.constructor.name}`);\r\n            }\r\n        }\r\n\r\n        return state;\r\n    }\r\n\r\n    _collectFunctionCalls(node: AST.Expression, functionCalls: AST.CallExpr[]) {\r\n        if (node instanceof AST.CallExpr) {\r\n            if (node.args) {\r\n                for (const arg of node.args) {\r\n                    this._collectFunctionCalls(arg, functionCalls);\r\n                }\r\n            }\r\n            // Only collect custom function calls, not built-in functions.\r\n            if (!node.isBuiltin) {\r\n                functionCalls.push(node);\r\n            }\r\n        } else if (node instanceof AST.BinaryOperator) {\r\n            this._collectFunctionCalls(node.left, functionCalls);\r\n            this._collectFunctionCalls(node.right, functionCalls);\r\n        } else if (node instanceof AST.UnaryOperator) {\r\n            this._collectFunctionCalls(node.right, functionCalls);\r\n        } else if (node instanceof AST.CreateExpr) {\r\n            if (node.args) {\r\n                for (const arg of node.args) {\r\n                    this._collectFunctionCalls(arg, functionCalls);\r\n                }\r\n            }\r\n        } else if (node instanceof AST.BitcastExpr) {\r\n            this._collectFunctionCalls(node.value, functionCalls);\r\n        } else if (node instanceof AST.ArrayIndex) {\r\n            this._collectFunctionCalls(node.index, functionCalls);\r\n        } else if (AST.LiteralExpr) {\r\n            // nothing to do\r\n        } else {\r\n            console.error(`TODO: expression type ${node.constructor.name}`);\r\n        }\r\n    }\r\n}\r\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderAttributeType, ShaderLayout, log} from '@luma.gl/core';\nimport {WgslReflect} from 'wgsl_reflect';\n\n/**\n * Parse a ShaderLayout from WGSL shader source code.\n * @param source WGSL source code (can contain both @vertex and @fragment entry points)\n * @returns\n */\nexport function getShaderLayoutFromWGSL(source: string): ShaderLayout {\n  const shaderLayout: ShaderLayout = {attributes: [], bindings: []};\n\n  let parsedWGSL: WgslReflect;\n  try {\n    parsedWGSL = parseWGSL(source);\n  } catch (error: any) {\n    log.error(error.message)();\n    return shaderLayout;\n  }\n\n  for (const uniform of parsedWGSL.uniforms) {\n    const members = [];\n    for (const attribute of (uniform.type as any)?.members || []) {\n      members.push({\n        name: attribute.name,\n        type: getType(attribute.type)\n      });\n    }\n\n    shaderLayout.bindings.push({\n      type: 'uniform',\n      name: uniform.name,\n      group: uniform.group,\n      location: uniform.binding,\n      // @ts-expect-error TODO - unused for now but needs fixing\n      members\n    });\n  }\n\n  for (const texture of parsedWGSL.textures) {\n    shaderLayout.bindings.push({\n      type: 'texture',\n      name: texture.name,\n      group: texture.group,\n      location: texture.binding\n    });\n  }\n\n  for (const sampler of parsedWGSL.samplers) {\n    shaderLayout.bindings.push({\n      type: 'sampler',\n      name: sampler.name,\n      group: sampler.group,\n      location: sampler.binding\n    });\n  }\n\n  const vertex = parsedWGSL.entry.vertex[0]; // \"main\"\n\n  // Vertex shader inputs\n  const attributeCount = vertex?.inputs.length || 0; // inputs to \"main\"\n  for (let i = 0; i < attributeCount; i++) {\n    const wgslAttribute = vertex.inputs[i];\n\n    // locationType can be \"builtin\"\n    if (wgslAttribute.locationType === 'location') {\n      const type = getType(wgslAttribute.type);\n\n      shaderLayout.attributes.push({\n        name: wgslAttribute.name,\n        location: Number(wgslAttribute.location),\n        type\n      });\n    }\n  }\n  return shaderLayout;\n}\n\n/** Get a valid shader attribute type string from a wgsl-reflect type */\nfunction getType(type: any): ShaderAttributeType {\n  return type.format ? `${type.name}<${type.format.name}>` : type.name;\n}\n\nfunction parseWGSL(source: string): WgslReflect {\n  try {\n    return new WgslReflect(source);\n  } catch (error: any) {\n    if (error instanceof Error) {\n      throw error;\n    }\n    let message = 'WGSL parse error';\n    if (typeof error === 'object' && error?.message) {\n      message += `: ${error.message} `;\n    }\n    if (typeof error === 'object' && error?.token) {\n      message += error.token.line || '';\n    }\n    throw new Error(message, {cause: error});\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Forked from THREE.js under MIT license\n// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nimport {clamp} from '@math.gl/core';\n\n/** Pre-calculated tables for float16 conversion */\ntype Float16Tables = {\n  // float32 to float16 helpers\n  baseTable: Uint32Array;\n  shiftTable: Uint32Array;\n  // float16 to float32 helpers\n  mantissaTable: Uint32Array;\n  exponentTable: Uint32Array;\n  offsetTable: Uint32Array;\n};\n\n/**  */\nlet float16Tables: Float16Tables | null = null;\n\n/** Storage that can be viewed both as float and integer */\nconst buffer = new ArrayBuffer(4);\nconst floatView = new Float32Array(buffer);\nconst uint32View = new Uint32Array(buffer);\n\n/**\n * float32 to float16\n * @param val\n * @returns\n */\nexport function toHalfFloat(val: number): number {\n  float16Tables ||= generateFloat16Tables();\n\n  // if ( Math.abs( val ) > 65504 ) console.warn( 'toHalfFloat(): Value out of range.' );\n\n  val = clamp(val, -65504, 65504);\n\n  floatView[0] = val;\n  const f = uint32View[0];\n  const e = (f >> 23) & 0x1ff;\n  return float16Tables.baseTable[e] + ((f & 0x007fffff) >> float16Tables.shiftTable[e]);\n}\n\n/**\n * float16 to float32\n * @param val\n * @returns\n */\nexport function fromHalfFloat(val: number): number {\n  float16Tables ||= generateFloat16Tables();\n\n  const m = val >> 10;\n  uint32View[0] =\n    float16Tables.mantissaTable[float16Tables.offsetTable[m] + (val & 0x3ff)] +\n    float16Tables.exponentTable[m];\n  return floatView[0];\n}\n\nfunction generateFloat16Tables(): Float16Tables {\n  // float32 to float16 helpers\n\n  const baseTable = new Uint32Array(512);\n  const shiftTable = new Uint32Array(512);\n\n  for (let i = 0; i < 256; ++i) {\n    const e = i - 127;\n\n    // very small number (0, -0)\n\n    if (e < -27) {\n      baseTable[i] = 0x0000;\n      baseTable[i | 0x100] = 0x8000;\n      shiftTable[i] = 24;\n      shiftTable[i | 0x100] = 24;\n\n      // small number (denorm)\n    } else if (e < -14) {\n      baseTable[i] = 0x0400 >> (-e - 14);\n      baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n      shiftTable[i] = -e - 1;\n      shiftTable[i | 0x100] = -e - 1;\n\n      // normal number\n    } else if (e <= 15) {\n      baseTable[i] = (e + 15) << 10;\n      baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n      shiftTable[i] = 13;\n      shiftTable[i | 0x100] = 13;\n\n      // large number (Infinity, -Infinity)\n    } else if (e < 128) {\n      baseTable[i] = 0x7c00;\n      baseTable[i | 0x100] = 0xfc00;\n      shiftTable[i] = 24;\n      shiftTable[i | 0x100] = 24;\n\n      // stay (NaN, Infinity, -Infinity)\n    } else {\n      baseTable[i] = 0x7c00;\n      baseTable[i | 0x100] = 0xfc00;\n      shiftTable[i] = 13;\n      shiftTable[i | 0x100] = 13;\n    }\n  }\n\n  // float16 to float32 helpers\n\n  const mantissaTable = new Uint32Array(2048);\n  const exponentTable = new Uint32Array(64);\n  const offsetTable = new Uint32Array(64);\n\n  for (let i = 1; i < 1024; ++i) {\n    let m = i << 13; // zero pad mantissa bits\n    let e = 0; // zero exponent\n\n    // normalized\n    while ((m & 0x00800000) === 0) {\n      m <<= 1;\n      e -= 0x00800000; // decrement exponent\n    }\n\n    m &= ~0x00800000; // clear leading 1 bit\n    e += 0x38800000; // adjust bias\n\n    mantissaTable[i] = m | e;\n  }\n\n  for (let i = 1024; i < 2048; ++i) {\n    mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n  }\n\n  for (let i = 1; i < 31; ++i) {\n    exponentTable[i] = i << 23;\n  }\n\n  exponentTable[31] = 0x47800000;\n  exponentTable[32] = 0x80000000;\n\n  for (let i = 33; i < 63; ++i) {\n    exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n  }\n\n  exponentTable[63] = 0xc7800000;\n\n  for (let i = 1; i < 64; ++i) {\n    if (i !== 32) {\n      offsetTable[i] = 1024;\n    }\n  }\n\n  return {baseTable, shiftTable, mantissaTable, exponentTable, offsetTable};\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumericArray} from '@math.gl/types';\n\n/**\n * Calculate WebGL 64 bit float\n * @param a  - the input float number\n * @param out - the output array. If not supplied, a new array is created.\n * @param startIndex - the index in the output array to fill from. Default 0.\n * @returns - the fp64 representation of the input number\n */\nexport function fp64ify(a: number, out: NumericArray = [], startIndex: number = 0): NumericArray {\n  const hiPart = Math.fround(a);\n  const loPart = a - hiPart;\n  out[startIndex] = hiPart;\n  out[startIndex + 1] = loPart;\n  return out;\n}\n\n/**\n * Calculate the low part of a WebGL 64 bit float\n * @param a the input float number\n * @returns the lower 32 bit of the number\n */\nexport function fp64LowPart(a: number): number {\n  return a - Math.fround(a);\n}\n\n/**\n * Calculate WebGL 64 bit matrix (transposed \"Float64Array\")\n * @param matrix  the input matrix\n * @returns the fp64 representation of the input matrix\n */\nexport function fp64ifyMatrix4(matrix: NumericArray): Float32Array {\n  // Transpose the projection matrix to column major for GLSL.\n  const matrixFP64 = new Float32Array(32);\n  for (let i = 0; i < 4; ++i) {\n    for (let j = 0; j < 4; ++j) {\n      const index = i * 4 + j;\n      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);\n    }\n  }\n  return matrixFP64;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// import {ShaderModule} from '../../types';\n\nconst fp32shader = /* glsl */ `\\\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n\n// All these functions are for substituting tan() function from Intel GPU only\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n\n    // 2pi range reduction\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n`;\n\n/**\n * 32 bit math library (fixups for GPUs)\n */\nexport const fp32 = {\n  name: 'fp32',\n  vs: fp32shader\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const fp64arithmeticShader = /* glsl */ `\\\n\nuniform fp64arithmeticUniforms {\n  uniform float ONE;\n} fp64;\n\n/*\nAbout LUMA_FP64_CODE_ELIMINATION_WORKAROUND\n\nThe purpose of this workaround is to prevent shader compilers from\noptimizing away necessary arithmetic operations by swapping their sequences\nor transform the equation to some 'equivalent' form.\n\nThe method is to multiply an artifical variable, ONE, which will be known to\nthe compiler to be 1 only at runtime. The whole expression is then represented\nas a polynomial with respective to ONE. In the coefficients of all terms, only one a\nand one b should appear\n\nerr = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE\n*/\n\n// Divide float number to high and low floats to extend fraction bits\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float a_hi = t * fp64.ONE - (t - a);\n  float a_lo = a * fp64.ONE - a_hi;\n#else\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n#endif\n  return vec2(a_hi, a_lo);\n}\n\n// Divide float number again when high float uses too many fraction bits\nvec2 split2(vec2 a) {\n  vec2 b = split(a.x);\n  b.y += a.y;\n  return b;\n}\n\n// Special sum operation when a > b\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float sum = (a + b) * fp64.ONE;\n  float err = b - (sum - a) * fp64.ONE;\n#else\n  float sum = a + b;\n  float err = b - (sum - a);\n#endif\n  return vec2(sum, err);\n}\n\n// General sum operation\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * fp64.ONE - a) * fp64.ONE;\n  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * fp64.ONE - a) * fp64.ONE;\n  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *\n    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;\n#else\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\n  return vec2(prod, err);\n}\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  // y component is for the error\n  prod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  prod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\n  vec2 yn = a * xn;\n#endif\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  return sum_fp64(split(yn), prod);\n#else\n  return sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\n\nimport {fp64ify, fp64LowPart, fp64ifyMatrix4} from '../../../modules/math/fp64/fp64-utils';\nimport {fp64arithmeticShader} from './fp64-arithmetic-glsl';\nimport {fp64functionShader} from './fp64-functions-glsl';\n\ntype FP64Props = {};\ntype FP64Uniforms = {ONE: number};\ntype FP64Bindings = {};\n\ntype FP64Utilities = {\n  fp64ify: typeof fp64ify;\n  fp64LowPart: typeof fp64LowPart;\n  fp64ifyMatrix4: typeof fp64ifyMatrix4;\n};\n\nconst defaultUniforms: FP64Uniforms = {\n  // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND\n  ONE: 1.0\n};\n\n/**\n * 64bit arithmetic: add, sub, mul, div (small subset of fp64 module)\n */\nexport const fp64arithmetic: ShaderModule<FP64Props, FP64Uniforms, FP64Bindings> & FP64Utilities = {\n  name: 'fp64arithmetic',\n  vs: fp64arithmeticShader,\n  defaultUniforms,\n  uniformTypes: {ONE: 'f32'},\n\n  // Additional Functions\n  fp64ify,\n  fp64LowPart,\n  fp64ifyMatrix4\n};\n\n/**\n * Full 64 bit math library\n */\nexport const fp64: ShaderModule<{}> & FP64Utilities = {\n  name: 'fp64',\n  vs: fp64functionShader,\n  dependencies: [fp64arithmetic],\n\n  // Additional Functions\n  fp64ify,\n  fp64LowPart,\n  fp64ifyMatrix4\n};\n\nexport {fp64ify, fp64LowPart, fp64ifyMatrix4};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport type {NumberArray3, NumberArray4} from '@math.gl/core';\n\n// cyan color\nconst DEFAULT_HIGHLIGHT_COLOR: NumberArray4 = [0, 1, 1, 1];\n\n/**\n * Props for the picking module, which depending on mode renders picking colors or highlighted item.\n * When active, renders picking colors, assumed to be rendered to off-screen \"picking\" buffer.\n * When inactive, renders normal colors, with the exception of selected object which is rendered with highlight\n */\nexport type PickingProps = {\n  /** Are we picking? I.e. rendering picking colors? */\n  isActive?: boolean;\n  /** Set to true when picking an attribute value instead of object index */\n  isAttribute?: boolean;\n  /** Set to a picking color to visually highlight that item, or `null` to explicitly clear **/\n  highlightedObjectColor?: NumberArray3 | null;\n  /** Color of visual highlight of \"selected\" item */\n  highlightColor?: NumberArray3 | NumberArray4;\n  /** Color range 0-1 or 0-255 */\n  useFloatColors?: boolean;\n};\n\n/**\n * Uniforms for the picking module, which renders picking colors and highlighted item.\n * When active, renders picking colors, assumed to be rendered to off-screen \"picking\" buffer.\n * When inactive, renders normal colors, with the exception of selected object which is rendered with highlight\n */\nexport type PickingUniforms = {\n  /**\n   * When true, renders picking colors. Set when rendering to off-screen \"picking\" buffer.\n   * When false, renders normal colors, with the exception of selected object which is rendered with highlight\n   */\n  isActive?: boolean;\n  /** Set to true when picking an attribute value instead of object index */\n  isAttribute?: boolean;\n  /** Color range 0-1 or 0-255 */\n  useFloatColors?: boolean;\n  /** Do we have a highlighted item? */\n  isHighlightActive?: boolean;\n  /** Set to a picking color to visually highlight that item */\n  highlightedObjectColor?: NumberArray3;\n  /** Color of visual highlight of \"selected\" item */\n  highlightColor?: NumberArray4;\n};\n\nconst vs = /* glsl */ `\\\nuniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n`;\n\nconst fs = /* glsl */ `\\\nuniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n`;\n\n/**\n * Provides support for color-coding-based picking and highlighting.\n * In particular, supports picking a specific instance in an instanced\n * draw call and highlighting an instance based on its picking color,\n * and correspondingly, supports picking and highlighting groups of\n * primitives with the same picking color in non-instanced draw-calls\n */\nexport const picking = {\n  props: {} as PickingProps,\n  uniforms: {} as PickingUniforms,\n\n  name: 'picking',\n\n  uniformTypes: {\n    isActive: 'f32',\n    isAttribute: 'f32',\n    isHighlightActive: 'f32',\n    useFloatColors: 'f32',\n    highlightedObjectColor: 'vec3<f32>',\n    highlightColor: 'vec4<f32>'\n  },\n  defaultUniforms: {\n    isActive: false,\n    isAttribute: false,\n    isHighlightActive: false,\n    useFloatColors: true,\n    highlightedObjectColor: [0, 0, 0],\n    highlightColor: DEFAULT_HIGHLIGHT_COLOR\n  },\n\n  vs,\n  fs,\n  getUniforms\n} as const satisfies ShaderModule<PickingProps, PickingUniforms>;\n\nfunction getUniforms(opts: PickingProps = {}, prevUniforms?: PickingUniforms): PickingUniforms {\n  const uniforms = {} as PickingUniforms;\n\n  if (opts.highlightedObjectColor === undefined) {\n    // Unless highlightedObjectColor explicitly null or set, do not update state\n  } else if (opts.highlightedObjectColor === null) {\n    uniforms.isHighlightActive = false;\n  } else {\n    uniforms.isHighlightActive = true;\n    const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3) as NumberArray3;\n    uniforms.highlightedObjectColor = highlightedObjectColor;\n  }\n\n  if (opts.highlightColor) {\n    const color = Array.from(opts.highlightColor, x => x / 255);\n    if (!Number.isFinite(color[3])) {\n      color[3] = 1;\n    }\n    uniforms.highlightColor = color as NumberArray4;\n  }\n\n  if (opts.isActive !== undefined) {\n    uniforms.isActive = Boolean(opts.isActive);\n    uniforms.isAttribute = Boolean(opts.isAttribute);\n  }\n\n  if (opts.useFloatColors !== undefined) {\n    uniforms.useFloatColors = Boolean(opts.useFloatColors);\n  }\n\n  return uniforms;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const lightingUniformsGLSL = /* glsl */ `\\\nprecision highp int;\n\n// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  vec3 color;\n};\n\nstruct PointLight {\n  vec3 color;\n  vec3 position;\n  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform lightingUniforms {\n  int enabled;\n  int lightType;\n\n  int directionalLightCount;\n  int pointLightCount;\n\n  vec3 ambientColor;\n\n  vec3 lightColor0;\n  vec3 lightPosition0;\n  vec3 lightDirection0;\n  vec3 lightAttenuation0;\n\n  vec3 lightColor1;\n  vec3 lightPosition1;\n  vec3 lightDirection1;\n  vec3 lightAttenuation1;\n\n  vec3 lightColor2;\n  vec3 lightPosition2;\n  vec3 lightDirection2;\n  vec3 lightAttenuation2;\n} lighting;\n\nPointLight lighting_getPointLight(int index) {\n  switch (index) {\n    case 0:\n      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);\n    case 1:\n      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);\n    case 2:\n    default:  \n      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);\n  }\n}\n\nDirectionalLight lighting_getDirectionalLight(int index) {\n  switch (index) {\n    case 0:\n      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);\n    case 1:\n      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);\n    case 2:\n    default:   \n      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);\n  }\n} \n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n// #endif\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const lightingUniformsWGSL = /* wgsl */ `\\\n// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  color: vec3<f32>,\n};\n\nstruct PointLight {\n  color: vec3<f32>,\n  position: vec3<f32>,\n  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  color: vec3<f32>,\n  direction: vec3<f32>,\n};\n\nstruct lightingUniforms {\n  enabled: i32,\n  pointLightCount: i32,\n  directionalLightCount: i32,\n\n  ambientColor: vec3<f32>,\n\n  // TODO - support multiple lights by uncommenting arrays below\n  lightType: i32,\n  lightColor: vec3<f32>,\n  lightDirection: vec3<f32>,\n  lightPosition: vec3<f32>,\n  lightAttenuation: vec3<f32>,\n\n  // AmbientLight ambientLight;\n  // PointLight pointLight[MAX_LIGHTS];\n  // DirectionalLight directionalLight[MAX_LIGHTS];\n};\n\n// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)\n@binding(1) @group(0) var<uniform> lighting : lightingUniforms;\n\nfn lighting_getPointLight(index: i32) -> PointLight {\n  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);\n}\n\nfn lighting_getDirectionalLight(index: i32) -> DirectionalLight {\n  return DirectionalLight(lighting.lightColor, lighting.lightDirection);\n} \n\nfn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log} from '@luma.gl/core';\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport {lightingUniformsGLSL} from './lighting-uniforms-glsl';\nimport {lightingUniformsWGSL} from './lighting-uniforms-wgsl';\nimport type {NumberArray3} from '@math.gl/core';\n\n/** Max number of supported lights (in addition to ambient light */\nconst MAX_LIGHTS = 3;\n\n/** Whether to divide */\nconst COLOR_FACTOR = 255.0;\n\n/** Shader type field for lights */\n// eslint-disable-next-line no-shadow\nexport enum LIGHT_TYPE {\n  POINT = 0,\n  DIRECTIONAL = 1\n}\n\n/** Lighting helper types */\n\nexport type Light = AmbientLight | PointLight | DirectionalLight;\n\nexport type AmbientLight = {\n  type: 'ambient';\n  color?: Readonly<NumberArray3>;\n  intensity?: number;\n};\n\nexport type PointLight = {\n  type: 'point';\n  position: Readonly<NumberArray3>;\n  color?: Readonly<NumberArray3>;\n  intensity?: number;\n  attenuation?: Readonly<NumberArray3>;\n};\n\nexport type DirectionalLight = {\n  type: 'directional';\n  direction: Readonly<NumberArray3>;\n  color?: Readonly<NumberArray3>;\n  intensity?: number;\n};\n\nexport type LightingProps = {\n  enabled?: boolean;\n  lights?: Light[];\n  /** @deprecated */\n  ambientLight?: AmbientLight;\n  /** @deprecated */\n  pointLights?: PointLight[];\n  /** @deprecated */\n  directionalLights?: DirectionalLight[];\n};\n\nexport type LightingUniforms = {\n  enabled: number;\n  ambientLightColor: Readonly<NumberArray3>;\n  directionalLightCount: number;\n  pointLightCount: number;\n  lightType: number; // [];\n  lightColor0: Readonly<NumberArray3>;\n  lightPosition0: Readonly<NumberArray3>;\n  lightDirection0: Readonly<NumberArray3>;\n  lightAttenuation0: Readonly<NumberArray3>;\n  lightColor1: Readonly<NumberArray3>;\n  lightPosition1: Readonly<NumberArray3>;\n  lightDirection1: Readonly<NumberArray3>;\n  lightAttenuation1: Readonly<NumberArray3>;\n  lightColor2: Readonly<NumberArray3>;\n  lightPosition2: Readonly<NumberArray3>;\n  lightDirection2: Readonly<NumberArray3>;\n  lightAttenuation2: Readonly<NumberArray3>;\n};\n\n/** UBO ready lighting module */\nexport const lighting = {\n  props: {} as LightingProps,\n  uniforms: {} as LightingUniforms,\n\n  name: 'lighting',\n\n  defines: {\n    MAX_LIGHTS\n  },\n\n  uniformTypes: {\n    enabled: 'i32',\n    lightType: 'i32',\n\n    directionalLightCount: 'i32',\n    pointLightCount: 'i32',\n\n    ambientLightColor: 'vec3<f32>',\n\n    // TODO define as arrays once we have appropriate uniformTypes\n    lightColor0: 'vec3<f32>',\n    lightPosition0: 'vec3<f32>',\n    // TODO - could combine direction and attenuation\n    lightDirection0: 'vec3<f32>',\n    lightAttenuation0: 'vec3<f32>',\n\n    lightColor1: 'vec3<f32>',\n    lightPosition1: 'vec3<f32>',\n    lightDirection1: 'vec3<f32>',\n    lightAttenuation1: 'vec3<f32>',\n    lightColor2: 'vec3<f32>',\n    lightPosition2: 'vec3<f32>',\n    lightDirection2: 'vec3<f32>',\n    lightAttenuation2: 'vec3<f32>'\n  },\n\n  defaultUniforms: {\n    enabled: 1,\n    lightType: LIGHT_TYPE.POINT,\n\n    directionalLightCount: 0,\n    pointLightCount: 0,\n\n    ambientLightColor: [0.1, 0.1, 0.1],\n    lightColor0: [1, 1, 1],\n    lightPosition0: [1, 1, 2],\n    // TODO - could combine direction and attenuation\n    lightDirection0: [1, 1, 1],\n    lightAttenuation0: [1, 0, 0],\n\n    lightColor1: [1, 1, 1],\n    lightPosition1: [1, 1, 2],\n    lightDirection1: [1, 1, 1],\n    lightAttenuation1: [1, 0, 0],\n    lightColor2: [1, 1, 1],\n    lightPosition2: [1, 1, 2],\n    lightDirection2: [1, 1, 1],\n    lightAttenuation2: [1, 0, 0]\n  },\n  source: lightingUniformsWGSL,\n  vs: lightingUniformsGLSL,\n  fs: lightingUniformsGLSL,\n\n  getUniforms\n} as const satisfies ShaderModule<LightingProps, LightingUniforms, {}>;\n\nfunction getUniforms(\n  props?: LightingProps,\n  prevUniforms: Partial<LightingUniforms> = {}\n): LightingUniforms {\n  // Copy props so we can modify\n  props = props ? {...props} : props;\n\n  // TODO legacy\n  if (!props) {\n    return {...lighting.defaultUniforms};\n  }\n  // Support for array of lights. Type of light is detected by type field\n  if (props.lights) {\n    props = {...props, ...extractLightTypes(props.lights), lights: undefined};\n  }\n\n  // Specify lights separately\n  const {ambientLight, pointLights, directionalLights} = props || {};\n  const hasLights =\n    ambientLight ||\n    (pointLights && pointLights.length > 0) ||\n    (directionalLights && directionalLights.length > 0);\n\n  // TODO - this may not be the correct decision\n  if (!hasLights) {\n    return {...lighting.defaultUniforms, enabled: 0};\n  }\n\n  const uniforms = {\n    ...lighting.defaultUniforms,\n    ...prevUniforms,\n    ...getLightSourceUniforms({ambientLight, pointLights, directionalLights})\n  };\n\n  if (props.enabled !== undefined) {\n    uniforms.enabled = props.enabled ? 1 : 0;\n  }\n\n  return uniforms;\n}\n\nfunction getLightSourceUniforms({\n  ambientLight,\n  pointLights = [],\n  directionalLights = []\n}: LightingProps): Partial<LightingUniforms> {\n  const lightSourceUniforms: Partial<LightingUniforms> = {};\n\n  lightSourceUniforms.ambientLightColor = convertColor(ambientLight);\n\n  let currentLight: 0 | 1 | 2 = 0;\n\n  for (const pointLight of pointLights) {\n    lightSourceUniforms.lightType = LIGHT_TYPE.POINT;\n\n    const i = currentLight as 0 | 1 | 2;\n    lightSourceUniforms[`lightColor${i}`] = convertColor(pointLight);\n    lightSourceUniforms[`lightPosition${i}`] = pointLight.position;\n    lightSourceUniforms[`lightAttenuation${i}`] = pointLight.attenuation || [1, 0, 0];\n    currentLight++;\n  }\n\n  for (const directionalLight of directionalLights) {\n    lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;\n\n    const i = currentLight as 0 | 1 | 2;\n    lightSourceUniforms[`lightColor${i}`] = convertColor(directionalLight);\n    lightSourceUniforms[`lightDirection${i}`] = directionalLight.direction;\n    currentLight++;\n  }\n\n  if (currentLight > MAX_LIGHTS) {\n    log.warn('MAX_LIGHTS exceeded')();\n  }\n\n  lightSourceUniforms.directionalLightCount = directionalLights.length;\n  lightSourceUniforms.pointLightCount = pointLights.length;\n\n  return lightSourceUniforms;\n}\n\nfunction extractLightTypes(lights: Light[]): LightingProps {\n  const lightSources: LightingProps = {pointLights: [], directionalLights: []};\n  for (const light of lights || []) {\n    switch (light.type) {\n      case 'ambient':\n        // Note: Only uses last ambient light\n        // TODO - add ambient light sources on CPU?\n        lightSources.ambientLight = light;\n        break;\n      case 'directional':\n        lightSources.directionalLights?.push(light);\n        break;\n      case 'point':\n        lightSources.pointLights?.push(light);\n        break;\n      default:\n      // eslint-disable-next-line\n      // console.warn(light.type);\n    }\n  }\n  return lightSources;\n}\n\n/** Take color 0-255 and intensity as input and output 0.0-1.0 range */\nfunction convertColor(\n  colorDef: {color?: Readonly<NumberArray3>; intensity?: number} = {}\n): NumberArray3 {\n  const {color = [0, 0, 0], intensity = 1.0} = colorDef;\n  return color.map(component => (component * intensity) / COLOR_FACTOR) as NumberArray3;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const PHONG_VS = /* glsl */ `\\\nuniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n`;\n\nexport const PHONG_FS = /* glsl */ `\\\nuniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n  vec3 halfway_direction = normalize(light_direction + view_direction);\n  float lambertian = dot(light_direction, normal_worldspace);\n  float specular = 0.0;\n  if (lambertian > 0.0) {\n    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, material.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  vec3 view_direction = normalize(cameraPosition - position_worldspace);\n  lightColor = material.ambient * surfaceColor * lighting.ambientColor;\n\n  for (int i = 0; i < lighting.pointLightCount; i++) {\n    PointLight pointLight = lighting_getPointLight(i);\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);\n  }\n\n  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);\n  for (int i = lighting.pointLightCount; i < totalLights; i++) {\n    DirectionalLight directionalLight = lighting_getDirectionalLight(i);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n}\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const PHONG_WGSL = /* wgsl */ `\\\nstruct phongMaterialUniforms {\n  ambient: f32,\n  diffuse: f32,\n  shininess: f32,\n  specularColor: vec3<f32>,\n};\n\n@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;\n\nfn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {\n  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);\n  var lambertian: f32 = dot(light_direction, normal_worldspace);\n  var specular: f32 = 0.0;\n  if (lambertian > 0.0) {\n    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, phongMaterial.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;\n}\n\nfn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {\n  var lightColor: vec3<f32> = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);\n  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;\n\n  if (lighting.lightType == 0) {\n    let pointLight: PointLight  = lighting_getPointLight(0);\n    let light_position_worldspace: vec3<f32> = pointLight.position;\n    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  } else if (lighting.lightType == 1) {\n    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n  /*\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.pointLightCount) {\n      break;\n    }\n    PointLight pointLight = lighting.pointLight[i];\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  }\n\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.directionalLightCount) {\n      break;\n    }\n    DirectionalLight directionalLight = lighting.directionalLight[i];\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  */\n}\n\nfn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{\n  var lightColor = vec3<f32>(0, 0, 0);\n  let surfaceColor = vec3<f32>(0, 0, 0);\n\n  if (lighting.enabled == 0) {\n    let view_direction = normalize(cameraPosition - position_worldspace);\n\n    switch (lighting.lightType) {\n      case 0, default: {\n        let pointLight: PointLight = lighting_getPointLight(0);\n        let light_position_worldspace: vec3<f32> = pointLight.position;\n        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n      }\n      case 1: {\n        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n      }\n    }\n  }\n  return lightColor;\n}\n`;\n\n// TODO - handle multiple lights\n/**\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting.pointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_getPointLight(i);\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting.directionalLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_getDirectionalLight(i);\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n    /**\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting.pointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_getPointLight(i);\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting.directionalLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_getDirectionalLight(i);\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  */\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {NumberArray3} from '@math.gl/types';\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport {lighting} from '../lights/lighting';\nimport {PHONG_VS, PHONG_FS} from '../phong-material/phong-shaders-glsl';\nimport {PHONG_WGSL} from '../phong-material/phong-shaders-wgsl';\n\nexport type GouraudMaterialProps = {\n  ambient?: number;\n  diffuse?: number;\n  /** Specularity exponent */\n  shininess?: number;\n  specularColor?: [number, number, number];\n};\n\n/** In Gouraud shading, color is calculated for each triangle vertex normal, and then color is interpolated colors across the triangle */\nexport const gouraudMaterial: ShaderModule<GouraudMaterialProps> = {\n  props: {} as GouraudMaterialProps,\n\n  name: 'gouraudMaterial',\n  // Note these are switched between phong and gouraud\n  vs: PHONG_FS.replace('phongMaterial', 'gouraudMaterial'),\n  fs: PHONG_VS.replace('phongMaterial', 'gouraudMaterial'),\n  source: PHONG_WGSL.replaceAll('phongMaterial', 'gouraudMaterial'),\n  defines: {\n    LIGHTING_VERTEX: 1\n  },\n  dependencies: [lighting],\n  uniformTypes: {\n    ambient: 'f32',\n    diffuse: 'f32',\n    shininess: 'f32',\n    specularColor: 'vec3<f32>'\n  },\n  defaultUniforms: {\n    ambient: 0.35,\n    diffuse: 0.6,\n    shininess: 32,\n    specularColor: [0.15, 0.15, 0.15]\n  },\n\n  getUniforms(props: GouraudMaterialProps) {\n    const uniforms = {...props};\n    if (uniforms.specularColor) {\n      uniforms.specularColor = uniforms.specularColor.map(x => x / 255) as NumberArray3;\n    }\n    return {...gouraudMaterial.defaultUniforms, ...uniforms};\n  }\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {NumberArray3} from '@math.gl/types';\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport {lighting} from '../lights/lighting';\nimport {PHONG_WGSL} from './phong-shaders-wgsl';\nimport {PHONG_VS, PHONG_FS} from './phong-shaders-glsl';\n\nexport type PhongMaterialProps = {\n  ambient?: number;\n  diffuse?: number;\n  /** Specularity exponent */\n  shininess?: number;\n  specularColor?: NumberArray3;\n};\n\n/** In Phong shading, the normal vector is linearly interpolated across the surface of the polygon from the polygon's vertex normals. */\nexport const phongMaterial: ShaderModule<PhongMaterialProps> = {\n  name: 'phongMaterial',\n  dependencies: [lighting],\n  // Note these are switched between phong and gouraud\n  source: PHONG_WGSL,\n  vs: PHONG_VS,\n  fs: PHONG_FS,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  uniformTypes: {\n    ambient: 'f32',\n    diffuse: 'f32',\n    shininess: 'f32',\n    specularColor: 'vec3<f32>'\n  },\n  defaultUniforms: {\n    ambient: 0.35,\n    diffuse: 0.6,\n    shininess: 32,\n    specularColor: [0.15, 0.15, 0.15]\n  },\n  getUniforms(props?: PhongMaterialProps) {\n    const uniforms = {...props};\n    if (uniforms.specularColor) {\n      uniforms.specularColor = uniforms.specularColor.map(x => x / 255) as NumberArray3;\n    }\n    return {...phongMaterial.defaultUniforms, ...uniforms};\n  }\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const vs = /* glsl */ `\\\nout vec3 pbr_vPosition;\nout vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nout mat3 pbr_vTBN;\n# else\nout vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = pbrProjection.modelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else // HAS_TANGENTS != 1\n  pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Attribution:\n// MIT license, Copyright (c) 2016-2017 Mohamad Moneimne and Contributors\n\n// This fragment shader defines a reference implementation for Physically Based Shading of\n// a microfacet surface material defined by a glTF model.\n\n// TODO - better do the checks outside of shader\n\nexport const fs = /* glsl */ `\\\nprecision highp float;\n\nuniform pbrMaterialUniforms {\n  // Material is unlit\n  bool unlit;\n\n  // Base color map\n  bool baseColorMapEnabled;\n  vec4 baseColorFactor;\n\n  bool normalMapEnabled;  \n  float normalScale; // #ifdef HAS_NORMALMAP\n\n  bool emissiveMapEnabled;\n  vec3 emissiveFactor; // #ifdef HAS_EMISSIVEMAP\n\n  vec2 metallicRoughnessValues;\n  bool metallicRoughnessMapEnabled;\n\n  bool occlusionMapEnabled;\n  float occlusionStrength; // #ifdef HAS_OCCLUSIONMAP\n  \n  bool alphaCutoffEnabled;\n  float alphaCutoff; // #ifdef ALPHA_CUTOFF\n  \n  // IBL\n  bool IBLenabled;\n  vec2 scaleIBLAmbient; // #ifdef USE_IBL\n  \n  // debugging flags used for shader output of intermediate PBR variables\n  // #ifdef PBR_DEBUG\n  vec4 scaleDiffBaseMR;\n  vec4 scaleFGDSpec;\n  // #endif\n} pbrMaterial;\n\n// Samplers\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D pbr_baseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D pbr_normalSampler;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D pbr_emissiveSampler;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D pbr_metallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D pbr_occlusionSampler;\n#endif\n#ifdef USE_IBL\nuniform samplerCube pbr_diffuseEnvSampler;\nuniform samplerCube pbr_specularEnvSampler;\nuniform sampler2D pbr_brdfLUT;\n#endif\n\n// Inputs from vertex shader\n\nin vec3 pbr_vPosition;\nin vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nin mat3 pbr_vTBN;\n#else\nin vec3 pbr_vNormal;\n#endif\n#endif\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo {\n  float NdotL;                  // cos angle between normal and light direction\n  float NdotV;                  // cos angle between normal and view direction\n  float NdotH;                  // cos angle between normal and half vector\n  float LdotH;                  // cos angle between light direction and half vector\n  float VdotH;                  // cos angle between view direction and half vector\n  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n  float metalness;              // metallic value at the surface\n  vec3 reflectance0;            // full reflectance color (normal incidence angle)\n  vec3 reflectance90;           // reflectance color at grazing angle\n  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n  vec3 diffuseColor;            // color contribution from diffuse lighting\n  vec3 specularColor;           // color contribution from specular lighting\n  vec3 n;                       // normal at surface point\n  vec3 v;                       // vector from surface point to camera\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else // SRGB_FAST_APPROXIMATION\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif //SRGB_FAST_APPROXIMATION\n  return vec4(linOut,srgbIn.w);;\n#else //MANUAL_SRGB\n  return srgbIn;\n#endif //MANUAL_SRGB\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n  // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else // HAS_TANGENTS\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));\n#else\n  // The tbn matrix is linearly interpolated, so we need to re-normalize\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0; // resolution of 512x512\n  float lod = (pbrInfo.perceptualRoughness * mipCount);\n  // retrieve a scale and bias to F0. See [1], Figure 3\n  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,\n    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;\n  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);\n\n  // For presentation, this allows us to disable IBL terms\n  diffuse *= pbrMaterial.scaleIBLAmbient.x;\n  specular *= pbrMaterial.scaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n// Basic Lambertian diffuse\n// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog\n// See also [1], Equation 1\nvec3 diffuse(PBRInfo pbrInfo)\n{\n  return pbrInfo.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(PBRInfo pbrInfo)\n{\n  return pbrInfo.reflectance0 +\n    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *\n    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);\n}\n\n// This calculates the specular geometric attenuation (aka G()),\n// where rougher material will reflect less light back to the viewer.\n// This implementation is based on [1] Equation 4, and we adopt their modifications to\n// alphaRoughness as input as originally proposed in [2].\nfloat geometricOcclusion(PBRInfo pbrInfo)\n{\n  float NdotL = pbrInfo.NdotL;\n  float NdotV = pbrInfo.NdotV;\n  float r = pbrInfo.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n// The following equation(s) model the distribution of microfacet normals across\n// the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface\n// for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes\n// from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(PBRInfo pbrInfo)\n{\n  float roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;\n  float f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInfo) {\n  pbrInfo.NdotL = 1.0;\n  pbrInfo.NdotH = 0.0;\n  pbrInfo.LdotH = 0.0;\n  pbrInfo.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInfo, vec3 lightDirection) {\n  vec3 n = pbrInfo.n;\n  vec3 v = pbrInfo.v;\n  vec3 l = normalize(lightDirection);             // Vector from surface point to light\n  vec3 h = normalize(l+v);                        // Half vector between both l and v\n\n  pbrInfo.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInfo, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInfo, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInfo, vec3 lightColor) {\n  // Calculate the shading terms for the microfacet specular shading model\n  vec3 F = specularReflection(pbrInfo);\n  float G = geometricOcclusion(pbrInfo);\n  float D = microfacetDistribution(pbrInfo);\n\n  // Calculation of analytical lighting contribution\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInfo);\n  vec3 specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);\n  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n  // The albedo may be defined from a base texture or a flat color\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture(pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;\n#else\n  vec4 baseColor = pbrMaterial.baseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < pbrMaterial.alphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbrMaterial.unlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    float perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;\n    float metallic = pbrMaterial.metallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    vec4 mrSample = texture(pbr_metallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    // For typical incident reflectance range (between 4% to 100%) set the grazing\n    // reflectance to 100% for typical fresnel effect.\n    // For very low reflectance range on highly diffuse objects (below 4%),\n    // incrementally reduce grazing reflecance to 0%.\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();                          // normal at surface point\n    vec3 v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInfo = PBRInfo(\n      0.0, // NdotL\n      NdotV,\n      0.0, // NdotH\n      0.0, // LdotH\n      0.0, // VdotH\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n\n#ifdef USE_LIGHTS\n    // Apply ambient light\n    PBRInfo_setAmbientLight(pbrInfo);\n    color += calculateFinalColor(pbrInfo, lighting.ambientColor);\n\n    // Apply directional light\n    for(int i = 0; i < lighting.directionalLightCount; i++) {\n      if (i < lighting.directionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInfo, lighting_getDirectionalLight(i).direction);\n        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);\n      }\n    }\n\n    // Apply point light\n    for(int i = 0; i < lighting.pointLightCount; i++) {\n      if (i < lighting.pointLightCount) {\n        PBRInfo_setPointLight(pbrInfo, lighting_getPointLight(i));\n        float attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));\n        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);\n      }\n    }\n#endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n    if (pbrMaterial.IBLenabled) {\n      color += getIBLContribution(pbrInfo, n, reflection);\n    }\n#endif\n\n // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSIONMAP\n    if (pbrMaterial.occlusionMapEnabled) {\n      float ao = texture(pbr_occlusionSampler, pbr_vUV).r;\n      color = mix(color, color * ao, pbrMaterial.occlusionStrength);\n    }\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    if (pbrMaterial.emissiveMapEnabled) {\n      vec3 emissive = SRGBtoLINEAR(texture(pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;\n      color += emissive;\n    }\n#endif\n\n    // This section uses mix to override final color for reference app visualization\n    // of various parameters in the lighting equation.\n#ifdef PBR_DEBUG\n    // TODO: Figure out how to debug multiple lights\n\n    // color = mix(color, F, pbr_scaleFGDSpec.x);\n    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);\n    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);\n    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);\n\n    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);\n    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), pbrMaterial.scaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable camelcase */\n\nimport type {NumberArray3, NumberArray16} from '@math.gl/core';\n\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\n\nconst uniformBlock = /* glsl */ `\\\nuniform pbrProjectionUniforms {\n  mat4 modelViewProjectionMatrix;\n  mat4 modelMatrix;\n  mat4 normalMatrix;\n  vec3 camera;\n} pbrProjection;\n`;\n\nexport type PBRProjectionProps = {\n  modelViewProjectionMatrix: NumberArray16;\n  modelMatrix: NumberArray16;\n  normalMatrix: NumberArray16;\n  camera: NumberArray3;\n};\n\nexport const pbrProjection: ShaderModule<PBRProjectionProps> = {\n  name: 'pbrProjection',\n  vs: uniformBlock,\n  fs: uniformBlock,\n  // TODO why is this needed?\n  getUniforms: props => props,\n  uniformTypes: {\n    modelViewProjectionMatrix: 'mat4x4<f32>',\n    modelMatrix: 'mat4x4<f32>',\n    normalMatrix: 'mat4x4<f32>',\n    camera: 'vec3<i32>'\n  }\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable camelcase */\n\nimport type {Texture} from '@luma.gl/core';\nimport type {\n  Vector2,\n  Vector3,\n  Vector4,\n  NumberArray2,\n  NumberArray3,\n  NumberArray4\n} from '@math.gl/core';\n\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport {lighting} from '../lights/lighting';\n\nimport {vs} from './pbr-vertex-glsl';\nimport {fs} from './pbr-fragment-glsl';\nimport {pbrProjection} from './pbr-projection';\n\n/** Non-uniform block bindings for pbr module */\nexport type PBRMaterialBindings = {\n  // Samplers\n  pbr_baseColorSampler?: Texture | null; // #ifdef HAS_BASECOLORMAP\n  pbr_normalSampler?: Texture | null; // #ifdef HAS_NORMALMAP\n  pbr_emissiveSampler?: Texture | null; // #ifdef HAS_EMISSIVEMAP\n  pbr_metallicRoughnessSampler?: Texture | null; // #ifdef HAS_METALROUGHNESSMAP\n  pbr_occlusionSampler?: Texture | null; // #ifdef HAS_OCCLUSIONMAP\n\n  // IBL Samplers\n  pbr_diffuseEnvSampler?: Texture | null; // #ifdef USE_IBL (samplerCube)\n  pbr_specularEnvSampler?: Texture | null; // #ifdef USE_IBL (samplerCube)\n  pbr_BrdfLUT?: Texture | null; // #ifdef USE_IBL\n};\n\nexport type PBRMaterialUniforms = {\n  unlit?: boolean;\n\n  // Base color map\n  baseColorMapEnabled?: boolean;\n  baseColorFactor?: Readonly<Vector4 | NumberArray4>;\n\n  normalMapEnabled?: boolean;\n  normalScale?: number; // #ifdef HAS_NORMALMAP\n\n  emissiveMapEnabled?: boolean;\n  emissiveFactor?: Readonly<Vector3 | NumberArray3>; // #ifdef HAS_EMISSIVEMAP\n\n  metallicRoughnessValues?: Readonly<Vector2 | NumberArray2>;\n  metallicRoughnessMapEnabled?: boolean;\n\n  occlusionMapEnabled?: boolean;\n  occlusionStrength?: number; // #ifdef HAS_OCCLUSIONMAP\n\n  alphaCutoffEnabled?: boolean;\n  alphaCutoff?: number; // #ifdef ALPHA_CUTOFF\n\n  // IBL\n  IBLenabled?: boolean;\n  scaleIBLAmbient?: Readonly<Vector2 | NumberArray2>; // #ifdef USE_IBL\n\n  // debugging flags used for shader output of intermediate PBR variables\n  // #ifdef PBR_DEBUG\n  scaleDiffBaseMR?: Readonly<Vector4 | NumberArray4>;\n  scaleFGDSpec?: Readonly<Vector4 | NumberArray4>;\n};\n\nexport type PBRMaterialProps = PBRMaterialBindings & PBRMaterialUniforms;\n\n/**\n * An implementation of PBR (Physically-Based Rendering).\n * Physically Based Shading of a microfacet surface defined by a glTF material.\n */\nexport const pbrMaterial = {\n  props: {} as PBRMaterialProps,\n  uniforms: {} as PBRMaterialUniforms,\n\n  name: 'pbrMaterial',\n  dependencies: [lighting, pbrProjection],\n  vs,\n  fs,\n\n  defines: {\n    LIGHTING_FRAGMENT: 1\n    // TODO defining these as 0 breaks shader\n    // HAS_NORMALMAP: 0\n    // HAS_EMISSIVEMAP: 0,\n    // HAS_OCCLUSIONMAP: 0,\n    // HAS_BASECOLORMAP: 0,\n    // HAS_METALROUGHNESSMAP: 0,\n    // ALPHA_CUTOFF: 0\n    // USE_IBL: 0\n    // PBR_DEBUG: 0\n  },\n  getUniforms: props => props,\n  uniformTypes: {\n    // Material is unlit\n    unlit: 'i32',\n\n    // Base color map\n    baseColorMapEnabled: 'i32',\n    baseColorFactor: 'vec4<f32>',\n\n    normalMapEnabled: 'i32',\n    normalScale: 'f32', // #ifdef HAS_NORMALMAP\n\n    emissiveMapEnabled: 'i32',\n    emissiveFactor: 'vec3<f32>', // #ifdef HAS_EMISSIVEMAP\n\n    metallicRoughnessValues: 'vec2<f32>',\n    metallicRoughnessMapEnabled: 'i32',\n\n    occlusionMapEnabled: 'i32',\n    occlusionStrength: 'f32', // #ifdef HAS_OCCLUSIONMAP\n\n    alphaCutoffEnabled: 'i32',\n    alphaCutoff: 'f32', // #ifdef ALPHA_CUTOFF\n\n    // IBL\n    IBLenabled: 'i32',\n    scaleIBLAmbient: 'vec2<f32>', // #ifdef USE_IBL\n\n    // debugging flags used for shader output of intermediate PBR variables\n    // #ifdef PBR_DEBUG\n    scaleDiffBaseMR: 'vec4<f32>',\n    scaleFGDSpec: 'vec4<f32>'\n  }\n} as const satisfies ShaderModule<PBRMaterialProps, PBRMaterialUniforms, PBRMaterialBindings>;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Vector3, Matrix4} from '@math.gl/core';\nimport {ShaderModule} from '../../lib/shader-module/shader-module';\nimport type {NumberArray3, NumberArray16} from '@math.gl/core';\n\ntype ProjectionProps = {\n  modelMatrix?: Readonly<Matrix4 | NumberArray16>;\n  viewMatrix?: Readonly<Matrix4 | NumberArray16>;\n  projectionMatrix?: Readonly<Matrix4 | NumberArray16>;\n  cameraPositionWorld?: Readonly<Vector3 | NumberArray3>;\n};\n\nconst IDENTITY_MATRIX: NumberArray16 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\nconst DEFAULT_MODULE_OPTIONS: ProjectionProps = {\n  modelMatrix: IDENTITY_MATRIX,\n  viewMatrix: IDENTITY_MATRIX,\n  projectionMatrix: IDENTITY_MATRIX,\n  cameraPositionWorld: [0, 0, 0]\n};\n\nfunction getUniforms(opts: ProjectionProps = DEFAULT_MODULE_OPTIONS, prevUniforms = {}) {\n  // const viewProjectionInverse = viewProjection.invert();\n  // viewInverseMatrix: view.invert(),\n  // viewProjectionInverseMatrix: viewProjectionInverse\n\n  const uniforms: Record<string, any> = {};\n  if (opts.modelMatrix !== undefined) {\n    uniforms.modelMatrix = opts.modelMatrix;\n  }\n  if (opts.viewMatrix !== undefined) {\n    uniforms.viewMatrix = opts.viewMatrix;\n  }\n  if (opts.projectionMatrix !== undefined) {\n    uniforms.projectionMatrix = opts.projectionMatrix;\n  }\n  if (opts.cameraPositionWorld !== undefined) {\n    uniforms.cameraPositionWorld = opts.cameraPositionWorld;\n  }\n\n  // COMPOSITE UNIFORMS\n  if (opts.projectionMatrix !== undefined && opts.viewMatrix !== undefined) {\n    uniforms.viewProjectionMatrix = new Matrix4(opts.projectionMatrix).multiplyRight(\n      opts.viewMatrix\n    );\n  }\n\n  return uniforms;\n}\n\nconst common = /* glsl */ `\\\nvarying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n`;\n\nconst vs = `\\\n${common}\n\n// Unprefixed uniforms\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n`;\n\nconst fs = `\n${common}\\\n`;\n\n/**\n * Projects coordinates\n */\nexport const project = {\n  name: 'project',\n  getUniforms,\n  vs,\n  fs\n} as const satisfies ShaderModule<ProjectionProps, ProjectionProps>;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport type {NumericArray} from '../../../types';\nimport {project} from '../../project/project';\n\n/* eslint-disable camelcase */\n\nexport type DirlightOptions = {\n  lightDirection?: NumericArray;\n};\n\nconst DEFAULT_MODULE_OPTIONS: Required<DirlightOptions> = {\n  lightDirection: new Float32Array([1, 1, 2])\n};\n\nfunction getUniforms(opts: DirlightOptions = DEFAULT_MODULE_OPTIONS): Record<string, any> {\n  const uniforms = {};\n  if (opts.lightDirection) {\n    // @ts-expect-error TODO add types\n    uniforms.dirlight_uLightDirection = opts.lightDirection;\n  }\n  return uniforms;\n}\n\nconst fs = /* glsl */ `\\\nuniform vec3 dirlight_uLightDirection;\n\n/*\n * Returns color attenuated by angle from light source\n */\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n`;\n\n/**\n * Cheap lighting - single directional light, single dot product, one uniform\n */\nexport const dirlight: ShaderModule = {\n  name: 'dirlight',\n  // vs // TODO - reuse normal from geometry module\n  fs,\n  getUniforms,\n  dependencies: [project]\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nconst uidCounters: Record<string, number> = {};\n\n/**\n * Returns a UID.\n * @param id= - Identifier base name\n * @return uid\n **/\nexport function uid(id: string = 'id'): string {\n  uidCounters[id] = uidCounters[id] || 1;\n  const count = uidCounters[id]++;\n  return `${id}-${count}`;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {PrimitiveTopology, BufferLayout} from '@luma.gl/core';\nimport {Device, Buffer, getVertexFormatFromAttribute} from '@luma.gl/core';\nimport type {Geometry} from '../geometry/geometry';\nimport {uid} from '../utils/uid';\n\nexport type GPUGeometryProps = {\n  id?: string;\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology: 'point-list' | 'line-list' | 'line-strip' | 'triangle-list' | 'triangle-strip';\n  /** Auto calculated from attributes if not provided */\n  vertexCount: number;\n  bufferLayout: BufferLayout[];\n  indices?: Buffer | null;\n  attributes: Record<string, Buffer>;\n};\n\nexport class GPUGeometry {\n  readonly id: string;\n  userData: Record<string, unknown> = {};\n\n  /** Determines how vertices are read from the 'vertex' attributes */\n  readonly topology?: PrimitiveTopology;\n  readonly bufferLayout: BufferLayout[] = [];\n\n  readonly vertexCount: number;\n  readonly indices?: Buffer | null;\n  readonly attributes: Record<string, Buffer>;\n\n  constructor(props: GPUGeometryProps) {\n    this.id = props.id || uid('geometry');\n    this.topology = props.topology;\n    this.indices = props.indices || null;\n    this.attributes = props.attributes;\n\n    this.vertexCount = props.vertexCount;\n\n    this.bufferLayout = props.bufferLayout || [];\n\n    if (this.indices) {\n      if (!(this.indices.usage & Buffer.INDEX)) {\n        throw new Error('Index buffer must have INDEX usage');\n      }\n    }\n  }\n\n  destroy(): void {\n    this.indices?.destroy();\n    for (const attribute of Object.values(this.attributes)) {\n      attribute.destroy();\n    }\n  }\n\n  getVertexCount(): number {\n    return this.vertexCount;\n  }\n\n  getAttributes(): Record<string, Buffer> {\n    return this.attributes;\n  }\n\n  getIndexes(): Buffer | null {\n    return this.indices || null;\n  }\n\n  _calculateVertexCount(positions: Buffer): number {\n    // Assume that positions is a fully packed float32x3 buffer\n    const vertexCount = positions.byteLength / 12;\n    return vertexCount;\n  }\n}\n\nexport function makeGPUGeometry(device: Device, geometry: Geometry | GPUGeometry): GPUGeometry {\n  if (geometry instanceof GPUGeometry) {\n    return geometry;\n  }\n\n  const indices = getIndexBufferFromGeometry(device, geometry);\n  const {attributes, bufferLayout} = getAttributeBuffersFromGeometry(device, geometry);\n  return new GPUGeometry({\n    topology: geometry.topology || 'triangle-list',\n    bufferLayout,\n    vertexCount: geometry.vertexCount,\n    indices,\n    attributes\n  });\n}\n\nexport function getIndexBufferFromGeometry(device: Device, geometry: Geometry): Buffer | undefined {\n  if (!geometry.indices) {\n    return undefined;\n  }\n  const data = geometry.indices.value;\n  return device.createBuffer({usage: Buffer.INDEX, data});\n}\n\nexport function getAttributeBuffersFromGeometry(\n  device: Device,\n  geometry: Geometry\n): {attributes: Record<string, Buffer>; bufferLayout: BufferLayout[]; vertexCount: number} {\n  const bufferLayout: BufferLayout[] = [];\n\n  const attributes: Record<string, Buffer> = {};\n  for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {\n    let name: string = attributeName;\n    // TODO Map some GLTF attribute names (is this still needed?)\n    switch (attributeName) {\n      case 'POSITION':\n        name = 'positions';\n        break;\n      case 'NORMAL':\n        name = 'normals';\n        break;\n      case 'TEXCOORD_0':\n        name = 'texCoords';\n        break;\n      case 'COLOR_0':\n        name = 'colors';\n        break;\n    }\n    if (attribute) {\n      attributes[name] = device.createBuffer({\n        data: attribute.value,\n        id: `${attributeName}-buffer`\n      });\n      const {value, size, normalized} = attribute;\n      // @ts-expect-error\n      bufferLayout.push({name, format: getVertexFormatFromAttribute(value, size, normalized)});\n    }\n  }\n\n  const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);\n\n  return {attributes, bufferLayout, vertexCount};\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {RenderPipelineProps, ComputePipelineProps} from '@luma.gl/core';\nimport {Device, RenderPipeline, ComputePipeline} from '@luma.gl/core';\n\nexport type PipelineFactoryProps = RenderPipelineProps;\n\ntype RenderPipelineCacheItem = {pipeline: RenderPipeline; useCount: number};\ntype ComputePipelineCacheItem = {pipeline: ComputePipeline; useCount: number};\n\n/**\n * Efficiently creates / caches pipelines\n */\nexport class PipelineFactory {\n  static defaultProps: Required<PipelineFactoryProps> = {...RenderPipeline.defaultProps};\n\n  /** Get the singleton default pipeline factory for the specified device */\n  static getDefaultPipelineFactory(device: Device): PipelineFactory {\n    device._lumaData.defaultPipelineFactory =\n      device._lumaData.defaultPipelineFactory || new PipelineFactory(device);\n    return device._lumaData.defaultPipelineFactory as PipelineFactory;\n  }\n\n  readonly device: Device;\n  readonly destroyPolicy: 'unused' | 'never';\n\n  private _hashCounter: number = 0;\n  private readonly _hashes: Record<string, number> = {};\n  private readonly _renderPipelineCache: Record<string, RenderPipelineCacheItem> = {};\n  private readonly _computePipelineCache: Record<string, ComputePipelineCacheItem> = {};\n\n  constructor(device: Device) {\n    this.device = device;\n    this.destroyPolicy = device.props._factoryDestroyPolicy;\n  }\n\n  /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */\n  createRenderPipeline(props: RenderPipelineProps): RenderPipeline {\n    const allProps: Required<RenderPipelineProps> = {...RenderPipeline.defaultProps, ...props};\n\n    const hash = this._hashRenderPipeline(allProps);\n\n    if (!this._renderPipelineCache[hash]) {\n      const pipeline = this.device.createRenderPipeline({\n        ...allProps,\n        id: allProps.id ? `${allProps.id}-cached` : undefined\n      });\n      pipeline.hash = hash;\n      this._renderPipelineCache[hash] = {pipeline, useCount: 0};\n    }\n\n    this._renderPipelineCache[hash].useCount++;\n    return this._renderPipelineCache[hash].pipeline;\n  }\n\n  createComputePipeline(props: ComputePipelineProps): ComputePipeline {\n    const allProps: Required<ComputePipelineProps> = {...ComputePipeline.defaultProps, ...props};\n\n    const hash = this._hashComputePipeline(allProps);\n\n    if (!this._computePipelineCache[hash]) {\n      const pipeline = this.device.createComputePipeline({\n        ...allProps,\n        id: allProps.id ? `${allProps.id}-cached` : undefined\n      });\n      pipeline.hash = hash;\n      this._computePipelineCache[hash] = {pipeline, useCount: 0};\n    }\n\n    this._computePipelineCache[hash].useCount++;\n    return this._computePipelineCache[hash].pipeline;\n  }\n\n  release(pipeline: RenderPipeline | ComputePipeline): void {\n    const hash = pipeline.hash;\n    const cache =\n      pipeline instanceof ComputePipeline ? this._computePipelineCache : this._renderPipelineCache;\n    cache[hash].useCount--;\n    if (cache[hash].useCount === 0) {\n      if (this.destroyPolicy === 'unused') {\n        cache[hash].pipeline.destroy();\n        delete cache[hash];\n      }\n    }\n  }\n\n  // PRIVATE\n  private _hashComputePipeline(props: ComputePipelineProps): string {\n    const shaderHash = this._getHash(props.shader.source);\n    return `${shaderHash}`;\n  }\n\n  /** Calculate a hash based on all the inputs for a render pipeline */\n  private _hashRenderPipeline(props: RenderPipelineProps): string {\n    const vsHash = props.vs ? this._getHash(props.vs.source) : 0;\n    const fsHash = props.fs ? this._getHash(props.fs.source) : 0;\n\n    // WebGL specific\n    // const {varyings = [], bufferMode = {}} = props;\n    // const varyingHashes = varyings.map((v) => this._getHash(v));\n    const varyingHash = '-'; // `${varyingHashes.join('/')}B${bufferMode}`\n    const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));\n\n    switch (this.device.type) {\n      case 'webgl':\n        // WebGL is more dynamic\n        return `${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;\n\n      default:\n        // On WebGPU we need to rebuild the pipeline if topology, parameters or bufferLayout change\n        const parameterHash = this._getHash(JSON.stringify(props.parameters));\n        // TODO - Can json.stringify() generate different strings for equivalent objects if order of params is different?\n        // create a deepHash() to deduplicate?\n        return `${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;\n    }\n  }\n\n  private _getHash(key: string): number {\n    if (this._hashes[key] === undefined) {\n      this._hashes[key] = this._hashCounter++;\n    }\n    return this._hashes[key];\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Shader, ShaderProps} from '@luma.gl/core';\n\n/** Manages a cached pool of Shaders for reuse. */\nexport class ShaderFactory {\n  static readonly defaultProps: Required<ShaderProps> = {...Shader.defaultProps};\n\n  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */\n  static getDefaultShaderFactory(device: Device): ShaderFactory {\n    device._lumaData.defaultShaderFactory ||= new ShaderFactory(device);\n    return device._lumaData.defaultShaderFactory as ShaderFactory;\n  }\n\n  public readonly device: Device;\n  readonly destroyPolicy: 'unused' | 'never';\n  private readonly _cache: Record<string, {shader: Shader; useCount: number}> = {};\n\n  /** @internal */\n  constructor(device: Device) {\n    this.device = device;\n    this.destroyPolicy = device.props._factoryDestroyPolicy;\n  }\n\n  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */\n  createShader(props: ShaderProps): Shader {\n    const key = this._hashShader(props);\n\n    let cacheEntry = this._cache[key];\n    if (!cacheEntry) {\n      const shader = this.device.createShader({\n        ...props,\n        id: props.id ? `${props.id}-cached` : undefined\n      });\n      this._cache[key] = cacheEntry = {shader, useCount: 0};\n    }\n\n    cacheEntry.useCount++;\n    return cacheEntry.shader;\n  }\n\n  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */\n  release(shader: Shader): void {\n    const key = this._hashShader(shader);\n    const cacheEntry = this._cache[key];\n    if (cacheEntry) {\n      cacheEntry.useCount--;\n      if (cacheEntry.useCount === 0) {\n        if (this.destroyPolicy === 'unused') {\n          delete this._cache[key];\n          cacheEntry.shader.destroy();\n        }\n      }\n    }\n  }\n\n  // PRIVATE\n\n  private _hashShader(value: Shader | ShaderProps): string {\n    return `${value.stage}:${value.source}`;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderLayout} from '@luma.gl/core';\n\n/**\n * Extracts a table suitable for `console.table()` from a shader layout to assist in debugging.\n * @param layout shader layout\n * @param name app should provide the most meaningful name, usually the model or pipeline name / id.\n * @returns\n */\nexport function getDebugTableForShaderLayout(\n  layout: ShaderLayout,\n  name: string\n): Record<string, Record<string, string>> {\n  const table: Record<string, Record<string, string>> = {};\n\n  const header = 'Values'; // '`Shader Layout for ${name}`;\n\n  if (layout.attributes.length === 0 && !layout.varyings?.length) {\n    return {'No attributes or varyings': {[header]: 'N/A'}};\n  }\n\n  for (const attributeDeclaration of layout.attributes) {\n    if (attributeDeclaration) {\n      const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;\n      table[`in ${glslDeclaration}`] = {[header]: attributeDeclaration.stepMode || 'vertex'};\n    }\n  }\n\n  for (const varyingDeclaration of layout.varyings || []) {\n    const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;\n    table[`out ${glslDeclaration}`] = {[header]: JSON.stringify(varyingDeclaration)};\n  }\n\n  return table;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Framebuffer, Texture} from '@luma.gl/core';\n// import {copyTextureToImage} from '../debug/copy-texture-to-image';\n\n/** Only works with 1st device? */\nlet canvas: HTMLCanvasElement | null = null;\nlet ctx: CanvasRenderingContext2D | null = null;\n// let targetImage: HTMLImageElement | null = null;\n\n/** Debug utility to draw FBO contents onto screen */\n// eslint-disable-next-line\nexport function debugFramebuffer(\n  fbo: Framebuffer | Texture,\n  {\n    id,\n    minimap,\n    opaque,\n    top = '0',\n    left = '0',\n    rgbaScale = 1\n  }: {\n    id: string;\n    minimap?: boolean;\n    opaque?: boolean;\n    top?: string;\n    left?: string;\n    rgbaScale?: number;\n  }\n) {\n  if (!canvas) {\n    canvas = document.createElement('canvas');\n    canvas.id = id;\n    canvas.title = id;\n    canvas.style.zIndex = '100';\n    canvas.style.position = 'absolute';\n    canvas.style.top = top; // ⚠️\n    canvas.style.left = left; // ⚠️\n    canvas.style.border = 'blue 5px solid';\n    canvas.style.transform = 'scaleY(-1)';\n    document.body.appendChild(canvas);\n\n    ctx = canvas.getContext('2d');\n    // targetImage = new Image();\n  }\n\n  // const canvasHeight = (minimap ? 2 : 1) * fbo.height;\n  if (canvas.width !== fbo.width || canvas.height !== fbo.height) {\n    canvas.width = fbo.width / 2;\n    canvas.height = fbo.height / 2;\n    canvas.style.width = '400px';\n    canvas.style.height = '400px';\n  }\n\n  // const image = copyTextureToImage(fbo, {targetMaxHeight: 100, targetImage});\n  // ctx.drawImage(image, 0, 0);\n\n  const color = fbo.device.readPixelsToArrayWebGL(fbo);\n  const imageData = ctx?.createImageData(fbo.width, fbo.height);\n  if (imageData) {\n    // Full map\n    const offset = 0;\n    // if (color.some((v) => v > 0)) {\n    //   console.error('THERE IS NON-ZERO DATA IN THE FBO!');\n    // }\n    for (let i = 0; i < color.length; i += 4) {\n      imageData.data[offset + i + 0] = color[i + 0] * rgbaScale;\n      imageData.data[offset + i + 1] = color[i + 1] * rgbaScale;\n      imageData.data[offset + i + 2] = color[i + 2] * rgbaScale;\n      imageData.data[offset + i + 3] = opaque ? 255 : color[i + 3] * rgbaScale;\n    }\n    ctx?.putImageData(imageData, 0, 0);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/**\n * Fast partial deep equal for prop.\n *\n * @param a Prop\n * @param b Prop to compare against `a`\n * @param depth Depth to which to recurse in nested Objects/Arrays. Use 0 (default) for shallow comparison, -1 for infinite depth\n */\n/* eslint-disable complexity */\nexport function deepEqual(a: any, b: any, depth: number): boolean {\n  if (a === b) {\n    return true;\n  }\n  if (!depth || !a || !b) {\n    return false;\n  }\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b) || a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i], depth - 1)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (Array.isArray(b)) {\n    return false;\n  }\n  if (typeof a === 'object' && typeof b === 'object') {\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n    for (const key of aKeys) {\n      if (!b.hasOwnProperty(key)) {\n        return false;\n      }\n      if (!deepEqual(a[key], b[key], depth - 1)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TypedArray, NumericArray, NumberArray} from './array-types';\n\n/**\n * Check is an array is a typed array\n * @param value value to be tested\n * @returns input with type narrowed to TypedArray, or null\n */\nexport function isTypedArray(value: unknown): value is TypedArray {\n  return ArrayBuffer.isView(value) && !(value instanceof DataView);\n}\n\n/**\n * Check is an array is an array of numbers)\n * @param value value to be tested\n * @returns input with type narrowed to NumberArray, or null\n */\nexport function isNumberArray(value: unknown): value is NumberArray {\n  if (Array.isArray(value)) {\n    return value.length === 0 || typeof value[0] === 'number';\n  }\n  return false;\n}\n\n/**\n * Check is an array is a numeric array (typed array or array of numbers)\n * @param value value to be tested\n * @returns input with type narrowed to NumericArray, or null\n */\nexport function isNumericArray(value: unknown): value is NumericArray {\n  return isTypedArray(value) || isNumberArray(value);\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {UniformValue, Binding} from '@luma.gl/core';\nimport {isNumericArray} from '@math.gl/types';\n\nexport function isUniformValue(value: unknown): value is UniformValue {\n  return isNumericArray(value) || typeof value === 'number' || typeof value === 'boolean';\n}\n\ntype UniformsAndBindings = {\n  bindings: Record<string, Binding>;\n  uniforms: Record<string, UniformValue>;\n};\n\nexport function splitUniformsAndBindings(\n  uniforms: Record<string, Binding | UniformValue>\n): UniformsAndBindings {\n  const result: UniformsAndBindings = {bindings: {}, uniforms: {}};\n  Object.keys(uniforms).forEach(name => {\n    const uniform = uniforms[name];\n    if (isUniformValue(uniform)) {\n      result.uniforms[name] = uniform;\n    } else {\n      result.bindings[name] = uniform;\n    }\n  });\n\n  return result;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Binding, UniformValue} from '@luma.gl/core';\nimport {log} from '@luma.gl/core';\n// import type {ShaderUniformType, UniformValue, UniformFormat, UniformInfoDevice, Texture, Sampler} from '@luma.gl/core';\nimport {getShaderModuleDependencies, ShaderModule} from '@luma.gl/shadertools';\nimport {splitUniformsAndBindings} from './model/split-uniforms-and-bindings';\n\nexport type ShaderInputsOptions = {\n  disableWarnings?: boolean;\n};\n\n/**\n * ShaderInputs holds uniform and binding values for one or more shader modules,\n * - It can generate binary data for any uniform buffer\n * - It can manage a uniform buffer for each block\n * - It can update managed uniform buffers with a single call\n * - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.\n */\nexport class ShaderInputs<\n  ShaderPropsT extends Partial<Record<string, Record<string, unknown>>> = Partial<\n    Record<string, Record<string, unknown>>\n  >\n> {\n  options: Required<ShaderInputsOptions> = {\n    disableWarnings: false\n  };\n\n  /**\n   * The map of modules\n   * @todo should should this include the resolved dependencies?\n   */\n  // @ts-ignore Fix typings\n  modules: Readonly<{[P in keyof ShaderPropsT]: ShaderModule<ShaderPropsT[P]>}>;\n\n  /** Stores the uniform values for each module */\n  moduleUniforms: Record<keyof ShaderPropsT, Record<string, UniformValue>>;\n  /** Stores the uniform bindings for each module  */\n  moduleBindings: Record<keyof ShaderPropsT, Record<string, Binding>>;\n  /** Tracks if uniforms have changed */\n  // moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;\n\n  /**\n   * Create a new UniformStore instance\n   * @param modules\n   */\n  constructor(\n    // @ts-ignore Fix typings\n    modules: {[P in keyof ShaderPropsT]?: ShaderModule<ShaderPropsT[P], any>},\n    options?: ShaderInputsOptions\n  ) {\n    Object.assign(this.options, options);\n\n    // Extract modules with dependencies\n    const resolvedModules = getShaderModuleDependencies(\n      Object.values(modules).filter(module => module.dependencies)\n    );\n    for (const resolvedModule of resolvedModules) {\n      // @ts-ignore\n      modules[resolvedModule.name] = resolvedModule;\n    }\n\n    log.log(1, 'Creating ShaderInputs with modules', Object.keys(modules))();\n\n    // Store the module definitions and create storage for uniform values and binding values, per module\n    // @ts-ignore Fix typings\n    this.modules = modules as {[P in keyof ShaderPropsT]: ShaderModule<ShaderPropsT[P]>};\n    this.moduleUniforms = {} as Record<keyof ShaderPropsT, Record<string, UniformValue>>;\n    this.moduleBindings = {} as Record<keyof ShaderPropsT, Record<string, Binding>>;\n\n    // Initialize the modules\n    for (const [name, module] of Object.entries(modules)) {\n      this._addModule(module);\n      if (module.name && name !== module.name && !this.options.disableWarnings) {\n        log.warn(`Module name: ${name} vs ${module.name}`)();\n      }\n    }\n  }\n\n  /** Destroy */\n  destroy(): void {}\n\n  /**\n   * Set module props\n   */\n  setProps(props: Partial<{[P in keyof ShaderPropsT]?: Partial<ShaderPropsT[P]>}>): void {\n    for (const name of Object.keys(props)) {\n      const moduleName = name as keyof ShaderPropsT;\n      const moduleProps = props[moduleName] || {};\n      const module = this.modules[moduleName];\n      if (!module) {\n        // Ignore props for unregistered modules\n        if (!this.options.disableWarnings) {\n          log.warn(`Module ${name} not found`)();\n        }\n        continue; // eslint-disable-line no-continue\n      }\n\n      const oldUniforms = this.moduleUniforms[moduleName] as (typeof module)['uniforms'];\n      const oldBindings = this.moduleBindings[moduleName];\n      const uniformsAndBindings =\n        module.getUniforms?.(moduleProps, oldUniforms) || (moduleProps as any);\n\n      const {uniforms, bindings} = splitUniformsAndBindings(uniformsAndBindings);\n      this.moduleUniforms[moduleName] = {...oldUniforms, ...uniforms};\n      this.moduleBindings[moduleName] = {...oldBindings, ...bindings};\n      // this.moduleUniformsChanged ||= moduleName;\n\n      // console.log(`setProps(${String(moduleName)}`, moduleName, this.moduleUniforms[moduleName])\n    }\n  }\n\n  /**\n   * Return the map of modules\n   * @todo should should this include the resolved dependencies?\n   */\n  getModules(): ShaderModule[] {\n    return Object.values(this.modules);\n  }\n\n  /** Get all uniform values for all modules */\n  getUniformValues(): Partial<Record<keyof ShaderPropsT, Record<string, UniformValue>>> {\n    return this.moduleUniforms;\n  }\n\n  /** Merges all bindings for the shader (from the various modules) */\n  getBindingValues(): Record<string, Binding> {\n    const bindings = {} as Record<string, Binding>;\n    for (const moduleBindings of Object.values(this.moduleBindings)) {\n      Object.assign(bindings, moduleBindings);\n    }\n    return bindings;\n  }\n\n  // INTERNAL\n\n  /** Return a debug table that can be used for console.table() or log.table() */\n  getDebugTable(): Record<string, Record<string, unknown>> {\n    const table: Record<string, Record<string, unknown>> = {};\n    for (const [moduleName, module] of Object.entries(this.moduleUniforms)) {\n      for (const [key, value] of Object.entries(module)) {\n        table[`${moduleName}.${key}`] = {\n          type: this.modules[moduleName].uniformTypes?.[key as keyof ShaderPropsT],\n          value: String(value)\n        };\n      }\n    }\n    return table;\n  }\n\n  _addModule(module: ShaderModule): void {\n    const moduleName = module.name as keyof ShaderPropsT;\n    // Get default uniforms from module\n    this.moduleUniforms[moduleName] = module.defaultUniforms || {};\n    this.moduleBindings[moduleName] = {};\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nlet pathPrefix = '';\n\n/**\n * Set a relative path prefix\n */\nexport function setPathPrefix(prefix: string) {\n  pathPrefix = prefix;\n}\n\n/**\n * Loads ImageBitmap asynchronously. Respects setPathPrefix.\n * image.crossOrigin can be set via opts.crossOrigin, default to 'anonymous'\n * @returns a promise tracking the load\n */\nexport async function loadImageBitmap(\n  url: string,\n  opts?: {crossOrigin?: string} & ImageBitmapOptions\n): Promise<ImageBitmap> {\n  const image = new Image();\n  image.crossOrigin = opts?.crossOrigin || 'anonymous';\n  image.src = url.startsWith('http') ? url : pathPrefix + url;\n  await image.decode();\n  return opts ? await createImageBitmap(image, opts) : await createImageBitmap(image);\n}\n\n/**\n * Loads image asynchronously. Respects setPathPrefix.\n * image.crossOrigin can be set via opts.crossOrigin, default to 'anonymous'\n * @returns a promise tracking the load\n * @deprecated Use `loadImageBitmap()` unless you are supporting old versions of Safari.\n */\nexport async function loadImage(\n  url: string,\n  opts?: {crossOrigin?: string}\n): Promise<HTMLImageElement> {\n  return await new Promise((resolve, reject) => {\n    try {\n      const image = new Image();\n      image.onload = () => resolve(image);\n      image.onerror = () => reject(new Error(`Could not load image ${url}.`));\n      image.crossOrigin = opts?.crossOrigin || 'anonymous';\n      image.src = url.startsWith('http') ? url : pathPrefix + url;\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n", "// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\n\nimport type {\n  Texture,\n  TextureProps,\n  Sampler,\n  TextureView,\n  Device,\n  Texture1DData,\n  Texture2DData,\n  Texture3DData,\n  TextureArrayData,\n  TextureCubeData,\n  TextureCubeArrayData\n} from '@luma.gl/core';\n\nimport {loadImageBitmap} from '../application-utils/load-file';\nimport {uid} from '../utils/uid';\n\nexport type AsyncTextureProps = Omit<TextureProps, 'data'> & AsyncTextureDataProps;\n\ntype AsyncTextureDataProps =\n  | AsyncTexture1DProps\n  | AsyncTexture2DProps\n  | AsyncTexture3DProps\n  | AsyncTextureArrayProps\n  | AsyncTextureCubeProps\n  | AsyncTextureCubeArrayProps;\n\ntype AsyncTexture1DProps = {dimension: '1d'; data: Promise<Texture1DData> | Texture1DData | null};\ntype AsyncTexture2DProps = {dimension?: '2d'; data: Promise<Texture2DData> | Texture2DData | null};\ntype AsyncTexture3DProps = {dimension: '3d'; data: Promise<Texture3DData> | Texture3DData | null};\ntype AsyncTextureArrayProps = {\n  dimension: '2d-array';\n  data: Promise<TextureArrayData> | TextureArrayData | null;\n};\ntype AsyncTextureCubeProps = {\n  dimension: 'cube';\n  data: Promise<TextureCubeData> | TextureCubeData | null;\n};\ntype AsyncTextureCubeArrayProps = {\n  dimension: 'cube-array';\n  data: Promise<TextureCubeArrayData> | TextureCubeArrayData | null;\n};\n\ntype TextureData = TextureProps['data'];\ntype AsyncTextureData = AsyncTextureProps['data'];\n\n/**\n * It is very convenient to be able to initialize textures with promises\n * This can add considerable complexity to the Texture class, and doesn't\n * fit with the immutable nature of WebGPU resources.\n * Instead, luma.gl offers async textures as a separate class.\n */\nexport class AsyncTexture {\n  readonly device: Device;\n  readonly id: string;\n\n  // TODO - should we type these as possibly `null`? It will make usage harder?\n  // @ts-expect-error\n  texture: Texture;\n  // @ts-expect-error\n  sampler: Sampler;\n  // @ts-expect-error\n  view: TextureView;\n\n  readonly ready: Promise<void>;\n  isReady: boolean = false;\n  destroyed: boolean = false;\n\n  protected resolveReady: () => void = () => {};\n  protected rejectReady: (error: Error) => void = () => {};\n\n  get [Symbol.toStringTag]() {\n    return 'AsyncTexture';\n  }\n\n  toString(): string {\n    return `AsyncTexture:\"${this.id}\"(${this.isReady ? 'ready' : 'loading'})`;\n  }\n\n  constructor(device: Device, props: AsyncTextureProps) {\n    this.device = device;\n    this.id = props.id || uid('async-texture');\n    // this.id = typeof props?.data === 'string' ? props.data.slice(-20) : uid('async-texture');\n\n    // Signature: new AsyncTexture(device, {data: url})\n    if (typeof props?.data === 'string' && props.dimension === '2d') {\n      props = {...props, data: loadImageBitmap(props.data)};\n    }\n\n    this.ready = new Promise<void>((resolve, reject) => {\n      this.resolveReady = () => {\n        this.isReady = true;\n        resolve();\n      };\n      this.rejectReady = reject;\n    });\n\n    this.initAsync(props);\n  }\n\n  async initAsync(props: AsyncTextureProps): Promise<void> {\n    const asyncData: AsyncTextureData = props.data;\n    let data: TextureData;\n    try {\n      data = await awaitAllPromises(asyncData);\n    } catch (error) {\n      this.rejectReady(error as Error);\n    }\n\n    // Check that we haven't been destroyed while waiting for texture data to load\n    if (this.destroyed) {\n      return;\n    }\n\n    // Now we can actually create the texture\n    // @ts-expect-error Discriminated union\n    const syncProps: TextureProps = {...props, data};\n\n    this.texture = this.device.createTexture(syncProps);\n    this.sampler = this.texture.sampler;\n    this.view = this.texture.view;\n    this.isReady = true;\n    this.resolveReady();\n  }\n\n  destroy(): void {\n    if (this.texture) {\n      this.texture.destroy();\n      // @ts-expect-error\n      this.texture = null;\n    }\n    this.destroyed = true;\n  }\n\n  /**\n   * Textures are immutable and cannot be resized after creation,\n   * but we can create a similar texture with the same parameters but a new size.\n   * @note Does not copy contents of the texture\n   * @todo Abort pending promise and create a texture with the new size?\n   */\n  resize(size: {width: number; height: number}): boolean {\n    if (!this.isReady) {\n      throw new Error('Cannot resize texture before it is ready');\n    }\n\n    if (size.width === this.texture.width && size.height === this.texture.height) {\n      return false;\n    }\n\n    if (this.texture) {\n      const texture = this.texture;\n      this.texture = texture.clone(size);\n      texture.destroy();\n    }\n    return true;\n  }\n}\n\n// HELPERS\n\n/** Resolve all promises in a nested data structure */\nasync function awaitAllPromises(x: any): Promise<any> {\n  x = await x;\n  if (Array.isArray(x)) {\n    return await Promise.all(x.map(awaitAllPromises));\n  }\n  if (x && typeof x === 'object' && x.constructor === Object) {\n    const object: Record<string, any> = x;\n    const values = await Promise.all(Object.values(object));\n    const keys = Object.keys(object);\n    const resolvedObject: Record<string, any> = {};\n    for (let i = 0; i < keys.length; i++) {\n      resolvedObject[keys[i]] = values[i];\n    }\n    return resolvedObject;\n  }\n  return x;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// A lot of imports, but then Model is where it all comes together...\nimport type {TypedArray} from '@math.gl/types';\nimport type {\n  RenderPipelineProps,\n  RenderPipelineParameters,\n  BufferLayout,\n  Shader,\n  VertexArray,\n  TransformFeedback,\n  AttributeInfo,\n  Binding,\n  UniformValue,\n  PrimitiveTopology\n} from '@luma.gl/core';\nimport {\n  Device,\n  DeviceFeature,\n  Buffer,\n  Texture,\n  TextureView,\n  Sampler,\n  RenderPipeline,\n  RenderPass,\n  UniformStore,\n  log,\n  getTypedArrayFromDataType,\n  getAttributeInfosFromLayouts,\n  _BufferLayoutHelper,\n  sortedBufferLayoutByShaderSourceLocations\n} from '@luma.gl/core';\n\nimport type {ShaderModule, PlatformInfo} from '@luma.gl/shadertools';\nimport {ShaderAssembler, getShaderLayoutFromWGSL} from '@luma.gl/shadertools';\n\nimport type {Geometry} from '../geometry/geometry';\nimport {GPUGeometry, makeGPUGeometry} from '../geometry/gpu-geometry';\nimport {PipelineFactory} from '../factories/pipeline-factory';\nimport {ShaderFactory} from '../factories/shader-factory';\nimport {getDebugTableForShaderLayout} from '../debug/debug-shader-layout';\nimport {debugFramebuffer} from '../debug/debug-framebuffer';\nimport {deepEqual} from '../utils/deep-equal';\nimport {uid} from '../utils/uid';\nimport {ShaderInputs} from '../shader-inputs';\n// import type {AsyncTextureProps} from '../async-texture/async-texture';\nimport {AsyncTexture} from '../async-texture/async-texture';\n\nimport {splitUniformsAndBindings} from './split-uniforms-and-bindings';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\nexport type ModelProps = Omit<RenderPipelineProps, 'vs' | 'fs' | 'bindings'> & {\n  source?: string;\n  vs: string | null;\n  fs: string | null;\n\n  /** shadertool shader modules (added to shader code) */\n  modules?: ShaderModule[];\n  /** Shadertool module defines (configures shader code)*/\n  defines?: Record<string, string | number | boolean>;\n  // TODO - injections, hooks etc?\n\n  /** Shader inputs, used to generated uniform buffers and bindings */\n  shaderInputs?: ShaderInputs;\n  /** Bindings */\n  bindings?: Record<string, Binding | AsyncTexture>;\n  /** Parameters that are built into the pipeline */\n  parameters?: RenderPipelineParameters;\n\n  /** Geometry */\n  geometry?: GPUGeometry | Geometry | null;\n\n  /** @deprecated Use instanced rendering? Will be auto-detected in 9.1 */\n  isInstanced?: boolean;\n  /** instance count */\n  instanceCount?: number;\n  /** Vertex count */\n  vertexCount?: number;\n\n  indexBuffer?: Buffer | null;\n  /** @note this is really a map of buffers, not a map of attributes */\n  attributes?: Record<string, Buffer>;\n  /**   */\n  constantAttributes?: Record<string, TypedArray>;\n\n  /** Some applications intentionally supply unused attributes and bindings, and want to disable warnings */\n  disableWarnings?: boolean;\n\n  /** @internal For use with {@link TransformFeedback}, WebGL only. */\n  varyings?: string[];\n\n  transformFeedback?: TransformFeedback;\n\n  /** Mapped uniforms for shadertool modules */\n  moduleSettings?: Record<string, Record<string, any>>;\n\n  /** Show shader source in browser? */\n  debugShaders?: 'never' | 'errors' | 'warnings' | 'always';\n\n  /** Factory used to create a {@link RenderPipeline}. Defaults to {@link Device} default factory. */\n  pipelineFactory?: PipelineFactory;\n  /** Factory used to create a {@link Shader}. Defaults to {@link Device} default factory. */\n  shaderFactory?: ShaderFactory;\n  /** Shader assembler. Defaults to the ShaderAssembler.getShaderAssembler() */\n  shaderAssembler?: ShaderAssembler;\n};\n\n/**\n * v9 Model API\n * A model\n * - automatically reuses pipelines (programs) when possible\n * - automatically rebuilds pipelines if necessary to accommodate changed settings\n * shadertools integration\n * - accepts modules and performs shader transpilation\n */\nexport class Model {\n  static defaultProps: Required<ModelProps> = {\n    ...RenderPipeline.defaultProps,\n    source: undefined!,\n    vs: null,\n    fs: null,\n    id: 'unnamed',\n    handle: undefined,\n    userData: {},\n    defines: {},\n    modules: [],\n    moduleSettings: undefined!,\n    geometry: null,\n    indexBuffer: null,\n    attributes: {},\n    constantAttributes: {},\n    varyings: [],\n\n    isInstanced: undefined!,\n    instanceCount: 0,\n    vertexCount: 0,\n\n    shaderInputs: undefined!,\n    pipelineFactory: undefined!,\n    shaderFactory: undefined!,\n    transformFeedback: undefined!,\n    shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),\n\n    debugShaders: undefined!,\n    disableWarnings: undefined!\n  };\n\n  readonly device: Device;\n  readonly id: string;\n  // @ts-expect-error assigned in function called from constructor\n  readonly source: string;\n  // @ts-expect-error assigned in function called from constructor\n  readonly vs: string;\n  // @ts-expect-error assigned in function called from constructor\n  readonly fs: string;\n  readonly pipelineFactory: PipelineFactory;\n  readonly shaderFactory: ShaderFactory;\n  userData: {[key: string]: any} = {};\n\n  // Fixed properties (change can trigger pipeline rebuild)\n\n  /** The render pipeline GPU parameters, depth testing etc */\n  parameters: RenderPipelineParameters;\n\n  /** The primitive topology */\n  topology: PrimitiveTopology;\n  /** Buffer layout */\n  bufferLayout: BufferLayout[];\n\n  // Dynamic properties\n\n  /** Use instanced rendering */\n  isInstanced: boolean | undefined = undefined;\n  /** instance count. `undefined` means not instanced */\n  instanceCount: number = 0;\n  /** Vertex count */\n  vertexCount: number;\n\n  /** Index buffer */\n  indexBuffer: Buffer | null = null;\n  /** Buffer-valued attributes */\n  bufferAttributes: Record<string, Buffer> = {};\n  /** Constant-valued attributes */\n  constantAttributes: Record<string, TypedArray> = {};\n  /** Bindings (textures, samplers, uniform buffers) */\n  bindings: Record<string, Binding | AsyncTexture> = {};\n  /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/\n  uniforms: Record<string, UniformValue> = {};\n\n  /**\n   * VertexArray\n   * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!\n   * @todo - allow application to define multiple vertex arrays?\n   * */\n  vertexArray: VertexArray;\n\n  /** TransformFeedback, WebGL 2 only. */\n  transformFeedback: TransformFeedback | null = null;\n\n  /** The underlying GPU \"program\". @note May be recreated if parameters change */\n  pipeline: RenderPipeline;\n\n  /** ShaderInputs instance */\n  // @ts-expect-error Assigned in function called by constructor\n  shaderInputs: ShaderInputs;\n  // @ts-expect-error Assigned in function called by constructor\n  _uniformStore: UniformStore;\n\n  _attributeInfos: Record<string, AttributeInfo> = {};\n  _gpuGeometry: GPUGeometry | null = null;\n  private _getModuleUniforms: (props?: Record<string, Record<string, any>>) => Record<string, any>;\n  private props: Required<ModelProps>;\n\n  _pipelineNeedsUpdate: string | false = 'newly created';\n  private _needsRedraw: string | false = 'initializing';\n  private _destroyed = false;\n\n  /** \"Time\" of last draw. Monotonically increasing timestamp */\n  _lastDrawTimestamp: number = -1;\n\n  get [Symbol.toStringTag](): string {\n    return 'Model';\n  }\n\n  toString(): string {\n    return `Model(${this.id})`;\n  }\n\n  constructor(device: Device, props: ModelProps) {\n    this.props = {...Model.defaultProps, ...props};\n    props = this.props;\n    this.id = props.id || uid('model');\n    this.device = device;\n\n    Object.assign(this.userData, props.userData);\n\n    // Setup shader module inputs\n    const moduleMap = Object.fromEntries(\n      this.props.modules?.map(module => [module.name, module]) || []\n    );\n\n    const shaderInputs =\n      props.shaderInputs ||\n      new ShaderInputs(moduleMap, {disableWarnings: this.props.disableWarnings});\n    // @ts-ignore\n    this.setShaderInputs(shaderInputs);\n\n    // Setup shader assembler\n    const platformInfo = getPlatformInfo(device);\n\n    // Extract modules from shader inputs if not supplied\n    const modules =\n      // @ts-ignore shaderInputs is assigned in setShaderInputs above.\n      (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];\n\n    const isWebGPU = this.device.type === 'webgpu';\n\n    // WebGPU\n    // TODO - hack to support unified WGSL shader\n    // TODO - this is wrong, compile a single shader\n    if (isWebGPU && this.props.source) {\n      // WGSL\n      const {source, getUniforms} = this.props.shaderAssembler.assembleWGSLShader({\n        platformInfo,\n        ...this.props,\n        modules\n      });\n      this.source = source;\n      // @ts-expect-error\n      this._getModuleUniforms = getUniforms;\n      // Extract shader layout after modules have been added to WGSL source, to include any bindings added by modules\n      this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.source);\n    } else {\n      // GLSL\n      const {vs, fs, getUniforms} = this.props.shaderAssembler.assembleGLSLShaderPair({\n        platformInfo,\n        ...this.props,\n        modules\n      });\n\n      this.vs = vs;\n      this.fs = fs;\n      // @ts-expect-error\n      this._getModuleUniforms = getUniforms;\n    }\n\n    this.vertexCount = this.props.vertexCount;\n    this.instanceCount = this.props.instanceCount;\n\n    this.topology = this.props.topology;\n    this.bufferLayout = this.props.bufferLayout;\n    this.parameters = this.props.parameters;\n\n    // Geometry, if provided, sets topology and vertex cound\n    if (props.geometry) {\n      this.setGeometry(props.geometry);\n    }\n\n    this.pipelineFactory =\n      props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);\n    this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);\n\n    // Create the pipeline\n    // @note order is important\n    this.pipeline = this._updatePipeline();\n\n    this.vertexArray = device.createVertexArray({\n      renderPipeline: this.pipeline\n    });\n\n    // Now we can apply geometry attributes\n    if (this._gpuGeometry) {\n      this._setGeometryAttributes(this._gpuGeometry);\n    }\n\n    // Apply any dynamic settings that will not trigger pipeline change\n    if ('isInstanced' in props) {\n      this.isInstanced = props.isInstanced;\n    }\n\n    if (props.instanceCount) {\n      this.setInstanceCount(props.instanceCount);\n    }\n    if (props.vertexCount) {\n      this.setVertexCount(props.vertexCount);\n    }\n    if (props.indexBuffer) {\n      this.setIndexBuffer(props.indexBuffer);\n    }\n    if (props.attributes) {\n      this.setAttributes(props.attributes);\n    }\n    if (props.constantAttributes) {\n      this.setConstantAttributes(props.constantAttributes);\n    }\n    if (props.bindings) {\n      this.setBindings(props.bindings);\n    }\n    if (props.uniforms) {\n      this.setUniformsWebGL(props.uniforms);\n    }\n    if (props.moduleSettings) {\n      // log.warn('Model.props.moduleSettings is deprecated. Use Model.shaderInputs.setProps()')();\n      this.updateModuleSettingsWebGL(props.moduleSettings);\n    }\n    if (props.transformFeedback) {\n      this.transformFeedback = props.transformFeedback;\n    }\n\n    // Catch any access to non-standard props\n    Object.seal(this);\n  }\n\n  destroy(): void {\n    if (this._destroyed) return;\n    this.pipelineFactory.release(this.pipeline);\n    this.shaderFactory.release(this.pipeline.vs);\n    if (this.pipeline.fs) {\n      this.shaderFactory.release(this.pipeline.fs);\n    }\n    this._uniformStore.destroy();\n    // TODO - mark resource as managed and destroyIfManaged() ?\n    this._gpuGeometry?.destroy();\n    this._destroyed = true;\n  }\n\n  // Draw call\n\n  /** Query redraw status. Clears the status. */\n  needsRedraw(): false | string {\n    // Catch any writes to already bound resources\n    if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {\n      this.setNeedsRedraw('contents of bound textures or buffers updated');\n    }\n    const needsRedraw = this._needsRedraw;\n    this._needsRedraw = false;\n    return needsRedraw;\n  }\n\n  /** Mark the model as needing a redraw */\n  setNeedsRedraw(reason: string): void {\n    this._needsRedraw ||= reason;\n  }\n\n  predraw(): void {\n    // Update uniform buffers if needed\n    this.updateShaderInputs();\n    // Check if the pipeline is invalidated\n    this.pipeline = this._updatePipeline();\n  }\n\n  draw(renderPass: RenderPass): boolean {\n    const loadingBinding = this._areBindingsLoading();\n    if (loadingBinding) {\n      log.info(LOG_DRAW_PRIORITY, `>>> DRAWING ABORTED ${this.id}: ${loadingBinding} not loaded`)();\n      return false;\n    }\n\n    try {\n      renderPass.pushDebugGroup(`${this}.predraw(${renderPass})`);\n      this.predraw();\n    } finally {\n      renderPass.popDebugGroup();\n    }\n\n    let drawSuccess: boolean;\n    try {\n      renderPass.pushDebugGroup(`${this}.draw(${renderPass})`);\n      this._logDrawCallStart();\n\n      // Update the pipeline if invalidated\n      // TODO - inside RenderPass is likely the worst place to do this from performance perspective.\n      // Application can call Model.predraw() to avoid this.\n      this.pipeline = this._updatePipeline();\n\n      // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw\n      // Any caching needs to be done inside the pipeline functions\n      // TODO this is a busy initialized check for all bindings every frame\n\n      const syncBindings = this._getBindings();\n      this.pipeline.setBindings(syncBindings, {\n        disableWarnings: this.props.disableWarnings\n      });\n      if (!isObjectEmpty(this.uniforms)) {\n        this.pipeline.setUniformsWebGL(this.uniforms);\n      }\n\n      const {indexBuffer} = this.vertexArray;\n      const indexCount = indexBuffer\n        ? indexBuffer.byteLength / (indexBuffer.indexType === 'uint32' ? 4 : 2)\n        : undefined;\n\n      drawSuccess = this.pipeline.draw({\n        renderPass,\n        vertexArray: this.vertexArray,\n        isInstanced: this.isInstanced,\n        vertexCount: this.vertexCount,\n        instanceCount: this.instanceCount,\n        indexCount,\n        transformFeedback: this.transformFeedback || undefined,\n        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,\n        // so we must provide our unique parameters to each draw\n        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)\n        parameters: this.parameters,\n        topology: this.topology\n      });\n    } finally {\n      renderPass.popDebugGroup();\n      this._logDrawCallEnd();\n    }\n    this._logFramebuffer(renderPass);\n\n    // Update needsRedraw flag\n    if (drawSuccess) {\n      this._lastDrawTimestamp = this.device.timestamp;\n      this._needsRedraw = false;\n    } else {\n      this._needsRedraw = 'waiting for resource initialization';\n    }\n    return drawSuccess;\n  }\n\n  // Update fixed fields (can trigger pipeline rebuild)\n\n  /**\n   * Updates the optional geometry\n   * Geometry, set topology and bufferLayout\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  setGeometry(geometry: GPUGeometry | Geometry | null): void {\n    this._gpuGeometry?.destroy();\n    const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);\n    if (gpuGeometry) {\n      this.setTopology(gpuGeometry.topology || 'triangle-list');\n      const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n      this.bufferLayout = bufferLayoutHelper.mergeBufferLayouts(\n        gpuGeometry.bufferLayout,\n        this.bufferLayout\n      );\n      if (this.vertexArray) {\n        this._setGeometryAttributes(gpuGeometry);\n      }\n    }\n    this._gpuGeometry = gpuGeometry;\n  }\n\n  /**\n   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).\n   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  setTopology(topology: PrimitiveTopology): void {\n    if (topology !== this.topology) {\n      this.topology = topology;\n      this._setPipelineNeedsUpdate('topology');\n    }\n  }\n\n  /**\n   * Updates the buffer layout.\n   * @note Triggers a pipeline rebuild / pipeline cache fetch\n   */\n  setBufferLayout(bufferLayout: BufferLayout[]): void {\n    const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n    this.bufferLayout = this._gpuGeometry\n      ? bufferLayoutHelper.mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout)\n      : bufferLayout;\n    this._setPipelineNeedsUpdate('bufferLayout');\n\n    // Recreate the pipeline\n    this.pipeline = this._updatePipeline();\n\n    // vertex array needs to be updated if we update buffer layout,\n    // but not if we update parameters\n    this.vertexArray = this.device.createVertexArray({\n      renderPipeline: this.pipeline\n    });\n\n    // Reapply geometry attributes to the new vertex array\n    if (this._gpuGeometry) {\n      this._setGeometryAttributes(this._gpuGeometry);\n    }\n  }\n\n  /**\n   * Set GPU parameters.\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch.\n   * @param parameters\n   */\n  setParameters(parameters: RenderPipelineParameters) {\n    if (!deepEqual(parameters, this.parameters, 2)) {\n      this.parameters = parameters;\n      this._setPipelineNeedsUpdate('parameters');\n    }\n  }\n\n  // Update dynamic fields\n\n  /**\n   * Updates the instance count (used in draw calls)\n   * @note Any attributes with stepMode=instance need to be at least this big\n   */\n  setInstanceCount(instanceCount: number): void {\n    this.instanceCount = instanceCount;\n    // luma.gl examples don't set props.isInstanced and rely on auto-detection\n    // but deck.gl sets instanceCount even for models that are not instanced.\n    if (this.isInstanced === undefined && instanceCount > 0) {\n      this.isInstanced = true;\n    }\n    this.setNeedsRedraw('instanceCount');\n  }\n\n  /**\n   * Updates the vertex count (used in draw calls)\n   * @note Any attributes with stepMode=vertex need to be at least this big\n   */\n  setVertexCount(vertexCount: number): void {\n    this.vertexCount = vertexCount;\n    this.setNeedsRedraw('vertexCount');\n  }\n\n  /** Set the shader inputs */\n  setShaderInputs(shaderInputs: ShaderInputs): void {\n    this.shaderInputs = shaderInputs;\n    this._uniformStore = new UniformStore(this.shaderInputs.modules);\n    // Create uniform buffer bindings for all modules that actually have uniforms\n    for (const [moduleName, module] of Object.entries(this.shaderInputs.modules)) {\n      if (shaderModuleHasUniforms(module)) {\n        const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);\n        this.bindings[`${moduleName}Uniforms`] = uniformBuffer;\n      }\n    }\n    this.setNeedsRedraw('shaderInputs');\n  }\n\n  /** Update uniform buffers from the model's shader inputs */\n  updateShaderInputs(): void {\n    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());\n    this.setBindings(this.shaderInputs.getBindingValues());\n    // TODO - this is already tracked through buffer/texture update times?\n    this.setNeedsRedraw('shaderInputs');\n  }\n\n  /**\n   * Sets bindings (textures, samplers, uniform buffers)\n   */\n  setBindings(bindings: Record<string, Binding | AsyncTexture>): void {\n    Object.assign(this.bindings, bindings);\n    this.setNeedsRedraw('bindings');\n  }\n\n  /**\n   * Updates optional transform feedback. WebGL only.\n   */\n  setTransformFeedback(transformFeedback: TransformFeedback | null): void {\n    this.transformFeedback = transformFeedback;\n    this.setNeedsRedraw('transformFeedback');\n  }\n\n  /**\n   * Sets the index buffer\n   * @todo - how to unset it if we change geometry?\n   */\n  setIndexBuffer(indexBuffer: Buffer | null): void {\n    this.vertexArray.setIndexBuffer(indexBuffer);\n    this.setNeedsRedraw('indexBuffer');\n  }\n\n  /**\n   * Sets attributes (buffers)\n   * @note Overrides any attributes previously set with the same name\n   */\n  setAttributes(buffers: Record<string, Buffer>, options?: {disableWarnings?: boolean}): void {\n    const disableWarnings = options?.disableWarnings ?? this.props.disableWarnings;\n    if (buffers.indices) {\n      log.warn(\n        `Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`\n      )();\n    }\n\n    // ensure bufferLayout order matches source layout so we bind\n    // the correct buffers to the correct indices in webgpu.\n    this.bufferLayout = sortedBufferLayoutByShaderSourceLocations(\n      this.pipeline.shaderLayout,\n      this.bufferLayout\n    );\n    const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n\n    // Check if all buffers have a layout\n    for (const [bufferName, buffer] of Object.entries(buffers)) {\n      const bufferLayout = bufferLayoutHelper.getBufferLayout(bufferName);\n      if (!bufferLayout) {\n        if (!disableWarnings) {\n          log.warn(`Model(${this.id}): Missing layout for buffer \"${bufferName}\".`)();\n        }\n        continue; // eslint-disable-line no-continue\n      }\n\n      // In WebGL, for an interleaved attribute we may need to set multiple attributes\n      // but in WebGPU, we set it according to the buffer's position in the vertexArray\n      const attributeNames = bufferLayoutHelper.getAttributeNamesForBuffer(bufferLayout);\n      let set = false;\n      for (const attributeName of attributeNames) {\n        const attributeInfo = this._attributeInfos[attributeName];\n        if (attributeInfo) {\n          const location =\n            this.device.type === 'webgpu'\n              ? bufferLayoutHelper.getBufferIndex(attributeInfo.bufferName)\n              : attributeInfo.location;\n\n          this.vertexArray.setBuffer(location, buffer);\n          set = true;\n        }\n      }\n      if (!set && !disableWarnings) {\n        log.warn(\n          `Model(${this.id}): Ignoring buffer \"${buffer.id}\" for unknown attribute \"${bufferName}\"`\n        )();\n      }\n    }\n    this.setNeedsRedraw('attributes');\n  }\n\n  /**\n   * Sets constant attributes\n   * @note Overrides any attributes previously set with the same name\n   * Constant attributes are only supported in WebGL, not in WebGPU\n   * Any attribute that is disabled in the current vertex array object\n   * is read from the context's global constant value for that attribute location.\n   * @param constantAttributes\n   */\n  setConstantAttributes(\n    attributes: Record<string, TypedArray>,\n    options?: {disableWarnings?: boolean}\n  ): void {\n    for (const [attributeName, value] of Object.entries(attributes)) {\n      const attributeInfo = this._attributeInfos[attributeName];\n      if (attributeInfo) {\n        this.vertexArray.setConstantWebGL(attributeInfo.location, value);\n      } else if (!(options?.disableWarnings ?? this.props.disableWarnings)) {\n        log.warn(\n          `Model \"${this.id}: Ignoring constant supplied for unknown attribute \"${attributeName}\"`\n        )();\n      }\n    }\n    this.setNeedsRedraw('constants');\n  }\n\n  // DEPRECATED METHODS\n\n  /**\n   * Sets individual uniforms\n   * @deprecated WebGL only, use uniform buffers for portability\n   * @param uniforms\n   */\n  setUniforms(uniforms: Record<string, UniformValue>): void {\n    this.setUniformsWebGL(uniforms);\n  }\n\n  /**\n   * Sets individual uniforms\n   * @deprecated WebGL only, use uniform buffers for portability\n   * @param uniforms\n   */\n  setUniformsWebGL(uniforms: Record<string, UniformValue>): void {\n    if (!isObjectEmpty(uniforms)) {\n      this.pipeline.setUniformsWebGL(uniforms);\n      Object.assign(this.uniforms, uniforms);\n    }\n    this.setNeedsRedraw('uniforms');\n  }\n\n  /**\n   * @deprecated Updates shader module settings (which results in uniforms being set)\n   */\n  updateModuleSettingsWebGL(props: Record<string, any>): void {\n    // log.warn('Model.updateModuleSettings is deprecated. Use Model.shaderInputs.setProps()')();\n    const {bindings, uniforms} = splitUniformsAndBindings(this._getModuleUniforms(props));\n    Object.assign(this.bindings, bindings);\n    Object.assign(this.uniforms, uniforms);\n    this.setNeedsRedraw('moduleSettings');\n  }\n\n  // Internal methods\n\n  /** Check that bindings are loaded. Returns id of first binding that is still loading. */\n  _areBindingsLoading(): string | false {\n    for (const binding of Object.values(this.bindings)) {\n      if (binding instanceof AsyncTexture && !binding.isReady) {\n        return binding.id;\n      }\n    }\n    return false;\n  }\n\n  /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */\n  _getBindings(): Record<string, Binding> {\n    const validBindings: Record<string, Binding> = {};\n\n    for (const [name, binding] of Object.entries(this.bindings)) {\n      if (binding instanceof AsyncTexture) {\n        // Check that async textures are loaded\n        if (binding.isReady) {\n          validBindings[name] = binding.texture;\n        }\n      } else {\n        validBindings[name] = binding;\n      }\n    }\n\n    return validBindings;\n  }\n\n  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */\n  _getBindingsUpdateTimestamp(): number {\n    let timestamp = 0;\n    for (const binding of Object.values(this.bindings)) {\n      if (binding instanceof TextureView) {\n        timestamp = Math.max(timestamp, binding.texture.updateTimestamp);\n      } else if (binding instanceof Buffer || binding instanceof Texture) {\n        timestamp = Math.max(timestamp, binding.updateTimestamp);\n      } else if (binding instanceof AsyncTexture) {\n        timestamp = binding.texture\n          ? Math.max(timestamp, binding.texture.updateTimestamp)\n          : // The texture will become available in the future\n            Infinity;\n      } else if (!(binding instanceof Sampler)) {\n        timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);\n      }\n    }\n    return timestamp;\n  }\n\n  /**\n   * Updates the optional geometry attributes\n   * Geometry, sets several attributes, indexBuffer, and also vertex count\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  _setGeometryAttributes(gpuGeometry: GPUGeometry): void {\n    // Filter geometry attribute so that we don't issue warnings for unused attributes\n    const attributes = {...gpuGeometry.attributes};\n    for (const [attributeName] of Object.entries(attributes)) {\n      if (\n        !this.pipeline.shaderLayout.attributes.find(layout => layout.name === attributeName) &&\n        attributeName !== 'positions'\n      ) {\n        delete attributes[attributeName];\n      }\n    }\n\n    // TODO - delete previous geometry?\n    this.vertexCount = gpuGeometry.vertexCount;\n    this.setIndexBuffer(gpuGeometry.indices || null);\n    this.setAttributes(gpuGeometry.attributes, {disableWarnings: true});\n    this.setAttributes(attributes, {disableWarnings: this.props.disableWarnings});\n\n    this.setNeedsRedraw('geometry attributes');\n  }\n\n  /** Mark pipeline as needing update */\n  _setPipelineNeedsUpdate(reason: string): void {\n    this._pipelineNeedsUpdate ||= reason;\n    this.setNeedsRedraw(reason);\n  }\n\n  /** Update pipeline if needed */\n  _updatePipeline(): RenderPipeline {\n    if (this._pipelineNeedsUpdate) {\n      let prevShaderVs: Shader | null = null;\n      let prevShaderFs: Shader | null = null;\n      if (this.pipeline) {\n        log.log(\n          1,\n          `Model ${this.id}: Recreating pipeline because \"${this._pipelineNeedsUpdate}\".`\n        )();\n        prevShaderVs = this.pipeline.vs;\n        prevShaderFs = this.pipeline.fs;\n      }\n\n      this._pipelineNeedsUpdate = false;\n\n      const vs = this.shaderFactory.createShader({\n        id: `${this.id}-vertex`,\n        stage: 'vertex',\n        source: this.source || this.vs,\n        debugShaders: this.props.debugShaders\n      });\n\n      let fs: Shader | null = null;\n      if (this.source) {\n        fs = vs;\n      } else if (this.fs) {\n        fs = this.shaderFactory.createShader({\n          id: `${this.id}-fragment`,\n          stage: 'fragment',\n          source: this.source || this.fs,\n          debugShaders: this.props.debugShaders\n        });\n      }\n\n      this.pipeline = this.pipelineFactory.createRenderPipeline({\n        ...this.props,\n        bufferLayout: this.bufferLayout,\n        topology: this.topology,\n        parameters: this.parameters,\n        // TODO - why set bindings here when we reset them every frame?\n        // Should we expose a BindGroup abstraction?\n        bindings: this._getBindings(),\n        vs,\n        fs\n      });\n\n      this._attributeInfos = getAttributeInfosFromLayouts(\n        this.pipeline.shaderLayout,\n        this.bufferLayout\n      );\n\n      if (prevShaderVs) this.shaderFactory.release(prevShaderVs);\n      if (prevShaderFs) this.shaderFactory.release(prevShaderFs);\n    }\n    return this.pipeline;\n  }\n\n  /** Throttle draw call logging */\n  _lastLogTime = 0;\n  _logOpen = false;\n\n  _logDrawCallStart(): void {\n    // IF level is 4 or higher, log every frame.\n    const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {\n      return;\n    }\n\n    this._lastLogTime = Date.now();\n    this._logOpen = true;\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.level <= 2})();\n  }\n\n  _logDrawCallEnd(): void {\n    if (this._logOpen) {\n      const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);\n\n      // log.table(logLevel, attributeTable)();\n      // log.table(logLevel, uniformTable)();\n      log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();\n\n      const uniformTable = this.shaderInputs.getDebugTable();\n      // Add any global uniforms\n      for (const [name, value] of Object.entries(this.uniforms)) {\n        uniformTable[name] = {value};\n      }\n      log.table(LOG_DRAW_PRIORITY, uniformTable)();\n\n      const attributeTable = this._getAttributeDebugTable();\n      log.table(LOG_DRAW_PRIORITY, this._attributeInfos)();\n      log.table(LOG_DRAW_PRIORITY, attributeTable)();\n\n      log.groupEnd(LOG_DRAW_PRIORITY)();\n      this._logOpen = false;\n    }\n  }\n\n  protected _drawCount = 0;\n  _logFramebuffer(renderPass: RenderPass): void {\n    const debugFramebuffers = this.device.props.debugFramebuffers;\n    this._drawCount++;\n    // Update first 3 frames and then every 60 frames\n    if (!debugFramebuffers) {\n      // } || (this._drawCount++ > 3 && this._drawCount % 60)) {\n      return;\n    }\n    // TODO - display framebuffer output in debug window\n    const framebuffer = renderPass.props.framebuffer;\n    if (framebuffer) {\n      debugFramebuffer(framebuffer, {id: framebuffer.id, minimap: true});\n      // log.image({logLevel: LOG_DRAW_PRIORITY, message: `${framebuffer.id} %c sup?`, image})();\n    }\n  }\n\n  _getAttributeDebugTable(): Record<string, Record<string, unknown>> {\n    const table: Record<string, Record<string, unknown>> = {};\n    for (const [name, attributeInfo] of Object.entries(this._attributeInfos)) {\n      const values = this.vertexArray.attributes[attributeInfo.location];\n      table[attributeInfo.location] = {\n        name,\n        type: attributeInfo.shaderType,\n        values: values\n          ? this._getBufferOrConstantValues(values, attributeInfo.bufferDataType)\n          : 'null'\n      };\n    }\n    if (this.vertexArray.indexBuffer) {\n      const {indexBuffer} = this.vertexArray;\n      const values =\n        indexBuffer.indexType === 'uint32'\n          ? new Uint32Array(indexBuffer.debugData)\n          : new Uint16Array(indexBuffer.debugData);\n      table.indices = {\n        name: 'indices',\n        type: indexBuffer.indexType,\n        values: values.toString()\n      };\n    }\n    return table;\n  }\n\n  // TODO - fix typing of luma data types\n  _getBufferOrConstantValues(attribute: Buffer | TypedArray, dataType: any): string {\n    const TypedArrayConstructor = getTypedArrayFromDataType(dataType);\n    const typedArray =\n      attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;\n    return typedArray.toString();\n  }\n}\n\nfunction shaderModuleHasUniforms(module: ShaderModule): boolean {\n  return Boolean(module.uniformTypes && !isObjectEmpty(module.uniformTypes));\n}\n\n// HELPERS\n\n/** Create a shadertools platform info from the Device */\nexport function getPlatformInfo(device: Device): PlatformInfo {\n  return {\n    type: device.type,\n    shaderLanguage: device.info.shadingLanguage,\n    shaderLanguageVersion: device.info.shadingLanguageVersion as 100 | 300,\n    gpu: device.info.gpu,\n    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API\n    features: device.features as unknown as Set<DeviceFeature>\n  };\n}\n\n/** Returns true if given object is empty, false otherwise. */\nfunction isObjectEmpty(obj: object): boolean {\n  // @ts-ignore key is unused\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const key in obj) {\n    return false;\n  }\n  return true;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Buffer, BufferRange, TransformFeedback, RenderPassProps} from '@luma.gl/core';\nimport {getPassthroughFS} from '@luma.gl/shadertools';\nimport {Model} from '../model/model';\nimport type {ModelProps} from '../model/model';\n\n/**\n * Properties for creating a {@link BufferTransform}\n * @note Only works under WebGL2.\n */\nexport type BufferTransformProps = Omit<ModelProps, 'fs'> & {\n  /** Optional fragment shader - normally not used in transforms */\n  fs?: ModelProps['fs']; // override as optional\n  /** A list of named outputs corresponding to shader declarations (varyings in WebGL) */\n  outputs?: string[];\n  /** @deprecated Use run({outputBuffers}) instead - Map of output buffers that the shaders will write results of computations to */\n  feedbackBuffers?: Record<string, Buffer | BufferRange>;\n};\n\n/**\n * Manages a WebGL program (pipeline) for buffer→buffer transforms.\n * @note Only works under WebGL2.\n */\nexport class BufferTransform {\n  readonly device: Device;\n  readonly model: Model;\n  readonly transformFeedback: TransformFeedback;\n\n  static defaultProps: Required<BufferTransformProps> = {\n    ...Model.defaultProps,\n    outputs: undefined!,\n    feedbackBuffers: undefined!\n  };\n\n  static isSupported(device: Device): boolean {\n    return device?.info?.type === 'webgl';\n  }\n\n  constructor(device: Device, props: BufferTransformProps = BufferTransform.defaultProps) {\n    if (!BufferTransform.isSupported(device)) {\n      throw new Error('BufferTransform not yet implemented on WebGPU');\n    }\n\n    this.device = device;\n\n    this.model = new Model(this.device, {\n      id: props.id || 'buffer-transform-model',\n      fs: props.fs || getPassthroughFS(),\n      topology: props.topology || 'point-list',\n      varyings: props.outputs || props.varyings,\n      ...props\n    });\n\n    this.transformFeedback = this.device.createTransformFeedback({\n      layout: this.model.pipeline.shaderLayout,\n      // @ts-expect-error TODO\n      buffers: props.feedbackBuffers\n    });\n\n    this.model.setTransformFeedback(this.transformFeedback);\n\n    Object.seal(this);\n  }\n\n  /** Destroy owned resources. */\n  destroy(): void {\n    if (this.model) {\n      this.model.destroy();\n    }\n  }\n\n  /** @deprecated Use {@link destroy}. */\n  delete(): void {\n    this.destroy();\n  }\n\n  /** Run one transform loop. */\n  run(\n    options?: RenderPassProps & {\n      inputBuffers?: Record<string, Buffer>;\n      outputBuffers?: Record<string, Buffer>;\n    }\n  ): void {\n    if (options?.inputBuffers) {\n      this.model.setAttributes(options.inputBuffers);\n    }\n    if (options?.outputBuffers) {\n      this.transformFeedback.setBuffers(options.outputBuffers);\n    }\n    const renderPass = this.device.beginRenderPass(options);\n    this.model.draw(renderPass);\n    renderPass.end();\n  }\n\n  // DEPRECATED METHODS\n\n  /** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */\n  getBuffer(varyingName: string): Buffer | BufferRange | null {\n    return this.transformFeedback.getBuffer(varyingName);\n  }\n\n  /** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */\n  readAsync(varyingName: string): Promise<Uint8Array> {\n    const result = this.getBuffer(varyingName);\n    if (!result) {\n      throw new Error('BufferTransform#getBuffer');\n    }\n    if (result instanceof Buffer) {\n      return result.readAsync();\n    }\n    const {buffer, byteOffset = 0, byteLength = buffer.byteLength} = result;\n    return buffer.readAsync(byteOffset, byteLength);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Buffer, Device, Framebuffer, RenderPassProps, Sampler, Texture} from '@luma.gl/core';\nimport {Model, ModelProps} from '../model/model';\nimport {getPassthroughFS} from '@luma.gl/shadertools';\n\n/**\n * Properties for creating a {@link TextureTransform}\n */\nexport type TextureTransformProps = Omit<ModelProps, 'fs'> & {\n  fs?: ModelProps['fs']; // override as optional\n  /** @deprecated TODO(donmccurdy): Needed? */\n  inject?: Record<string, string>;\n  /** @deprecated TODO(donmccurdy): Needed? */\n  framebuffer?: Framebuffer;\n  /** @deprecated TODO(donmccurdy): Model already handles this? */\n  sourceBuffers?: Record<string, Buffer>;\n  /** @deprecated TODO(donmccurdy): Model already handles this? */\n  sourceTextures?: Record<string, Texture>;\n  targetTexture: Texture;\n  targetTextureChannels: 1 | 2 | 3 | 4;\n  targetTextureVarying: string;\n};\n\ntype TextureBinding = {\n  sourceBuffers: Record<string, Buffer>;\n  sourceTextures: Record<string, Texture>;\n  targetTexture: Texture;\n  framebuffer?: Framebuffer;\n};\n\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\n/**\n * Creates a pipeline for texture→texture transforms.\n * @deprecated\n */\nexport class TextureTransform {\n  readonly device: Device;\n  readonly model: Model;\n  readonly sampler: Sampler;\n\n  currentIndex = 0;\n  samplerTextureMap: Record<string, any> | null = null;\n  bindings: TextureBinding[] = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n  resources: Record<string, any> = {}; // resources to be deleted\n\n  constructor(device: Device, props: TextureTransformProps) {\n    this.device = device;\n\n    // For precise picking of element IDs.\n    this.sampler = device.createSampler({\n      addressModeU: 'clamp-to-edge',\n      addressModeV: 'clamp-to-edge',\n      minFilter: 'nearest',\n      magFilter: 'nearest',\n      mipmapFilter: 'nearest'\n    });\n\n    this.model = new Model(this.device, {\n      id: props.id || 'texture-transform-model',\n      fs:\n        props.fs ||\n        getPassthroughFS({\n          input: props.targetTextureVarying,\n          inputChannels: props.targetTextureChannels,\n          output: FS_OUTPUT_VARIABLE\n        }),\n      vertexCount: props.vertexCount, // TODO(donmccurdy): Naming?\n      ...props\n    });\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  destroy(): void {\n    this.model.destroy();\n    for (const binding of this.bindings) {\n      binding.framebuffer?.destroy();\n    }\n  }\n\n  /** @deprecated Use {@link destroy}. */\n  delete(): void {\n    this.destroy();\n  }\n\n  run(options?: RenderPassProps): void {\n    const {framebuffer} = this.bindings[this.currentIndex];\n    const renderPass = this.device.beginRenderPass({framebuffer, ...options});\n    this.model.draw(renderPass);\n    renderPass.end();\n  }\n\n  getTargetTexture(): Texture {\n    const {targetTexture} = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getFramebuffer(): Framebuffer | undefined {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  // Private\n\n  _initialize(props: TextureTransformProps): void {\n    this._updateBindings(props);\n  }\n\n  _updateBindings(props: TextureTransformProps) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], props);\n  }\n\n  _updateBinding(\n    binding: TextureBinding,\n    {sourceBuffers, sourceTextures, targetTexture}: TextureTransformProps\n  ): TextureBinding {\n    if (!binding) {\n      binding = {\n        sourceBuffers: {},\n        sourceTextures: {},\n        // @ts-expect-error\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    Object.assign(binding.sourceBuffers, sourceBuffers);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n      const {width, height} = targetTexture;\n      // TODO(donmccurdy): When is this called, and is this expected?\n      if (binding.framebuffer) {\n        binding.framebuffer.destroy();\n      }\n      binding.framebuffer = this.device.createFramebuffer({\n        id: 'transform-framebuffer',\n        width,\n        height,\n        colorAttachments: [targetTexture]\n      });\n      binding.framebuffer.resize({width, height});\n    }\n    return binding;\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters(): void {\n    const index = this.currentIndex;\n    const {sourceTextures} = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].sampler = this.sampler;\n    }\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TypedArray} from '@math.gl/core';\nimport type {PrimitiveTopology} from '@luma.gl/core';\nimport {uid} from '../utils/uid';\n\nexport type GeometryProps = {\n  id?: string;\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology: 'point-list' | 'line-list' | 'line-strip' | 'triangle-list' | 'triangle-strip';\n  /** Auto calculated from attributes if not provided */\n  vertexCount?: number;\n  attributes: Record<string, GeometryAttribute | TypedArray>;\n  indices?: GeometryAttribute | TypedArray;\n};\n\nexport type GeometryAttributes = {\n  POSITION: GeometryAttribute;\n  NORMAL: GeometryAttribute;\n  TEXCOORD_0: GeometryAttribute;\n  COLOR_0?: GeometryAttribute;\n  indices?: GeometryAttribute & {size: 1; value: Uint32Array | Uint16Array};\n};\n\nexport type GeometryAttribute = {\n  size?: number;\n  value: TypedArray;\n  [key: string]: any;\n};\n\nexport class Geometry {\n  readonly id: string;\n  /** Determines how vertices are read from the 'vertex' attributes */\n  readonly topology?: PrimitiveTopology;\n  readonly vertexCount: number;\n  readonly indices?: GeometryAttribute;\n  readonly attributes: {\n    POSITION: GeometryAttribute;\n    NORMAL: GeometryAttribute;\n    TEXCOORD_0: GeometryAttribute;\n    COLOR_0?: GeometryAttribute;\n    [key: string]: GeometryAttribute | undefined;\n  };\n\n  userData: Record<string, unknown> = {};\n\n  constructor(props: GeometryProps) {\n    const {attributes = {}, indices = null, vertexCount = null} = props;\n\n    this.id = props.id || uid('geometry');\n    this.topology = props.topology;\n\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {value: indices, size: 1} : indices;\n    }\n\n    // @ts-expect-error\n    this.attributes = {};\n\n    for (const [attributeName, attributeValue] of Object.entries(attributes)) {\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      const attribute: GeometryAttribute = ArrayBuffer.isView(attributeValue)\n        ? {value: attributeValue}\n        : attributeValue;\n\n      if (!ArrayBuffer.isView(attribute.value)) {\n        throw new Error(\n          `${this._print(attributeName)}: must be typed array or object with value as typed array`\n        );\n      }\n\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        if (this.indices) {\n          throw new Error('Multiple indices detected');\n        }\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n  }\n\n  getVertexCount(): number {\n    return this.vertexCount;\n  }\n\n  /**\n   * Return an object with all attributes plus indices added as a field.\n   * TODO Geometry types are a mess\n   */\n  getAttributes(): GeometryAttributes {\n    return this.indices ? {indices: this.indices, ...this.attributes} : this.attributes;\n  }\n\n  // PRIVATE\n\n  _print(attributeName: string): string {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n\n  /**\n   * GeometryAttribute\n   * value: typed array\n   * type: indices, vertices, uvs\n   * size: elements per vertex\n   * target: WebGL buffer type (string or constant)\n   *\n   * @param attributes\n   * @param indices\n   * @returns\n   */\n  _setAttributes(attributes: Record<string, GeometryAttribute>, indices: any): this {\n    return this;\n  }\n\n  _calculateVertexCount(attributes: GeometryAttributes, indices?: GeometryAttribute): number {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attribute of Object.values(attributes)) {\n      const {value, size, constant} = attribute;\n      if (!constant && value && size !== undefined && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n\n    // assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// ClipSpace\nimport {Device} from '@luma.gl/core';\nimport {Model, ModelProps} from '../model/model';\nimport {Geometry} from '../geometry/geometry';\nimport {uid} from '../utils/uid';\n\nconst CLIPSPACE_VERTEX_SHADER_WGSL = /* wgsl */ `\\\nstruct VertexInputs {\n  @location(0) clipSpacePosition: vec2<f32>,\n  @location(1) texCoord: vec2<f32>,\n  @location(2) coordinate: vec2<f32>  \n}\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) position : vec2<f32>,\n  @location(1) coordinate : vec2<f32>,\n  @location(2) uv : vec2<f32>\n};\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs: FragmentInputs;\n  outputs.Position = vec4(inputs.clipSpacePosition, 0., 1.);\n  outputs.position = inputs.clipSpacePosition;\n  outputs.coordinate = inputs.coordinate;\n  outputs.uv = inputs.texCoord;\n  return outputs;\n}\n`;\n\nconst CLIPSPACE_VERTEX_SHADER = /* glsl */ `\\\n#version 300 es\nin vec2 clipSpacePositions;\nin vec2 texCoords;\nin vec2 coordinates;\n\nout vec2 position;\nout vec2 coordinate;\nout vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(clipSpacePositions, 0., 1.);\n  position = clipSpacePositions;\n  coordinate = coordinates;\n  uv = texCoords;\n}\n`;\n\n/* eslint-disable indent, no-multi-spaces */\nconst POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];\n\n/** Props for ClipSpace */\nexport type ClipSpaceProps = Omit<ModelProps, 'vs' | 'vertexCount' | 'geometry'>;\n\n/**\n * A flat geometry that covers the \"visible area\" that the GPU renders.\n */\nexport class ClipSpace extends Model {\n  constructor(device: Device, props: ClipSpaceProps) {\n    const TEX_COORDS = POSITIONS.map(coord => (coord === -1 ? 0 : coord));\n\n    // For WGSL we need to append the supplied fragment shader to the default vertex shader source\n    if (props.source) {\n      props = {...props, source: `${CLIPSPACE_VERTEX_SHADER_WGSL}\\n${props.source}`};\n    }\n\n    super(device, {\n      id: props.id || uid('clip-space'),\n      ...props,\n      vs: CLIPSPACE_VERTEX_SHADER,\n      vertexCount: 4,\n      geometry: new Geometry({\n        topology: 'triangle-strip',\n        vertexCount: 4,\n        attributes: {\n          clipSpacePositions: {size: 2, value: new Float32Array(POSITIONS)},\n          texCoords: {size: 2, value: new Float32Array(TEX_COORDS)},\n          coordinates: {size: 2, value: new Float32Array(TEX_COORDS)}\n        }\n      })\n    });\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Texture} from '@luma.gl/core';\nimport {AsyncTexture} from '../async-texture/async-texture';\nimport {ClipSpace} from './clip-space';\n\nconst BACKGROUND_FS_WGSL = /* wgsl */ `\\\n@group(0) @binding(0) var backgroundTexture: texture_2d<f32>;\n@group(0) @binding(1) var backgroundTextureSampler: sampler;\n\nfn billboardTexture_getTextureUV(coordinates: vec2<f32>) -> vec2<f32> {\n\tlet iTexSize: vec2<u32> = textureDimensions(backgroundTexture, 0) * 2;\n\tlet texSize: vec2<f32> = vec2<f32>(f32(iTexSize.x), f32(iTexSize.y));\n\tvar position: vec2<f32> = coordinates.xy / texSize;\n\treturn position;\n} \n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n\tlet position: vec2<f32> = billboardTexture_getTextureUV(inputs.coordinate);\n\treturn textureSample(backgroundTexture, backgroundTextureSampler, position);\n}\n`;\n\nconst BACKGROUND_FS = /* glsl */ `\\\n#version 300 es\nprecision highp float;\n\nuniform sampler2D backgroundTexture;\nout vec4 fragColor;\n\nvec2 billboardTexture_getTextureUV() {\n  ivec2 iTexSize = textureDimensions(backgroundTexture, 0) * 2;\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n  vec2 position = gl_FragCoord.xy / texSize;\n  return position;\n}\n\nvoid main(void) {\n  vec2 position = billboardTexture_getTextureUV();\n  fragColor = texture(backgroundTexture, position);\n}\n`;\n\n/**\n * Props for a Model that renders a bitmap into the \"background\", i.e covering the screen\n */\nexport type BackgroundTextureModelProps = {\n  /** id of this model */\n  id?: string;\n  /** The texture to render */\n  backgroundTexture: Texture | AsyncTexture;\n  /** If true, the texture is rendered into transparent areas of the screen only, i.e blended in where background alpha is small */\n  blend?: boolean;\n};\n\n/**\n * Model that renders a bitmap into the \"background\", i.e covering the screen\n */\nexport class BackgroundTextureModel extends ClipSpace {\n  constructor(device: Device, props: BackgroundTextureModelProps) {\n    super(device, {\n      id: props.id || 'background-texture-model',\n      source: BACKGROUND_FS_WGSL,\n      fs: BACKGROUND_FS,\n      parameters: {\n        depthWriteEnabled: false,\n        depthCompare: 'always',\n        ...(props.blend\n          ? {\n              blend: true,\n              blendColorOperation: 'add',\n              blendAlphaOperation: 'add',\n              blendColorSrcFactor: 'one',\n              blendColorDstFactor: 'one-minus-src-color',\n              blendAlphaSrcFactor: 'one',\n              blendAlphaDstFactor: 'one-minus-src-alpha'\n            }\n          : {})\n      }\n    });\n\n    this.setTexture(props.backgroundTexture);\n  }\n\n  setTexture(backgroundTexture: Texture | AsyncTexture): void {\n    this.setBindings({\n      backgroundTexture\n    });\n  }\n\n  override predraw(): void {\n    this.shaderInputs.setProps({});\n    super.predraw();\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Vector3, Matrix4, NumericArray} from '@math.gl/core';\nimport {uid} from '../utils/uid';\n\n/** Properties for creating a new Scenegraph */\nexport type ScenegraphNodeProps = {\n  id?: string;\n  /** whether to display the object at all */\n  display?: boolean;\n  matrix?: NumericArray;\n  position?: NumericArray;\n  rotation?: NumericArray;\n  scale?: NumericArray;\n  update?: boolean;\n};\n\nexport class ScenegraphNode {\n  readonly id: string;\n  matrix: Matrix4 = new Matrix4();\n\n  display = true;\n  position = new Vector3();\n  rotation = new Vector3();\n  scale = new Vector3(1, 1, 1);\n  userData: Record<string, unknown> = {};\n\n  props: ScenegraphNodeProps = {};\n\n  constructor(props: ScenegraphNodeProps = {}) {\n    const {id} = props;\n\n    this.id = id || uid(this.constructor.name);\n\n    this._setScenegraphNodeProps(props);\n  }\n\n  getBounds(): [number[], number[]] | null {\n    return null;\n  }\n\n  destroy(): void {}\n\n  /** @deprecated use .destroy() */\n  delete(): void {\n    this.destroy();\n  }\n  setProps(props: ScenegraphNodeProps): this {\n    this._setScenegraphNodeProps(props);\n    return this;\n  }\n\n  toString(): string {\n    return `{type: ScenegraphNode, id: ${this.id})}`;\n  }\n\n  setPosition(position: any): this {\n    // assert(position.length === 3, 'setPosition requires vector argument');\n    this.position = position;\n    return this;\n  }\n\n  setRotation(rotation: any): this {\n    // assert(rotation.length === 3, 'setRotation requires vector argument');\n    this.rotation = rotation;\n    return this;\n  }\n\n  setScale(scale: any): this {\n    // assert(scale.length === 3, 'setScale requires vector argument');\n    this.scale = scale;\n    return this;\n  }\n\n  setMatrix(matrix: any, copyMatrix: boolean = true): void {\n    if (copyMatrix) {\n      this.matrix.copy(matrix);\n    } else {\n      this.matrix = matrix;\n    }\n  }\n\n  setMatrixComponents(components: {\n    position?: any;\n    rotation?: any;\n    scale?: any;\n    update?: boolean;\n  }): this {\n    const {position, rotation, scale, update = true} = components;\n    if (position) {\n      this.setPosition(position);\n    }\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n    if (scale) {\n      this.setScale(scale);\n    }\n    if (update) {\n      this.updateMatrix();\n    }\n    return this;\n  }\n\n  updateMatrix(): this {\n    const pos = this.position;\n    const rot = this.rotation;\n    const scale = this.scale;\n\n    this.matrix.identity();\n    this.matrix.translate(pos);\n    this.matrix.rotateXYZ(rot);\n    this.matrix.scale(scale);\n    return this;\n  }\n\n  update(options: {position?: any; rotation?: any; scale?: any} = {}): this {\n    const {position, rotation, scale} = options;\n    if (position) {\n      this.setPosition(position);\n    }\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n    if (scale) {\n      this.setScale(scale);\n    }\n    this.updateMatrix();\n    return this;\n  }\n\n  getCoordinateUniforms(\n    viewMatrix: any,\n    modelMatrix?: any\n  ): {\n    viewMatrix: any;\n    modelMatrix: any;\n    objectMatrix: any;\n    worldMatrix: any;\n    worldInverseMatrix: any;\n    worldInverseTransposeMatrix: any;\n  } {\n    // TODO - solve multiple class problem\n    // assert(viewMatrix instanceof Matrix4);\n    // assert(viewMatrix);\n    modelMatrix = modelMatrix || this.matrix;\n    const worldMatrix = new Matrix4(viewMatrix).multiplyRight(modelMatrix);\n    const worldInverse = worldMatrix.invert();\n    const worldInverseTranspose = worldInverse.transpose();\n\n    return {\n      viewMatrix,\n      modelMatrix,\n      objectMatrix: modelMatrix,\n      worldMatrix,\n      worldInverseMatrix: worldInverse,\n      worldInverseTransposeMatrix: worldInverseTranspose\n    };\n  }\n\n  // TODO - copied code, not yet vetted\n  /*\n  transform() {\n    if (!this.parent) {\n      this.endPosition.set(this.position);\n      this.endRotation.set(this.rotation);\n      this.endScale.set(this.scale);\n    } else {\n      const parent = this.parent;\n      this.endPosition.set(this.position.add(parent.endPosition));\n      this.endRotation.set(this.rotation.add(parent.endRotation));\n      this.endScale.set(this.scale.add(parent.endScale));\n    }\n\n    const ch = this.children;\n    for (let i = 0; i < ch.length; ++i) {\n      ch[i].transform();\n    }\n\n    return this;\n  }\n  */\n\n  _setScenegraphNodeProps(props: ScenegraphNodeProps): void {\n    // if ('display' in props) {\n    //   this.display = props.display;\n    // }\n\n    if ('position' in props) {\n      this.setPosition(props.position);\n    }\n    if ('rotation' in props) {\n      this.setRotation(props.rotation);\n    }\n    if ('scale' in props) {\n      this.setScale(props.scale);\n    }\n\n    // Matrix overwrites other props\n    if ('matrix' in props) {\n      this.setMatrix(props.matrix);\n    }\n\n    Object.assign(this.props, props);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Matrix4, Vector3} from '@math.gl/core';\nimport {log} from '@luma.gl/core';\nimport {ScenegraphNode, ScenegraphNodeProps} from './scenegraph-node';\n\nexport type GroupNodeProps = ScenegraphNodeProps & {\n  children?: ScenegraphNode[];\n};\n\nexport class GroupNode extends ScenegraphNode {\n  children: ScenegraphNode[];\n\n  constructor(children: ScenegraphNode[]);\n  constructor(props?: GroupNodeProps);\n\n  constructor(props: ScenegraphNode[] | GroupNodeProps = {}) {\n    props = Array.isArray(props) ? {children: props} : props;\n    const {children = []} = props;\n    log.assert(\n      children.every(child => child instanceof ScenegraphNode),\n      'every child must an instance of ScenegraphNode'\n    );\n    super(props);\n    this.children = children;\n  }\n\n  override getBounds(): [number[], number[]] | null {\n    const result: [number[], number[]] = [\n      [Infinity, Infinity, Infinity],\n      [-Infinity, -Infinity, -Infinity]\n    ];\n\n    this.traverse((node, {worldMatrix}) => {\n      const bounds = node.getBounds();\n      if (!bounds) {\n        return;\n      }\n      const [min, max] = bounds;\n      const center = new Vector3(min).add(max).divide([2, 2, 2]);\n      worldMatrix.transformAsPoint(center, center);\n      const halfSize = new Vector3(max).subtract(min).divide([2, 2, 2]);\n      worldMatrix.transformAsVector(halfSize, halfSize);\n\n      for (let v = 0; v < 8; v++) {\n        // Test all 8 corners of the box\n        const position = new Vector3(v & 0b001 ? -1 : 1, v & 0b010 ? -1 : 1, v & 0b100 ? -1 : 1)\n          .multiply(halfSize)\n          .add(center);\n\n        for (let i = 0; i < 3; i++) {\n          result[0][i] = Math.min(result[0][i], position[i]);\n          result[1][i] = Math.max(result[1][i], position[i]);\n        }\n      }\n    });\n    if (!Number.isFinite(result[0][0])) {\n      return null;\n    }\n    return result;\n  }\n\n  override destroy(): void {\n    this.children.forEach(child => child.destroy());\n    this.removeAll();\n    super.destroy();\n  }\n\n  // Unpacks arrays and nested arrays of children\n  add(...children: (ScenegraphNode | ScenegraphNode[])[]): this {\n    for (const child of children) {\n      if (Array.isArray(child)) {\n        this.add(...child);\n      } else {\n        this.children.push(child);\n      }\n    }\n    return this;\n  }\n\n  remove(child: ScenegraphNode): this {\n    const children = this.children;\n    const indexOf = children.indexOf(child);\n    if (indexOf > -1) {\n      children.splice(indexOf, 1);\n    }\n    return this;\n  }\n\n  removeAll(): this {\n    this.children = [];\n    return this;\n  }\n\n  traverse(\n    visitor: (node: ScenegraphNode, context: {worldMatrix: Matrix4}) => void,\n    {worldMatrix = new Matrix4()} = {}\n  ) {\n    const modelMatrix = new Matrix4(worldMatrix).multiplyRight(this.matrix);\n\n    for (const child of this.children) {\n      if (child instanceof GroupNode) {\n        child.traverse(visitor, {worldMatrix: modelMatrix});\n      } else {\n        visitor(child, {worldMatrix: modelMatrix});\n      }\n    }\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {RenderPass} from '@luma.gl/core';\nimport {ScenegraphNode, ScenegraphNodeProps} from './scenegraph-node';\nimport {Model} from '../model/model';\n\nexport type ModelNodeProps = ScenegraphNodeProps & {\n  model: Model;\n  managedResources?: any[];\n  bounds?: [number[], number[]];\n};\n\nexport class ModelNode extends ScenegraphNode {\n  readonly model: Model;\n  bounds: [number[], number[]] | null = null;\n  managedResources: any[];\n\n  // TODO - is this used? override callbacks to make sure we call them with this\n  // onBeforeRender = null;\n  // onAfterRender = null;\n  // AfterRender = null;\n\n  constructor(props: ModelNodeProps) {\n    super(props);\n\n    // Create new Model or used supplied Model\n    this.model = props.model;\n    this.managedResources = props.managedResources || [];\n    this.bounds = props.bounds || null;\n    this.setProps(props);\n  }\n\n  override destroy(): void {\n    if (this.model) {\n      this.model.destroy();\n      // @ts-expect-error\n      this.model = null;\n    }\n    this.managedResources.forEach(resource => resource.destroy());\n    this.managedResources = [];\n  }\n\n  override getBounds(): [number[], number[]] | null {\n    return this.bounds;\n  }\n\n  // Expose model methods\n  draw(renderPass: RenderPass) {\n    // Return value indicates if something was actually drawn\n    return this.model.draw(renderPass);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Geometry} from '../geometry/geometry';\nimport {uid} from '../utils/uid';\n\nconst INDEX_OFFSETS = {\n  x: [2, 0, 1],\n  y: [0, 1, 2],\n  z: [1, 2, 0]\n};\n\nexport type TruncatedConeGeometryProps = {\n  topRadius?: number;\n  bottomRadius?: number;\n  topCap?: boolean;\n  bottomCap?: boolean;\n  height?: number;\n  nradial?: number;\n  nvertical?: number;\n  verticalAxis?: 'x' | 'y' | 'z';\n};\n\n/**\n * Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n * copyright 2011 Google Inc. new BSD License\n * (http://www.opensource.org/licenses/bsd-license.php).\n */\nexport class TruncatedConeGeometry extends Geometry {\n  constructor(props: TruncatedConeGeometryProps & {id?: string; attributes?: any} = {}) {\n    const {id = uid('truncated-code-geometry')} = props;\n    const {indices, attributes} = tesselateTruncatedCone(props);\n    super({\n      ...props,\n      id,\n      topology: 'triangle-list',\n      indices,\n      attributes: {\n        POSITION: {size: 3, value: attributes.POSITION},\n        NORMAL: {size: 3, value: attributes.NORMAL},\n        TEXCOORD_0: {size: 2, value: attributes.TEXCOORD_0},\n        ...props.attributes\n      }\n    });\n  }\n}\n\n/* eslint-disable max-statements, complexity */\nfunction tesselateTruncatedCone(props: TruncatedConeGeometryProps = {}) {\n  const {\n    bottomRadius = 0,\n    topRadius = 0,\n    height = 1,\n    nradial = 10,\n    nvertical = 10,\n    verticalAxis = 'y',\n    topCap = false,\n    bottomCap = false\n  } = props;\n\n  const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);\n  const numVertices = (nradial + 1) * (nvertical + 1 + extra);\n\n  const slant = Math.atan2(bottomRadius - topRadius, height);\n  const msin = Math.sin;\n  const mcos = Math.cos;\n  const mpi = Math.PI;\n  const cosSlant = mcos(slant);\n  const sinSlant = msin(slant);\n  const start = topCap ? -2 : 0;\n  const end = nvertical + (bottomCap ? 2 : 0);\n  const vertsAroundEdge = nradial + 1;\n\n  const indices = new Uint16Array(nradial * (nvertical + extra) * 6);\n  const indexOffset = INDEX_OFFSETS[verticalAxis];\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  const texCoords = new Float32Array(numVertices * 2);\n\n  let i3 = 0;\n  let i2 = 0;\n  for (let i = start; i <= end; i++) {\n    let v = i / nvertical;\n    let y = height * v;\n    let ringRadius;\n\n    if (i < 0) {\n      y = 0;\n      v = 1;\n      ringRadius = bottomRadius;\n    } else if (i > nvertical) {\n      y = height;\n      v = 1;\n      ringRadius = topRadius;\n    } else {\n      ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);\n    }\n    if (i === -2 || i === nvertical + 2) {\n      ringRadius = 0;\n      v = 0;\n    }\n    y -= height / 2;\n    for (let j = 0; j < vertsAroundEdge; j++) {\n      const sin = msin((j * mpi * 2) / nradial);\n      const cos = mcos((j * mpi * 2) / nradial);\n\n      positions[i3 + indexOffset[0]] = sin * ringRadius;\n      positions[i3 + indexOffset[1]] = y;\n      positions[i3 + indexOffset[2]] = cos * ringRadius;\n\n      normals[i3 + indexOffset[0]] = i < 0 || i > nvertical ? 0 : sin * cosSlant;\n      normals[i3 + indexOffset[1]] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;\n      normals[i3 + indexOffset[2]] = i < 0 || i > nvertical ? 0 : cos * cosSlant;\n\n      texCoords[i2 + 0] = j / nradial;\n      texCoords[i2 + 1] = v;\n\n      i2 += 2;\n      i3 += 3;\n    }\n  }\n\n  for (let i = 0; i < nvertical + extra; i++) {\n    for (let j = 0; j < nradial; j++) {\n      const index = (i * nradial + j) * 6;\n      indices[index + 0] = vertsAroundEdge * (i + 0) + 0 + j;\n      indices[index + 1] = vertsAroundEdge * (i + 0) + 1 + j;\n      indices[index + 2] = vertsAroundEdge * (i + 1) + 1 + j;\n      indices[index + 3] = vertsAroundEdge * (i + 0) + 0 + j;\n      indices[index + 4] = vertsAroundEdge * (i + 1) + 1 + j;\n      indices[index + 5] = vertsAroundEdge * (i + 1) + 0 + j;\n    }\n  }\n\n  return {\n    indices,\n    attributes: {\n      POSITION: positions,\n      NORMAL: normals,\n      TEXCOORD_0: texCoords\n    }\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TruncatedConeGeometry} from './truncated-cone-geometry';\nimport {uid} from '../utils/uid';\n\nexport type ConeGeometryProps = {\n  id?: string;\n  radius?: number;\n  cap?: boolean;\n};\n\nexport class ConeGeometry extends TruncatedConeGeometry {\n  constructor(props: ConeGeometryProps = {}) {\n    const {id = uid('cone-geometry'), radius = 1, cap = true} = props;\n    super({\n      ...props,\n      id,\n      topRadius: 0,\n      topCap: Boolean(cap),\n      bottomCap: Boolean(cap),\n      bottomRadius: radius\n    });\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Geometry} from '../geometry/geometry';\nimport {uid} from '../utils/uid';\n// import type {GeometryType} from '../geometry/geometry-type';\n\nexport type CubeGeometryProps = {\n  id?: string;\n  indices?: boolean;\n  attributes?: any;\n};\n\nexport class CubeGeometry extends Geometry {\n  constructor(props: CubeGeometryProps = {}) {\n    const {id = uid('cube-geometry'), indices = true} = props;\n    super(\n      indices\n        ? {\n            ...props,\n            id,\n            topology: 'triangle-list',\n            indices: {size: 1, value: CUBE_INDICES},\n            attributes: {...ATTRIBUTES, ...props.attributes}\n          }\n        : {\n            ...props,\n            id,\n            topology: 'triangle-list',\n            indices: undefined,\n            attributes: {...NON_INDEXED_ATTRIBUTES, ...props.attributes}\n          }\n    );\n  }\n}\n\n// prettier-ignore\nconst CUBE_INDICES = new Uint16Array([\n  0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13,\n  14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23\n]);\n\n// prettier-ignore\nconst CUBE_POSITIONS = new Float32Array([\n  -1,  -1,  1, 1,  -1,  1,  1,  1,  1,  -1,  1,  1,\n  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1,  -1,\n  -1,  1,  -1,  -1,  1,  1,  1,  1,  1,  1,  1,  -1,\n  -1,  -1,  -1,  1,  -1,  -1,  1,  -1,  1,  -1,  -1,  1,\n  1,  -1,  -1,  1,  1,  -1,  1,  1,  1,  1,  -1,  1,\n  -1,  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1\n]);\n\n// TODO - could be Uint8\n// prettier-ignore\nconst CUBE_NORMALS = new Float32Array([\n  // Front face\n  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,\n  // Back face\n  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,\n  // Top face\n  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,\n  // Bottom face\n  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,\n  // Right face\n  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,\n  // Left face\n  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0\n]);\n\n// prettier-ignore\nconst CUBE_TEX_COORDS = new Float32Array([\n  // Front face\n  0,  0,  1,  0,  1,  1,  0,  1,\n  // Back face\n  1,  0,  1,  1,  0,  1,  0,  0,\n  // Top face\n  0,  1,  0,  0,  1,  0,  1,  1,\n  // Bottom face\n  1,  1,  0,  1,  0,  0,  1,  0,\n  // Right face\n  1,  0,  1,  1,  0,  1,  0,  0,\n  // Left face\n  0,  0,  1,  0,  1,  1,  0,  1\n]);\n\n// float4 position\n// prettier-ignore\nexport const CUBE_NON_INDEXED_POSITIONS = new Float32Array([\n  1, -1, 1,\n  -1, -1, 1,\n  -1, -1, -1,\n  1, -1, -1,\n  1, -1, 1,\n  -1, -1, -1,\n\n  1, 1, 1,\n  1, -1, 1,\n  1, -1, -1,\n  1, 1, -1,\n  1, 1, 1,\n  1, -1, -1,\n\n  -1, 1, 1,\n  1, 1, 1,\n  1, 1, -1,\n  -1, 1, -1,\n  -1, 1, 1,\n  1, 1, -1,\n\n  -1, -1, 1,\n  -1, 1, 1,\n  -1, 1, -1,\n  -1, -1, -1,\n  -1, -1, 1,\n  -1, 1, -1,\n\n  1, 1, 1,\n  -1, 1, 1,\n  -1, -1, 1,\n  -1, -1, 1,\n  1, -1, 1,\n  1, 1, 1,\n\n  1, -1, -1,\n  -1, -1, -1,\n  -1, 1, -1,\n  1, 1, -1,\n  1, -1, -1,\n  -1, 1, -1,\n]);\n\n// float2 uv,\n// prettier-ignore\nexport const CUBE_NON_INDEXED_TEX_COORDS = new Float32Array([\n  1, 1,\n  0, 1,\n  0, 0,\n  1, 0,\n  1, 1,\n  0, 0,\n\n  1, 1,\n  0, 1,\n  0, 0,\n  1, 0,\n  1, 1,\n  0, 0,\n\n  1, 1,\n  0, 1,\n  0, 0,\n  1, 0,\n  1, 1,\n  0, 0,\n\n  1, 1,\n  0, 1,\n  0, 0,\n  1, 0,\n  1, 1,\n  0, 0,\n\n  1, 1,\n  0, 1,\n  0, 0,\n  0, 0,\n  1, 0,\n  1, 1,\n\n  1, 1,\n  0, 1,\n  0, 0,\n  1, 0,\n  1, 1,\n  0, 0,\n]);\n\n// float4 color\n// prettier-ignore\nexport const CUBE_NON_INDEXED_COLORS = new Float32Array([\n  1, 0, 1, 1,\n  0, 0, 1, 1,\n  0, 0, 0, 1,\n  1, 0, 0, 1,\n  1, 0, 1, 1,\n  0, 0, 0, 1,\n\n  1, 1, 1, 1,\n  1, 0, 1, 1,\n  1, 0, 0, 1,\n  1, 1, 0, 1,\n  1, 1, 1, 1,\n  1, 0, 0, 1,\n\n  0, 1, 1, 1,\n  1, 1, 1, 1,\n  1, 1, 0, 1,\n  0, 1, 0, 1,\n  0, 1, 1, 1,\n  1, 1, 0, 1,\n\n  0, 0, 1, 1,\n  0, 1, 1, 1,\n  0, 1, 0, 1,\n  0, 0, 0, 1,\n  0, 0, 1, 1,\n  0, 1, 0, 1,\n\n  1, 1, 1, 1,\n  0, 1, 1, 1,\n  0, 0, 1, 1,\n  0, 0, 1, 1,\n  1, 0, 1, 1,\n  1, 1, 1, 1,\n\n  1, 0, 0, 1,\n  0, 0, 0, 1,\n  0, 1, 0, 1,\n  1, 1, 0, 1,\n  1, 0, 0, 1,\n  0, 1, 0, 1,\n]);\n\nconst ATTRIBUTES = {\n  POSITION: {size: 3, value: CUBE_POSITIONS},\n  NORMAL: {size: 3, value: CUBE_NORMALS},\n  TEXCOORD_0: {size: 2, value: CUBE_TEX_COORDS}\n};\n\nconst NON_INDEXED_ATTRIBUTES = {\n  POSITION: {size: 3, value: CUBE_NON_INDEXED_POSITIONS},\n  // NORMAL: {size: 3, value: CUBE_NON_INDEXED_NORMALS},\n  TEXCOORD_0: {size: 2, value: CUBE_NON_INDEXED_TEX_COORDS},\n  COLOR_0: {size: 3, value: CUBE_NON_INDEXED_COLORS}\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TruncatedConeGeometry} from './truncated-cone-geometry';\nimport {uid} from '../utils/uid';\n\nexport type CylinderGeometryProps = {\n  id?: string;\n  radius?: number;\n  attributes?: any;\n};\n\nexport class CylinderGeometry extends TruncatedConeGeometry {\n  constructor(props: CylinderGeometryProps = {}) {\n    const {id = uid('cylinder-geometry'), radius = 1} = props;\n    super({\n      ...props,\n      id,\n      bottomRadius: radius,\n      topRadius: radius\n    });\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Vector3} from '@math.gl/core';\nimport {Geometry} from '../geometry/geometry';\nimport {uid} from '../utils/uid';\n\n/* eslint-disable comma-spacing, max-statements, complexity */\n\nconst ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];\nconst ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];\n\nexport type IcoSphereGeometryProps = {\n  id?: string;\n  radius?: number;\n  iterations?: number;\n  attributes?: any;\n};\n\nexport class IcoSphereGeometry extends Geometry {\n  constructor(props: IcoSphereGeometryProps = {}) {\n    const {id = uid('ico-sphere-geometry')} = props;\n    const {indices, attributes} = tesselateIcosaHedron(props);\n    super({\n      ...props,\n      id,\n      topology: 'triangle-list',\n      indices,\n      attributes: {...attributes, ...props.attributes}\n    });\n  }\n}\n\nfunction tesselateIcosaHedron(props: IcoSphereGeometryProps) {\n  const {iterations = 0} = props;\n\n  const PI = Math.PI;\n  const PI2 = PI * 2;\n\n  const positions = [...ICO_POSITIONS];\n  let indices = [...ICO_INDICES];\n\n  positions.push();\n  indices.push();\n\n  const getMiddlePoint = (() => {\n    const pointMemo: Record<string, number> = {};\n\n    return (i1: number, i2: number) => {\n      i1 *= 3;\n      i2 *= 3;\n      const mini = i1 < i2 ? i1 : i2;\n      const maxi = i1 > i2 ? i1 : i2;\n      const key = `${mini}|${maxi}`;\n\n      if (key in pointMemo) {\n        return pointMemo[key];\n      }\n\n      const x1 = positions[i1];\n      const y1 = positions[i1 + 1];\n      const z1 = positions[i1 + 2];\n      const x2 = positions[i2];\n      const y2 = positions[i2 + 1];\n      const z2 = positions[i2 + 2];\n      let xm = (x1 + x2) / 2;\n      let ym = (y1 + y2) / 2;\n      let zm = (z1 + z2) / 2;\n      const len = Math.sqrt(xm * xm + ym * ym + zm * zm);\n\n      xm /= len;\n      ym /= len;\n      zm /= len;\n\n      positions.push(xm, ym, zm);\n\n      return (pointMemo[key] = positions.length / 3 - 1);\n    };\n  })();\n\n  for (let i = 0; i < iterations; i++) {\n    const indices2: number[] = [];\n    for (let j = 0; j < indices.length; j += 3) {\n      const a = getMiddlePoint(indices[j + 0], indices[j + 1]);\n      const b = getMiddlePoint(indices[j + 1], indices[j + 2]);\n      const c = getMiddlePoint(indices[j + 2], indices[j + 0]);\n\n      indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);\n    }\n    indices = indices2;\n  }\n\n  // Calculate texCoords and normals\n  const normals = new Array(positions.length);\n  const texCoords = new Array((positions.length / 3) * 2);\n\n  const l = indices.length;\n  for (let i = l - 3; i >= 0; i -= 3) {\n    const i1 = indices[i + 0];\n    const i2 = indices[i + 1];\n    const i3 = indices[i + 2];\n    const in1 = i1 * 3;\n    const in2 = i2 * 3;\n    const in3 = i3 * 3;\n    const iu1 = i1 * 2;\n    const iu2 = i2 * 2;\n    const iu3 = i3 * 2;\n    const x1 = positions[in1 + 0];\n    const y1 = positions[in1 + 1];\n    const z1 = positions[in1 + 2];\n    const theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));\n    const phi1 = Math.atan2(y1, x1) + PI;\n    const v1 = theta1 / PI;\n    const u1 = 1 - phi1 / PI2;\n    const x2 = positions[in2 + 0];\n    const y2 = positions[in2 + 1];\n    const z2 = positions[in2 + 2];\n    const theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));\n    const phi2 = Math.atan2(y2, x2) + PI;\n    const v2 = theta2 / PI;\n    const u2 = 1 - phi2 / PI2;\n    const x3 = positions[in3 + 0];\n    const y3 = positions[in3 + 1];\n    const z3 = positions[in3 + 2];\n    const theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));\n    const phi3 = Math.atan2(y3, x3) + PI;\n    const v3 = theta3 / PI;\n    const u3 = 1 - phi3 / PI2;\n    const vec1 = [x3 - x2, y3 - y2, z3 - z2];\n    const vec2 = [x1 - x2, y1 - y2, z1 - z2];\n    const normal = new Vector3(vec1).cross(vec2).normalize();\n    let newIndex;\n\n    if (\n      (u1 === 0 || u2 === 0 || u3 === 0) &&\n      (u1 === 0 || u1 > 0.5) &&\n      (u2 === 0 || u2 > 0.5) &&\n      (u3 === 0 || u3 > 0.5)\n    ) {\n      positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);\n      newIndex = positions.length / 3 - 1;\n      indices.push(newIndex);\n      texCoords[newIndex * 2 + 0] = 1;\n      texCoords[newIndex * 2 + 1] = v1;\n      normals[newIndex * 3 + 0] = normal.x;\n      normals[newIndex * 3 + 1] = normal.y;\n      normals[newIndex * 3 + 2] = normal.z;\n\n      positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);\n      newIndex = positions.length / 3 - 1;\n      indices.push(newIndex);\n      texCoords[newIndex * 2 + 0] = 1;\n      texCoords[newIndex * 2 + 1] = v2;\n      normals[newIndex * 3 + 0] = normal.x;\n      normals[newIndex * 3 + 1] = normal.y;\n      normals[newIndex * 3 + 2] = normal.z;\n\n      positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);\n      newIndex = positions.length / 3 - 1;\n      indices.push(newIndex);\n      texCoords[newIndex * 2 + 0] = 1;\n      texCoords[newIndex * 2 + 1] = v3;\n      normals[newIndex * 3 + 0] = normal.x;\n      normals[newIndex * 3 + 1] = normal.y;\n      normals[newIndex * 3 + 2] = normal.z;\n    }\n\n    normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;\n    normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;\n    normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;\n\n    texCoords[iu1 + 0] = u1;\n    texCoords[iu1 + 1] = v1;\n\n    texCoords[iu2 + 0] = u2;\n    texCoords[iu2 + 1] = v2;\n\n    texCoords[iu3 + 0] = u3;\n    texCoords[iu3 + 1] = v3;\n  }\n\n  return {\n    indices: {size: 1, value: new Uint16Array(indices)},\n    attributes: {\n      POSITION: {size: 3, value: new Float32Array(positions)},\n      NORMAL: {size: 3, value: new Float32Array(normals)},\n      TEXCOORD_0: {size: 2, value: new Float32Array(texCoords)}\n    }\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport function unpackIndexedGeometry(geometry: any) {\n  const {indices, attributes} = geometry;\n  if (!indices) {\n    return geometry;\n  }\n\n  const vertexCount = indices.value.length;\n  const unpackedAttributes: Record<string, any> = {};\n\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const {constant, value, size} = attribute;\n    if (constant || !size) {\n      continue; // eslint-disable-line\n    }\n    const unpackedValue = new value.constructor(vertexCount * size);\n    for (let x = 0; x < vertexCount; ++x) {\n      const index = indices.value[x];\n      for (let i = 0; i < size; i++) {\n        unpackedValue[x * size + i] = value[index * size + i];\n      }\n    }\n    unpackedAttributes[attributeName] = {size, value: unpackedValue};\n  }\n\n  return {\n    attributes: Object.assign({}, attributes, unpackedAttributes)\n  };\n}\n\n// export function calculateVertexNormals(positions: Float32Array): Uint8Array {\n//   let normals = new Uint8Array(positions.length / 3);\n\n//   for (let i = 0; i < positions.length; i++) {\n//     const vec1 = new Vector3(positions.subarray(i * 3, i + 0, i + 3));\n//     const vec2 = new Vector3(positions.subarray(i + 3, i + 6));\n//     const vec3 = new Vector3(positions.subarray(i + 6, i + 9));\n\n//     const normal = new Vector3(vec1).cross(vec2).normalize();\n//     normals.set(normal[0], i + 4);\n//     normals.set(normal[1], i + 4 + 1);\n//     normals.set(normal[2], i + 2);\n//   }\n//   const normal = new Vector3(vec1).cross(vec2).normalize();\n// }\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Geometry} from '../geometry/geometry';\nimport {unpackIndexedGeometry} from '../geometry/geometry-utils';\nimport {uid} from '../utils/uid';\n\nexport type PlaneGeometryProps = {\n  id?: string;\n  radius?: number;\n  attributes?: any;\n};\n\n// Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n// copyright 2011 Google Inc. new BSD License\n// (http://www.opensource.org/licenses/bsd-license.php).\nexport class PlaneGeometry extends Geometry {\n  constructor(props: PlaneGeometryProps = {}) {\n    const {id = uid('plane-geometry')} = props;\n\n    const {indices, attributes} = tesselatePlane(props);\n    super({\n      ...props,\n      id,\n      topology: 'triangle-list',\n      indices,\n      attributes: {...attributes, ...props.attributes}\n    });\n  }\n}\n\n/* eslint-disable complexity, max-statements */\nfunction tesselatePlane(props: any) {\n  const {type = 'x,y', offset = 0, flipCull = false, unpack = false} = props;\n\n  const coords = type.split(',');\n  // width, height\n  let c1len = props[`${coords[0]}len`] || 1;\n  const c2len = props[`${coords[1]}len`] || 1;\n  // subdivisionsWidth, subdivisionsDepth\n  const subdivisions1 = props[`n${coords[0]}`] || 1;\n  const subdivisions2 = props[`n${coords[1]}`] || 1;\n  const numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  const texCoords = new Float32Array(numVertices * 2);\n\n  if (flipCull) {\n    c1len = -c1len;\n  }\n\n  let i2 = 0;\n  let i3 = 0;\n  for (let z = 0; z <= subdivisions2; z++) {\n    for (let x = 0; x <= subdivisions1; x++) {\n      const u = x / subdivisions1;\n      const v = z / subdivisions2;\n      texCoords[i2 + 0] = flipCull ? 1 - u : u;\n      texCoords[i2 + 1] = v;\n\n      switch (type) {\n        case 'x,y':\n          positions[i3 + 0] = c1len * u - c1len * 0.5;\n          positions[i3 + 1] = c2len * v - c2len * 0.5;\n          positions[i3 + 2] = offset;\n\n          normals[i3 + 0] = 0;\n          normals[i3 + 1] = 0;\n          normals[i3 + 2] = flipCull ? 1 : -1;\n          break;\n\n        case 'x,z':\n          positions[i3 + 0] = c1len * u - c1len * 0.5;\n          positions[i3 + 1] = offset;\n          positions[i3 + 2] = c2len * v - c2len * 0.5;\n\n          normals[i3 + 0] = 0;\n          normals[i3 + 1] = flipCull ? 1 : -1;\n          normals[i3 + 2] = 0;\n          break;\n\n        case 'y,z':\n          positions[i3 + 0] = offset;\n          positions[i3 + 1] = c1len * u - c1len * 0.5;\n          positions[i3 + 2] = c2len * v - c2len * 0.5;\n\n          normals[i3 + 0] = flipCull ? 1 : -1;\n          normals[i3 + 1] = 0;\n          normals[i3 + 2] = 0;\n          break;\n\n        default:\n          throw new Error('PlaneGeometry: unknown type');\n      }\n\n      i2 += 2;\n      i3 += 3;\n    }\n  }\n\n  const numVertsAcross = subdivisions1 + 1;\n  const indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);\n\n  for (let z = 0; z < subdivisions2; z++) {\n    for (let x = 0; x < subdivisions1; x++) {\n      const index = (z * subdivisions1 + x) * 6;\n      // Make triangle 1 of quad.\n      indices[index + 0] = (z + 0) * numVertsAcross + x;\n      indices[index + 1] = (z + 1) * numVertsAcross + x;\n      indices[index + 2] = (z + 0) * numVertsAcross + x + 1;\n\n      // Make triangle 2 of quad.\n      indices[index + 3] = (z + 1) * numVertsAcross + x;\n      indices[index + 4] = (z + 1) * numVertsAcross + x + 1;\n      indices[index + 5] = (z + 0) * numVertsAcross + x + 1;\n    }\n  }\n\n  const geometry = {\n    indices: {size: 1, value: indices},\n    attributes: {\n      POSITION: {size: 3, value: positions},\n      NORMAL: {size: 3, value: normals},\n      TEXCOORD_0: {size: 2, value: texCoords}\n    }\n  };\n\n  // Optionally, unpack indexed geometry\n  return unpack ? unpackIndexedGeometry(geometry) : geometry;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Geometry} from '../geometry/geometry';\nimport {uid} from '../utils/uid';\n\nexport type SphereGeometryProps = {\n  id?: string;\n  radius?: number;\n  nlat?: number;\n  nlong?: number;\n  attributes?: any;\n};\n\n// Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n// copyright 2011 Google Inc. new BSD License\n// (http://www.opensource.org/licenses/bsd-license.php).\nexport class SphereGeometry extends Geometry {\n  constructor(props: SphereGeometryProps = {}) {\n    const {id = uid('sphere-geometry')} = props;\n    const {indices, attributes} = tesselateSphere(props);\n    super({\n      ...props,\n      id,\n      topology: 'triangle-list',\n      indices,\n      attributes: {...attributes, ...props.attributes}\n    });\n  }\n}\n\n/* eslint-disable max-statements, complexity */\nfunction tesselateSphere(props: SphereGeometryProps) {\n  const {nlat = 10, nlong = 10} = props;\n\n  const startLat = 0;\n  const endLat = Math.PI;\n  const latRange = endLat - startLat;\n  const startLong = 0;\n  const endLong = 2 * Math.PI;\n  const longRange = endLong - startLong;\n  const numVertices = (nlat + 1) * (nlong + 1);\n\n  const radius = (n1: number, n2: number, n3: number, u: number, v: number) => props.radius || 1;\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  const texCoords = new Float32Array(numVertices * 2);\n\n  const IndexType = numVertices > 0xffff ? Uint32Array : Uint16Array;\n  const indices = new IndexType(nlat * nlong * 6);\n\n  // Create positions, normals and texCoords\n  for (let y = 0; y <= nlat; y++) {\n    for (let x = 0; x <= nlong; x++) {\n      const u = x / nlong;\n      const v = y / nlat;\n\n      const index = x + y * (nlong + 1);\n      const i2 = index * 2;\n      const i3 = index * 3;\n\n      const theta = longRange * u;\n      const phi = latRange * v;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      const sinPhi = Math.sin(phi);\n      const cosPhi = Math.cos(phi);\n      const ux = cosTheta * sinPhi;\n      const uy = cosPhi;\n      const uz = sinTheta * sinPhi;\n\n      const r = radius(ux, uy, uz, u, v);\n\n      positions[i3 + 0] = r * ux;\n      positions[i3 + 1] = r * uy;\n      positions[i3 + 2] = r * uz;\n\n      normals[i3 + 0] = ux;\n      normals[i3 + 1] = uy;\n      normals[i3 + 2] = uz;\n\n      texCoords[i2 + 0] = u;\n      texCoords[i2 + 1] = 1 - v;\n    }\n  }\n\n  // Create indices\n  const numVertsAround = nlong + 1;\n  for (let x = 0; x < nlong; x++) {\n    for (let y = 0; y < nlat; y++) {\n      const index = (x * nlat + y) * 6;\n\n      indices[index + 0] = y * numVertsAround + x;\n      indices[index + 1] = y * numVertsAround + x + 1;\n      indices[index + 2] = (y + 1) * numVertsAround + x;\n\n      indices[index + 3] = (y + 1) * numVertsAround + x;\n      indices[index + 4] = y * numVertsAround + x + 1;\n      indices[index + 5] = (y + 1) * numVertsAround + x + 1;\n    }\n  }\n\n  return {\n    indices: {size: 1, value: indices},\n    attributes: {\n      POSITION: {size: 3, value: positions},\n      NORMAL: {size: 3, value: normals},\n      TEXCOORD_0: {size: 2, value: texCoords}\n    }\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/** Creates a deterministic pseudorandom number generator */\nexport function makeRandomGenerator(): () => number {\n  let s = 1;\n  let c = 1;\n  return () => {\n    s = Math.sin(c * 17.23);\n    c = Math.cos(s * 27.92);\n    return fract(Math.abs(s * c) * 1432.71);\n  };\n}\n\nfunction fract(n: number): number {\n  return n - Math.floor(n);\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {BufferProps, FramebufferProps} from '@luma.gl/core';\nimport {Device, Resource, Buffer, Framebuffer, Texture} from '@luma.gl/core';\n\n/**\n * Helper class for working with repeated transformations / computations\n * Primarily intended for GPU buffers `Swap<Buffer>` or textures `Swap<Texture>`)\n * @note the two resources are expected to be structurally identical (same size, length, format, etc)\n * @note the two resources can be destroyed by calling `destroy()`\n */\nexport class Swap<T extends Resource<any>> {\n  /** The current resource - usually the source for renders or computations */\n  current: T;\n  /** The next resource - usually the target/destination for transforms / computations */\n  next: T;\n\n  constructor(props: {current: T; next: T}) {\n    this.current = props.current;\n    this.next = props.next;\n  }\n\n  /** Destroys the two managed resources */\n  destroy() {\n    this.current?.destroy();\n    this.next?.destroy();\n  }\n\n  /** Make the next resource into the current resource, and reuse the current resource as the next resource */\n  swap() {\n    const current = this.current;\n    this.current = this.next;\n    this.next = current;\n  }\n}\n\n/** Helper for managing double-buffered framebuffers */\nexport class SwapFramebuffers extends Swap<Framebuffer> {\n  constructor(device: Device, props: FramebufferProps) {\n    props = {...props};\n\n    let colorAttachments = props.colorAttachments?.map(colorAttachment =>\n      typeof colorAttachment !== 'string'\n        ? colorAttachment\n        : device.createTexture({\n            format: colorAttachment,\n            usage: Texture.COPY_DST | Texture.RENDER_ATTACHMENT\n          })\n    );\n\n    const current = device.createFramebuffer({...props, colorAttachments});\n\n    colorAttachments = props.colorAttachments?.map(colorAttachment =>\n      typeof colorAttachment !== 'string'\n        ? colorAttachment\n        : device.createTexture({\n            format: colorAttachment,\n            usage: Texture.COPY_DST | Texture.RENDER_ATTACHMENT\n          })\n    );\n\n    const next = device.createFramebuffer({...props, colorAttachments});\n\n    super({current, next});\n  }\n\n  /**\n   * Resizes the Framebuffers.\n   * @returns true if the size changed, otherwise exiting framebuffers were preserved\n   * @note any contents are not preserved!\n   */\n  resize(size: {width: number; height: number}): boolean {\n    if (size.width === this.current.width && size.height === this.current.height) {\n      return false;\n    }\n    const {current, next} = this;\n\n    this.current = current.clone(size);\n    current.destroy();\n\n    this.next = next.clone(size);\n    next.destroy();\n\n    return true;\n  }\n}\n\n/** Helper for managing double-buffered GPU buffers */\nexport class SwapBuffers extends Swap<Buffer> {\n  constructor(device: Device, props: BufferProps) {\n    super({current: device.createBuffer(props), next: device.createBuffer(props)});\n  }\n\n  /**\n   * Resizes the Buffers.\n   * @returns true if the size changed, otherwise exiting buffers were preserved.\n   * @note any contents are not preserved!\n   */\n  resize(props: {byteLength: number}) {\n    if (props.byteLength === this.current.byteLength) {\n      return false;\n    }\n\n    const {current, next} = this;\n\n    this.current = current.clone(props);\n    current.destroy();\n\n    this.next = next.clone(props);\n    next.destroy();\n\n    return true;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderPass} from '@luma.gl/shadertools';\n\n/**\n * Gets fragment shader source for a shader pass sub pass\n * @param options\n * @returns\n */\nexport function getFragmentShaderForRenderPass(options: {\n  shaderPass: ShaderPass;\n  action: 'filter' | 'sample';\n  shadingLanguage: 'wgsl' | 'glsl';\n}): string {\n  const {shaderPass, action, shadingLanguage} = options;\n  switch (action) {\n    case 'filter':\n      const filterFunc = `${shaderPass.name}_filterColor_ext`;\n      return shadingLanguage === 'wgsl'\n        ? getFilterShaderWGSL(filterFunc)\n        : getFilterShaderGLSL(filterFunc);\n\n    case 'sample':\n      const samplerFunc = `${shaderPass.name}_sampleColor`;\n      return shadingLanguage === 'wgsl'\n        ? getSamplerShaderWGSL(samplerFunc)\n        : getSamplerShaderGLSL(samplerFunc);\n\n    default:\n      throw new Error(`${shaderPass.name} no fragment shader generated for shader pass`);\n  }\n}\n\n/** Get a filtering WGSL fragment shader */\nfunction getFilterShaderWGSL(func: string) {\n  return /* wgsl */ `\\\n// Binding 0:1 is reserved for shader passes\n@group(0) @binding(0) var<uniform> brightnessContrast : brightnessContrastUniforms;\n@group(0) @binding(1) var texture: texture_2d<f32>;\n@group(0) @binding(2) var sampler: sampler;\n\nstruct FragmentInputs = {\n  @location(0) fragUV: vec2f,\n  @location(1) fragPosition: vec4f,\n  @location(2) fragCoordinate: vec4f\n};\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  let texSize = textureDimensions(texture, 0);\n  var fragColor = textureSample(texture, sampler, fragUV);\n  fragColor = ${func}(gl_FragColor, texSize, texCoord);\n  return fragColor;\n}\n`;\n}\n\n/** Get a sampling WGSL fragment shader */\nfunction getSamplerShaderWGSL(func: string) {\n  return /* wgsl */ `\\\n// Binding 0:1 is reserved for shader passes\n@group(0) @binding(0) var<uniform> brightnessContrast : brightnessContrastUniforms;\n@group(0) @binding(1) var texture: texture_2d<f32>;\n@group(0) @binding(2) var sampler: sampler;\n\nstruct FragmentInputs = {\n  @location(0) fragUV: vec2f,\n  @location(1) fragPosition: vec4f,\n  @location(2) fragCoordinate: vec4f\n};\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  let texSize = textureDimensions(texture, 0);\n  var fragColor = textureSample(texture, sampler, fragUV);\n  fragColor = ${func}(gl_FragColor, texSize, texCoord);\n  return fragColor;\n}\n`;\n}\n\n/** Get a filtering GLSL fragment shader */\nfunction getFilterShaderGLSL(func: string) {\n  return /* glsl */ `\\\n#version 300 es\n\nuniform sampler2D sourceTexture;\n\nin vec2 position;\nin vec2 coordinate;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  ivec2 iTexSize = textureSize(sourceTexture, 0);\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n\n  fragColor = texture(sourceTexture, texCoord);\n  fragColor = ${func}(fragColor, texSize, texCoord);\n}\n`;\n}\n\n/** Get a sampling GLSL fragment shader */\nfunction getSamplerShaderGLSL(func: string) {\n  return /* glsl */ `\\\n#version 300 es\n\nuniform sampler2D sourceTexture;\n\nin vec2 position;\nin vec2 coordinate;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  ivec2 iTexSize = textureSize(sourceTexture, 0);\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n\n  fragColor = ${func}(sourceTexture, texSize, texCoord);\n}\n`;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, RenderPass, Texture} from '@luma.gl/core';\nimport type {ShaderPass} from '@luma.gl/shadertools';\nimport {initializeShaderModule} from '@luma.gl/shadertools';\nimport {ShaderInputs} from '../shader-inputs';\nimport {AsyncTexture} from '../async-texture/async-texture';\nimport {ClipSpace} from '../models/clip-space';\nimport {SwapFramebuffers} from '../compute/swap';\nimport {BackgroundTextureModel} from '../models/billboard-texture-model';\n\nimport {getFragmentShaderForRenderPass} from './get-fragment-shader';\n\ntype ShaderSubPass = NonNullable<ShaderPass['passes']>[0];\n\n/** Props for ShaderPassRenderer */\nexport type ShaderPassRendererProps = {\n  /** List of ShaderPasses to apply to the sourceTexture */\n  shaderPasses: ShaderPass[];\n  /** Optional typed ShaderInputs object for setting uniforms */\n  shaderInputs: ShaderInputs;\n};\n\n/** A pass that renders a given texture into screen space */\nexport class ShaderPassRenderer {\n  device: Device;\n  shaderInputs: ShaderInputs;\n  passRenderers: PassRenderer[];\n  swapFramebuffers: SwapFramebuffers;\n  /** For rendering to the screen */\n  clipSpace: ClipSpace;\n  textureModel: BackgroundTextureModel;\n\n  constructor(device: Device, props: ShaderPassRendererProps) {\n    this.device = device;\n\n    props.shaderPasses.map(shaderPass => initializeShaderModule(shaderPass));\n\n    const modules = props.shaderPasses.reduce(\n      (object, shaderPass) => ({...object, [shaderPass.name]: shaderPass}),\n      {}\n    );\n    this.shaderInputs = props.shaderInputs || new ShaderInputs(modules);\n\n    const size = device.getCanvasContext().getPixelSize();\n    this.swapFramebuffers = new SwapFramebuffers(device, {\n      colorAttachments: ['rgba8unorm'],\n      width: size[0],\n      height: size[1]\n    });\n\n    this.textureModel = new BackgroundTextureModel(device, {\n      backgroundTexture: this.swapFramebuffers.current.colorAttachments[0].texture\n    });\n\n    this.clipSpace = new ClipSpace(device, {\n      source: /* wgsl */ `\\\n  @group(0) @binding(0) var sourceTexture: texture_2d<f32>;\n  @group(0) @binding(1) var sourceTextureSampler: sampler;\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n\tlet texCoord: vec2<f32> = inputs.coordinate;\n\treturn textureSample(sourceTexture, sourceTextureSampler, texCoord);\n}\n`,\n\n      fs: /* glsl */ `\\\n#version 300 es\n\nuniform sampler2D sourceTexture;\nin vec2 uv;\nin vec2 coordinate;\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  fragColor = texture(sourceTexture, coordinate);\n}\n`\n    });\n\n    this.passRenderers = props.shaderPasses.map(shaderPass => new PassRenderer(device, shaderPass));\n  }\n\n  /** Destroys resources created by this ShaderPassRenderer */\n  destroy() {\n    for (const subPassRenderer of this.passRenderers) {\n      subPassRenderer.destroy();\n    }\n    this.swapFramebuffers.destroy();\n    this.clipSpace.destroy();\n  }\n\n  resize(width: number, height: number): void {\n    this.swapFramebuffers.resize({width, height});\n    // this.props.passes.forEach(pass => pass.resize(width, height));\n  }\n\n  renderToScreen(options: {sourceTexture: AsyncTexture; uniforms: any; bindings: any}): boolean {\n    // Run the shader passes and generate an output texture\n    const outputTexture = this.renderToTexture(options);\n    if (!outputTexture) {\n      // source texture not yet loaded\n      return false;\n    }\n\n    const renderPass = this.device.beginRenderPass({clearColor: [0, 0, 0, 1], clearDepth: 1});\n    this.clipSpace.setBindings({sourceTexture: outputTexture});\n    this.clipSpace.draw(renderPass);\n    renderPass.end();\n    return true;\n  }\n\n  /** Runs the shaderPasses in sequence on the sourceTexture and returns a texture with the results.\n   * @returns null if the the sourceTexture has not yet been loaded\n   */\n  renderToTexture(options: {\n    sourceTexture: AsyncTexture;\n    uniforms: any;\n    bindings: any;\n  }): Texture | null {\n    const {sourceTexture} = options;\n    if (!sourceTexture.isReady) {\n      return null;\n    }\n\n    this.textureModel.destroy();\n    this.textureModel = new BackgroundTextureModel(this.device, {\n      backgroundTexture: sourceTexture\n    });\n\n    // Clear the current texture before we begin\n    const clearTexturePass = this.device.beginRenderPass({\n      framebuffer: this.swapFramebuffers.current,\n      clearColor: [0, 0, 0, 1]\n    });\n    this.textureModel.draw(clearTexturePass);\n    clearTexturePass.end();\n\n    // const commandEncoder = this.device.createCommandEncoder();\n    // commandEncoder.copyTextureToTexture({\n    //   sourceTexture: sourceTexture.texture,\n    //   destinationTexture: this.swapFramebuffers.current.colorAttachments[0].texture\n    // });\n    // commandEncoder.finish();\n\n    let first = true;\n    for (const passRenderer of this.passRenderers) {\n      for (const subPassRenderer of passRenderer.subPassRenderers) {\n        if (!first) {\n          this.swapFramebuffers.swap();\n        }\n        first = false;\n\n        const swapBufferTexture = this.swapFramebuffers.current.colorAttachments[0].texture;\n\n        const bindings = {\n          sourceTexture: swapBufferTexture\n          // texSize: [sourceTextures.width, sourceTextures.height]\n        };\n\n        const renderPass = this.device.beginRenderPass({\n          framebuffer: this.swapFramebuffers.next,\n          clearColor: [0, 0, 0, 1],\n          clearDepth: 1\n        });\n        subPassRenderer.render({renderPass, bindings});\n        renderPass.end();\n      }\n    }\n\n    this.swapFramebuffers.swap();\n    const outputTexture = this.swapFramebuffers.current.colorAttachments[0].texture;\n    return outputTexture;\n  }\n}\n\n/** renders one ShaderPass */\nclass PassRenderer {\n  shaderPass: ShaderPass;\n  subPassRenderers: SubPassRenderer[];\n\n  constructor(device: Device, shaderPass: ShaderPass, props = {}) {\n    this.shaderPass = shaderPass;\n    // const id = `${shaderPass.name}-pass`;\n\n    const subPasses = shaderPass.passes || [];\n    // normalizePasses(gl, module, id, props);\n\n    this.subPassRenderers = subPasses.map(subPass => {\n      // const idn = `${id}-${subPasses.length + 1}`;\n      return new SubPassRenderer(device, shaderPass, subPass);\n    });\n  }\n\n  destroy() {\n    for (const subPassRenderer of this.subPassRenderers) {\n      subPassRenderer.destroy();\n    }\n  }\n}\n\n/** Renders one subpass of a ShaderPass */\nclass SubPassRenderer {\n  model: ClipSpace;\n  shaderPass: ShaderPass;\n  subPass: ShaderSubPass;\n\n  constructor(device: Device, shaderPass: ShaderPass, subPass: ShaderSubPass) {\n    this.shaderPass = shaderPass;\n    this.subPass = subPass;\n    const action =\n      subPass.action || (subPass.filter && 'filter') || (subPass.sampler && 'sample') || 'filter';\n    const fs = getFragmentShaderForRenderPass({\n      shaderPass,\n      action,\n      shadingLanguage: device.info.shadingLanguage\n    });\n\n    this.model = new ClipSpace(device, {\n      id: `${shaderPass.name}-subpass`,\n      source: fs,\n      fs,\n      modules: [shaderPass],\n      parameters: {\n        depthWriteEnabled: false,\n        depthCompare: 'always'\n      }\n    });\n  }\n\n  destroy() {\n    this.model.destroy();\n  }\n\n  render(options: {renderPass: RenderPass; bindings: any}): void {\n    const {renderPass, bindings} = options;\n\n    this.model.shaderInputs.setProps({\n      [this.shaderPass.name]: this.shaderPass.uniforms || {}\n    });\n    this.model.shaderInputs.setProps({\n      [this.shaderPass.name]: this.subPass.uniforms || {}\n    });\n    // this.model.setBindings(this.subPass.bindings || {});\n    this.model.setBindings(bindings || {});\n    this.model.draw(renderPass);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {DeviceFeature, ComputePipelineProps, Shader, Binding} from '@luma.gl/core';\nimport {\n  Device,\n  Buffer,\n  ComputePipeline,\n  ComputePass,\n  UniformStore,\n  log,\n  getTypedArrayFromDataType\n} from '@luma.gl/core';\nimport type {ShaderModule, PlatformInfo} from '@luma.gl/shadertools';\nimport {ShaderAssembler, getShaderLayoutFromWGSL} from '@luma.gl/shadertools';\nimport {TypedArray, isNumericArray} from '@math.gl/types';\nimport {ShaderInputs} from '../shader-inputs';\nimport {PipelineFactory} from '../factories/pipeline-factory';\nimport {ShaderFactory} from '../factories/shader-factory';\nimport {uid} from '../utils/uid';\n// import {getDebugTableForShaderLayout} from '../debug/debug-shader-layout';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\nexport type ComputationProps = Omit<ComputePipelineProps, 'shader'> & {\n  source?: string;\n\n  /** shadertool shader modules (added to shader code) */\n  modules?: ShaderModule[];\n  /** Shadertool module defines (configures shader code)*/\n  defines?: Record<string, string | number | boolean>;\n  // TODO - injections, hooks etc?\n\n  /** Shader inputs, used to generated uniform buffers and bindings */\n  shaderInputs?: ShaderInputs;\n\n  /** Bindings */\n  bindings?: Record<string, Binding>;\n\n  /** Show shader source in browser? */\n  debugShaders?: 'never' | 'errors' | 'warnings' | 'always';\n\n  /** Factory used to create a {@link ComputePipeline}. Defaults to {@link Device} default factory. */\n  pipelineFactory?: PipelineFactory;\n  /** Factory used to create a {@link Shader}. Defaults to {@link Device} default factory. */\n  shaderFactory?: ShaderFactory;\n  /** Shader assembler. Defaults to the ShaderAssembler.getShaderAssembler() */\n  shaderAssembler?: ShaderAssembler;\n};\n\n/**\n * v9 Model API\n * A model\n * - automatically reuses pipelines (programs) when possible\n * - automatically rebuilds pipelines if necessary to accommodate changed settings\n * shadertools integration\n * - accepts modules and performs shader transpilation\n */\nexport class Computation {\n  static defaultProps: Required<ComputationProps> = {\n    ...ComputePipeline.defaultProps,\n    id: 'unnamed',\n    handle: undefined,\n    userData: {},\n\n    source: '',\n    modules: [],\n    defines: {},\n\n    bindings: undefined!,\n    shaderInputs: undefined!,\n\n    pipelineFactory: undefined!,\n    shaderFactory: undefined!,\n    shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),\n\n    debugShaders: undefined!\n  };\n\n  readonly device: Device;\n  readonly id: string;\n\n  readonly pipelineFactory: PipelineFactory;\n  readonly shaderFactory: ShaderFactory;\n\n  userData: {[key: string]: any} = {};\n\n  /** Bindings (textures, samplers, uniform buffers) */\n  bindings: Record<string, Binding> = {};\n\n  /** The underlying GPU pipeline. */\n  pipeline: ComputePipeline;\n  /** Assembled compute shader source */\n  source: string;\n  /** the underlying compiled compute shader */\n  // @ts-ignore Set in function called from constructor\n  shader: Shader;\n\n  /** ShaderInputs instance */\n  shaderInputs: ShaderInputs;\n\n  // @ts-ignore Set in function called from constructor\n  _uniformStore: UniformStore;\n\n  _pipelineNeedsUpdate: string | false = 'newly created';\n\n  private _getModuleUniforms: (props?: Record<string, Record<string, any>>) => Record<string, any>;\n  private props: Required<ComputationProps>;\n\n  private _destroyed = false;\n\n  constructor(device: Device, props: ComputationProps) {\n    if (device.type !== 'webgpu') {\n      throw new Error('Computation is only supported in WebGPU');\n    }\n\n    this.props = {...Computation.defaultProps, ...props};\n    props = this.props;\n    this.id = props.id || uid('model');\n    this.device = device;\n\n    Object.assign(this.userData, props.userData);\n\n    // Setup shader module inputs\n    const moduleMap = Object.fromEntries(\n      this.props.modules?.map(module => [module.name, module]) || []\n    );\n    // @ts-ignore TODO - fix up typing?\n    this.shaderInputs = props.shaderInputs || new ShaderInputs(moduleMap);\n    this.setShaderInputs(this.shaderInputs);\n\n    // Support WGSL shader layout introspection\n    // TODO - Don't modify props!!\n    this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.props.source);\n\n    // Setup shader assembler\n    const platformInfo = getPlatformInfo(device);\n\n    // Extract modules from shader inputs if not supplied\n    const modules =\n      (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];\n\n    this.pipelineFactory =\n      props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);\n    this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);\n\n    const {source, getUniforms} = this.props.shaderAssembler.assembleWGSLShader({\n      platformInfo,\n      ...this.props,\n      modules\n    });\n\n    this.source = source;\n    // @ts-ignore\n    this._getModuleUniforms = getUniforms;\n\n    // Create the pipeline\n    // @note order is important\n    this.pipeline = this._updatePipeline();\n\n    // Apply any dynamic settings that will not trigger pipeline change\n    if (props.bindings) {\n      this.setBindings(props.bindings);\n    }\n\n    // Catch any access to non-standard props\n    Object.seal(this);\n  }\n\n  destroy(): void {\n    if (this._destroyed) return;\n    this.pipelineFactory.release(this.pipeline);\n    this.shaderFactory.release(this.shader);\n    this._uniformStore.destroy();\n    this._destroyed = true;\n  }\n\n  // Draw call\n\n  predraw() {\n    // Update uniform buffers if needed\n    this.updateShaderInputs();\n  }\n\n  dispatch(computePass: ComputePass, x: number, y?: number, z?: number): void {\n    try {\n      this._logDrawCallStart();\n\n      // Check if the pipeline is invalidated\n      // TODO - this is likely the worst place to do this from performance perspective. Perhaps add a predraw()?\n      this.pipeline = this._updatePipeline();\n\n      // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw\n      // Any caching needs to be done inside the pipeline functions\n      this.pipeline.setBindings(this.bindings);\n      computePass.setPipeline(this.pipeline);\n      // @ts-expect-error\n      computePass.setBindings([]);\n\n      computePass.dispatch(x, y, z);\n    } finally {\n      this._logDrawCallEnd();\n    }\n  }\n\n  // Update fixed fields (can trigger pipeline rebuild)\n\n  // Update dynamic fields\n\n  /**\n   * Updates the vertex count (used in draw calls)\n   * @note Any attributes with stepMode=vertex need to be at least this big\n   */\n  setVertexCount(vertexCount: number): void {\n    // this.vertexCount = vertexCount;\n  }\n\n  /**\n   * Updates the instance count (used in draw calls)\n   * @note Any attributes with stepMode=instance need to be at least this big\n   */\n  setInstanceCount(instanceCount: number): void {\n    // this.instanceCount = instanceCount;\n  }\n\n  setShaderInputs(shaderInputs: ShaderInputs): void {\n    this.shaderInputs = shaderInputs;\n    this._uniformStore = new UniformStore(this.shaderInputs.modules);\n    // Create uniform buffer bindings for all modules\n    for (const moduleName of Object.keys(this.shaderInputs.modules)) {\n      const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);\n      this.bindings[`${moduleName}Uniforms`] = uniformBuffer;\n    }\n  }\n\n  /**\n   * Updates shader module settings (which results in uniforms being set)\n   */\n  setShaderModuleProps(props: Record<string, any>): void {\n    const uniforms = this._getModuleUniforms(props);\n\n    // Extract textures & framebuffers set by the modules\n    // TODO better way to extract bindings\n    const keys = Object.keys(uniforms).filter(k => {\n      const uniform = uniforms[k];\n      return (\n        !isNumericArray(uniform) && typeof uniform !== 'number' && typeof uniform !== 'boolean'\n      );\n    });\n    const bindings: Record<string, Binding> = {};\n    for (const k of keys) {\n      bindings[k] = uniforms[k];\n      delete uniforms[k];\n    }\n  }\n\n  updateShaderInputs(): void {\n    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());\n  }\n\n  /**\n   * Sets bindings (textures, samplers, uniform buffers)\n   */\n  setBindings(bindings: Record<string, Binding>): void {\n    Object.assign(this.bindings, bindings);\n  }\n\n  _setPipelineNeedsUpdate(reason: string): void {\n    this._pipelineNeedsUpdate = this._pipelineNeedsUpdate || reason;\n  }\n\n  _updatePipeline(): ComputePipeline {\n    if (this._pipelineNeedsUpdate) {\n      let prevShader: Shader | null = null;\n      if (this.pipeline) {\n        log.log(\n          1,\n          `Model ${this.id}: Recreating pipeline because \"${this._pipelineNeedsUpdate}\".`\n        )();\n        prevShader = this.shader;\n      }\n\n      this._pipelineNeedsUpdate = false;\n\n      this.shader = this.shaderFactory.createShader({\n        id: `${this.id}-fragment`,\n        stage: 'compute',\n        source: this.source,\n        debugShaders: this.props.debugShaders\n      });\n\n      this.pipeline = this.pipelineFactory.createComputePipeline({\n        ...this.props,\n        shader: this.shader\n      });\n\n      if (prevShader) {\n        this.shaderFactory.release(prevShader);\n      }\n    }\n    return this.pipeline;\n  }\n\n  /** Throttle draw call logging */\n  _lastLogTime = 0;\n  _logOpen = false;\n\n  _logDrawCallStart(): void {\n    // IF level is 4 or higher, log every frame.\n    const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {\n      return;\n    }\n\n    this._lastLogTime = Date.now();\n    this._logOpen = true;\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.level <= 2})();\n  }\n\n  _logDrawCallEnd(): void {\n    if (this._logOpen) {\n      // const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.props.shaderLayout, this.id);\n\n      // log.table(logLevel, attributeTable)();\n      // log.table(logLevel, uniformTable)();\n      // log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();\n\n      const uniformTable = this.shaderInputs.getDebugTable();\n      log.table(LOG_DRAW_PRIORITY, uniformTable)();\n\n      log.groupEnd(LOG_DRAW_PRIORITY)();\n      this._logOpen = false;\n    }\n  }\n\n  protected _drawCount = 0;\n\n  // TODO - fix typing of luma data types\n  _getBufferOrConstantValues(attribute: Buffer | TypedArray, dataType: any): string {\n    const TypedArrayConstructor = getTypedArrayFromDataType(dataType);\n    const typedArray =\n      attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;\n    return typedArray.toString();\n  }\n}\n\n/** Create a shadertools platform info from the Device */\nexport function getPlatformInfo(device: Device): PlatformInfo {\n  return {\n    type: device.type,\n    shaderLanguage: device.info.shadingLanguage,\n    shaderLanguageVersion: device.info.shadingLanguageVersion as 100 | 300,\n    gpu: device.info.gpu,\n    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API\n    features: device.features as unknown as Set<DeviceFeature>\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumberArray4} from '@math.gl/types';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\n/** Default color for auto highlight, a cyan color */\nconst DEFAULT_HIGHLIGHT_COLOR: NumberArray4 = [0, 1, 1, 1];\n\nexport const INVALID_INDEX = -1;\n\n/**\n * Props for the picking module, which depending on mode renders picking colors or highlighted item.\n * When active, renders picking colors, assumed to be rendered to off-screen \"picking\" buffer.\n * When inactive, renders normal colors, with the exception of selected object which is rendered with highlight\n * can distinguish between 2^32 different objects in each of 2^32 different batches.\n */\nexport type PickingProps = {\n  /** Are we picking? I.e. rendering picking colors? */\n  isActive?: boolean;\n  /** Whether to use instance_index (built-in) or a custom application supplied index (usually from an attribute) */\n  indexMode?: 'instance' | 'custom';\n  /** Batch index (used when rendering multiple models to identify which model was picked), defaults to 0 */\n  batchIndex?: number;\n\n  /** Index of the highlighted batch, defaults to 0 */\n  highlightedBatchIndex?: number | null;\n  /** Set an index to highlight that item, or `null` to explicitly clear **/\n  highlightedObjectIndex?: number | null;\n  /** Color of visual highlight of \"selected\" item () */\n  highlightColor?: NumberArray4;\n};\n\n/**\n * Uniforms for the picking module, which renders picking colors and highlighted item.\n * When active, renders picking colors, assumed to be rendered to off-screen \"picking\" buffer.\n * When inactive, renders normal colors, with the exception of selected object which is rendered with highlight\n */\nexport type PickingUniforms = {\n  /**\n   * When true, renders picking colors. Set when rendering to off-screen \"picking\" buffer.\n   * When false, renders normal colors, with the exception of selected object which is rendered with highlight\n   */\n  isActive: boolean;\n  /** Set to true when picking an attribute value instead of object index */\n  indexMode: 0 | 1;\n  /** Index of batch currently being rendered */\n  batchIndex: number;\n\n  /** Do we have a highlighted item? */\n  isHighlightActive: boolean;\n  /** Color of visual highlight of \"selected\" item. Note: RGBA components must in the range 0-1 */\n  highlightColor: NumberArray4;\n  /** Indicates which batch to visually highlight an item in (defaults to 0) */\n  highlightedBatchIndex: number;\n  /** Indicates which index in the batch to highlight an item in */\n  highlightedObjectIndex: number;\n};\n\nexport type PickingBindings = {};\n\n// GLSL_UNIFORMS\n\nconst uniformTypes: Required<ShaderModule<PickingProps, PickingUniforms>>['uniformTypes'] = {\n  isActive: 'i32',\n  indexMode: 'i32',\n  batchIndex: 'i32',\n\n  isHighlightActive: 'i32',\n  highlightedBatchIndex: 'i32',\n  highlightedObjectIndex: 'i32',\n  highlightColor: 'vec4<f32>'\n};\n\nexport const GLSL_UNIFORMS = /* glsl */ `\\\nprecision highp float;\nprecision highp int;\n\nuniform pickingUniforms {\n  int isActive;\n  int indexMode;\n  int batchIndex;\n\n  int isHighlightActive;\n  int highlightedBatchIndex;\n  int highlightedObjectIndex;\n  vec4 highlightColor;\n} picking;\n`;\n\nexport const WGSL_UNIFORMS = /* wgsl */ `\\\nstruct pickingUniforms {\n  isActive: int32;\n  indexMode: int32;\n  batchIndex: int32;\n\n  isHighlightActive: int32;\n  highlightedBatchIndex: int32;\n  highlightedObjectIndex: int32;\n  highlightColor: vec4<f32>;\n} picking;\n`;\n\nfunction getUniforms(props: PickingProps = {}, prevUniforms?: PickingUniforms): PickingUniforms {\n  const uniforms = {...prevUniforms} as PickingUniforms;\n\n  // picking\n  if (props.isActive !== undefined) {\n    uniforms.isActive = Boolean(props.isActive);\n  }\n\n  switch (props.indexMode) {\n    case 'instance':\n      uniforms.indexMode = 0;\n      break;\n    case 'custom':\n      uniforms.indexMode = 1;\n      break;\n    case undefined:\n      // no change\n      break;\n  }\n\n  switch (props.highlightedObjectIndex) {\n    case undefined:\n      // Unless highlightedObjectColor explicitly null or set, do not update state\n      break;\n    case null:\n      // Clear highlight\n      uniforms.isHighlightActive = false;\n      uniforms.highlightedObjectIndex = INVALID_INDEX;\n      break;\n    default:\n      uniforms.isHighlightActive = true;\n      uniforms.highlightedObjectIndex = props.highlightedObjectIndex;\n  }\n\n  if (typeof props.highlightedBatchIndex === 'number') {\n    uniforms.highlightedBatchIndex = props.highlightedBatchIndex;\n  }\n\n  if (props.highlightColor) {\n    uniforms.highlightColor = props.highlightColor;\n  }\n\n  return uniforms;\n}\n\n/**\n * Provides support for color-based picking and highlighting.\n *\n * In particular, supports picking a specific instance in an instanced\n * draw call and highlighting an instance based on its picking color,\n * and correspondingly, supports picking and highlighting groups of\n * primitives with the same picking color in non-instanced draw-calls\n *\n * @note Color based picking has the significant advantage in that it can be added to any\n * existing shader without requiring any additional picking logic.\n */\nexport const pickingUniforms = {\n  props: {} as PickingProps,\n  uniforms: {} as PickingUniforms,\n\n  name: 'picking',\n\n  uniformTypes,\n  defaultUniforms: {\n    isActive: false,\n    indexMode: 0,\n    batchIndex: 0,\n    isHighlightActive: true,\n    highlightedBatchIndex: INVALID_INDEX,\n    highlightedObjectIndex: INVALID_INDEX,\n    highlightColor: DEFAULT_HIGHLIGHT_COLOR\n  },\n\n  getUniforms\n} as const satisfies ShaderModule<PickingProps, PickingUniforms, PickingBindings>;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Framebuffer} from '@luma.gl/core';\nimport {ShaderInputs} from '../../shader-inputs';\nimport {pickingUniforms, INVALID_INDEX} from './picking-uniforms';\n// import {picking} from './color-picking';\n\n/** Information about picked object */\nexport type PickInfo = {\n  batchIndex: number | null;\n  objectIndex: number | null;\n};\n\nexport type PickingManagerProps = {\n  /** Shader Inputs from models to pick */\n  shaderInputs?: ShaderInputs<{picking: typeof pickingUniforms.props}>;\n  /** Callback */\n  onObjectPicked?: (info: PickInfo) => void;\n};\n\n/**\n * Helper class for using the new picking module\n * @todo Port to WebGPU\n * @todo Support multiple models\n * @todo Switching picking module\n */\nexport class PickingManager {\n  device: Device;\n  props: Required<PickingManagerProps>;\n  /** Info from latest pick operation */\n  pickInfo: PickInfo = {batchIndex: null, objectIndex: null};\n  /** Framebuffer used for picking */\n  framebuffer: Framebuffer | null = null;\n\n  static defaultProps: Required<PickingManagerProps> = {\n    shaderInputs: undefined!,\n    onObjectPicked: () => {}\n  };\n\n  constructor(device: Device, props: PickingManagerProps) {\n    this.device = device;\n    this.props = {...PickingManager.defaultProps, ...props};\n  }\n\n  destroy() {\n    this.framebuffer?.destroy();\n  }\n\n  // TODO - Ask for a cached framebuffer? a Framebuffer factory?\n  getFramebuffer() {\n    if (!this.framebuffer) {\n      this.framebuffer = this.device.createFramebuffer({\n        colorAttachments: ['rgba8unorm', 'rg32sint'],\n        depthStencilAttachment: 'depth24plus'\n      });\n    }\n    return this.framebuffer;\n  }\n\n  /** Clear highlighted / picked object */\n  clearPickState() {\n    this.props.shaderInputs.setProps({picking: {highlightedObjectIndex: null}});\n  }\n\n  /** Prepare for rendering picking colors */\n  beginRenderPass() {\n    const framebuffer = this.getFramebuffer();\n    framebuffer.resize(this.device.getDefaultCanvasContext().getPixelSize());\n\n    this.props.shaderInputs?.setProps({picking: {isActive: true}});\n\n    const pickingPass = this.device.beginRenderPass({\n      framebuffer,\n      clearColors: [new Float32Array([0, 0, 0, 0]), new Int32Array([-1, -1, 0, 0])],\n      clearDepth: 1\n    });\n\n    return pickingPass;\n  }\n\n  getPickInfo(mousePosition: [number, number]): PickInfo | null {\n    const framebuffer = this.getFramebuffer();\n\n    // use the center pixel location in device pixel range\n    const [pickX, pickY] = this.getPickPosition(mousePosition);\n\n    // Read back\n    const pixelData = this.device.readPixelsToArrayWebGL(framebuffer, {\n      sourceX: pickX,\n      sourceY: pickY,\n      sourceWidth: 1,\n      sourceHeight: 1,\n      sourceAttachment: 1\n    });\n    if (!pixelData) {\n      return null;\n    }\n\n    const pickInfo: PickInfo = {\n      objectIndex: pixelData[0] === INVALID_INDEX ? null : pixelData[0],\n      batchIndex: pixelData[1] === INVALID_INDEX ? null : pixelData[1]\n    };\n\n    // Call callback if picked object has changed\n    if (\n      pickInfo.objectIndex !== this.pickInfo.objectIndex ||\n      pickInfo.batchIndex !== this.pickInfo.batchIndex\n    ) {\n      this.pickInfo = pickInfo;\n      this.props.onObjectPicked(pickInfo);\n      // console.log(`Object ${pickInfo.objectIndex} in batch ${pickInfo.batchIndex} was picked`)\n    }\n\n    this.props.shaderInputs?.setProps({\n      picking: {\n        isActive: false,\n        highlightedBatchIndex: pickInfo.batchIndex,\n        highlightedObjectIndex: pickInfo.objectIndex\n      }\n    });\n\n    return this.pickInfo;\n  }\n\n  /**\n   * Get pick position in device pixel range\n   * use the center pixel location in device pixel range\n   */\n  getPickPosition(mousePosition: number[]): [number, number] {\n    const devicePixels = this.device.getDefaultCanvasContext().cssToDevicePixels(mousePosition);\n    const pickX = devicePixels.x + Math.floor(devicePixels.width / 2);\n    const pickY = devicePixels.y + Math.floor(devicePixels.height / 2);\n    return [pickX, pickY];\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nimport type {PickingBindings, PickingProps, PickingUniforms} from './picking-uniforms';\nimport {pickingUniforms, GLSL_UNIFORMS, WGSL_UNIFORMS, INVALID_INDEX} from './picking-uniforms';\n\n// SHADERS\n\nconst source = /* wgsl */ `\\\n${WGSL_UNIFORMS}\n\nconst INDEX_PICKING_MODE_INSTANCE = 0;\nconst INDEX_PICKING_MODE_CUSTOM = 1;\nconst INDEX_PICKING_INVALID_INDEX = ${INVALID_INDEX}; // 2^32 - 1\n\nstruct indexPickingFragmentInputs = {\n  objectIndex: int32;\n};\n\nlet indexPickingFragmentInputs: indexPickingFragmentInputs;\n\n/**\n * Vertex shaders should call this function to set the object index.\n * If using instance or vertex mode, argument will be ignored, 0 can be supplied.\n */\nfn picking_setObjectIndex(objectIndex: int32) {\n  switch (picking.indexMode) {\n    case INDEX_PICKING_MODE_INSTANCE, default: {\n      picking_objectIndex = instance_index;\n    };\n    case INDEX_PICKING_MODE_CUSTOM: {\n      picking_objectIndex = objectIndex;\n    };\n  }\n}\n\n`;\n\nconst vs = /* glsl */ `\\\n${GLSL_UNIFORMS}\n\nconst int INDEX_PICKING_MODE_INSTANCE = 0;\nconst int INDEX_PICKING_MODE_CUSTOM = 1;\n\nconst int INDEX_PICKING_INVALID_INDEX = ${INVALID_INDEX}; // 2^32 - 1\n\nflat out int picking_objectIndex;\n\n/**\n * Vertex shaders should call this function to set the object index.\n * If using instance or vertex mode, argument will be ignored, 0 can be supplied.\n */\nvoid picking_setObjectIndex(int objectIndex) {\n  switch (picking.indexMode) {\n    case INDEX_PICKING_MODE_INSTANCE:\n      picking_objectIndex = gl_InstanceID;\n      break;\n    case INDEX_PICKING_MODE_CUSTOM:\n      picking_objectIndex = objectIndex;\n      break;\n  }\n}\n`;\n\nconst fs = /* glsl */ `\\\n${GLSL_UNIFORMS}\n\nconst int INDEX_PICKING_INVALID_INDEX = ${INVALID_INDEX}; // 2^32 - 1\n\nflat in int picking_objectIndex;\n\n/**\n * Check if this vertex is highlighted (part of the selected batch and object)\n */ \nbool picking_isFragmentHighlighted() {\n  return \n    bool(picking.isHighlightActive) &&\n    picking.highlightedBatchIndex == picking.batchIndex &&\n    picking.highlightedObjectIndex == picking_objectIndex\n    ;\n}\n\n/**\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (bool(picking.isActive)) {\n    return color;\n  }\n\n  // If we are not highlighted, return color as is\n  if (!picking_isFragmentHighlighted()) {\n    return color;\n  }\n   \n  // Blend in highlight color based on its alpha value\n  float highLightAlpha = picking.highlightColor.a;\n  float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n  float highLightRatio = highLightAlpha / blendedAlpha;\n\n  vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n  return vec4(blendedRGB, blendedAlpha);\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nivec4 picking_getPickingColor() {\n  // Assumes that colorAttachment0 is rg32int\n  // TODO? - we could render indices into a second color attachment and not mess with fragColor\n  return ivec4(picking_objectIndex, picking.batchIndex, 0u, 0u);  \n}\n\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_objectIndex == INDEX_PICKING_INVALID_INDEX) {\n      discard;\n    }\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 outColor = color;\n  outColor = picking_filterHighlightColor(outColor);\n  outColor = picking_filterPickingColor(outColor);\n  return outColor;\n}\n`;\n\n/**\n * Provides support for color-based picking and highlighting.\n *\n * In particular, supports picking a specific instance in an instanced\n * draw call and highlighting an instance based on its picking color,\n * and correspondingly, supports picking and highlighting groups of\n * primitives with the same picking color in non-instanced draw-calls\n *\n * @note Color based picking has the significant advantage in that it can be added to any\n * existing shader without requiring any additional picking logic.\n */\nexport const picking = {\n  ...pickingUniforms,\n  name: 'picking',\n  source,\n  vs,\n  fs\n} as const satisfies ShaderModule<PickingProps, PickingUniforms, PickingBindings>;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nimport type {PickingProps, PickingUniforms, PickingBindings} from './picking-uniforms';\nimport {pickingUniforms, GLSL_UNIFORMS, WGSL_UNIFORMS} from './picking-uniforms';\n\nconst source = /* wgsl */ `\\\n${WGSL_UNIFORMS}\n`;\n\nconst vs = /* glsl */ `\\\n${GLSL_UNIFORMS}\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setObjectIndex(uint objectIndex) {\n  if (bool(picking.isActive)) {\n    uint index = objectIndex;\n    if (picking.indexMode == PICKING_INDEX_MODE_INSTANCE) {\n      index = uint(gl_InstanceID);\n    }\n    picking_vRGBcolor_Avalid.r = float(index % 255) / 255.0;\n    picking_vRGBcolor_Avalid.g = float((index / 255) % 255) / 255.0;\n    picking_vRGBcolor_Avalid.b = float((index / 255 / 255) %255) / 255.0;\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n`;\n\nconst fs = /* glsl */ `\\\n${GLSL_UNIFORMS}\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n`;\n\n/**\n * Provides support for color-coding-based picking and highlighting.\n * In particular, supports picking a specific instance in an instanced\n * draw call and highlighting an instance based on its picking color,\n * and correspondingly, supports picking and highlighting groups of\n * primitives with the same picking color in non-instanced draw-calls\n */\nexport const picking = {\n  ...pickingUniforms,\n  name: 'picking',\n  source,\n  vs,\n  fs\n} as const satisfies ShaderModule<PickingProps, PickingUniforms, PickingBindings>;\n\n// function getUniforms(opts: PickingProps = {}, prevUniforms?: PickingUniforms): PickingUniforms {\n//   const uniforms = {} as PickingUniforms;\n\n//   if (opts.highlightedObjectColor === undefined) {\n//     // Unless highlightedObjectColor explicitly null or set, do not update state\n//   } else if (opts.highlightedObjectColor === null) {\n//     uniforms.isHighlightActive = false;\n//   } else {\n//     uniforms.isHighlightActive = true;\n//     const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);\n//     uniforms.highlightedObjectColor = highlightedObjectColor;\n//   }\n\n//   if (opts.highlightColor) {\n//     const color = Array.from(opts.highlightColor, x => x / 255);\n//     if (!Number.isFinite(color[3])) {\n//       color[3] = 1;\n//     }\n//     uniforms.highlightColor = color;\n//   }\n\n//   if (opts.isActive !== undefined) {\n//     uniforms.isActive = Boolean(opts.isActive);\n//     uniforms.isAttribute = Boolean(opts.isAttribute);\n//   }\n\n//   if (opts.useFloatColors !== undefined) {\n//     uniforms.useFloatColors = Boolean(opts.useFloatColors);\n//   }\n\n//   return uniforms;\n// }\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Framebuffer} from '@luma.gl/core';\nimport {picking} from '@luma.gl/shadertools';\nimport {ShaderInputs} from '../../shader-inputs';\nimport {NumberArray3} from '@math.gl/types';\n\n/**\n * Helper class for using the legacy picking module\n */\nexport class LegacyPickingManager {\n  device: Device;\n  framebuffer: Framebuffer | null = null;\n  shaderInputs: ShaderInputs<{picking: typeof picking.props}>;\n\n  constructor(device: Device, shaderInputs: ShaderInputs) {\n    this.device = device;\n    this.shaderInputs = shaderInputs as ShaderInputs<{picking: typeof picking.props}>;\n  }\n\n  destroy() {\n    this.framebuffer?.destroy();\n  }\n\n  getFramebuffer() {\n    if (!this.framebuffer) {\n      this.framebuffer = this.device.createFramebuffer({\n        colorAttachments: ['rgba8unorm'],\n        depthStencilAttachment: 'depth24plus'\n      });\n    }\n    return this.framebuffer;\n  }\n\n  /** Clear highlighted / picked object */\n  clearPickState() {\n    this.shaderInputs.setProps({picking: {highlightedObjectColor: null}});\n  }\n\n  /** Prepare for rendering picking colors */\n  beginRenderPass() {\n    const framebuffer = this.getFramebuffer();\n    framebuffer.resize(this.device.getCanvasContext().getPixelSize());\n\n    this.shaderInputs.setProps({picking: {isActive: true}});\n\n    const pickingPass = this.device.beginRenderPass({\n      framebuffer,\n      clearColor: [0, 0, 0, 0],\n      clearDepth: 1\n    });\n\n    return pickingPass;\n  }\n\n  updatePickState(mousePosition: [number, number]) {\n    const framebuffer = this.getFramebuffer();\n\n    // use the center pixel location in device pixel range\n    const [pickX, pickY] = this.getPickPosition(mousePosition);\n\n    // Read back\n    const color255 = this.device.readPixelsToArrayWebGL(framebuffer, {\n      sourceX: pickX,\n      sourceY: pickY,\n      sourceWidth: 1,\n      sourceHeight: 1\n    });\n    // console.log(color255);\n\n    // Check if we have\n    let highlightedObjectColor: NumberArray3 | null = [...color255].map(\n      x => x / 255\n    ) as NumberArray3;\n    const isHighlightActive =\n      highlightedObjectColor[0] + highlightedObjectColor[1] + highlightedObjectColor[2] > 0;\n\n    if (!isHighlightActive) {\n      highlightedObjectColor = null;\n    }\n\n    this.shaderInputs.setProps({\n      picking: {isActive: false, highlightedObjectColor}\n    });\n  }\n\n  /**\n   * Get pick position in device pixel range\n   * use the center pixel location in device pixel range\n   */\n  getPickPosition(mousePosition: number[]): [number, number] {\n    const devicePixels = this.device.getCanvasContext().cssToDevicePixels(mousePosition);\n    const pickX = devicePixels.x + Math.floor(devicePixels.width / 2);\n    const pickY = devicePixels.y + Math.floor(devicePixels.height / 2);\n    return [pickX, pickY];\n  }\n}\n"],
  "mappings": "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CA,gBACA,OACA,QACA,eACA,eACA,mBACA,oBACA,SACA,OACA,SACA,SACA,cACA,eACA,SACA,UACA,OACA,QACA,OACA,OACA,OACA,QACA,aACA,OACA,iBACA,WACA,WACA,WACA,eACA,SACA,YACA,QACA,OACA,QACA,cACA,QACA,QACA,OACA,QACA,aACA,SACA,QACA,cACA,YACA,QACA,cACA,YACA,UACA,gBACA,cACA,qBACA,iBACA,wBACA,eACA,oBACA,oBACA,qBACA,iBACA,qBACA,wBACA,6BACA,qBACA,sBACA,gCACA,gBACA,cACA,eACA,aACA,aACA,aACA,aACA,aACA,YACA,aACA,kBACA,6BACA,gBACA,gBACA,YACA,YACA,gBACA,iBACA,iBACA,iBACA,iBACA,kBACA,kBACA,cACA,cACA,mBACA,mBACA,mBACA,kBACA,kBACA,oBACA,wBACA,eACA,wBACA,wBACA,eACA,eACA,eACA,kBACA,qBACA,0BACA,iBACA,eACA,eACA,eACA,wBACA,wBACA,cACA,mBACA,uBACA,qBACA,sBACA,eACA,iBACA,oBACA,aACA,WAAA,CAAA;AAQI,IAAO4H,IAAP,cAAyBnB,EAAAA;EAC7B,cAAAvG;AACEjC,UAAAA;EACD;AAAA;AAQG,IAAO4J,IAAP,cAAwBD,EAAAA;EAU5B,YACE7K,IACA+K,IACAlI,IACAmI,IACA7J,IACAC,IAAAA;AAEAF,UAAAA,GAVFhB,KAAA8C,QAAuB,oBAAIC,OAWzB/C,KAAKF,OAAOA,IACZE,KAAK6K,OAAOA,IACZ7K,KAAK2C,aAAaA,IAClB3C,KAAK8K,OAAOA,IACZ9K,KAAKiB,YAAYA,IACjBjB,KAAKkB,UAAUA;EAChB;EAED,IAAA,cAAI0I;AACF,WAAO;EACR;EAED,OAAOC,IAAAA;AACL,QAAI7J,KAAKD,WACP,YAAWgL,MAAQ/K,KAAKD,WACtB8J,CAAAA,GAASkB,EAAAA;AAGblB,IAAAA,GAAS7J,IAAAA;AACT,eAAWgL,MAAOhL,KAAK6K,KACrBhB,CAAAA,GAASmB,EAAAA;AAEXhL,SAAKmK,YAAYnK,KAAK8K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",
  "names": ["i", "name", "name", "arrayBuffer", "source", "canvas", "x", "y", "t", "r", "source", "log", "a", "b", "i", "attachment", "i", "TYPE_SIZES", "name", "attributeMapping", "uniformTypes", "arrayBuffer", "name", "a", "b", "i", "uniformBlock", "uniformBlock", "name", "a", "b", "name", "canvas", "name", "source", "a", "b", "i", "log", "_a", "a", "b", "name", "source", "a", "b", "name", "source", "getShaderName", "vs", "fs", "source", "log", "name", "getUniforms", "source", "m", "source", "getUniforms", "i", "name", "TypeInfo", "name", "attributes", "this", "size", "isArray", "isStruct", "isTemplate", "isPointer", "getTypeName", "MemberInfo", "type", "offset", "align", "members", "format", "count", "stride", "StructInfo", "super", "startLine", "endLine", "inUse", "ArrayInfo", "PointerInfo", "TemplateInfo", "access", "ResourceType", "VariableInfo", "group", "binding", "resourceType", "AliasInfo", "InputInfo", "locationType", "location", "interpolation", "OutputInfo", "OverrideInfo", "id", "ArgumentInfo", "FunctionInfo", "stage", "inputs", "outputs", "arguments", "returnType", "resources", "overrides", "calls", "Set", "EntryFunctions", "constructor", "vertex", "fragment", "compute", "float16ToFloat32", "float16", "s", "e", "f", "Math", "pow", "NaN", "Infinity", "float32View", "Float32Array", "int32View", "Int32Array", "buffer", "float16View", "Uint16Array", "float32ToFloat16", "float32", "f32", "sign", "exponent", "fraction", "shift", "uint32", "Uint32Array", "uint32ToFloat32", "float11ToFloat32", "f11", "u32", "getTexturePixel", "imageData", "x", "y", "z", "mipLevel", "height", "bytesPerRow", "texelByteSize", "pixelValue", "value", "uintValue", "gi", "bi", "f10", "numChannels", "i", "setPixelValue", "Int16Array", "f16", "TextureFormatInfo", "r8unorm", "bytesPerBlock", "blockWidth", "blockHeight", "isCompressed", "channels", "r8snorm", "r8uint", "r8sint", "rg8unorm", "rg8snorm", "rg8uint", "rg8sint", "rgba8unorm", "rgba8snorm", "rgba8uint", "rgba8sint", "bgra8unorm", "r16uint", "r16sint", "r16float", "rg16uint", "rg16sint", "rg16float", "rgba16uint", "rgba16sint", "rgba16float", "r32uint", "r32sint", "r32float", "rg32uint", "rg32sint", "rg32float", "rgba32uint", "rgba32sint", "rgba32float", "rgb10a2uint", "rgb10a2unorm", "rg11b10ufloat", "stencil8", "isDepthStencil", "hasDepth", "hasStencil", "depth16unorm", "depth24plus", "depthOnlyFormat", "depth32float", "stencilOnlyFormat", "rgb9e5ufloat", "Node", "_id", "line", "isAstNode", "astNodeType", "callback", "block", "_BlockStart", "instance", "node", "Array", "searchBlock", "search", "_BlockEnd", "context", "Error", "constEvaluate", "toString", "BuiltinFunctionNames", "Statement", "Function", "args", "body", "attr", "arg", "StaticAssert", "expression", "While", "condition", "Continuing", "loopId", "For", "init", "increment", "_a", "_b", "_c", "Var", "storage", "Override", "Let", "Const", "IncrementOperator", "AssignOperator", "TokenClass", "parse", "val", "key", "Increment", "operator", "variable", "Assign", "Call", "isBuiltin", "has", "Loop", "continuing", "Switch", "cases", "If", "elseif", "_else", "else", "Return", "Enable", "Requires", "extensions", "Diagnostic", "severity", "rule", "Alias", "Discard", "Break", "Continue", "Type", "t", "length", "tv", "_priority", "get", "i32", "x32", "bool", "void", "Map", "ForwardType", "Struct", "member", "TemplateType", "vec2f", "vec3f", "vec4f", "vec2i", "vec3i", "vec4i", "vec2u", "vec3u", "vec4u", "vec2h", "vec3h", "vec4h", "vec2b", "vec3b", "vec4b", "mat2x2f", "mat2x3f", "mat2x4f", "mat3x2f", "mat3x3f", "mat3x4f", "mat4x2f", "mat4x3f", "mat4x4f", "mat2x2h", "mat2x3h", "mat2x4h", "mat3x2h", "mat3x3h", "mat3x4h", "mat4x2h", "mat4x3h", "mat4x4h", "mat2x2i", "mat2x3i", "mat2x4i", "mat3x2i", "mat3x3i", "mat3x4i", "mat4x2i", "mat4x3i", "mat4x4i", "mat2x2u", "mat2x3u", "mat2x4u", "mat3x2u", "mat3x3u", "mat3x4u", "mat4x2u", "mat4x3u", "mat4x4u", "PointerType", "ArrayType", "SamplerType", "Expression", "postfix", "StringExpr", "constEvaluateString", "CreateExpr", "evalExpression", "CallExpr", "cachedReturnValue", "VariableExpr", "ConstExpr", "initializer", "data", "getSubData", "LiteralExpr", "isScalar", "ScalarData", "isVector", "VectorData", "MatrixData", "scalarValue", "console", "error", "vectorValue", "BitcastExpr", "ArrayIndex", "Expression", "index", "super", "this", "callback", "search", "Operator", "constructor", "UnaryOperator", "operator", "right", "astNodeType", "context", "type", "evalExpression", "BinaryOperator", "left", "t1", "t2", "name", "Type", "f32", "u32", "i32", "SwitchCase", "Node", "body", "searchBlock", "DefaultSelector", "Case", "selectors", "Default", "Argument", "attributes", "ElseIf", "condition", "Member", "Attribute", "value", "Data", "typeInfo", "parent", "id", "_id", "clone", "exec", "postfix", "console", "error", "toString", "getTypeName", "VoidData", "TypeInfo", "void", "PointerData", "reference", "PointerInfo", "setDataValue", "getSubData", "ScalarData", "Int32Array", "Uint32Array", "Float32Array", "data", "Math", "floor", "v", "_getVectorData", "values", "formatName", "size", "length", "VectorData", "getTypeInfo", "typename", "StringExpr", "format", "TemplateInfo", "typeName", "self", "idx", "i", "LiteralExpr", "d", "buffer", "byteOffset", "member", "toLowerCase", "m", "push", "s", "MatrixData", "endsWith", "formatSuffix", "vectorData", "TypedData", "offset", "ArrayBuffer", "cloned", "Uint8Array", "log", "ArrayInfo", "stride", "StructInfo", "found", "members", "element", "setData", "x", "byteLength", "set", "_i", "fa", "ua", "_a", "_b", "_c", "TextureData", "descriptor", "view", "width", "Array", "e", "Object", "t", "height", "depthOrArrayLayers", "sampleCount", "mipLevelCount", "dimension", "level", "max", "texelByteSize", "formatInfo", "TextureFormatInfo", "isDepthStencil", "bytesPerBlock", "bytesPerRow", "getGpuSize", "blockWidth", "blockHeight", "y", "z", "mipLevel", "getTexturePixel", "imageData", "setPixelValue", "TokenClass", "TokenType", "rule", "TokenTypes", "none", "reserved", "eof", "token", "asm", "bf16", "do", "enum", "f16", "f64", "handle", "i8", "i16", "i64", "mat", "premerge", "regardless", "typedef", "u8", "u16", "u64", "unless", "using", "vec", "keywords", "array", "keyword", "atomic", "bool", "mat2x2", "mat2x3", "mat2x4", "mat3x2", "mat3x3", "mat3x4", "mat4x2", "mat4x3", "mat4x4", "ptr", "sampler", "sampler_comparison", "struct", "texture_1d", "texture_2d", "texture_2d_array", "texture_3d", "texture_cube", "texture_cube_array", "texture_multisampled_2d", "texture_storage_1d", "texture_storage_2d", "texture_storage_2d_array", "texture_storage_3d", "texture_depth_2d", "texture_depth_2d_array", "texture_depth_cube", "texture_depth_cube_array", "texture_depth_multisampled_2d", "texture_external", "vec2", "vec3", "vec4", "bitcast", "block", "break", "case", "continue", "continuing", "default", "diagnostic", "discard", "else", "enable", "fallthrough", "false", "fn", "for", "function", "if", "let", "const", "loop", "while", "private", "read", "read_write", "return", "requires", "storage", "switch", "true", "alias", "uniform", "var", "override", "workgroup", "write", "r8unorm", "r8snorm", "r8uint", "r8sint", "r16uint", "r16sint", "r16float", "rg8unorm", "rg8snorm", "rg8uint", "rg8sint", "r32uint", "r32sint", "r32float", "rg16uint", "rg16sint", "rg16float", "rgba8unorm", "rgba8unorm_srgb", "rgba8snorm", "rgba8uint", "rgba8sint", "bgra8unorm", "bgra8unorm_srgb", "rgb10a2unorm", "rg11b10float", "rg32uint", "rg32sint", "rg32float", "rgba16uint", "rgba16sint", "rgba16float", "rgba32uint", "rgba32sint", "rgba32float", "static_assert", "tokens", "decimal_float_literal", "hex_float_literal", "int_literal", "uint_literal", "ident", "and", "and_and", "arrow", "attr", "forward_slash", "bang", "bracket_left", "bracket_right", "brace_left", "brace_right", "colon", "comma", "equal", "equal_equal", "not_equal", "greater_than", "greater_than_equal", "shift_right", "less_than", "less_than_equal", "shift_left", "modulo", "minus", "minus_minus", "period", "plus", "plus_plus", "or", "or_or", "paren_left", "paren_right", "semicolon", "star", "tilde", "underscore", "xor", "plus_equal", "minus_equal", "times_equal", "division_equal", "modulo_equal", "and_equal", "or_equal", "xor_equal", "shift_right_equal", "shift_left_equal", "simpleTokens", "literalTokens", "_", "regexTokens", "storage_class", "access_mode", "sampler_type", "sampled_texture_type", "multisampled_texture_type", "storage_texture_type", "depth_texture_type", "texture_external_type", "any_texture_type", "texel_format", "const_literal", "literal_or_ident", "element_count_expression", "template_types", "attribute_name", "assignment_operators", "increment_operators", "Token", "lexeme", "line", "start", "end", "isTemplateType", "indexOf", "isArrayType", "isArrayOrTemplateType", "WgslScanner", "source", "_tokens", "_start", "_current", "_line", "_source", "scanTokens", "_isAtEnd", "scanToken", "_advance", "_isWhitespace", "_peekAhead", "commentLevel", "simpleToken", "_addToken", "matchType", "isAlpha", "_isAlpha", "isUnderscore", "_isAlphaNumeric", "nextChar", "matchedType", "_findType", "nextLexeme", "ti", "foundLessThan", "count", "lookAheadLexeme", "lookAhead", "maxLookAhead", "li", "_match", "match", "c", "_isNumeric", "amount", "text", "substring", "isArray", "_f32", "_f32_i32", "_f32_u32", "_i32", "_i32_f32", "_i32_u32", "_u32", "_u32_f32", "_u32_i32", "castScalar", "from", "to", "_FunctionResources", "node", "resources", "inUse", "info", "_TypeSize", "align", "Reflect", "uniforms", "textures", "samplers", "aliases", "overrides", "structs", "entry", "EntryFunctions", "functions", "_types", "Map", "_functions", "ast", "Function", "Struct", "Alias", "_getAliasInfo", "Override", "_getAttributeNum", "OverrideInfo", "_isUniformVar", "g", "b", "varInfo", "VariableInfo", "ResourceType", "Uniform", "access", "_isStorageVar", "isStorageTexture", "_isStorageTexture", "StorageTexture", "Storage", "_isTextureVar", "Texture", "_isSamplerVar", "Sampler", "vertexStage", "_getAttribute", "fragmentStage", "computeStage", "stage", "FunctionInfo", "startLine", "endLine", "get", "_findResources", "inputs", "_getInputs", "args", "outputs", "_getOutputs", "returnType", "arguments", "map", "arg", "ArgumentInfo", "_addCalls", "calls", "VariableExpr", "u", "_markStructsInUse", "o", "isStruct", "isTemplate", "_getAlias", "call", "add", "group", "binding", "compute", "r", "vertex", "fragment", "isEntry", "varStack", "_BlockStart", "_BlockEnd", "pop", "Var", "_markStructsFromAST", "CreateExpr", "Let", "_findResource", "CallExpr", "callFn", "Call", "getBindGroups", "groups", "_makeRoom", "undefined", "_getStructOutputs", "output", "_getOutputInfo", "location", "locationValue", "_parseInt", "OutputInfo", "_getStructInputs", "input", "_getInputInfo", "interpolation", "InputInfo", "_parseString", "n", "parseInt", "isNaN", "a", "AliasInfo", "has", "PointerType", "_updateTypeInfo", "ArrayType", "MemberInfo", "SamplerType", "formatIsType", "TemplateType", "typeSize", "_getTypeSize", "_updateStructInfo", "lastSize", "lastOffset", "structAlign", "mi", "ml", "sizeInfo", "_roundUp", "explicitSize", "explicitAlign", "_typeInfo", "divisor", "arrayType", "E", "_textureTypes", "_samplerTypes", "obj", "attrs", "defaultValue", "k", "ceil", "VarRef", "FunctionRef", "ExecContext", "variables", "currentFunctionName", "getVariable", "getFunction", "createVariable", "ExecInterface", "BuiltinFunctions", "isTrue", "forEach", "Error", "res", "some", "arrayArg", "arrayData", "ta", "abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ys", "xs", "min", "_clamp", "minS", "maxS", "cos", "cosh", "clz32", "_countOneBits", "_countTrailingZeros", "l", "lv", "rv", "radToDeg", "PI", "mv", "mt", "formatType", "sum", "sqrt", "ls", "rs", "e1", "e2", "dot", "_dot", "exp", "pow", "_firstLeadingBit", "log2", "_firstTrailingBit", "av", "bv", "cv", "insert", "mask", "invMask", "as", "Length", "e3", "sqrtK", "round", "sign", "sin", "sinh", "edge0", "edge1", "_smoothstep", "e0", "xS", "edge", "tan", "tanh", "tname", "ttype", "_getTransposeType", "trunc", "textureArg", "textureName", "texture", "getVariableValue", "textureSize", "getMipLevelSize", "slice", "uv", "texel", "getPixel", "setPixel", "getVariableName", "currentValue", "originalValue", "VectorTypeSize", "vec2f", "vec2i", "vec2u", "vec2b", "vec2h", "vec3f", "vec3i", "vec3u", "vec3b", "vec3h", "vec4f", "vec4i", "vec4u", "vec4b", "vec4h", "MatrixTypeSize", "mat2x2f", "mat2x2h", "mat2x3f", "mat2x3h", "mat2x4f", "mat2x4h", "mat3x2f", "mat3x2h", "mat3x3f", "mat3x3h", "mat3x4f", "mat3x4h", "mat4x2f", "mat4x2h", "mat4x3f", "mat4x3h", "mat4x4f", "mat4x4h", "WgslExec", "reflection", "updateAST", "builtins", "config", "_setOverrides", "_execStatements", "kernel", "dispatchCount", "bindGroups", "f", "depth", "setVariable", "kernelRefl", "getFunctionInfo", "resource", "textureData", "_dispatchWorkgroup", "stmt", "Return", "Break", "_breakObj", "Continue", "_continueObj", "_let", "_var", "Const", "_const", "_function", "If", "_if", "Switch", "_switch", "For", "_for", "While", "_while", "Loop", "_loop", "Continuing", "subContext", "Assign", "_assign", "Increment", "_increment", "_call", "Diagnostic", "_evalBinaryOp", "_evalLiteral", "_evalVariable", "_evalCall", "_evalCreate", "ConstExpr", "_evalConst", "BitcastExpr", "_evalBitcast", "_evalUnaryOp", "getTypeInfoByName", "constants", "getOverrideInfo", "workgroup_id", "workgroupSize", "local_invocation_id", "global_invocation_id", "_dispatchExec", "globalName", "globalVar", "statements", "execStatement", "ai", "isBuiltin", "_callBuiltinFunction", "variable", "refData", "_getVariableData", "varData", "assignValue", "op", "rNode", "defType", "defaultCase", "cases", "selector", "selectorValue", "elseif", "init", "_getScalarValue", "increment", "fromType", "fromCast", "toType", "toCast", "cast", "_callConstructorValue", "_callConstructorVec", "_callConstructorMatrix", "memberInfo", "scalarValue", "tv", "_priority", "_r", "result", "rn", "_maxFormatTypeInfo", "_l", "la", "ra", "ln", "matrixA", "matrixB", "j", "colsB", "rowsA", "matrix", "vector", "cols", "rows", "resultVec", "cachedReturnValue", "All", "Any", "Select", "ArrayLength", "Abs", "Acos", "Acosh", "Asin", "Asinh", "Atan", "Atanh", "Atan2", "Ceil", "Clamp", "Cos", "Cosh", "CountLeadingZeros", "CountOneBits", "CountTrailingZeros", "Cross", "Degrees", "Determinant", "Distance", "Dot", "Dot4U8Packed", "Dot4I8Packed", "Exp", "Exp2", "ExtractBits", "FaceForward", "FirstLeadingBit", "FirstTrailingBit", "Floor", "Fma", "Fract", "Frexp", "InsertBits", "InverseSqrt", "Ldexp", "Log", "Log2", "Max", "Min", "Mix", "Modf", "Normalize", "Pow", "QuantizeToF16", "Radians", "Refract", "ReverseBits", "Round", "Saturate", "Sign", "Sin", "Sinh", "SmoothStep", "Sqrt", "Step", "Tan", "Tanh", "Transpose", "Trunc", "Dpdx", "DpdxCoarse", "DpdxFine", "Dpdy", "DpdyCoarse", "DpdyFine", "Fwidth", "FwidthCoarse", "FwidthFine", "TextureDimensions", "TextureGather", "TextureGatherCompare", "TextureLoad", "TextureNumLayers", "TextureNumLevels", "TextureNumSamples", "TextureSample", "TextureSampleBias", "TextureSampleCompare", "TextureSampleCompareLevel", "TextureSampleGrad", "TextureSampleLevel", "TextureSampleBaseClampToEdge", "TextureStore", "AtomicLoad", "AtomicStore", "AtomicAdd", "AtomicSub", "AtomicMax", "AtomicMin", "AtomicAnd", "AtomicOr", "AtomicXor", "AtomicExchange", "AtomicCompareExchangeWeak", "Pack4x8snorm", "Pack4x8unorm", "Pack4xI8", "Pack4xU8", "Pack4x8Clamp", "Pack4xU8Clamp", "Pack2x16snorm", "Pack2x16unorm", "Pack2x16float", "Unpack4x8snorm", "Unpack4x8unorm", "Unpack4xI8", "Unpack4xU8", "Unpack2x16snorm", "Unpack2x16unorm", "Unpack2x16float", "StorageBarrier", "TextureBarrier", "WorkgroupBarrier", "WorkgroupUniformLoad", "SubgroupAdd", "SubgroupExclusiveAdd", "SubgroupInclusiveAdd", "SubgroupAll", "SubgroupAnd", "SubgroupAny", "SubgroupBallot", "SubgroupBroadcast", "SubgroupBroadcastFirst", "SubgroupElect", "SubgroupMax", "SubgroupMin", "SubgroupMul", "SubgroupExclusiveMul", "SubgroupInclusiveMul", "SubgroupOr", "SubgroupShuffle", "SubgroupShuffleDown", "SubgroupShuffleUp", "SubgroupShuffleXor", "SubgroupXor", "QuadBroadcast", "QuadSwapDiagonal", "QuadSwapX", "QuadSwapY", "isVector", "vectorValue", "argValue", "vd", "fill", "ParseContext", "WgslParser", "_currentLine", "_deferArrayCountEval", "_currentLoop", "_context", "_exec", "_forwardTypeCount", "tokensOrCode", "_initialize", "statement", "_global_decl_or_directive", "arrayDecl", "countNode", "AST.VariableExpr", "constant", "constEvaluate", "AST.Member", "AST.PointerType", "_forwardType", "AST.ArrayType", "AST.Var", "AST.Let", "AST.Const", "AST.Function", "AST.Argument", "AST.ForwardType", "ft", "_getType", "scanner", "message", "_peek", "types", "_check", "_error", "tk", "hasNameType", "_previous", "_type_alias", "_consume", "directive", "_diagnostic", "_requires_directive", "_enable_directive", "_attribute", "_global_variable_decl", "_override", "_override_variable_decl", "_global_let_decl", "_global_const_decl", "_struct", "_struct_decl", "_fn", "_function_decl", "argAttrs", "typeAttrs", "_type_decl", "_updateNode", "_return", "_compound_statement", "_statement", "_if_statement", "_switch_statement", "_loop_statement", "_for_statement", "_while_statement", "_continuing_statement", "_static_assert_statement", "_return_statement", "_variable_statement", "AST.Discard", "breakStmt", "AST.Break", "loopId", "_optional_paren_expression", "continueStmt", "AST.Continue", "_increment_decrement_statement", "_func_call_statement", "_assignment_statement", "expression", "AST.StaticAssert", "whileLoop", "AST.While", "AST.Continuing", "forLoop", "AST.For", "_for_init", "_short_circuit_or_expression", "_for_increment", "_variable_decl", "AST.LiteralExpr", "savedPos", "_unary_expression", "AST.Increment", "AST.IncrementOperator", "decrement", "AST.Assign", "AST.AssignOperator", "parse", "_argument_expression_list", "AST.Call", "AST.Loop", "switchStmt", "AST.Switch", "_switch_body", "hasDefault", "_case_selectors", "AST.DefaultSelector", "_case_body", "AST.Case", "AST.Default", "_shift_expression", "nextStatement", "_match_elseif", "_elseif_statement", "_else", "AST.If", "AST.ElseIf", "AST.Return", "expr", "_short_circuit_and_expr", "AST.BinaryOperator", "_inclusive_or_expression", "_exclusive_or_expression", "_and_expression", "_equality_expression", "_relational_expression", "_additive_expression", "_multiplicative_expression", "AST.UnaryOperator", "_singular_expression", "_primary_expression", "p", "_postfix_expression", "arrayIndex", "AST.ArrayIndex", "AST.StringExpr", "_getStruct", "AST.Type", "AST.TemplateType", "mat2x2i", "mat2x3i", "mat2x4i", "mat3x2i", "mat3x3i", "mat3x4i", "mat4x2i", "mat4x3i", "mat4x4i", "mat2x2u", "mat2x3u", "mat2x4u", "mat3x2u", "mat3x3u", "mat3x4u", "mat4x2u", "mat4x3u", "mat4x4u", "AST.CreateExpr", "AST.CallExpr", "AST.ConstExpr", "x32", "_validateTypeRange", "fs", "isF16", "parseFloat", "_paren_expression", "AST.BitcastExpr", "memberAttrs", "memberName", "memberType", "structNode", "AST.Struct", "_const_expression", "isScalar", "_override_decl", "valueExpr", "constValue", "AST.Override", "severity", "ruleMessage", "AST.Diagnostic", "AST.Enable", "extensions", "AST.Requires", "aliasType", "aliasNode", "AST.Alias", "_texture_sampler_types", "pointer", "decl", "countInt", "AST.SamplerType", "AST.Attribute", "WgslReflect", "code", "update", "source", "i", "a", "i", "j", "x", "LIGHT_TYPE", "getUniforms", "i", "lights", "x", "x", "vs", "fs", "vs", "fs", "vs", "fs", "uidCounters", "uid", "uid", "geometry", "name", "name", "i", "a", "b", "i", "isTypedArray", "isNumberArray", "name", "name", "uid", "x", "i", "uid", "source", "getUniforms", "vs", "fs", "geometry", "buffer", "name", "buffer", "name", "uid", "uid", "uid", "v", "i", "uid", "i", "v", "y", "j", "uid", "uid", "uid", "uid", "i", "j", "a", "b", "c", "l", "i2", "geometry", "x", "i", "uid", "z", "x", "u", "v", "geometry", "uid", "u", "v", "y", "x", "r", "s", "c", "n", "fs", "LOG_DRAW_PRIORITY", "LOG_DRAW_TIMEOUT", "uid", "getPlatformInfo", "source", "getUniforms", "x", "y", "z", "k", "DEFAULT_HIGHLIGHT_COLOR", "getUniforms", "vs", "fs", "picking", "source", "vs", "fs", "picking", "x"]
}
