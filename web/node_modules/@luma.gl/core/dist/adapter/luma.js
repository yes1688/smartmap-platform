// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
import { isBrowser } from '@probe.gl/env';
import { Device } from "./device.js";
import { lumaStats } from "../utils/stats-manager.js";
import { log } from "../utils/log.js";
const isPage = isBrowser() && typeof document !== 'undefined';
const isPageLoaded = () => isPage && document.readyState === 'complete';
const STARTUP_MESSAGE = 'set luma.log.level=1 (or higher) to trace rendering';
const ERROR_MESSAGE = 'No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.';
/**
 * Entry point to the luma.gl GPU abstraction
 * Register WebGPU and/or WebGL adapters (controls application bundle size)
 * Run-time selection of the first available Device
 */
export class Luma {
    static defaultProps = {
        ...Device.defaultProps,
        type: 'best-available',
        adapters: undefined,
        waitForPageLoad: true
    };
    /**
     * Page load promise
     * Get a 'lazy' promise that resolves when the DOM is loaded.
     * @note Since there may be limitations on number of `load` event listeners,
     * it is recommended avoid calling this function until actually needed.
     * I.e. don't call it until you know that you will be looking up a string in the DOM.
     */
    static pageLoaded = getPageLoadPromise().then(() => {
        log.probe(2, 'DOM is loaded')();
    });
    /** Global stats for all devices */
    stats = lumaStats;
    /**
     * Global log
     *
     * Assign luma.log.level in console to control logging: \
     * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs
     * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;
     */
    log = log;
    /** Version of luma.gl */
    VERSION = 
    // Version detection using build plugin
    // @ts-expect-error no-undef
    typeof "9.1.9" !== 'undefined' ? "9.1.9" : 'running from source';
    spector;
    preregisteredAdapters = new Map();
    constructor() {
        if (globalThis.luma) {
            if (globalThis.luma.VERSION !== this.VERSION) {
                log.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)();
                log.error(`'yarn why @luma.gl/core' can help identify the source of the conflict`)();
                throw new Error(`luma.gl - multiple versions detected: see console log`);
            }
            log.error('This version of luma.gl has already been initialized')();
        }
        log.log(1, `${this.VERSION} - ${STARTUP_MESSAGE}`)();
        globalThis.luma = this;
    }
    registerAdapters(adapters) {
        for (const deviceClass of adapters) {
            this.preregisteredAdapters.set(deviceClass.type, deviceClass);
        }
    }
    /** Get type strings for supported Devices */
    getSupportedAdapters(adapters = []) {
        const adapterMap = this.getAdapterMap(adapters);
        return Array.from(adapterMap)
            .map(([, adapter]) => adapter)
            .filter(adapter => adapter.isSupported?.())
            .map(adapter => adapter.type);
    }
    /** Get type strings for best available Device */
    getBestAvailableAdapter(adapters = []) {
        const adapterMap = this.getAdapterMap(adapters);
        if (adapterMap.get('webgpu')?.isSupported?.()) {
            return 'webgpu';
        }
        if (adapterMap.get('webgl')?.isSupported?.()) {
            return 'webgl';
        }
        return null;
    }
    setDefaultDeviceProps(props) {
        Object.assign(Luma.defaultProps, props);
    }
    /** Creates a device. Asynchronously. */
    async createDevice(props = {}) {
        props = { ...Luma.defaultProps, ...props };
        if (props.waitForPageLoad) {
            // || props.createCanvasContext) {
            await Luma.pageLoaded;
        }
        const adapterMap = this.getAdapterMap(props.adapters);
        let type = props.type || '';
        if (type === 'best-available') {
            type = this.getBestAvailableAdapter(props.adapters) || type;
        }
        const adapters = this.getAdapterMap(props.adapters) || adapterMap;
        const adapter = adapters.get(type);
        const device = await adapter?.create?.(props);
        if (device) {
            return device;
        }
        throw new Error(ERROR_MESSAGE);
    }
    /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */
    async attachDevice(props) {
        const adapters = this.getAdapterMap(props.adapters);
        // WebGL
        let type = '';
        if (props.handle instanceof WebGL2RenderingContext) {
            type = 'webgl';
        }
        if (props.createCanvasContext) {
            await Luma.pageLoaded;
        }
        // TODO - WebGPU does not yet have a stable API
        // if (props.handle instanceof GPUDevice) {
        //   const WebGPUDevice = adapters.get('webgpu') as any;
        //   if (WebGPUDevice) {
        //     return (await WebGPUDevice.attach(props.handle)) as Device;
        //   }
        // }
        // null
        if (props.handle === null) {
            type = 'unknown';
        }
        const adapter = adapters.get(type);
        const device = await adapter?.attach?.(null);
        if (device) {
            return device;
        }
        throw new Error(ERROR_MESSAGE);
    }
    /**
     * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.
     * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.
     */
    enforceWebGL2(enforce = true, adapters = []) {
        const adapterMap = this.getAdapterMap(adapters);
        const webgl2Adapter = adapterMap.get('webgl');
        if (!webgl2Adapter) {
            log.warn('enforceWebGL2: webgl adapter not found')();
        }
        webgl2Adapter?.enforceWebGL2?.(enforce);
    }
    /** Convert a list of adapters to a map */
    getAdapterMap(adapters = []) {
        const map = new Map(this.preregisteredAdapters);
        for (const adapter of adapters) {
            map.set(adapter.type, adapter);
        }
        return map;
    }
    // DEPRECATED
    /** @deprecated Use registerAdapters */
    registerDevices(deviceClasses) {
        log.warn('luma.registerDevices() is deprecated, use luma.registerAdapters() instead');
        for (const deviceClass of deviceClasses) {
            const adapter = deviceClass.adapter;
            if (adapter) {
                this.preregisteredAdapters.set(adapter.type, adapter);
            }
        }
    }
}
/**
 * Entry point to the luma.gl GPU abstraction
 * Register WebGPU and/or WebGL adapters (controls application bundle size)
 * Run-time selection of the first available Device
 */
export const luma = new Luma();
// HELPER FUNCTIONS
/** Returns a promise that resolves when the page is loaded */
function getPageLoadPromise() {
    if (isPageLoaded() || typeof window === 'undefined') {
        return Promise.resolve();
    }
    return new Promise(resolve => {
        window.addEventListener('load', () => resolve());
    });
}
//# sourceMappingURL=luma.js.map