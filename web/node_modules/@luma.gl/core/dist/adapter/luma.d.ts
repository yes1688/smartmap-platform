import type { Log } from '@probe.gl/log';
import type { DeviceProps } from "./device.js";
import { Device } from "./device.js";
import { Adapter } from "./adapter.js";
import { StatsManager } from "../utils/stats-manager.js";
declare global {
    var luma: Luma;
}
/** Properties for creating a new device */
export type CreateDeviceProps = {
    /** Selects the type of device. `best-available` uses webgpu if available, then webgl. */
    type?: 'webgl' | 'webgpu' | 'unknown' | 'best-available';
    /** List of adapters. Will also search any pre-registered adapters */
    adapters?: Adapter[];
    /** Whether to wait for page to be loaded */
    waitForPageLoad?: boolean;
} & DeviceProps;
/** Properties for attaching an existing WebGL context or WebGPU device to a new luma Device */
export type AttachDeviceProps = {
    type?: 'webgl' | 'webgpu' | 'unknown' | 'best-available';
    /** Externally created WebGL context or WebGPU device */
    handle: unknown;
    /** List of adapters. Will also search any pre-registered adapters */
    adapters?: Adapter[];
} & DeviceProps;
/**
 * Entry point to the luma.gl GPU abstraction
 * Register WebGPU and/or WebGL adapters (controls application bundle size)
 * Run-time selection of the first available Device
 */
export declare class Luma {
    static defaultProps: Required<CreateDeviceProps>;
    /**
     * Page load promise
     * Get a 'lazy' promise that resolves when the DOM is loaded.
     * @note Since there may be limitations on number of `load` event listeners,
     * it is recommended avoid calling this function until actually needed.
     * I.e. don't call it until you know that you will be looking up a string in the DOM.
     */
    static pageLoaded: Promise<void>;
    /** Global stats for all devices */
    readonly stats: StatsManager;
    /**
     * Global log
     *
     * Assign luma.log.level in console to control logging: \
     * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs
     * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;
     */
    readonly log: Log;
    /** Version of luma.gl */
    readonly VERSION: string;
    spector: unknown;
    protected preregisteredAdapters: Map<string, Adapter>;
    constructor();
    registerAdapters(adapters: Adapter[]): void;
    /** Get type strings for supported Devices */
    getSupportedAdapters(adapters?: Adapter[]): string[];
    /** Get type strings for best available Device */
    getBestAvailableAdapter(adapters?: Adapter[]): 'webgpu' | 'webgl' | null;
    setDefaultDeviceProps(props: CreateDeviceProps): void;
    /** Creates a device. Asynchronously. */
    createDevice(props?: CreateDeviceProps): Promise<Device>;
    /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */
    attachDevice(props: AttachDeviceProps): Promise<Device>;
    /**
     * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.
     * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.
     */
    enforceWebGL2(enforce?: boolean, adapters?: Adapter[]): void;
    /** Convert a list of adapters to a map */
    protected getAdapterMap(adapters?: Adapter[]): Map<string, Adapter>;
    /** @deprecated Use registerAdapters */
    registerDevices(deviceClasses: any[]): void;
}
/**
 * Entry point to the luma.gl GPU abstraction
 * Register WebGPU and/or WebGL adapters (controls application bundle size)
 * Run-time selection of the first available Device
 */
export declare const luma: Luma;
//# sourceMappingURL=luma.d.ts.map