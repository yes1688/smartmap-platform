// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
import { Resource } from "./resource.js";
/**
 * Abstract Texture interface
 * Texture Object
 * https://gpuweb.github.io/gpuweb/#gputexture
 */
export class Texture extends Resource {
    static COPY_SRC = 0x01;
    static COPY_DST = 0x02;
    static TEXTURE = 0x04;
    static STORAGE = 0x08;
    static RENDER_ATTACHMENT = 0x10;
    static CubeFaces = ['+X', '-X', '+Y', '-Y', '+Z', '-Z'];
    static defaultProps = {
        ...Resource.defaultProps,
        data: null,
        dimension: '2d',
        format: 'rgba8unorm',
        width: undefined,
        height: undefined,
        depth: 1,
        mipmaps: false,
        compressed: false,
        usage: 0,
        mipLevels: undefined,
        samples: undefined,
        sampler: {},
        view: undefined,
        flipY: undefined
    };
    get [Symbol.toStringTag]() {
        return 'Texture';
    }
    toString() {
        return `Texture(${this.id},${this.format},${this.width}x${this.height})`;
    }
    /** dimension of this texture */
    dimension;
    /** format of this texture */
    format;
    /** width in pixels of this texture */
    width;
    /** height in pixels of this texture */
    height;
    /** depth of this texture */
    depth;
    /** mip levels in this texture */
    mipLevels;
    /** "Time" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */
    updateTimestamp;
    /** Do not use directly. Create with device.createTexture() */
    constructor(device, props) {
        props = Texture.normalizeProps(device, props);
        super(device, props, Texture.defaultProps);
        this.dimension = this.props.dimension;
        this.format = this.props.format;
        // Size
        this.width = this.props.width;
        this.height = this.props.height;
        this.depth = this.props.depth;
        // Calculate size, if not provided
        if (this.props.width === undefined || this.props.height === undefined) {
            // @ts-ignore
            const size = Texture.getTextureDataSize(this.props.data);
            this.width = size?.width || 1;
            this.height = size?.height || 1;
        }
        // mipLevels
        // If mipmap generation is requested and mipLevels is not provided, initialize a full pyramid
        if (this.props.mipmaps && this.props.mipLevels === undefined) {
            this.props.mipLevels = 'pyramid';
        }
        // Auto-calculate the number of mip levels as a convenience
        // TODO - Should we clamp to 1-getMipLevelCount?
        this.mipLevels =
            this.props.mipLevels === 'pyramid'
                ? Texture.getMipLevelCount(this.width, this.height)
                : this.props.mipLevels || 1;
        // TODO - perhaps this should be set on async write completion?
        this.updateTimestamp = device.incrementTimestamp();
    }
    /**
     * Create a new texture with the same parameters and optionally, a different size
     * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.
     * @note Does not copy contents of the texture
     */
    clone(size) {
        return this.device.createTexture({ ...this.props, ...size });
    }
    /** Check if data is an external image */
    static isExternalImage(data) {
        return ((typeof ImageData !== 'undefined' && data instanceof ImageData) ||
            (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) ||
            (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) ||
            (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) ||
            (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) ||
            (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) ||
            (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas));
    }
    /** Determine size (width and height) of provided image data */
    static getExternalImageSize(data) {
        if ((typeof ImageData !== 'undefined' && data instanceof ImageData) ||
            (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) ||
            (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) ||
            (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)) {
            return { width: data.width, height: data.height };
        }
        if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {
            return { width: data.naturalWidth, height: data.naturalHeight };
        }
        if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {
            return { width: data.videoWidth, height: data.videoHeight };
        }
        if (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) {
            // TODO: is this the right choice for width and height?
            return { width: data.displayWidth, height: data.displayHeight };
        }
        throw new Error('Unknown image type');
    }
    /** Check if texture data is a typed array */
    static isTextureLevelData(data) {
        const typedArray = data?.data;
        return ArrayBuffer.isView(typedArray);
    }
    /** Get the size of the texture described by the provided TextureData */
    static getTextureDataSize(data) {
        if (!data) {
            return null;
        }
        if (ArrayBuffer.isView(data)) {
            return null;
        }
        // Recurse into arrays (array of miplevels)
        if (Array.isArray(data)) {
            return Texture.getTextureDataSize(data[0]);
        }
        if (Texture.isExternalImage(data)) {
            return Texture.getExternalImageSize(data);
        }
        if (data && typeof data === 'object' && data.constructor === Object) {
            const textureDataArray = Object.values(data);
            const untypedData = textureDataArray[0];
            return { width: untypedData.width, height: untypedData.height };
        }
        throw new Error('texture size deduction failed');
    }
    /**
     * Normalize TextureData to an array of TextureLevelData / ExternalImages
     * @param data
     * @param options
     * @returns array of TextureLevelData / ExternalImages
     */
    static normalizeTextureData(data, options) {
        let lodArray;
        if (ArrayBuffer.isView(data)) {
            lodArray = [
                {
                    // ts-expect-error does data really need to be Uint8ClampedArray?
                    data,
                    width: options.width,
                    height: options.height
                    // depth: options.depth
                }
            ];
        }
        else if (!Array.isArray(data)) {
            lodArray = [data];
        }
        else {
            lodArray = data;
        }
        return lodArray;
    }
    /** Calculate the number of mip levels for a texture of width and height */
    static getMipLevelCount(width, height) {
        return Math.floor(Math.log2(Math.max(width, height))) + 1;
    }
    /** Convert luma.gl cubemap face constants to depth index */
    static getCubeFaceDepth(face) {
        // prettier-ignore
        switch (face) {
            case '+X': return 0;
            case '-X': return 1;
            case '+Y': return 2;
            case '-Y': return 3;
            case '+Z': return 4;
            case '-Z': return 5;
            default: throw new Error(face);
        }
    }
    /** Default options */
    static defaultCopyExternalImageOptions = {
        image: undefined,
        sourceX: 0,
        sourceY: 0,
        width: undefined,
        height: undefined,
        depth: 1,
        mipLevel: 0,
        x: 0,
        y: 0,
        z: 0,
        aspect: 'all',
        colorSpace: 'srgb',
        premultipliedAlpha: false,
        flipY: false
    };
    /** Ensure we have integer coordinates */
    static normalizeProps(device, props) {
        const newProps = { ...props };
        // Allow device to override props (e.g. props.mipmaps)
        const overriddenDefaultProps = device?.props?._resourceDefaults?.texture || {};
        // TODO - Type issue with props.data circumvented with Object.assign
        Object.assign(newProps, overriddenDefaultProps);
        // Ensure we have integer coordinates
        const { width, height } = newProps;
        if (typeof width === 'number') {
            newProps.width = Math.max(1, Math.ceil(width));
        }
        if (typeof height === 'number') {
            newProps.height = Math.max(1, Math.ceil(height));
        }
        return newProps;
    }
}
//# sourceMappingURL=texture.js.map