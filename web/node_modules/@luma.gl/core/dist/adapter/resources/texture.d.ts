import type { Device } from "../device.js";
import type { TypedArray } from "../../types.js";
import type { TextureFormat } from "../../gpu-type-utils/texture-formats.js";
import type { TextureView, TextureViewProps } from "./texture-view.js";
import { Resource, ResourceProps } from "./resource.js";
import { Sampler, SamplerProps } from "./sampler.js";
/**
 * These represent the main compressed texture formats
 * Each format typically has a number of more specific subformats
 */
export type TextureCompressionFormat = 'dxt' | 'dxt-srgb' | 'etc1' | 'etc2' | 'pvrtc' | 'atc' | 'astc' | 'rgtc';
/** Names of cube texture faces */
export type TextureCubeFace = '+X' | '-X' | '+Y' | '-Y' | '+Z' | '-Z';
/**
 * One mip level
 * Basic data structure is similar to `ImageData`
 * additional optional fields can describe compressed texture data.
 */
export type TextureLevelData = {
    /** WebGPU style format string. Defaults to 'rgba8unorm' */
    format?: TextureFormat;
    data: TypedArray;
    width: number;
    height: number;
    compressed?: boolean;
    byteLength?: number;
    hasAlpha?: boolean;
};
/**
 * Built-in data types that can be used to initialize textures
 * @note ImageData can be used for 8 bit data via Uint8ClampedArray
 */
export type ExternalImage = ImageBitmap | ImageData | HTMLImageElement | HTMLVideoElement | VideoFrame | HTMLCanvasElement | OffscreenCanvas;
export type TextureLevelSource = TextureLevelData | ExternalImage;
/** Texture data can be one or more mip levels */
export type TextureData = TextureLevelData | ExternalImage | (TextureLevelData | ExternalImage)[];
/** @todo - define what data type is supported for 1D textures */
export type Texture1DData = TypedArray | TextureLevelData;
/** Texture data can be one or more mip levels */
export type Texture2DData = TypedArray | TextureLevelData | ExternalImage | (TextureLevelData | ExternalImage)[];
/** Array of textures */
export type Texture3DData = TypedArray | TextureData[];
/** 6 face textures */
export type TextureCubeData = Record<TextureCubeFace, Texture2DData>;
/** Array of textures */
export type TextureArrayData = TextureData[];
/** Array of 6 face textures */
export type TextureCubeArrayData = Record<TextureCubeFace, TextureData>[];
export type TextureDataProps = Texture1DProps | Texture2DProps | Texture3DProps | TextureArrayProps | TextureCubeProps | TextureCubeArrayProps;
export type Texture1DProps = {
    dimension: '1d';
    data?: Texture1DData | null;
};
export type Texture2DProps = {
    dimension?: '2d';
    data?: Texture2DData | null;
};
export type Texture3DProps = {
    dimension: '3d';
    data?: Texture3DData | null;
};
export type TextureArrayProps = {
    dimension: '2d-array';
    data?: TextureArrayData | null;
};
export type TextureCubeProps = {
    dimension: 'cube';
    data?: TextureCubeData | null;
};
export type TextureCubeArrayProps = {
    dimension: 'cube-array';
    data: TextureCubeArrayData | null;
};
/** Texture properties */
export type TextureProps = ResourceProps & TextureDataProps & {
    format?: TextureFormat;
    width?: number | undefined;
    height?: number | undefined;
    depth?: number;
    usage?: number;
    /** How many mip levels */
    mipLevels?: number | 'pyramid';
    /** Multi sampling */
    samples?: number;
    /** Specifying mipmaps will default mipLevels to 'pyramid' and attempt to generate mipmaps */
    mipmaps?: boolean;
    /** Sampler (or SamplerProps) for the default sampler for this texture. Used if no sampler provided. Note that other samplers can still be used. */
    sampler?: Sampler | SamplerProps;
    /** Props for the default TextureView for this texture. Note that other views can still be created and used. */
    view?: TextureViewProps;
    /** Whether to flip the image vertically. Used if texture is initialized with an image. */
    flipY?: boolean;
    /** @deprecated - this is implicit from format */
    compressed?: boolean;
};
/** Options for Texture.copyExternalImage */
export type CopyExternalImageOptions = {
    /** Image */
    image: ExternalImage;
    /** Copy from image x offset (default 0) */
    sourceX?: number;
    /** Copy from image y offset (default 0) */
    sourceY?: number;
    /** Copy area width (default 1) */
    width?: number;
    /** Copy area height (default 1) */
    height?: number;
    /** Copy depth (default 1) */
    depth?: number;
    /** Which mip-level to copy into (default 0) */
    mipLevel?: number;
    /** Start copying into offset x (default 0) */
    x?: number;
    /** Start copying into offset y (default 0) */
    y?: number;
    /** Start copying from depth layer z (default 0) */
    z?: number;
    /** When copying into depth stencil textures (default 'all') */
    aspect?: 'all' | 'stencil-only' | 'depth-only';
    /** Specific color space of image data */
    colorSpace?: 'srgb';
    /** load as premultiplied alpha  */
    premultipliedAlpha?: boolean;
    /** Whether to flip the image vertically */
    flipY?: boolean;
};
/**
 * Abstract Texture interface
 * Texture Object
 * https://gpuweb.github.io/gpuweb/#gputexture
 */
export declare abstract class Texture extends Resource<TextureProps> {
    static COPY_SRC: number;
    static COPY_DST: number;
    static TEXTURE: number;
    static STORAGE: number;
    static RENDER_ATTACHMENT: number;
    static CubeFaces: TextureCubeFace[];
    static defaultProps: Required<TextureProps>;
    get [Symbol.toStringTag](): string;
    toString(): string;
    /** dimension of this texture */
    readonly dimension: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d';
    /** format of this texture */
    readonly format: TextureFormat;
    /** width in pixels of this texture */
    width: number;
    /** height in pixels of this texture */
    height: number;
    /** depth of this texture */
    depth: number;
    /** mip levels in this texture */
    mipLevels: number;
    /** Default sampler for this texture */
    abstract sampler: Sampler;
    /** Default view for this texture */
    abstract view: TextureView;
    /** "Time" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */
    updateTimestamp: number;
    /** Do not use directly. Create with device.createTexture() */
    constructor(device: Device, props: TextureProps);
    /** Create a texture view for this texture */
    abstract createView(props: TextureViewProps): TextureView;
    /** Set sampler props associated with this texture */
    abstract setSampler(sampler?: Sampler | SamplerProps): void;
    /** Copy external image data into the texture */
    abstract copyExternalImage(options: CopyExternalImageOptions): {
        width: number;
        height: number;
    };
    /**
     * Create a new texture with the same parameters and optionally, a different size
     * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.
     * @note Does not copy contents of the texture
     */
    clone(size?: {
        width: number;
        height: number;
    }): Texture;
    /** Check if data is an external image */
    static isExternalImage(data: unknown): data is ExternalImage;
    /** Determine size (width and height) of provided image data */
    static getExternalImageSize(data: ExternalImage): {
        width: number;
        height: number;
    };
    /** Check if texture data is a typed array */
    static isTextureLevelData(data: TextureData): data is TextureLevelData;
    /** Get the size of the texture described by the provided TextureData */
    static getTextureDataSize(data: TextureData | TextureCubeData | TextureArrayData | TextureCubeArrayData | TypedArray): {
        width: number;
        height: number;
    } | null;
    /**
     * Normalize TextureData to an array of TextureLevelData / ExternalImages
     * @param data
     * @param options
     * @returns array of TextureLevelData / ExternalImages
     */
    static normalizeTextureData(data: Texture2DData, options: {
        width: number;
        height: number;
        depth: number;
    }): (TextureLevelData | ExternalImage)[];
    /** Calculate the number of mip levels for a texture of width and height */
    static getMipLevelCount(width: number, height: number): number;
    /** Convert luma.gl cubemap face constants to depth index */
    static getCubeFaceDepth(face: TextureCubeFace): number;
    /** Default options */
    protected static defaultCopyExternalImageOptions: Required<CopyExternalImageOptions>;
    /** Ensure we have integer coordinates */
    protected static normalizeProps(device: Device, props: TextureProps): TextureProps;
}
//# sourceMappingURL=texture.d.ts.map