// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
import { lumaStats } from "../utils/stats-manager.js";
import { log } from "../utils/log.js";
import { uid } from "../utils/uid.js";
import { Buffer } from "./resources/buffer.js";
import { isTextureFormatCompressed } from "../gpu-type-utils/decode-texture-format.js";
import { getTextureFormatCapabilities } from "../gpu-type-utils/texture-format-capabilities.js";
/** Limits for a device (max supported sizes of resources, max number of bindings etc) */
export class DeviceLimits {
}
/** Set-like class for features (lets apps check for WebGL / WebGPU extensions) */
export class DeviceFeatures {
    features;
    disabledFeatures;
    constructor(features = [], disabledFeatures) {
        this.features = new Set(features);
        this.disabledFeatures = disabledFeatures || {};
    }
    *[Symbol.iterator]() {
        yield* this.features;
    }
    has(feature) {
        return !this.disabledFeatures?.[feature] && this.features.has(feature);
    }
}
/**
 * WebGPU Device/WebGL context abstraction
 */
export class Device {
    static defaultProps = {
        id: null,
        powerPreference: 'high-performance',
        failIfMajorPerformanceCaveat: false,
        createCanvasContext: undefined,
        // Callbacks
        onError: (error) => log.error(error.message)(),
        // Experimental
        _reuseDevices: false,
        _requestMaxLimits: true,
        _factoryDestroyPolicy: 'unused',
        // TODO - Change these after confirming things work as expected
        _initializeFeatures: true,
        _disabledFeatures: {
            'compilation-status-async-webgl': true
        },
        _resourceDefaults: {},
        // WebGL specific
        webgl: {},
        debug: log.get('debug') || undefined,
        debugShaders: log.get('debug-shaders') || undefined,
        debugFramebuffers: Boolean(log.get('debug-framebuffers')),
        debugWebGL: Boolean(log.get('debug-webgl')),
        debugSpectorJS: undefined, // Note: log setting is queried by the spector.js code
        debugSpectorJSUrl: undefined,
        // INTERNAL
        _handle: undefined
    };
    get [Symbol.toStringTag]() {
        return 'Device';
    }
    constructor(props) {
        this.props = { ...Device.defaultProps, ...props };
        this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());
    }
    /** id of this device, primarily for debugging */
    id;
    /** A copy of the device props  */
    props;
    /** Available for the application to store data on the device */
    userData = {};
    /** stats */
    statsManager = lumaStats;
    /** An abstract timestamp used for change tracking */
    timestamp = 0;
    /** True if this device has been reused during device creation (app has multiple references) */
    _reused = false;
    /** Used by other luma.gl modules to store data on the device */
    _lumaData = {};
    /** Determines what operations are supported on a texture format, checking against supported device features */
    getTextureFormatCapabilities(format) {
        const genericCapabilities = getTextureFormatCapabilities(format);
        // Check standard features
        const checkFeature = (featureOrBoolean) => (typeof featureOrBoolean === 'string'
            ? this.features.has(featureOrBoolean)
            : featureOrBoolean) ?? true;
        const supported = checkFeature(genericCapabilities.create);
        const deviceCapabilities = {
            format,
            create: supported,
            render: supported && checkFeature(genericCapabilities.render),
            filter: supported && checkFeature(genericCapabilities.filter),
            blend: supported && checkFeature(genericCapabilities.blend),
            store: supported && checkFeature(genericCapabilities.store)
        };
        return this._getDeviceSpecificTextureFormatCapabilities(deviceCapabilities);
    }
    /** Check if device supports a specific texture format (creation and `nearest` sampling) */
    isTextureFormatSupported(format, capabilities) {
        return this.getTextureFormatCapabilities(format).create;
    }
    /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */
    isTextureFormatFilterable(format) {
        return this.getTextureFormatCapabilities(format).filter;
    }
    /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */
    isTextureFormatRenderable(format) {
        return this.getTextureFormatCapabilities(format).render;
    }
    /** Check if a specific texture format is GPU compressed */
    isTextureFormatCompressed(format) {
        return isTextureFormatCompressed(format);
    }
    /**
     * Trigger device loss.
     * @returns `true` if context loss could actually be triggered.
     * @note primarily intended for testing how application reacts to device loss
     */
    loseDevice() {
        return false;
    }
    /** Report error (normally called for unhandled device errors) */
    reportError(error) {
        this.props.onError(error);
    }
    /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
    getDefaultCanvasContext() {
        if (!this.canvasContext) {
            throw new Error('Device has no default CanvasContext. See props.createCanvasContext');
        }
        return this.canvasContext;
    }
    createCommandEncoder(props = {}) {
        throw new Error('not implemented');
    }
    /** A monotonic counter for tracking buffer and texture updates */
    incrementTimestamp() {
        return this.timestamp++;
    }
    // Error Handling
    /** Report unhandled device errors */
    onError(error) {
        this.props.onError(error);
    }
    // DEPRECATED METHODS
    /** @deprecated Use getDefaultCanvasContext() */
    getCanvasContext() {
        return this.getDefaultCanvasContext();
    }
    // WebGL specific HACKS - enables app to remove webgl import
    // Use until we have a better way to handle these
    /** @deprecated - will be removed - should use command encoder */
    readPixelsToArrayWebGL(source, options) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use command encoder */
    readPixelsToBufferWebGL(source, options) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
    setParametersWebGL(parameters) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
    getParametersWebGL(parameters) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
    withParametersWebGL(parameters, func) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use clear arguments in RenderPass */
    clearWebGL(options) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use for debugging only */
    resetWebGL() {
        throw new Error('not implemented');
    }
    // IMPLEMENTATION
    /** Helper to get the canvas context props */
    static _getCanvasContextProps(props) {
        return props.createCanvasContext === true ? {} : props.createCanvasContext;
    }
    /** Subclasses use this to support .createBuffer() overloads */
    _normalizeBufferProps(props) {
        if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {
            props = { data: props };
        }
        // TODO - fragile, as this is done before we merge with default options
        // inside the Buffer constructor
        const newProps = { ...props };
        // Deduce indexType
        if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {
            if (props.data instanceof Uint32Array) {
                newProps.indexType = 'uint32';
            }
            else if (props.data instanceof Uint16Array) {
                newProps.indexType = 'uint16';
            }
            else {
                log.warn('indices buffer content must be of integer type')();
            }
        }
        return newProps;
    }
}
//# sourceMappingURL=device.js.map