{
  "version": 3,
  "sources": ["../src/index.ts", "../src/adapter/luma.ts", "../src/utils/stats-manager.ts", "../src/utils/log.ts", "../src/utils/uid.ts", "../src/adapter/resources/resource.ts", "../src/adapter/resources/buffer.ts", "../src/gpu-type-utils/decode-data-type.ts", "../src/gpu-type-utils/texture-format-table.ts", "../src/gpu-type-utils/decode-texture-format.ts", "../src/gpu-type-utils/texture-format-capabilities.ts", "../src/adapter/device.ts", "../src/adapter/adapter.ts", "../src/adapter/canvas-context.ts", "../src/adapter/resources/texture.ts", "../src/adapter/resources/texture-view.ts", "../src/adapter/resources/external-texture.ts", "../src/adapter-utils/format-compiler-log.ts", "../src/adapter/resources/shader.ts", "../src/adapter/resources/sampler.ts", "../src/adapter/resources/framebuffer.ts", "../src/adapter/resources/render-pipeline.ts", "../src/adapter/resources/render-pass.ts", "../src/adapter/resources/compute-pipeline.ts", "../src/adapter/resources/compute-pass.ts", "../src/adapter/resources/command-encoder.ts", "../src/adapter/resources/command-buffer.ts", "../src/gpu-type-utils/decode-attribute-type.ts", "../src/gpu-type-utils/decode-vertex-format.ts", "../src/adapter-utils/get-attribute-from-layouts.ts", "../src/adapter/resources/vertex-array.ts", "../src/adapter/resources/transform-feedback.ts", "../src/adapter/resources/query-set.ts", "../src/adapter/resources/pipeline-layout.ts", "../src/gpu-type-utils/decode-shader-types.ts", "../src/utils/array-utils-flat.ts", "../src/utils/is-array.ts", "../src/portable/uniform-buffer-layout.ts", "../src/utils/array-equal.ts", "../src/portable/uniform-block.ts", "../src/portable/uniform-store.ts", "../src/gpu-type-utils/vertex-format-from-attribute.ts", "../src/adapter-utils/buffer-layout-helper.ts", "../src/adapter-utils/buffer-layout-order.ts"],
  "sourcesContent": ["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// MAIN API ACCESS POINT\nexport type {AttachDeviceProps, CreateDeviceProps} from './adapter/luma';\nexport {luma} from './adapter/luma';\n\n// ADAPTER (DEVICE AND GPU RESOURCE INTERFACES)\nexport {Adapter} from './adapter/adapter';\n\nexport type {\n  DeviceProps,\n  DeviceInfo,\n  DeviceFeature,\n  DeviceTextureFormatCapabilities\n} from './adapter/device';\nexport {Device, DeviceFeatures, DeviceLimits} from './adapter/device';\n\nexport type {CanvasContextProps} from './adapter/canvas-context';\nexport {CanvasContext} from './adapter/canvas-context';\n\n// GPU RESOURCES\nexport type {ResourceProps} from './adapter/resources/resource';\nexport {Resource} from './adapter/resources/resource';\n\nexport type {BufferProps} from './adapter/resources/buffer';\nexport {Buffer} from './adapter/resources/buffer';\n\nexport type {TextureProps} from './adapter/resources/texture';\nexport {Texture} from './adapter/resources/texture';\n\nexport type {TextureViewProps} from './adapter/resources/texture-view';\nexport {TextureView} from './adapter/resources/texture-view';\n\nexport type {ExternalTextureProps} from './adapter/resources/external-texture';\nexport {ExternalTexture} from './adapter/resources/external-texture';\n\nexport type {ShaderProps} from './adapter/resources/shader';\nexport {Shader} from './adapter/resources/shader';\n\nexport type {SamplerProps, SamplerParameters} from './adapter/resources/sampler';\nexport {Sampler} from './adapter/resources/sampler';\n\nexport type {FramebufferProps} from './adapter/resources/framebuffer';\nexport {Framebuffer} from './adapter/resources/framebuffer';\n\nexport type {RenderPipelineProps} from './adapter/resources/render-pipeline';\nexport {RenderPipeline} from './adapter/resources/render-pipeline';\n\nexport type {RenderPassProps} from './adapter/resources/render-pass';\nexport {RenderPass} from './adapter/resources/render-pass';\n\nexport type {ComputePipelineProps} from './adapter/resources/compute-pipeline';\nexport {ComputePipeline} from './adapter/resources/compute-pipeline';\n\nexport type {ComputePassProps} from './adapter/resources/compute-pass';\nexport {ComputePass} from './adapter/resources/compute-pass';\n\nexport type {CommandEncoderProps} from './adapter/resources/command-encoder';\nexport {CommandEncoder} from './adapter/resources/command-encoder';\n\nexport type {CommandBufferProps} from './adapter/resources/command-buffer';\nexport {CommandBuffer} from './adapter/resources/command-buffer';\n\nexport type {VertexArrayProps} from './adapter/resources/vertex-array';\nexport {VertexArray} from './adapter/resources/vertex-array';\n\nexport type {TransformFeedbackProps, BufferRange} from './adapter/resources/transform-feedback';\nexport {TransformFeedback} from './adapter/resources/transform-feedback';\n\nexport type {QuerySetProps} from './adapter/resources/query-set';\nexport {QuerySet} from './adapter/resources/query-set';\n\nexport type {PipelineLayoutProps} from './adapter/resources/pipeline-layout';\nexport {PipelineLayout} from './adapter/resources/pipeline-layout';\n\n// PORTABLE API - UNIFORM BUFFERS\nexport {UniformBufferLayout} from './portable/uniform-buffer-layout';\nexport {UniformBlock} from './portable/uniform-block';\nexport {UniformStore} from './portable/uniform-store';\n// TEXTURE TYPES\n\n// API TYPES\nexport type {CompilerMessage} from './adapter/types/compiler-message';\n\nexport type {\n  TextureCompressionFormat,\n  TextureCubeFace,\n  TextureLevelData,\n  ExternalImage,\n  TextureData,\n  Texture1DData,\n  Texture2DData,\n  Texture3DData,\n  TextureCubeData,\n  TextureArrayData,\n  TextureCubeArrayData,\n  CopyExternalImageOptions\n} from './adapter/resources/texture';\n\nexport type {Parameters, PrimitiveTopology, IndexFormat} from './adapter/types/parameters';\n\nexport type {\n  CullMode,\n  FrontFace,\n  RasterizationParameters,\n  CompareFunction,\n  StencilOperation,\n  DepthStencilParameters,\n  BlendFactor,\n  BlendOperation,\n  ColorParameters,\n  MultisampleParameters,\n  RenderPassParameters,\n  RenderPipelineParameters,\n  PolygonMode,\n  ProvokingVertex\n} from './adapter/types/parameters';\n\nexport type {ColorAttachment, DepthStencilAttachment} from './adapter/types/attachments';\n\nexport type {\n  ShaderLayout,\n  ComputeShaderLayout,\n  AttributeDeclaration,\n  BindingDeclaration,\n  Binding,\n  UniformBufferBindingLayout,\n  StorageBufferBindingLayout,\n  TextureBindingLayout,\n  SamplerBindingLayout,\n  StorageTextureBindingLayout\n} from './adapter/types/shader-layout';\nexport type {BufferLayout, BufferAttributeLayout} from './adapter/types/buffer-layout';\nexport type {\n  // Deprecated, todo\n  AttributeBinding,\n  UniformBinding,\n  UniformBlockBinding,\n  VaryingBinding\n} from './adapter/types/shader-layout';\n\nexport type {UniformValue} from './adapter/types/uniforms';\n\n// GPU TYPE UTILS - GPU MEMORY LAYOUT TYPES - EXTERNAL\n\nexport type {NumberArray, TypedArray, TypedArrayConstructor} from './types';\nexport type {VertexFormat, VertexType} from './gpu-type-utils/vertex-formats';\nexport type {\n  ShaderDataType,\n  ShaderAttributeType,\n  ShaderUniformType\n} from './gpu-type-utils/shader-types';\nexport type {\n  TextureFormat,\n  ColorTextureFormat,\n  DepthStencilTextureFormat\n} from './gpu-type-utils/texture-formats';\nexport type {TextureFormatInfo} from './gpu-type-utils/texture-format-info';\nexport type {TextureFormatCapabilities} from './gpu-type-utils/texture-format-capabilities';\n\n// GPU TYPE UTILS - GPU MEMORY LAYOUT HELPERS - CAN BE USED BY APPS BUT MOSTLY USED INTERNALLY\n\nexport {decodeVertexFormat} from './gpu-type-utils/decode-vertex-format';\nexport {decodeShaderUniformType} from './gpu-type-utils/decode-shader-types';\nexport {decodeShaderAttributeType} from './gpu-type-utils/decode-attribute-type';\nexport {getDataTypeFromTypedArray} from './gpu-type-utils/vertex-format-from-attribute';\nexport {getTypedArrayFromDataType} from './gpu-type-utils/vertex-format-from-attribute';\nexport {getVertexFormatFromAttribute} from './gpu-type-utils/vertex-format-from-attribute';\n\nexport {decodeTextureFormat} from './gpu-type-utils/decode-texture-format';\nexport {getTextureFormatCapabilities} from './gpu-type-utils/texture-format-capabilities';\n\n// GENERAL EXPORTS - FOR APPLICATIONS\n\nexport type {StatsManager} from './utils/stats-manager'; // TODO - should this be moved to probe.gl?\n\n// ADAPTER UTILS - for implementing Device adapters (@luma.gl/webgl and @luma.gl/webgpu)\n\nexport type {\n  CopyBufferToBufferOptions,\n  CopyBufferToTextureOptions,\n  CopyTextureToBufferOptions,\n  CopyTextureToTextureOptions\n} from './adapter/resources/command-encoder';\n\n// INTERNAL UTILS - for use in other luma.gl modules only\nexport {log} from './utils/log';\nexport {getScratchArray} from './utils/array-utils-flat';\nexport type {AttributeInfo} from './adapter-utils/get-attribute-from-layouts';\nexport {BufferLayoutHelper as _BufferLayoutHelper} from './adapter-utils/buffer-layout-helper';\nexport {getAttributeInfosFromLayouts} from './adapter-utils/get-attribute-from-layouts';\nexport {sortedBufferLayoutByShaderSourceLocations} from './adapter-utils/buffer-layout-order';\n\n// TEST EXPORTS\nexport {\n  getTextureFormatDefinition as _getTextureFormatDefinition,\n  getTextureFormatTable as _getTextureFormatTable\n} from './gpu-type-utils/texture-format-table';\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Log} from '@probe.gl/log';\nimport {isBrowser} from '@probe.gl/env';\nimport type {DeviceProps} from './device';\nimport {Device} from './device';\nimport {Adapter} from './adapter';\nimport {StatsManager, lumaStats} from '../utils/stats-manager';\nimport {log} from '../utils/log';\n\nconst isPage: boolean = isBrowser() && typeof document !== 'undefined';\nconst isPageLoaded: () => boolean = () => isPage && document.readyState === 'complete';\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var luma: Luma;\n}\n\nconst STARTUP_MESSAGE = 'set luma.log.level=1 (or higher) to trace rendering';\n\nconst ERROR_MESSAGE =\n  'No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.';\n\n/** Properties for creating a new device */\nexport type CreateDeviceProps = {\n  /** Selects the type of device. `best-available` uses webgpu if available, then webgl. */\n  type?: 'webgl' | 'webgpu' | 'unknown' | 'best-available';\n  /** List of adapters. Will also search any pre-registered adapters */\n  adapters?: Adapter[];\n  /** Whether to wait for page to be loaded */\n  waitForPageLoad?: boolean;\n} & DeviceProps;\n\n/** Properties for attaching an existing WebGL context or WebGPU device to a new luma Device */\nexport type AttachDeviceProps = {\n  type?: 'webgl' | 'webgpu' | 'unknown' | 'best-available';\n  /** Externally created WebGL context or WebGPU device */\n  handle: unknown; // WebGL2RenderingContext | GPUDevice | null;\n  /** List of adapters. Will also search any pre-registered adapters */\n  adapters?: Adapter[];\n} & DeviceProps;\n\n/**\n * Entry point to the luma.gl GPU abstraction\n * Register WebGPU and/or WebGL adapters (controls application bundle size)\n * Run-time selection of the first available Device\n */\nexport class Luma {\n  static defaultProps: Required<CreateDeviceProps> = {\n    ...Device.defaultProps,\n    type: 'best-available',\n    adapters: undefined!,\n    waitForPageLoad: true\n  };\n\n  /**\n   * Page load promise\n   * Get a 'lazy' promise that resolves when the DOM is loaded.\n   * @note Since there may be limitations on number of `load` event listeners,\n   * it is recommended avoid calling this function until actually needed.\n   * I.e. don't call it until you know that you will be looking up a string in the DOM.\n   */\n  static pageLoaded: Promise<void> = getPageLoadPromise().then(() => {\n    log.probe(2, 'DOM is loaded')();\n  });\n\n  /** Global stats for all devices */\n  readonly stats: StatsManager = lumaStats;\n\n  /**\n   * Global log\n   *\n   * Assign luma.log.level in console to control logging: \\\n   * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs\n   * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;\n   */\n  readonly log: Log = log;\n\n  /** Version of luma.gl */\n  readonly VERSION: string =\n    // Version detection using build plugin\n    // @ts-expect-error no-undef\n    typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'running from source';\n\n  spector: unknown;\n\n  protected preregisteredAdapters = new Map<string, Adapter>();\n\n  constructor() {\n    if (globalThis.luma) {\n      if (globalThis.luma.VERSION !== this.VERSION) {\n        log.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)();\n        log.error(`'yarn why @luma.gl/core' can help identify the source of the conflict`)();\n        throw new Error(`luma.gl - multiple versions detected: see console log`);\n      }\n\n      log.error('This version of luma.gl has already been initialized')();\n    }\n\n    log.log(1, `${this.VERSION} - ${STARTUP_MESSAGE}`)();\n\n    globalThis.luma = this;\n  }\n\n  registerAdapters(adapters: Adapter[]): void {\n    for (const deviceClass of adapters) {\n      this.preregisteredAdapters.set(deviceClass.type, deviceClass);\n    }\n  }\n\n  /** Get type strings for supported Devices */\n  getSupportedAdapters(adapters: Adapter[] = []): string[] {\n    const adapterMap = this.getAdapterMap(adapters);\n    return Array.from(adapterMap)\n      .map(([, adapter]) => adapter)\n      .filter(adapter => adapter.isSupported?.())\n      .map(adapter => adapter.type);\n  }\n\n  /** Get type strings for best available Device */\n  getBestAvailableAdapter(adapters: Adapter[] = []): 'webgpu' | 'webgl' | null {\n    const adapterMap = this.getAdapterMap(adapters);\n    if (adapterMap.get('webgpu')?.isSupported?.()) {\n      return 'webgpu';\n    }\n    if (adapterMap.get('webgl')?.isSupported?.()) {\n      return 'webgl';\n    }\n    return null;\n  }\n\n  setDefaultDeviceProps(props: CreateDeviceProps): void {\n    Object.assign(Luma.defaultProps, props);\n  }\n\n  /** Creates a device. Asynchronously. */\n  async createDevice(props: CreateDeviceProps = {}): Promise<Device> {\n    props = {...Luma.defaultProps, ...props};\n\n    if (props.waitForPageLoad) {\n      // || props.createCanvasContext) {\n      await Luma.pageLoaded;\n    }\n\n    const adapterMap = this.getAdapterMap(props.adapters);\n\n    let type: string = props.type || '';\n    if (type === 'best-available') {\n      type = this.getBestAvailableAdapter(props.adapters) || type;\n    }\n\n    const adapters = this.getAdapterMap(props.adapters) || adapterMap;\n\n    const adapter = adapters.get(type);\n    const device = await adapter?.create?.(props);\n    if (device) {\n      return device;\n    }\n\n    throw new Error(ERROR_MESSAGE);\n  }\n\n  /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */\n  async attachDevice(props: AttachDeviceProps): Promise<Device> {\n    const adapters = this.getAdapterMap(props.adapters);\n\n    // WebGL\n    let type = '';\n    if (props.handle instanceof WebGL2RenderingContext) {\n      type = 'webgl';\n    }\n\n    if (props.createCanvasContext) {\n      await Luma.pageLoaded;\n    }\n\n    // TODO - WebGPU does not yet have a stable API\n    // if (props.handle instanceof GPUDevice) {\n    //   const WebGPUDevice = adapters.get('webgpu') as any;\n    //   if (WebGPUDevice) {\n    //     return (await WebGPUDevice.attach(props.handle)) as Device;\n    //   }\n    // }\n\n    // null\n    if (props.handle === null) {\n      type = 'unknown';\n    }\n\n    const adapter = adapters.get(type);\n    const device = await adapter?.attach?.(null);\n    if (device) {\n      return device;\n    }\n\n    throw new Error(ERROR_MESSAGE);\n  }\n\n  /**\n   * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.\n   * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.\n   */\n  enforceWebGL2(enforce: boolean = true, adapters: Adapter[] = []): void {\n    const adapterMap = this.getAdapterMap(adapters);\n    const webgl2Adapter = adapterMap.get('webgl');\n    if (!webgl2Adapter) {\n      log.warn('enforceWebGL2: webgl adapter not found')();\n    }\n    (webgl2Adapter as any)?.enforceWebGL2?.(enforce);\n  }\n\n  /** Convert a list of adapters to a map */\n  protected getAdapterMap(adapters: Adapter[] = []): Map<string, Adapter> {\n    const map = new Map(this.preregisteredAdapters);\n    for (const adapter of adapters) {\n      map.set(adapter.type, adapter);\n    }\n    return map;\n  }\n\n  // DEPRECATED\n\n  /** @deprecated Use registerAdapters */\n  registerDevices(deviceClasses: any[]): void {\n    log.warn('luma.registerDevices() is deprecated, use luma.registerAdapters() instead');\n    for (const deviceClass of deviceClasses) {\n      const adapter = deviceClass.adapter as Adapter;\n      if (adapter) {\n        this.preregisteredAdapters.set(adapter.type, adapter);\n      }\n    }\n  }\n}\n\n/**\n * Entry point to the luma.gl GPU abstraction\n * Register WebGPU and/or WebGL adapters (controls application bundle size)\n * Run-time selection of the first available Device\n */\nexport const luma = new Luma();\n\n// HELPER FUNCTIONS\n\n/** Returns a promise that resolves when the page is loaded */\nfunction getPageLoadPromise(): Promise<void> {\n  if (isPageLoaded() || typeof window === 'undefined') {\n    return Promise.resolve();\n  }\n  return new Promise(resolve => {\n    window.addEventListener('load', () => resolve());\n  });\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Stats} from '@probe.gl/stats';\n\n/**\n * Helper class managing a collection of probe.gl stats objects\n */\nexport class StatsManager {\n  stats = new Map();\n\n  getStats(name: string): Stats {\n    return this.get(name);\n  }\n\n  get(name: string): Stats {\n    if (!this.stats.has(name)) {\n      this.stats.set(name, new Stats({id: name}));\n    }\n\n    return this.stats.get(name);\n  }\n}\n\n/** Global stats for all luma.gl devices */\nexport const lumaStats: StatsManager = new StatsManager();\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Log} from '@probe.gl/log';\n\n/** Global log instance */\nexport const log: Log = new Log({id: 'luma.gl'});\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nconst uidCounters: Record<string, number> = {};\n\n/**\n * Returns a UID.\n * @param id= - Identifier base name\n * @return uid\n **/\nexport function uid(id: string = 'id'): string {\n  uidCounters[id] = uidCounters[id] || 1;\n  const count = uidCounters[id]++;\n  return `${id}-${count}`;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {uid} from '../../utils/uid';\n\nexport type ResourceProps = {\n  /** Name of resource, mainly for debugging purposes. A unique name will be assigned if not provided */\n  id?: string;\n  /** Handle for the underlying resources (WebGL object or WebGPU handle) */\n  handle?: any;\n  /** User provided data stored on this resource  */\n  userData?: {[key: string]: any};\n};\n\n/**\n * Base class for GPU (WebGPU/WebGL) Resources\n */\nexport abstract class Resource<Props extends ResourceProps> {\n  /** Default properties for resource */\n  static defaultProps: Required<ResourceProps> = {\n    id: 'undefined',\n    handle: undefined,\n    userData: undefined!\n  };\n\n  abstract get [Symbol.toStringTag](): string;\n\n  toString(): string {\n    return `${this[Symbol.toStringTag] || this.constructor.name}:\"${this.id}\"`;\n  }\n\n  /** props.id, for debugging. */\n  id: string;\n  readonly props: Required<Props>;\n  readonly userData: Record<string, unknown> = {};\n  abstract readonly device: Device;\n  private _device: Device;\n\n  /** Whether this resource has been destroyed */\n  destroyed: boolean = false;\n  /** For resources that allocate GPU memory */\n  private allocatedBytes: number = 0;\n  /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created \"sub\" resources. */\n  private _attachedResources = new Set<Resource<ResourceProps>>();\n\n  /**\n   * Create a new Resource. Called from Subclass\n   */\n  constructor(device: Device, props: Props, defaultProps: Required<Props>) {\n    if (!device) {\n      throw new Error('no device');\n    }\n    this._device = device;\n    this.props = selectivelyMerge<Props>(props, defaultProps);\n\n    const id =\n      this.props.id !== 'undefined' ? (this.props.id as string) : uid(this[Symbol.toStringTag]);\n    this.props.id = id;\n    this.id = id;\n    this.userData = this.props.userData || {};\n\n    this.addStats();\n  }\n\n  /**\n   * destroy can be called on any resource to release it before it is garbage collected.\n   */\n  destroy(): void {\n    this.destroyResource();\n  }\n\n  /** @deprecated Use destroy() */\n  delete(): this {\n    this.destroy();\n    return this;\n  }\n\n  /**\n   * Combines a map of user props and default props, only including props from defaultProps\n   * @returns returns a map of overridden default props\n   */\n  getProps(): object {\n    return this.props;\n  }\n\n  // ATTACHED RESOURCES\n\n  /**\n   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed\n   * Called automatically when sub resources are auto created but can be called by application\n   */\n  attachResource(resource: Resource<ResourceProps>): void {\n    this._attachedResources.add(resource);\n  }\n\n  /**\n   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.\n   */\n  detachResource(resource: Resource<ResourceProps>): void {\n    this._attachedResources.delete(resource);\n  }\n\n  /**\n   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.\n   */\n  destroyAttachedResource(resource: Resource<ResourceProps>): void {\n    if (this._attachedResources.delete(resource)) {\n      resource.destroy();\n    }\n  }\n\n  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */\n  destroyAttachedResources(): void {\n    for (const resource of Object.values(this._attachedResources)) {\n      resource.destroy();\n    }\n    // don't remove while we are iterating\n    this._attachedResources = new Set<Resource<ResourceProps>>();\n  }\n\n  // PROTECTED METHODS\n\n  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */\n  protected destroyResource(): void {\n    this.destroyAttachedResources();\n    this.removeStats();\n    this.destroyed = true;\n  }\n\n  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */\n  protected removeStats(): void {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    const name = this[Symbol.toStringTag];\n    stats.get(`${name}s Active`).decrementCount();\n  }\n\n  /** Called by subclass to track memory allocations */\n  protected trackAllocatedMemory(bytes: number, name = this[Symbol.toStringTag]): void {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    stats.get('GPU Memory').addCount(bytes);\n    stats.get(`${name} Memory`).addCount(bytes);\n    this.allocatedBytes = bytes;\n  }\n\n  /** Called by subclass to track memory deallocations */\n  protected trackDeallocatedMemory(name = this[Symbol.toStringTag]): void {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    stats.get('GPU Memory').subtractCount(this.allocatedBytes);\n    stats.get(`${name} Memory`).subtractCount(this.allocatedBytes);\n    this.allocatedBytes = 0;\n  }\n\n  /** Called by resource constructor to track object creation */\n  private addStats(): void {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    const name = this[Symbol.toStringTag];\n    stats.get('Resources Created').incrementCount();\n    stats.get(`${name}s Created`).incrementCount();\n    stats.get(`${name}s Active`).incrementCount();\n  }\n}\n\n/**\n * Combines a map of user props and default props, only including props from defaultProps\n * @param props\n * @param defaultProps\n * @returns returns a map of overridden default props\n */\nfunction selectivelyMerge<Props>(props: Props, defaultProps: Required<Props>): Required<Props> {\n  const mergedProps = {...defaultProps};\n  for (const key in props) {\n    if (props[key] !== undefined) {\n      mergedProps[key] = props[key];\n    }\n  }\n  return mergedProps;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n\nexport type BufferProps = ResourceProps & {\n  /** Supply a handle to connect to an existing device-specific buffer */\n  handle?: WebGLBuffer;\n  /** Specifies how this buffer can be used */\n  usage?: number;\n  /** Length in bytes of memory to be allocated. If not specified, `byteLength` of  `props.data` will be used. */\n  byteLength?: number;\n  /** Data to initialize the buffer with. */\n  data?: ArrayBuffer | ArrayBufferView | null;\n  /** Byte offset into the newly created Buffer to store data at */\n  byteOffset?: number;\n  /** If props.usage includes Buffer.INDEX */\n  indexType?: 'uint16' | 'uint32';\n\n  // TBD\n  mappedAtCreation?: boolean;\n};\n\n/** Abstract GPU buffer */\nexport abstract class Buffer extends Resource<BufferProps> {\n  static override defaultProps: Required<BufferProps> = {\n    ...Resource.defaultProps,\n    usage: 0, // Buffer.COPY_DST | Buffer.COPY_SRC\n    byteLength: 0,\n    byteOffset: 0,\n    data: null,\n    indexType: 'uint16',\n    mappedAtCreation: false\n  };\n\n  // Usage Flags\n  static MAP_READ = 0x01;\n  static MAP_WRITE = 0x02;\n  static COPY_SRC = 0x0004;\n  static COPY_DST = 0x0008;\n  /** Index buffer */\n  static INDEX = 0x0010;\n  /** Vertex buffer */\n  static VERTEX = 0x0020;\n  /** Uniform buffer */\n  static UNIFORM = 0x0040;\n  /** Storage buffer */\n  static STORAGE = 0x0080;\n  static INDIRECT = 0x0100;\n  static QUERY_RESOLVE = 0x0200;\n\n  override get [Symbol.toStringTag](): string {\n    return 'Buffer';\n  }\n\n  /** The usage with which this buffer was created */\n  readonly usage: number;\n  /** For index buffers, whether indices are 16 or 32 bit */\n  readonly indexType?: 'uint16' | 'uint32';\n  /** Length of buffer in bytes */\n  abstract byteLength: number;\n  /** \"Time\" of last update, can be used to check if redraw is needed */\n  updateTimestamp: number;\n\n  constructor(device: Device, props: BufferProps) {\n    const deducedProps = {...props};\n\n    // Deduce indexType\n    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {\n      if (props.data instanceof Uint32Array) {\n        deducedProps.indexType = 'uint32';\n      } else if (props.data instanceof Uint16Array) {\n        deducedProps.indexType = 'uint16';\n      }\n    }\n\n    // Remove data from props before storing, we don't want to hold on to a big chunk of memory\n    delete deducedProps.data;\n\n    super(device, deducedProps, Buffer.defaultProps);\n\n    this.usage = deducedProps.usage || 0;\n    this.indexType = deducedProps.indexType;\n\n    // TODO - perhaps this should be set on async write completion?\n    this.updateTimestamp = device.incrementTimestamp();\n  }\n\n  /**\n   * Create a copy of this Buffer with new byteLength, with same props but of the specified size.\n   * @note Does not copy contents of the cloned Buffer.\n   */\n  clone(props: {byteLength: number}): Buffer {\n    return this.device.createBuffer({...this.props, ...props});\n  }\n\n  /** Write data to buffer */\n  abstract write(data: ArrayBufferView, byteOffset?: number): void;\n\n  /** Read data asynchronously */\n  abstract readAsync(byteOffset?: number, byteLength?: number): Promise<Uint8Array>;\n\n  /** Read data synchronously. @note WebGL2 only */\n  readSyncWebGL(byteOffset?: number, byteLength?: number): Uint8Array {\n    throw new Error('not implemented');\n  }\n\n  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)\n\n  /** Max amount of debug data saved. Two vec4's */\n  static DEBUG_DATA_MAX_LENGTH = 32;\n\n  /** A partial CPU-side copy of the data in this buffer, for debugging purposes */\n  debugData: ArrayBuffer = new ArrayBuffer(0);\n\n  /** This doesn't handle partial non-zero offset updates correctly */\n  protected _setDebugData(\n    data: ArrayBufferView | ArrayBuffer | null,\n    byteOffset: number,\n    byteLength: number\n  ): void {\n    const arrayBuffer: ArrayBuffer | null = ArrayBuffer.isView(data) ? data.buffer : data;\n    const debugDataLength = Math.min(\n      data ? data.byteLength : byteLength,\n      Buffer.DEBUG_DATA_MAX_LENGTH\n    );\n    if (arrayBuffer === null) {\n      this.debugData = new ArrayBuffer(debugDataLength);\n    } else if (byteOffset === 0 && byteLength === arrayBuffer.byteLength) {\n      this.debugData = arrayBuffer.slice(0, debugDataLength);\n    } else {\n      this.debugData = arrayBuffer.slice(byteOffset, byteOffset + debugDataLength);\n    }\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {DataType, NormalizedDataType} from './vertex-formats';\n\nexport type DecodedVertexType = {\n  /** WebGPU data type */\n  dataType: DataType;\n  /** Length in bytes of the data for one vertex */\n  byteLength: number;\n  /** Whether this is for integer or float vert */\n  integer: boolean;\n  /** Whether this data type is signed */\n  signed: boolean;\n  /** Whether this is a normalized integer (that must be used as float) */\n  normalized: boolean;\n};\n\n/** Decodes a vertex type, returning byte length and flags (integer, signed, normalized) */\nexport function decodeVertexType(type: NormalizedDataType): DecodedVertexType {\n  const dataType = TYPE_MAP[type];\n  const bytes = getDataTypeBytes(dataType);\n  const normalized: boolean = type.includes('norm');\n  const integer: boolean = !normalized && !type.startsWith('float');\n  const signed: boolean = type.startsWith('s');\n  return {\n    dataType: TYPE_MAP[type],\n    byteLength: bytes,\n    integer,\n    signed,\n    normalized\n  };\n}\n\nfunction getDataTypeBytes(type: DataType): number {\n  const bytes = TYPE_SIZES[type];\n  // assert(bytes);\n  return bytes;\n}\n\nconst TYPE_MAP: Record<NormalizedDataType, DataType> = {\n  uint8: 'uint8',\n  sint8: 'sint8',\n  unorm8: 'uint8',\n  snorm8: 'sint8',\n  uint16: 'uint16',\n  sint16: 'sint16',\n  unorm16: 'uint16',\n  snorm16: 'sint16',\n  float16: 'float16',\n  float32: 'float32',\n  uint32: 'uint32',\n  sint32: 'sint32'\n};\n\nconst TYPE_SIZES: Record<DataType, number> = {\n  uint8: 1,\n  sint8: 1,\n  uint16: 2,\n  sint16: 2,\n  float16: 2,\n  float32: 4,\n  uint32: 4,\n  sint32: 4\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TextureFormat} from './texture-formats';\nimport {TextureFeature} from './texture-features';\nimport {TextureFormatInfo} from './texture-format-info';\n\n/* eslint-disable camelcase */\n\n// Define local device feature strings to optimize minification\nconst texture_compression_bc: TextureFeature = 'texture-compression-bc';\nconst texture_compression_astc: TextureFeature = 'texture-compression-astc';\nconst texture_compression_etc2: TextureFeature = 'texture-compression-etc2';\nconst texture_compression_etc1_webgl: TextureFeature = 'texture-compression-etc1-webgl';\nconst texture_compression_pvrtc_webgl: TextureFeature = 'texture-compression-pvrtc-webgl';\nconst texture_compression_atc_webgl: TextureFeature = 'texture-compression-atc-webgl';\n\nconst float32_renderable: TextureFeature = 'float32-renderable-webgl';\nconst float16_renderable: TextureFeature = 'float16-renderable-webgl';\nconst rgb9e5ufloat_renderable: TextureFeature = 'rgb9e5ufloat-renderable-webgl';\nconst snorm8_renderable: TextureFeature = 'snorm8-renderable-webgl';\nconst norm16_renderable: TextureFeature = 'norm16-renderable-webgl';\nconst snorm16_renderable: TextureFeature = 'snorm16-renderable-webgl';\n\nconst float32_filterable: TextureFeature = 'float32-filterable';\nconst float16_filterable: TextureFeature = 'float16-filterable-webgl';\n\n/** https://www.w3.org/TR/webgpu/#texture-format-caps */\n\n/** Internal type representing texture capabilities */\ntype TextureFormatDefinition = Partial<TextureFormatInfo> & {\n  /** for compressed texture formats */\n  f?: TextureFeature;\n  /** renderable if feature is present. false means the spec does not support this format */\n  render?: TextureFeature | false;\n  /** filterable if feature is present. false means the spec does not support this format */\n  filter?: TextureFeature | false;\n  blend?: TextureFeature | false;\n  store?: TextureFeature | false;\n\n  /** (bytes per pixel), for memory usage calculations. */\n  b?: number;\n  /** channels */\n  c?: number;\n  bpp?: number;\n  /** packed */\n  p?: number;\n\n  /** If not supported on WebGPU */\n  wgpu?: false;\n};\n\nexport function getTextureFormatDefinition(format: TextureFormat): TextureFormatDefinition {\n  const info = TEXTURE_FORMAT_TABLE[format];\n  if (!info) {\n    throw new Error(`Unsupported texture format ${format}`);\n  }\n  return info;\n}\n\nexport function getTextureFormatTable(): Readonly<Record<TextureFormat, TextureFormatDefinition>> {\n  return TEXTURE_FORMAT_TABLE;\n}\n\n// prettier-ignore\nconst TEXTURE_FORMAT_TABLE: Readonly<Record<TextureFormat, TextureFormatDefinition>> = {\n  // 8-bit formats\n  'r8unorm': {},\n  'r8snorm': {render: snorm8_renderable},\n  'r8uint': {},\n  'r8sint': {},\n\n  // 16-bit formats\n  'rg8unorm': {},\n  'rg8snorm': {render: snorm8_renderable},\n  'rg8uint': {},\n  'rg8sint': {},\n\n  'r16uint': {},\n  'r16sint': {},\n  'r16float': {render: float16_renderable, filter: 'float16-filterable-webgl'},\n  'r16unorm-webgl': {f: norm16_renderable},\n  'r16snorm-webgl': {f: snorm16_renderable},\n\n  // Packed 16-bit formats\n  'rgba4unorm-webgl': {channels: 'rgba', bitsPerChannel: [4, 4, 4, 4], packed: true},\n  'rgb565unorm-webgl': {channels: 'rgb', bitsPerChannel: [5, 6, 5, 0], packed: true},\n  'rgb5a1unorm-webgl': {channels: 'rgba', bitsPerChannel: [5, 5, 5, 1], packed: true},\n\n  // 24-bit formats\n  'rgb8unorm-webgl': {},\n  'rgb8snorm-webgl': {},\n\n  // 32-bit formats  \n  'rgba8unorm': {},\n  'rgba8unorm-srgb': {},\n  'rgba8snorm': {render: snorm8_renderable},\n  'rgba8uint': {},\n  'rgba8sint': {},\n\n  // 32-bit, reverse colors, webgpu only\n  'bgra8unorm': {},\n  'bgra8unorm-srgb': {},\n\n  'rg16uint': {},\n  'rg16sint': {},\n  'rg16float': {render: float16_renderable, filter: float16_filterable},\n  'rg16unorm-webgl': {render: norm16_renderable},\n  'rg16snorm-webgl': {render: snorm16_renderable},\n\n  'r32uint': {},\n  'r32sint': {},\n  'r32float': {render: float32_renderable, filter: float32_filterable},\n\n  // Packed 32 bit formats\n  'rgb9e5ufloat': {channels: 'rgb', packed: true, render: rgb9e5ufloat_renderable}, // , filter: true},\n  'rg11b10ufloat': {channels: 'rgb', bitsPerChannel: [11, 11, 10, 0], packed: true, p: 1,render: float32_renderable},\n  'rgb10a2unorm': {channels: 'rgba',  bitsPerChannel: [10, 10, 10, 2], packed: true, p: 1},\n  'rgb10a2uint-webgl': {channels: 'rgba', bitsPerChannel: [10, 10, 10, 2], packed: true, p: 1, wgpu: false},\n\n  // 48-bit formats\n  'rgb16unorm-webgl': {f: norm16_renderable}, // rgb not renderable\n  'rgb16snorm-webgl': {f: norm16_renderable}, // rgb not renderable\n\n  // 64-bit formats\n  'rg32uint': {},\n  'rg32sint': {},\n  'rg32float': {render: false, filter: float32_filterable},\n  'rgba16uint': {},\n  'rgba16sint': {},\n  'rgba16float': {render: float16_renderable, filter: float16_filterable},\n  'rgba16unorm-webgl': {render: norm16_renderable},\n  'rgba16snorm-webgl': {render: snorm16_renderable},\n\n  // 96-bit formats (deprecated!)\n  'rgb32float-webgl': {render: float32_renderable, filter: float32_filterable},\n  \n  // 128-bit formats\n  'rgba32uint': {},\n  'rgba32sint': {},\n  'rgba32float': {render: float32_renderable, filter: float32_filterable},\n\n  // Depth/stencil\n  \n  // Depth and stencil formats\n  stencil8: {attachment: 'stencil', bitsPerChannel: [8, 0, 0, 0], dataType: 'uint8'},\n  'depth16unorm': {attachment: 'depth',  bitsPerChannel: [16, 0, 0, 0], dataType: 'uint16'},\n  'depth24plus': {attachment: 'depth', bitsPerChannel: [24, 0, 0, 0], dataType: 'uint32'},\n  'depth32float': {attachment: 'depth', bitsPerChannel: [32, 0, 0, 0], dataType: 'float32'},\n  // The depth component of the \"depth24plus\" and \"depth24plus-stencil8\" formats may be implemented as either a 24-bit depth value or a \"depth32float\" value.\n  'depth24plus-stencil8': {attachment: 'depth-stencil', bitsPerChannel: [24, 8, 0, 0], packed: true},\n  // \"depth32float-stencil8\" feature\n  'depth32float-stencil8': {attachment: 'depth-stencil', bitsPerChannel: [32, 8, 0, 0], packed: true},\n\n  // BC compressed formats: check device.features.has(\"texture-compression-bc\");\n\n  'bc1-rgb-unorm-webgl': {f: texture_compression_bc},\n  'bc1-rgb-unorm-srgb-webgl': {f: texture_compression_bc},\n\n  'bc1-rgba-unorm': {f: texture_compression_bc},\n  'bc1-rgba-unorm-srgb': {f: texture_compression_bc},\n  'bc2-rgba-unorm': {f: texture_compression_bc},\n  'bc2-rgba-unorm-srgb': {f: texture_compression_bc},\n  'bc3-rgba-unorm': {f: texture_compression_bc},\n  'bc3-rgba-unorm-srgb': {f: texture_compression_bc},\n  'bc4-r-unorm': {f: texture_compression_bc},\n  'bc4-r-snorm': {f: texture_compression_bc},\n  'bc5-rg-unorm': {f: texture_compression_bc},\n  'bc5-rg-snorm': {f: texture_compression_bc},\n  'bc6h-rgb-ufloat': {f: texture_compression_bc},\n  'bc6h-rgb-float': {f: texture_compression_bc},\n  'bc7-rgba-unorm': {f: texture_compression_bc},\n  'bc7-rgba-unorm-srgb': {f: texture_compression_bc},\n\n  // WEBGL_compressed_texture_etc: device.features.has(\"texture-compression-etc2\")\n  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression\n\n  'etc2-rgb8unorm': {f: texture_compression_etc2},\n  'etc2-rgb8unorm-srgb': {f: texture_compression_etc2},\n  'etc2-rgb8a1unorm': {f: texture_compression_etc2},\n  'etc2-rgb8a1unorm-srgb': {f: texture_compression_etc2},\n  'etc2-rgba8unorm': {f: texture_compression_etc2},\n  'etc2-rgba8unorm-srgb': {f: texture_compression_etc2},\n\n  'eac-r11unorm': {f: texture_compression_etc2},\n  'eac-r11snorm': {f: texture_compression_etc2},\n  'eac-rg11unorm': {f: texture_compression_etc2},\n  'eac-rg11snorm': {f: texture_compression_etc2},\n\n  // X_ASTC compressed formats: device.features.has(\"texture-compression-astc\")\n\n  'astc-4x4-unorm': {f: texture_compression_astc},\n  'astc-4x4-unorm-srgb': {f: texture_compression_astc},\n  'astc-5x4-unorm': {f: texture_compression_astc},\n  'astc-5x4-unorm-srgb': {f: texture_compression_astc},\n  'astc-5x5-unorm': {f: texture_compression_astc},\n  'astc-5x5-unorm-srgb': {f: texture_compression_astc},\n  'astc-6x5-unorm': {f: texture_compression_astc},\n  'astc-6x5-unorm-srgb': {f: texture_compression_astc},\n  'astc-6x6-unorm': {f: texture_compression_astc},\n  'astc-6x6-unorm-srgb': {f: texture_compression_astc},\n  'astc-8x5-unorm': {f: texture_compression_astc},\n  'astc-8x5-unorm-srgb': {f: texture_compression_astc},\n  'astc-8x6-unorm': {f: texture_compression_astc},\n  'astc-8x6-unorm-srgb': {f: texture_compression_astc},\n  'astc-8x8-unorm': {f: texture_compression_astc},\n  'astc-8x8-unorm-srgb': {f: texture_compression_astc},\n  'astc-10x5-unorm': {f: texture_compression_astc},\n  'astc-10x5-unorm-srgb': {f: texture_compression_astc},\n  'astc-10x6-unorm': {f: texture_compression_astc},\n  'astc-10x6-unorm-srgb': {f: texture_compression_astc},\n  'astc-10x8-unorm': {f: texture_compression_astc},\n  'astc-10x8-unorm-srgb': {f: texture_compression_astc},\n  'astc-10x10-unorm': {f: texture_compression_astc},\n  'astc-10x10-unorm-srgb': {f: texture_compression_astc},\n  'astc-12x10-unorm': {f: texture_compression_astc},\n  'astc-12x10-unorm-srgb': {f: texture_compression_astc},\n  'astc-12x12-unorm': {f: texture_compression_astc},\n  'astc-12x12-unorm-srgb': {f: texture_compression_astc},\n\n  // WEBGL_compressed_texture_pvrtc\n\n  'pvrtc-rgb4unorm-webgl': {f: texture_compression_pvrtc_webgl},\n  'pvrtc-rgba4unorm-webgl': {f: texture_compression_pvrtc_webgl},\n  'pvrtc-rbg2unorm-webgl': {f: texture_compression_pvrtc_webgl},\n  'pvrtc-rgba2unorm-webgl': {f: texture_compression_pvrtc_webgl},\n\n  // WEBGL_compressed_texture_etc1\n\n  'etc1-rbg-unorm-webgl': {f: texture_compression_etc1_webgl},\n\n  // WEBGL_compressed_texture_atc\n\n  'atc-rgb-unorm-webgl': {f: texture_compression_atc_webgl},\n  'atc-rgba-unorm-webgl': {f: texture_compression_atc_webgl},\n  'atc-rgbai-unorm-webgl': {f: texture_compression_atc_webgl}\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TextureFormat, CompressedTextureFormat} from './texture-formats';\nimport {VertexType} from './vertex-formats';\nimport {decodeVertexType} from './decode-data-type';\nimport {TextureFormatInfo} from './texture-format-info';\n\nimport {getTextureFormatDefinition} from './texture-format-table';\n\n// prettier-ignore\nconst COMPRESSED_TEXTURE_FORMAT_PREFIXES = [\n  'bc1', 'bc2', 'bc3', 'bc4', 'bc5', 'bc6', 'bc7', 'etc1', 'etc2', 'eac', 'atc', 'astc', 'pvrtc'\n];\n\nconst RGB_FORMAT_REGEX = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;\n\n/**\n * Returns true if a texture format is GPU compressed\n */\nexport function isTextureFormatCompressed(\n  format: TextureFormat\n): format is CompressedTextureFormat {\n  return COMPRESSED_TEXTURE_FORMAT_PREFIXES.some(prefix => (format as string).startsWith(prefix));\n}\n\n/**\n * Decodes a texture format, returning e.g. attatchment type, components, byte length and flags (integer, signed, normalized)\n */\nexport function decodeTextureFormat(format: TextureFormat): TextureFormatInfo {\n  let formatInfo: TextureFormatInfo = decodeTextureFormatUsingTable(format);\n\n  if (isTextureFormatCompressed(format)) {\n    formatInfo.channels = 'rgb';\n    formatInfo.components = 3;\n    formatInfo.bytesPerPixel = 1;\n    formatInfo.srgb = false;\n    formatInfo.compressed = true;\n\n    const blockSize = getCompressedTextureBlockSize(format);\n    if (blockSize) {\n      formatInfo.blockWidth = blockSize.blockWidth;\n      formatInfo.blockHeight = blockSize.blockHeight;\n    }\n  }\n\n  // Fill in missing information that can be derived from the format string\n  const matches = RGB_FORMAT_REGEX.exec(format as string);\n  if (matches) {\n    const [, channels, length, type, srgb, suffix] = matches;\n    const dataType = `${type}${length}` as VertexType;\n    const decodedType = decodeVertexType(dataType);\n    const bits = decodedType.byteLength * 8;\n    const components = channels.length as 1 | 2 | 3 | 4;\n    const bitsPerChannel: [number, number, number, number] = [\n      bits,\n      components >= 2 ? bits : 0,\n      components >= 3 ? bits : 0,\n      components >= 4 ? bits : 0\n    ];\n\n    formatInfo = {\n      format,\n      attachment: formatInfo.attachment,\n      dataType: decodedType.dataType,\n      components,\n      channels: channels as 'r' | 'rg' | 'rgb' | 'rgba',\n      integer: decodedType.integer,\n      signed: decodedType.signed,\n      normalized: decodedType.normalized,\n      bitsPerChannel,\n      bytesPerPixel: decodedType.byteLength * channels.length,\n      packed: formatInfo.packed,\n      srgb: formatInfo.srgb\n    };\n\n    if (suffix === '-webgl') {\n      formatInfo.webgl = true;\n    }\n    // dataType - overwritten by decodedType\n    if (srgb === '-srgb') {\n      formatInfo.srgb = true;\n    }\n  }\n\n  if (format.endsWith('-webgl')) {\n    formatInfo.webgl = true;\n  }\n  if (format.endsWith('-srgb')) {\n    formatInfo.srgb = true;\n  }\n\n  return formatInfo;\n}\n\n/** Decode texture format info from the table */\nfunction decodeTextureFormatUsingTable(format: TextureFormat): TextureFormatInfo {\n  const info = getTextureFormatDefinition(format);\n\n  const bytesPerPixel = info.bytesPerPixel || 1;\n  const bitsPerChannel = info.bitsPerChannel || [8, 8, 8, 8];\n  delete info.bitsPerChannel;\n  delete info.bytesPerPixel;\n  delete info.f;\n  delete info.render;\n  delete info.filter;\n  delete info.blend;\n  delete info.store;\n\n  const formatInfo: TextureFormatInfo = {\n    ...info,\n    format,\n    attachment: info.attachment || 'color',\n    channels: info.channels || 'r',\n    components: (info.components || info.channels?.length || 1) as 1 | 2 | 3 | 4,\n    bytesPerPixel,\n    bitsPerChannel,\n    dataType: info.dataType || 'uint8',\n    srgb: info.srgb ?? false,\n    packed: info.packed ?? false,\n    webgl: info.webgl ?? false,\n    integer: info.integer ?? false,\n    signed: info.signed ?? false,\n    normalized: info.normalized ?? false,\n    compressed: info.compressed ?? false\n  };\n\n  return formatInfo;\n}\n\n/** Parses ASTC block widths from format string */\nfunction getCompressedTextureBlockSize(\n  format: CompressedTextureFormat\n): {blockWidth: number; blockHeight: number} | null {\n  const REGEX = /.*-(\\d+)x(\\d+)-.*/;\n  const matches = REGEX.exec(format as string);\n  if (matches) {\n    const [, blockWidth, blockHeight] = matches;\n    return {blockWidth: Number(blockWidth), blockHeight: Number(blockHeight)};\n  }\n  return null;\n}\n\n/*\n'r8unorm':\t{s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t},\n'r8snorm':\t{s: \"float\"}, // \t\t\u2713\t\t},\n'r8uint':\t{s: \"uint\"}, // \t\u2713\t\u2713\t\t},\n'r8sint':\t{s: \"sint\"}, // \t\u2713\t\u2713\t\t},\n'rg8unorm':\t{s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t},\n'rg8snorm':\t{s: \"float\"}, // \t\t\u2713\t\t},\n'rg8uint':\t{s: \"uint\"}, // \t\u2713\t\u2713\t\t},\n'rg8sint':\t{s: \"sint\"}, // \t\u2713\t\u2713\t\t},\n'rgba8unorm':\t{s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t\u2713},\n'rgba8unorm-srgb': {s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t},\n'rgba8snorm':\t{s: \"float\"}, // \t\t\u2713\t\t\u2713},\n'rgba8uint':\t{s: \"uint\"}, // \t\u2713\t\u2713\t\t\u2713},\n'rgba8sint':\t{s: \"sint\"}, // \t\u2713\t\u2713\t\t\u2713},\n'bgra8unorm':\t{s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t},\n'bgra8unorm-srgb': {s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t},\n// 16-bit per component\t\t\t\t\t\n'r16uint': {s: \"uint\"}, // \t\u2713\t\u2713\t\t},\n'r16sint': {s: \"sint\"}, // \t\u2713\t\u2713\t\t},\n'r16float': {s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t},\n'rg16uint': {s: \"uint\"}, // \t\u2713\t\u2713\t\t},\n'rg16sint': {s: \"sint\"}, // \t\u2713\t\u2713\t\t},\n'rg16float': {s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t},\n'rgba16uint': {s: \"uint\"}, // \t\u2713\t\u2713\t\t\u2713},\n'rgba16sint': {s: \"sint\"}, // \t\u2713\t\u2713\t\t\u2713},\n'rgba16float': {s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t\u2713},\n// 32-bit per component\t\t\t\t\t\n'r32uint': {s: \"uint\"}, // \t\u2713\t\t\t\u2713},\n'r32sint': {s: \"sint\"}, // \t\u2713\t\t\t\u2713},\n'r32float': {\"unfilterable-float\"\t\u2713\t\u2713\t\t\u2713},\n'rg32uint': {s: \"uint\"}, // \t\u2713\t\t\t\u2713},\n'rg32sint': {s: \"sint\"}, // \t\u2713\t\t\t\u2713},\n'rg32float': {\"unfilterable-float\"\t\u2713\t\t\t\u2713},\n'rgba32uint': {s: \"uint\"}, // \t\u2713\t\t\t\u2713},\n'rgba32sint': {s: \"sint\"}, // \t\u2713\t\t\t\u2713},\n'rgba32float': {\"unfilterable-float\"\t\u2713\t\t\t\u2713},\n// mixed component width\t\t\t\t\t\n'rgb10a2unorm': {s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t}\n'rg11b10ufloat': {s: \"float\"}, // \t\t\u2713\t\t}\n// Format\tBytes per texel\tAspect\tGPUTextureSampleType\tValid image copy source\tValid image copy destination\n'stencil8': {1 \u2212 4\tstencil\t\"uint\"\t\u2713}\n'depth16unorm': {2\tdepth\t\"depth\"\t\u2713}\n'depth24plus': {4\tdepth\t\"depth\"\t\u2717}\n'depth24plus': {stencil8\t4 \u2212 8\tdepth\t\"depth\"\t\u2717}\n'stencil': {s: \"uint\"}, // \t\u2713}\n'depth32float': {4\tdepth\t\"depth\"\t\u2713\t\u2717}\n'depth24unorm': {stencil8\t4\tdepth\t\"depth\"\t\u2717}\n'stencil': {s: \"uint\"}, // \t\u2713}\n'depth32float': {stencil8}\n\n// Format\tBytes per block\tGPUTextureSampleType\tBlock Size\tFeature\n'rgb9e5ufloat': {c: 4, s: \"float\",\tbpp: 4/(1*1)},\n\n'bc1-rgba-unorm': {c: 4. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc1-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc2-rgba-unorm': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc2-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc3-rgba-unorm': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc3-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc4-r-unorm': {c: 1. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc4-r-snorm': {c: 1. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc5-rg-unorm': {c: 2. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc5-rg-snorm': { },\n'bc6h-rgb-ufloat': {\t16 },\n'bc6h-rgb-float': { },\n'bc7-rgba-unorm': {\t16 },\n'bc7-rgba-unorm-srgb': { },\n\n'etc2-rgb8unorm': {\t8\t\"float\"\t4 \u00D7 4\ttexture-compression-etc2 },\n'etc2-rgb8unorm-srgb': { },\n'etc2-rgb8a1unorm': {\t8 },\n'etc2-rgb8a1unorm-srgb': { },\n'etc2-rgba8unorm': {\t16 },\n'etc2-rgba8unorm-srgb': { },\n\n'eac-r11unorm': {\t8 },\n'eac-r11snorm': { },\n'eac-rg11unorm': {\t16 },\n'eac-rg11snorm': { },\n\n'astc-4x4-unorm': {\t16\t\"float\"\t4 \u00D7 4\ttexture-compression-astc },\n'astc-4x4-unorm-srgb': { },\n'astc-5x4-unorm': {\t16\t5 \u00D7 4 },\n'astc-5x4-unorm-srgb': { },\n'astc-5x5-unorm': {\t16\t5 \u00D7 5 },\n'astc-5x5-unorm-srgb': { },\n'astc-6x5-unorm': {\t16\t6 \u00D7 5 },\n'astc-6x5-unorm-srgb': { },\n'astc-6x6-unorm': {\t16\t6 \u00D7 6 },\n'astc-6x6-unorm-srgb': { },\n'astc-8x5-unorm': {\t16\t8 \u00D7 5 },\n'astc-8x5-unorm-srgb': { },\n'astc-8x6-unorm': {\t16\t8 \u00D7 6 },\n'astc-8x6-unorm-srgb': { },\n'astc-8x8-unorm': {\t16\t8 \u00D7 8 },\n'astc-8x8-unorm-srgb': { },\n'astc-10x5-unorm': {\t16\t10 \u00D7 5 },\n'astc-10x5-unorm-srgb': { },\n'astc-10x6-unorm': {\t16\t10 \u00D7 6 },\n'astc-10x6-unorm-srgb': { },\n'astc-10x8-unorm': {\t16\t10 \u00D7 8 },\n'astc-10x8-unorm-srgb': { },\n'astc-10x10-unorm': {\t16\t10 \u00D7 10 },\n'astc-10x10-unorm-srgb': { },\n'astc-12x10-unorm': {\t16\t12 \u00D7 10 },\n'astc-12x10-unorm-srgb': { },\n'astc-12x12-unorm': {\t16 },\n*/\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TextureFormat} from './texture-formats';\nimport type {TextureFeature} from './texture-features';\nimport {decodeTextureFormat} from './decode-texture-format';\n\nimport {getTextureFormatDefinition} from './texture-format-table';\n\n/**\n * Texture format capabilities.\n * @note Not directly usable. Can contain TextureFeature strings that need to be checked against a specific device.\n */\nexport type TextureFormatCapabilities = {\n  format: TextureFormat;\n  /** Can the format be created */\n  create: TextureFeature | boolean;\n  /** If a feature string, the specified device feature determines if format is renderable. */\n  render: TextureFeature | boolean;\n  /** If a feature string, the specified device feature determines if format is filterable. */\n  filter: TextureFeature | boolean;\n  /** If a feature string, the specified device feature determines if format is blendable. */\n  blend: TextureFeature | boolean;\n  /** If a feature string, the specified device feature determines if format is storeable. */\n  store: TextureFeature | boolean;\n};\n\nexport function getTextureFormatCapabilities(format: TextureFormat): TextureFormatCapabilities {\n  const info = getTextureFormatDefinition(format);\n\n  const formatCapabilities: Required<TextureFormatCapabilities> = {\n    format,\n    create: info.f ?? true,\n    render: info.render ?? true,\n    filter: info.filter ?? true,\n    blend: info.blend ?? true,\n    store: info.store ?? true\n  };\n\n  const formatInfo = decodeTextureFormat(format);\n  const isDepthStencil = format.startsWith('depth') || format.startsWith('stencil');\n  const isSigned = formatInfo?.signed;\n  const isInteger = formatInfo?.integer;\n  const isWebGLSpecific = formatInfo?.webgl;\n\n  // signed formats are not renderable\n  formatCapabilities.render &&= !isSigned;\n  // signed and integer formats are not filterable\n  formatCapabilities.filter &&= !isDepthStencil && !isSigned && !isInteger && !isWebGLSpecific;\n\n  return formatCapabilities;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {StatsManager, lumaStats} from '../utils/stats-manager';\nimport {log} from '../utils/log';\nimport {uid} from '../utils/uid';\nimport type {TextureFormat} from '../gpu-type-utils/texture-formats';\nimport type {TextureFormatCapabilities} from '../gpu-type-utils/texture-format-capabilities';\nimport type {CanvasContext, CanvasContextProps} from './canvas-context';\nimport type {BufferProps} from './resources/buffer';\nimport {Buffer} from './resources/buffer';\nimport type {RenderPipeline, RenderPipelineProps} from './resources/render-pipeline';\nimport type {ComputePipeline, ComputePipelineProps} from './resources/compute-pipeline';\nimport type {Sampler, SamplerProps} from './resources/sampler';\nimport type {Shader, ShaderProps} from './resources/shader';\nimport type {Texture, TextureProps} from './resources/texture';\nimport type {ExternalTexture, ExternalTextureProps} from './resources/external-texture';\nimport type {Framebuffer, FramebufferProps} from './resources/framebuffer';\nimport type {RenderPass, RenderPassProps} from './resources/render-pass';\nimport type {ComputePass, ComputePassProps} from './resources/compute-pass';\nimport type {CommandEncoder, CommandEncoderProps} from './resources/command-encoder';\nimport type {VertexArray, VertexArrayProps} from './resources/vertex-array';\nimport type {TransformFeedback, TransformFeedbackProps} from './resources/transform-feedback';\nimport type {QuerySet, QuerySetProps} from './resources/query-set';\n\nimport {isTextureFormatCompressed} from '../gpu-type-utils/decode-texture-format';\nimport {getTextureFormatCapabilities} from '../gpu-type-utils/texture-format-capabilities';\n\n/**\n * Identifies the GPU vendor and driver.\n * @note Chrome WebGPU does not provide much information, though more can be enabled with\n * @see https://developer.chrome.com/blog/new-in-webgpu-120#adapter_information_updates\n * chrome://flags/#enable-webgpu-developer-features\n */\nexport type DeviceInfo = {\n  /** Type of device */\n  type: 'webgl' | 'webgpu' | 'unknown';\n  /** Vendor (name of GPU vendor, Apple, nVidia etc */\n  vendor: string;\n  /** Renderer (usually driver name) */\n  renderer: string;\n  /** version of driver */\n  version: string;\n  /** family of GPU */\n  gpu: 'nvidia' | 'amd' | 'intel' | 'apple' | 'software' | 'unknown';\n  /** Type of GPU () */\n  gpuType: 'discrete' | 'integrated' | 'cpu' | 'unknown';\n  /** GPU architecture */\n  gpuArchitecture?: string; // 'common-3' on Apple\n  /** GPU driver backend. Can sometimes be sniffed */\n  gpuBackend?: 'opengl' | 'opengles' | 'metal' | 'd3d11' | 'd3d12' | 'vulkan' | 'unknown';\n  /** If this is a fallback adapter */\n  fallback?: boolean;\n  /** Shader language supported by device.createShader() */\n  shadingLanguage: 'wgsl' | 'glsl';\n  /** Highest supported shader language version: GLSL 3.00 = 300, WGSL 1.00 = 100 */\n  shadingLanguageVersion: number;\n};\n\n/** Limits for a device (max supported sizes of resources, max number of bindings etc) */\nexport abstract class DeviceLimits {\n  /** max number of TextureDimension1D */\n  abstract maxTextureDimension1D: number;\n  /** max number of TextureDimension2D */\n  abstract maxTextureDimension2D: number;\n  /** max number of TextureDimension3D */\n  abstract maxTextureDimension3D: number;\n  /** max number of TextureArrayLayers */\n  abstract maxTextureArrayLayers: number;\n  /** max number of BindGroups */\n  abstract maxBindGroups: number;\n  /** max number of DynamicUniformBuffers per PipelineLayout */\n  abstract maxDynamicUniformBuffersPerPipelineLayout: number;\n  /** max number of DynamicStorageBuffers per PipelineLayout */\n  abstract maxDynamicStorageBuffersPerPipelineLayout: number;\n  /** max number of SampledTextures per ShaderStage */\n  abstract maxSampledTexturesPerShaderStage: number;\n  /** max number of Samplers per ShaderStage */\n  abstract maxSamplersPerShaderStage: number;\n  /** max number of StorageBuffers per ShaderStage */\n  abstract maxStorageBuffersPerShaderStage: number;\n  /** max number of StorageTextures per ShaderStage */\n  abstract maxStorageTexturesPerShaderStage: number;\n  /** max number of UniformBuffers per ShaderStage */\n  abstract maxUniformBuffersPerShaderStage: number;\n  /** max number of UniformBufferBindingSize */\n  abstract maxUniformBufferBindingSize: number;\n  /** max number of StorageBufferBindingSize */\n  abstract maxStorageBufferBindingSize: number;\n  /** min UniformBufferOffsetAlignment */\n  abstract minUniformBufferOffsetAlignment: number;\n  /** min StorageBufferOffsetAlignment */\n  abstract minStorageBufferOffsetAlignment: number;\n  /** max number of VertexBuffers */\n  abstract maxVertexBuffers: number;\n  /** max number of VertexAttributes */\n  abstract maxVertexAttributes: number;\n  /** max number of VertexBufferArrayStride */\n  abstract maxVertexBufferArrayStride: number;\n  /** max number of InterStageShaderComponents */\n  abstract maxInterStageShaderComponents: number;\n  /** max number of ComputeWorkgroupStorageSize */\n  abstract maxComputeWorkgroupStorageSize: number;\n  /** max number of ComputeInvocations per Workgroup */\n  abstract maxComputeInvocationsPerWorkgroup: number;\n  /** max ComputeWorkgroupSizeX */\n  abstract maxComputeWorkgroupSizeX: number;\n  /** max ComputeWorkgroupSizeY */\n  abstract maxComputeWorkgroupSizeY: number;\n  /** max ComputeWorkgroupSizeZ */\n  abstract maxComputeWorkgroupSizeZ: number;\n  /** max ComputeWorkgroupsPerDimension */\n  abstract maxComputeWorkgroupsPerDimension: number;\n}\n\n/** Set-like class for features (lets apps check for WebGL / WebGPU extensions) */\nexport class DeviceFeatures {\n  protected features: Set<DeviceFeature>;\n  protected disabledFeatures?: Partial<Record<DeviceFeature, boolean>>;\n\n  constructor(\n    features: DeviceFeature[] = [],\n    disabledFeatures: Partial<Record<DeviceFeature, boolean>>\n  ) {\n    this.features = new Set<DeviceFeature>(features);\n    this.disabledFeatures = disabledFeatures || {};\n  }\n\n  *[Symbol.iterator](): IterableIterator<DeviceFeature> {\n    yield* this.features;\n  }\n\n  has(feature: DeviceFeature): boolean {\n    return !this.disabledFeatures?.[feature] && this.features.has(feature);\n  }\n}\n\n/** Device feature names */\nexport type DeviceFeature =\n  | WebGPUDeviceFeature\n  | WebGLDeviceFeature\n  | WebGLCompressedTextureFeatures;\n\nexport type WebGPUDeviceFeature =\n  | 'depth-clip-control'\n  | 'indirect-first-instance'\n  | 'timestamp-query'\n  | 'shader-f16'\n  | 'depth32float-stencil8'\n  | 'rg11b10ufloat-renderable' // Is the rg11b10ufloat texture format renderable?\n  | 'float32-filterable' // Is the float32 format filterable?\n  | 'bgra8unorm-storage' // Can the bgra8unorm texture format be used in storage buffers?\n  | 'texture-compression-bc'\n  | 'texture-compression-etc2'\n  | 'texture-compression-astc';\n// | 'depth-clamping' // removed from the WebGPU spec...\n// | 'pipeline-statistics-query' // removed from the WebGPU spec...\n\nexport type WebGLDeviceFeature =\n  // webgl extension features\n  | 'timer-query-webgl' // unify with WebGPU timestamp-query?\n  | 'compilation-status-async-webgl' // Non-blocking shader compile/link status query available\n  | 'provoking-vertex-webgl' // parameters.provokingVertex\n  | 'polygon-mode-webgl' // parameters.polygonMode and parameters.polygonOffsetLine\n\n  // GLSL extension features\n  | 'shader-noperspective-interpolation-webgl' // Vertex outputs & fragment inputs can have a `noperspective` interpolation qualifier.\n  | 'shader-conservative-depth-webgl' // GLSL `gl_FragDepth` qualifiers `depth_unchanged` etc can enable early depth test\n  | 'shader-clip-cull-distance-webgl' // Makes gl_ClipDistance and gl_CullDistance available in shaders\n\n  // texture rendering\n  | 'float32-renderable-webgl'\n  | 'float16-renderable-webgl'\n  | 'rgb9e5ufloat-renderable-webgl'\n  | 'snorm8-renderable-webgl'\n  | 'norm16-renderable-webgl'\n  | 'snorm16-renderable-webgl'\n\n  // texture filtering\n  | 'float16-filterable-webgl'\n  | 'texture-filterable-anisotropic-webgl'\n\n  // texture storage bindings\n  | 'bgra8unorm-storage'\n\n  // texture blending\n  | 'texture-blend-float-webgl';\n\ntype WebGLCompressedTextureFeatures =\n  | 'texture-compression-bc5-webgl'\n  | 'texture-compression-bc7-webgl'\n  | 'texture-compression-etc1-webgl'\n  | 'texture-compression-pvrtc-webgl'\n  | 'texture-compression-atc-webgl';\n\n/** Texture format capabilities that have been checked against a specific device */\nexport type DeviceTextureFormatCapabilities = {\n  format: TextureFormat;\n  /** Can the format be created */\n  create: boolean;\n  /** If a feature string, the specified device feature determines if format is renderable. */\n  render: boolean;\n  /** If a feature string, the specified device feature determines if format is filterable. */\n  filter: boolean;\n  /** If a feature string, the specified device feature determines if format is blendable. */\n  blend: boolean;\n  /** If a feature string, the specified device feature determines if format is storeable. */\n  store: boolean;\n};\n\n/** Device properties */\nexport type DeviceProps = {\n  /** string id for debugging. Stored on the object, used in logging and set on underlying GPU objects when feasible. */\n  id?: string;\n  /** Properties for creating a default canvas context */\n  createCanvasContext?: CanvasContextProps | true;\n  /** Control which type of GPU is preferred on systems with both integrated and discrete GPU. Defaults to \"high-performance\" / discrete GPU. */\n  powerPreference?: 'default' | 'high-performance' | 'low-power';\n  /** Hints that device creation should fail if no hardware GPU is available (if the system performance is \"low\"). */\n  failIfMajorPerformanceCaveat?: boolean;\n  /** Error handling */\n  onError?: (error: Error) => unknown;\n\n  /** WebGL specific: Properties passed through to WebGL2RenderingContext creation: `canvas.getContext('webgl2', props.webgl)` */\n  webgl?: WebGLContextProps;\n\n  // DEBUG SETTINGS\n\n  /** Turn on implementation defined checks that slow down execution but help break where errors occur */\n  debug?: boolean;\n  /** Show shader source in browser? The default is`'error'`, meaning that logs are shown when shader compilation has errors */\n  debugShaders?: 'never' | 'errors' | 'warnings' | 'always';\n  /** Renders a small version of updated Framebuffers into the primary canvas context. Can be set in console luma.log.set('debug-framebuffers', true) */\n  debugFramebuffers?: boolean;\n  /** WebGL specific - Trace WebGL calls (instruments WebGL2RenderingContext at the expense of performance). Can be set in console luma.log.set('debug-webgl', true)  */\n  debugWebGL?: boolean;\n  /** WebGL specific - Initialize the SpectorJS WebGL debugger. Can be set in console luma.log.set('debug-spectorjs', true)  */\n  debugSpectorJS?: boolean;\n  /** WebGL specific - SpectorJS URL. Override if CDN is down or different SpectorJS version is desired. */\n  debugSpectorJSUrl?: string;\n\n  // EXPERIMENTAL SETTINGS - subject to change\n\n  /** adapter.create() returns the existing Device if the provided canvas' WebGL context is already associated with a Device.  */\n  _reuseDevices?: boolean;\n  /** WebGPU specific - Request a Device with the highest limits supported by platform. On WebGPU devices can be created with minimal limits. */\n  _requestMaxLimits?: boolean;\n  /** Disable specific features */\n  _disabledFeatures?: Partial<Record<DeviceFeature, boolean>>;\n  /** WebGL specific - Initialize all features on startup */\n  _initializeFeatures?: boolean;\n  /** Never destroy cached shaders and pipelines */\n  _factoryDestroyPolicy?: 'unused' | 'never';\n  /** Resource default overrides */\n  _resourceDefaults?: {\n    texture?: Partial<TextureProps>;\n    sampler?: Partial<SamplerProps>;\n    renderPass?: Partial<RenderPassProps>;\n  };\n\n  /** @deprecated Internal, Do not use directly! Use `luma.attachDevice()` to attach to pre-created contexts/devices. */\n  _handle?: unknown; // WebGL2RenderingContext | GPUDevice | null;\n};\n\n/** WebGL independent copy of WebGLContextAttributes */\ntype WebGLContextProps = {\n  alpha?: boolean; // indicates if the canvas contains an alpha buffer.\n  desynchronized?: boolean; // hints the user agent to reduce the latency by desynchronizing the canvas paint cycle from the event loop\n  antialias?: boolean; // indicates whether or not to perform anti-aliasing.\n  depth?: boolean; // indicates that the drawing buffer has a depth buffer of at least 16 bits.\n  failIfMajorPerformanceCaveat?: boolean; // indicates if a context will be created if the system performance is low or if no hardware GPU is available.\n  powerPreference?: 'default' | 'high-performance' | 'low-power';\n  premultipliedAlpha?: boolean; // page compositor will assume the drawing buffer contains colors with pre-multiplied alpha.\n  preserveDrawingBuffer?: boolean; // buffers will not be cleared and will preserve their values until cleared or overwritten by the author.\n};\n\n/**\n * Create and attach devices for a specific backend. Currently static methods on each device\n */\nexport interface DeviceFactory {\n  // new (props: DeviceProps): Device; Constructor isn't used\n  type: string;\n  isSupported(): boolean;\n  create(props: DeviceProps): Promise<Device>;\n  attach?(handle: unknown): Device;\n}\n\n/**\n * WebGPU Device/WebGL context abstraction\n */\nexport abstract class Device {\n  static defaultProps: Required<DeviceProps> = {\n    id: null!,\n    powerPreference: 'high-performance',\n    failIfMajorPerformanceCaveat: false,\n    createCanvasContext: undefined!,\n\n    // Callbacks\n    onError: (error: Error) => log.error(error.message)(),\n\n    // Experimental\n    _reuseDevices: false,\n    _requestMaxLimits: true,\n    _factoryDestroyPolicy: 'unused',\n    // TODO - Change these after confirming things work as expected\n    _initializeFeatures: true,\n    _disabledFeatures: {\n      'compilation-status-async-webgl': true\n    },\n    _resourceDefaults: {},\n\n    // WebGL specific\n    webgl: {},\n\n    debug: log.get('debug') || undefined!,\n    debugShaders: log.get('debug-shaders') || undefined!,\n    debugFramebuffers: Boolean(log.get('debug-framebuffers')),\n    debugWebGL: Boolean(log.get('debug-webgl')),\n    debugSpectorJS: undefined!, // Note: log setting is queried by the spector.js code\n    debugSpectorJSUrl: undefined!,\n\n    // INTERNAL\n    _handle: undefined!\n  };\n\n  get [Symbol.toStringTag](): string {\n    return 'Device';\n  }\n\n  constructor(props: DeviceProps) {\n    this.props = {...Device.defaultProps, ...props};\n    this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());\n  }\n\n  /** id of this device, primarily for debugging */\n  readonly id: string;\n  /** type of this device */\n  abstract readonly type: 'webgl' | 'webgpu' | 'unknown';\n  /** A copy of the device props  */\n  readonly props: Required<DeviceProps>;\n  /** Available for the application to store data on the device */\n  userData: {[key: string]: unknown} = {};\n  /** stats */\n  readonly statsManager: StatsManager = lumaStats;\n  /** An abstract timestamp used for change tracking */\n  timestamp: number = 0;\n\n  /** True if this device has been reused during device creation (app has multiple references) */\n  _reused: boolean = false;\n  /** Used by other luma.gl modules to store data on the device */\n  _lumaData: {[key: string]: unknown} = {};\n\n  abstract destroy(): void;\n\n  // Capabilities\n\n  /** Information about the device (vendor, versions etc) */\n  abstract info: DeviceInfo;\n  /** Optional capability discovery */\n  abstract features: DeviceFeatures;\n  /** WebGPU style device limits */\n  abstract get limits(): DeviceLimits;\n\n  /** Determines what operations are supported on a texture format, checking against supported device features */\n  getTextureFormatCapabilities(format: TextureFormat): DeviceTextureFormatCapabilities {\n    const genericCapabilities = getTextureFormatCapabilities(format);\n\n    // Check standard features\n    const checkFeature = (featureOrBoolean: DeviceFeature | boolean | undefined) =>\n      (typeof featureOrBoolean === 'string'\n        ? this.features.has(featureOrBoolean)\n        : featureOrBoolean) ?? true;\n\n    const supported = checkFeature(genericCapabilities.create);\n\n    const deviceCapabilities: DeviceTextureFormatCapabilities = {\n      format,\n      create: supported,\n      render: supported && checkFeature(genericCapabilities.render),\n      filter: supported && checkFeature(genericCapabilities.filter),\n      blend: supported && checkFeature(genericCapabilities.blend),\n      store: supported && checkFeature(genericCapabilities.store)\n    };\n\n    return this._getDeviceSpecificTextureFormatCapabilities(deviceCapabilities);\n  }\n\n  /** Check if device supports a specific texture format (creation and `nearest` sampling) */\n  isTextureFormatSupported(\n    format: TextureFormat,\n    capabilities: Partial<TextureFormatCapabilities>\n  ): boolean {\n    return this.getTextureFormatCapabilities(format).create;\n  }\n\n  /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */\n  isTextureFormatFilterable(format: TextureFormat): boolean {\n    return this.getTextureFormatCapabilities(format).filter;\n  }\n\n  /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */\n  isTextureFormatRenderable(format: TextureFormat): boolean {\n    return this.getTextureFormatCapabilities(format).render;\n  }\n\n  /** Check if a specific texture format is GPU compressed */\n  isTextureFormatCompressed(format: TextureFormat): boolean {\n    return isTextureFormatCompressed(format);\n  }\n\n  // Device loss\n\n  /** `true` if device is already lost */\n  abstract get isLost(): boolean;\n\n  /** Promise that resolves when device is lost */\n  abstract readonly lost: Promise<{reason: 'destroyed'; message: string}>;\n\n  /**\n   * Trigger device loss.\n   * @returns `true` if context loss could actually be triggered.\n   * @note primarily intended for testing how application reacts to device loss\n   */\n  loseDevice(): boolean {\n    return false;\n  }\n\n  /** Report error (normally called for unhandled device errors) */\n  reportError(error: Error): void {\n    this.props.onError(error);\n  }\n\n  // Canvas context\n\n  /** Default / primary canvas context. Can be null as WebGPU devices can be created without a CanvasContext */\n  abstract canvasContext: CanvasContext | null;\n\n  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */\n  getDefaultCanvasContext(): CanvasContext {\n    if (!this.canvasContext) {\n      throw new Error('Device has no default CanvasContext. See props.createCanvasContext');\n    }\n    return this.canvasContext;\n  }\n\n  /** Creates a new CanvasContext (WebGPU only) */\n  abstract createCanvasContext(props?: CanvasContextProps): CanvasContext;\n\n  /** Call after rendering a frame (necessary e.g. on WebGL OffscreenCanvas) */\n  abstract submit(): void;\n\n  // Resource creation\n\n  /** Create a buffer */\n  abstract createBuffer(props: BufferProps | ArrayBuffer | ArrayBufferView): Buffer;\n\n  /** Create a texture */\n  abstract createTexture(props: TextureProps): Texture;\n\n  /** Create a temporary texture view of a video source */\n  abstract createExternalTexture(props: ExternalTextureProps): ExternalTexture;\n\n  /** Create a sampler */\n  abstract createSampler(props: SamplerProps): Sampler;\n\n  /** Create a Framebuffer. Must have at least one attachment. */\n  abstract createFramebuffer(props: FramebufferProps): Framebuffer;\n\n  /** Create a shader */\n  abstract createShader(props: ShaderProps): Shader;\n\n  /** Create a render pipeline (aka program) */\n  abstract createRenderPipeline(props: RenderPipelineProps): RenderPipeline;\n\n  /** Create a compute pipeline (aka program). WebGPU only. */\n  abstract createComputePipeline(props: ComputePipelineProps): ComputePipeline;\n\n  /** Create a vertex array */\n  abstract createVertexArray(props: VertexArrayProps): VertexArray;\n\n  /** Create a RenderPass */\n  abstract beginRenderPass(props?: RenderPassProps): RenderPass;\n\n  /** Create a ComputePass */\n  abstract beginComputePass(props?: ComputePassProps): ComputePass;\n\n  /** Create a transform feedback (immutable set of output buffer bindings). WebGL only. */\n  abstract createTransformFeedback(props: TransformFeedbackProps): TransformFeedback;\n\n  abstract createQuerySet(props: QuerySetProps): QuerySet;\n\n  createCommandEncoder(props: CommandEncoderProps = {}): CommandEncoder {\n    throw new Error('not implemented');\n  }\n\n  /** A monotonic counter for tracking buffer and texture updates */\n  incrementTimestamp(): number {\n    return this.timestamp++;\n  }\n\n  // Error Handling\n\n  /** Report unhandled device errors */\n  onError(error: Error) {\n    this.props.onError(error);\n  }\n\n  // DEPRECATED METHODS\n\n  /** @deprecated Use getDefaultCanvasContext() */\n  getCanvasContext(): CanvasContext {\n    return this.getDefaultCanvasContext();\n  }\n\n  // WebGL specific HACKS - enables app to remove webgl import\n  // Use until we have a better way to handle these\n\n  /** @deprecated - will be removed - should use command encoder */\n  readPixelsToArrayWebGL(\n    source: Framebuffer | Texture,\n    options?: {\n      sourceX?: number;\n      sourceY?: number;\n      sourceFormat?: number;\n      sourceAttachment?: number;\n      target?: Uint8Array | Uint16Array | Float32Array;\n      // following parameters are auto deduced if not provided\n      sourceWidth?: number;\n      sourceHeight?: number;\n      sourceType?: number;\n    }\n  ): Uint8Array | Uint16Array | Float32Array {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use command encoder */\n  readPixelsToBufferWebGL(\n    source: Framebuffer | Texture,\n    options?: {\n      sourceX?: number;\n      sourceY?: number;\n      sourceFormat?: number;\n      target?: Buffer; // A new Buffer object is created when not provided.\n      targetByteOffset?: number; // byte offset in buffer object\n      // following parameters are auto deduced if not provided\n      sourceWidth?: number;\n      sourceHeight?: number;\n      sourceType?: number;\n    }\n  ): Buffer {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  setParametersWebGL(parameters: any): void {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  getParametersWebGL(parameters: any): void {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  withParametersWebGL(parameters: any, func: any): any {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use clear arguments in RenderPass */\n  clearWebGL(options?: {framebuffer?: Framebuffer; color?: any; depth?: any; stencil?: any}): void {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use for debugging only */\n  resetWebGL(): void {\n    throw new Error('not implemented');\n  }\n\n  // IMPLEMENTATION\n\n  /** Helper to get the canvas context props */\n  static _getCanvasContextProps(props: DeviceProps): CanvasContextProps | undefined {\n    return props.createCanvasContext === true ? {} : props.createCanvasContext;\n  }\n\n  /**\n   * Determines what operations are supported on a texture format, checking against supported device features\n   * Subclasses override to apply additional checks\n   */\n  protected abstract _getDeviceSpecificTextureFormatCapabilities(\n    format: DeviceTextureFormatCapabilities\n  ): DeviceTextureFormatCapabilities;\n\n  /** Subclasses use this to support .createBuffer() overloads */\n  protected _normalizeBufferProps(props: BufferProps | ArrayBuffer | ArrayBufferView): BufferProps {\n    if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {\n      props = {data: props};\n    }\n\n    // TODO - fragile, as this is done before we merge with default options\n    // inside the Buffer constructor\n\n    const newProps = {...props};\n    // Deduce indexType\n    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {\n      if (props.data instanceof Uint32Array) {\n        newProps.indexType = 'uint32';\n      } else if (props.data instanceof Uint16Array) {\n        newProps.indexType = 'uint16';\n      } else {\n        log.warn('indices buffer content must be of integer type')();\n      }\n    }\n    return newProps;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, DeviceProps} from './device';\n\n/**\n * Create and attach devices for a specific backend.\n */\nexport abstract class Adapter {\n  // new (props: DeviceProps): Device; Constructor isn't used\n  abstract type: string;\n  abstract isSupported(): boolean;\n  abstract create(props: DeviceProps): Promise<Device>;\n  abstract attach?(handle: unknown): Promise<Device>;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {isBrowser} from '@probe.gl/env';\nimport type {Device} from './device';\nimport type {Framebuffer} from './resources/framebuffer';\nimport {log} from '../utils/log';\nimport {uid} from '../utils/uid';\nimport type {TextureFormat} from '../gpu-type-utils/texture-formats';\n\n/** Properties for a CanvasContext */\nexport type CanvasContextProps = {\n  /** If a canvas not supplied, one will be created and added to the DOM. If a string, a canvas with that id will be looked up in the DOM */\n  canvas?: HTMLCanvasElement | OffscreenCanvas | string | null;\n  /** If new canvas is created, it will be created in the specified container, otherwise is appended as a child of document.body */\n  container?: HTMLElement | string | null;\n  /** Width in pixels of the canvas - used when creating a new canvas */\n  width?: number;\n  /** Height in pixels of the canvas - used when creating a new canvas */\n  height?: number;\n  /** Visibility (only used if new canvas is created). */\n  visible?: boolean;\n  /** Whether to apply a device pixels scale factor (`true` uses browser DPI) */\n  useDevicePixels?: boolean | number;\n  /** Whether to track window resizes */\n  autoResize?: boolean;\n  /** https://developer.mozilla.org/en-US/docs/Web/API/GPUCanvasContext/configure#alphamode */\n  alphaMode?: 'opaque' | 'premultiplied';\n  /** https://developer.mozilla.org/en-US/docs/Web/API/GPUCanvasContext/configure#colorspace */\n  colorSpace?: 'srgb'; // GPUPredefinedColorSpace\n};\n\n/**\n * Manages a canvas. Supports both HTML or offscreen canvas\n * - Creates a new canvas or looks up a canvas from the DOM\n * - Provides check for DOM loaded\n * @todo commit(): https://github.com/w3ctag/design-reviews/issues/288\n * @todo transferControlToOffscreen: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/transferControlToOffscreen\n */\nexport abstract class CanvasContext {\n  static defaultProps: Required<CanvasContextProps> = {\n    canvas: null,\n    width: 800, // width are height are only used by headless gl\n    height: 600,\n    useDevicePixels: true,\n    autoResize: true,\n    container: null,\n    visible: true,\n    alphaMode: 'opaque',\n    colorSpace: 'srgb'\n  };\n\n  abstract readonly device: Device;\n  readonly id: string;\n  readonly props: Required<CanvasContextProps>;\n  readonly canvas: HTMLCanvasElement | OffscreenCanvas;\n  readonly htmlCanvas?: HTMLCanvasElement;\n  readonly offscreenCanvas?: OffscreenCanvas;\n  readonly type: 'html-canvas' | 'offscreen-canvas' | 'node';\n\n  /** Format of returned textures: \"bgra8unorm\", \"rgba8unorm\" */\n  abstract readonly format: TextureFormat;\n  /** Default stencil format for depth textures */\n  abstract readonly depthStencilFormat: TextureFormat;\n\n  width: number = 1;\n  height: number = 1;\n\n  readonly resizeObserver: ResizeObserver | undefined;\n\n  /** State used by luma.gl classes: TODO - move to canvasContext*/\n  readonly _canvasSizeInfo = {clientWidth: 0, clientHeight: 0, devicePixelRatio: 1};\n\n  abstract get [Symbol.toStringTag](): string;\n\n  toString(): string {\n    return `${this[Symbol.toStringTag]}(${this.id})`;\n  }\n\n  constructor(props?: CanvasContextProps) {\n    this.props = {...CanvasContext.defaultProps, ...props};\n    props = this.props;\n\n    if (!isBrowser()) {\n      this.id = 'node-canvas-context';\n      this.type = 'node';\n      this.width = this.props.width;\n      this.height = this.props.height;\n      // TODO - does this prevent app from using jsdom style polyfills?\n      this.canvas = null!;\n      return;\n    }\n\n    if (!props.canvas) {\n      const canvas = createCanvas(props);\n      const container = getContainer(props?.container || null);\n      container.insertBefore(canvas, container.firstChild);\n\n      this.canvas = canvas;\n\n      if (!props?.visible) {\n        this.canvas.style.visibility = 'hidden';\n      }\n    } else if (typeof props.canvas === 'string') {\n      this.canvas = getCanvasFromDOM(props.canvas);\n    } else {\n      this.canvas = props.canvas;\n    }\n\n    if (this.canvas instanceof HTMLCanvasElement) {\n      this.id = this.canvas.id;\n      this.type = 'html-canvas';\n      this.htmlCanvas = this.canvas;\n    } else {\n      this.id = 'offscreen-canvas';\n      this.type = 'offscreen-canvas';\n      this.offscreenCanvas = this.canvas;\n    }\n\n    // React to size changes\n    if (this.canvas instanceof HTMLCanvasElement && props.autoResize) {\n      this.resizeObserver = new ResizeObserver(entries => {\n        for (const entry of entries) {\n          if (entry.target === this.canvas) {\n            this.update();\n          }\n        }\n      });\n      this.resizeObserver.observe(this.canvas);\n    }\n  }\n\n  /** Returns a framebuffer with properly resized current 'swap chain' textures */\n  abstract getCurrentFramebuffer(): Framebuffer;\n\n  /**\n   * Returns the current DPR, if props.useDevicePixels is true\n   * Device refers to physical\n   */\n  getDevicePixelRatio(useDevicePixels?: boolean | number): number {\n    if (typeof OffscreenCanvas !== 'undefined' && this.canvas instanceof OffscreenCanvas) {\n      return 1;\n    }\n\n    useDevicePixels = useDevicePixels === undefined ? this.props.useDevicePixels : useDevicePixels;\n\n    if (!useDevicePixels || (useDevicePixels as number) <= 0) {\n      return 1;\n    }\n\n    // The param was mainly provide to support the test cases, could be removed\n    if (useDevicePixels === true) {\n      const dpr = typeof window !== 'undefined' && window.devicePixelRatio;\n      return dpr || 1;\n    }\n\n    return useDevicePixels;\n  }\n\n  /**\n   * Returns the size of drawing buffer in device pixels.\n   * @note This can be different from the 'CSS' size of a canvas, and also from the\n   * canvas' internal drawing buffer size (.width, .height).\n   * This is the size required to cover the canvas, adjusted for DPR\n   */\n  getPixelSize(): [number, number] {\n    switch (this.type) {\n      case 'node':\n        return [this.width, this.height];\n      case 'offscreen-canvas':\n        return [this.canvas.width, this.canvas.height];\n      case 'html-canvas':\n        const dpr = this.getDevicePixelRatio();\n        const canvas = this.canvas as HTMLCanvasElement;\n        // If not attached to DOM client size can be 0\n        return canvas.parentElement\n          ? [canvas.clientWidth * dpr, canvas.clientHeight * dpr]\n          : [this.canvas.width, this.canvas.height];\n      default:\n        throw new Error(this.type);\n    }\n  }\n\n  getAspect(): number {\n    const [width, height] = this.getPixelSize();\n    return width / height;\n  }\n\n  /**\n   * Returns multiplier need to convert CSS size to Device size\n   */\n  cssToDeviceRatio(): number {\n    try {\n      // For headless gl we might have used custom width and height\n      // hence use cached clientWidth\n      const [drawingBufferWidth] = this.getDrawingBufferSize();\n      // _canvasSizeInfo may not be populated if `setDevicePixelRatio` is never called\n      const clientWidth = this._canvasSizeInfo.clientWidth || this.htmlCanvas?.clientWidth;\n      return clientWidth ? drawingBufferWidth / clientWidth : 1;\n    } catch {\n      return 1;\n    }\n  }\n\n  /**\n   * Maps CSS pixel position to device pixel position\n   */\n  cssToDevicePixels(\n    cssPixel: number[],\n    yInvert: boolean = true\n  ): {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  } {\n    const ratio = this.cssToDeviceRatio();\n    const [width, height] = this.getDrawingBufferSize();\n    return scalePixels(cssPixel, ratio, width, height, yInvert);\n  }\n\n  /**\n   * Use devicePixelRatio to set canvas width and height\n   * @note this is a raw port of luma.gl v8 code. Might be worth a review\n   */\n  setDevicePixelRatio(\n    devicePixelRatio: number,\n    options: {width?: number; height?: number} = {}\n  ): void {\n    if (!this.htmlCanvas) {\n      return;\n    }\n\n    // NOTE: if options.width and options.height not used remove in v8\n    let clientWidth = 'width' in options ? options.width : this.htmlCanvas.clientWidth;\n    let clientHeight = 'height' in options ? options.height : this.htmlCanvas.clientHeight;\n\n    if (!clientWidth || !clientHeight) {\n      log.log(1, 'Canvas clientWidth/clientHeight is 0')();\n      // by forcing devicePixel ratio to 1, we do not scale canvas.width and height in each frame.\n      devicePixelRatio = 1;\n      clientWidth = this.htmlCanvas.width || 1;\n      clientHeight = this.htmlCanvas.height || 1;\n    }\n\n    const cachedSize = this._canvasSizeInfo;\n    // Check if canvas needs to be resized\n    if (\n      cachedSize.clientWidth !== clientWidth ||\n      cachedSize.clientHeight !== clientHeight ||\n      cachedSize.devicePixelRatio !== devicePixelRatio\n    ) {\n      let clampedPixelRatio = devicePixelRatio;\n\n      const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);\n      const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);\n      this.htmlCanvas.width = canvasWidth;\n      this.htmlCanvas.height = canvasHeight;\n\n      // @ts-expect-error This only works for WebGL\n      const gl = this.device.gl;\n      if (gl) {\n        // Note: when devicePixelRatio is too high, it is possible we might hit system limit for\n        // drawing buffer width and hight, in those cases they get clamped and resulting aspect ration may not be maintained\n        // for those cases, reduce devicePixelRatio.\n        const [drawingBufferWidth, drawingBufferHeight] = this.getDrawingBufferSize();\n\n        if (drawingBufferWidth !== canvasWidth || drawingBufferHeight !== canvasHeight) {\n          clampedPixelRatio = Math.min(\n            drawingBufferWidth / clientWidth,\n            drawingBufferHeight / clientHeight\n          );\n\n          this.htmlCanvas.width = Math.floor(clientWidth * clampedPixelRatio);\n          this.htmlCanvas.height = Math.floor(clientHeight * clampedPixelRatio);\n\n          log.warn('Device pixel ratio clamped')();\n        }\n\n        this._canvasSizeInfo.clientWidth = clientWidth;\n        this._canvasSizeInfo.clientHeight = clientHeight;\n        this._canvasSizeInfo.devicePixelRatio = devicePixelRatio;\n      }\n    }\n  }\n\n  // PRIVATE\n\n  /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */\n  getDrawingBufferSize(): [number, number] {\n    // @ts-expect-error This only works for WebGL\n    const gl = this.device.gl;\n    if (!gl) {\n      // use default device pixel ratio\n      return this.getPixelSize();\n    }\n    return [gl.drawingBufferWidth, gl.drawingBufferHeight];\n  }\n\n  abstract resize(options?: {\n    width?: number;\n    height?: number;\n    useDevicePixels?: boolean | number;\n  }): void;\n\n  /** Perform platform specific updates (WebGPU vs WebGL) */\n  protected abstract update(): void;\n\n  /**\n   * Allows subclass constructor to override the canvas id for auto created canvases.\n   * This can really help when debugging DOM in apps that create multiple devices\n   */\n  protected _setAutoCreatedCanvasId(id: string) {\n    if (this.htmlCanvas?.id === 'lumagl-auto-created-canvas') {\n      this.htmlCanvas.id = id;\n    }\n  }\n}\n\n// HELPER FUNCTIONS\n\nfunction getContainer(container: HTMLElement | string | null): HTMLElement {\n  if (typeof container === 'string') {\n    const element = document.getElementById(container);\n    if (!element) {\n      throw new Error(`${container} is not an HTML element`);\n    }\n    return element;\n  } else if (container) {\n    return container;\n  }\n  return document.body;\n}\n\n/** Get a Canvas element from DOM id */\nfunction getCanvasFromDOM(canvasId: string): HTMLCanvasElement {\n  const canvas = document.getElementById(canvasId);\n  if (!(canvas instanceof HTMLCanvasElement)) {\n    throw new Error('Object is not a canvas element');\n  }\n  return canvas;\n}\n\n/** Create a new canvas */\nfunction createCanvas(props: CanvasContextProps) {\n  const {width, height} = props;\n  const targetCanvas = document.createElement('canvas');\n  targetCanvas.id = uid('lumagl-auto-created-canvas');\n  targetCanvas.width = width || 1;\n  targetCanvas.height = height || 1;\n  targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';\n  targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';\n  return targetCanvas;\n}\n\n/**\n *\n * @param pixel\n * @param ratio\n * @param width\n * @param height\n * @param yInvert\n * @returns\n */\nfunction scalePixels(\n  pixel: number[],\n  ratio: number,\n  width: number,\n  height: number,\n  yInvert: boolean\n): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n} {\n  const point = pixel as [number, number];\n\n  const x = scaleX(point[0], ratio, width);\n  let y = scaleY(point[1], ratio, height, yInvert);\n\n  // Find boundaries of next pixel to provide valid range of device pixel locations\n\n  let t = scaleX(point[0] + 1, ratio, width);\n  // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary\n  const xHigh = t === width - 1 ? t : t - 1;\n\n  t = scaleY(point[1] + 1, ratio, height, yInvert);\n  let yHigh;\n  if (yInvert) {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    t = t === 0 ? t : t + 1;\n    // swap y and yHigh\n    yHigh = y;\n    y = t;\n  } else {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    yHigh = t === height - 1 ? t : t - 1;\n    // y remains same\n  }\n  return {\n    x,\n    y,\n    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\n\nfunction scaleX(x: number, ratio: number, width: number): number {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\n\nfunction scaleY(y: number, ratio: number, height: number, yInvert: boolean): number {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  return yInvert\n    ? Math.max(0, height - 1 - Math.round(y * ratio))\n    : Math.min(Math.round(y * ratio), height - 1);\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport type {TypedArray} from '../../types';\nimport type {TextureFormat} from '../../gpu-type-utils/texture-formats';\nimport type {TextureView, TextureViewProps} from './texture-view';\nimport {Resource, ResourceProps} from './resource';\nimport {Sampler, SamplerProps} from './sampler';\n\n/**\n * These represent the main compressed texture formats\n * Each format typically has a number of more specific subformats\n */\nexport type TextureCompressionFormat =\n  | 'dxt'\n  | 'dxt-srgb'\n  | 'etc1'\n  | 'etc2'\n  | 'pvrtc'\n  | 'atc'\n  | 'astc'\n  | 'rgtc';\n\n/** Names of cube texture faces */\nexport type TextureCubeFace = '+X' | '-X' | '+Y' | '-Y' | '+Z' | '-Z';\n\n/**\n * One mip level\n * Basic data structure is similar to `ImageData`\n * additional optional fields can describe compressed texture data.\n */\nexport type TextureLevelData = {\n  /** WebGPU style format string. Defaults to 'rgba8unorm' */\n  format?: TextureFormat;\n  data: TypedArray;\n  width: number;\n  height: number;\n\n  compressed?: boolean;\n  byteLength?: number;\n  hasAlpha?: boolean;\n};\n\n/**\n * Built-in data types that can be used to initialize textures\n * @note ImageData can be used for 8 bit data via Uint8ClampedArray\n */\nexport type ExternalImage =\n  | ImageBitmap\n  | ImageData\n  | HTMLImageElement\n  | HTMLVideoElement\n  | VideoFrame\n  | HTMLCanvasElement\n  | OffscreenCanvas;\n\nexport type TextureLevelSource = TextureLevelData | ExternalImage;\n\n/** Texture data can be one or more mip levels */\nexport type TextureData = TextureLevelData | ExternalImage | (TextureLevelData | ExternalImage)[];\n\n/** @todo - define what data type is supported for 1D textures */\nexport type Texture1DData = TypedArray | TextureLevelData;\n\n/** Texture data can be one or more mip levels */\nexport type Texture2DData =\n  | TypedArray\n  | TextureLevelData\n  | ExternalImage\n  | (TextureLevelData | ExternalImage)[];\n\n/** Array of textures */\nexport type Texture3DData = TypedArray | TextureData[];\n\n/** 6 face textures */\nexport type TextureCubeData = Record<TextureCubeFace, Texture2DData>;\n\n/** Array of textures */\nexport type TextureArrayData = TextureData[];\n\n/** Array of 6 face textures */\nexport type TextureCubeArrayData = Record<TextureCubeFace, TextureData>[];\n\nexport type TextureDataProps =\n  | Texture1DProps\n  | Texture2DProps\n  | Texture3DProps\n  | TextureArrayProps\n  | TextureCubeProps\n  | TextureCubeArrayProps;\n\nexport type Texture1DProps = {dimension: '1d'; data?: Texture1DData | null};\nexport type Texture2DProps = {dimension?: '2d'; data?: Texture2DData | null};\nexport type Texture3DProps = {dimension: '3d'; data?: Texture3DData | null};\nexport type TextureArrayProps = {dimension: '2d-array'; data?: TextureArrayData | null};\nexport type TextureCubeProps = {dimension: 'cube'; data?: TextureCubeData | null};\nexport type TextureCubeArrayProps = {dimension: 'cube-array'; data: TextureCubeArrayData | null};\n\n/** Texture properties */\nexport type TextureProps = ResourceProps &\n  TextureDataProps & {\n    format?: TextureFormat;\n    width?: number | undefined;\n    height?: number | undefined;\n    depth?: number;\n    usage?: number;\n\n    /** How many mip levels */\n    mipLevels?: number | 'pyramid';\n    /** Multi sampling */\n    samples?: number;\n\n    /** Specifying mipmaps will default mipLevels to 'pyramid' and attempt to generate mipmaps */\n    mipmaps?: boolean;\n\n    /** Sampler (or SamplerProps) for the default sampler for this texture. Used if no sampler provided. Note that other samplers can still be used. */\n    sampler?: Sampler | SamplerProps;\n    /** Props for the default TextureView for this texture. Note that other views can still be created and used. */\n    view?: TextureViewProps;\n\n    /** Whether to flip the image vertically. Used if texture is initialized with an image. */\n    flipY?: boolean;\n\n    /** @deprecated - this is implicit from format */\n    compressed?: boolean;\n  };\n\n/** Options for Texture.copyExternalImage */\nexport type CopyExternalImageOptions = {\n  /** Image */\n  image: ExternalImage;\n  /** Copy from image x offset (default 0) */\n  sourceX?: number;\n  /** Copy from image y offset (default 0) */\n  sourceY?: number;\n  /** Copy area width (default 1) */\n  width?: number;\n  /** Copy area height (default 1) */\n  height?: number;\n  /** Copy depth (default 1) */\n  depth?: number;\n  /** Which mip-level to copy into (default 0) */\n  mipLevel?: number;\n  /** Start copying into offset x (default 0) */\n  x?: number;\n  /** Start copying into offset y (default 0) */\n  y?: number;\n  /** Start copying from depth layer z (default 0) */\n  z?: number;\n  /** When copying into depth stencil textures (default 'all') */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n  /** Specific color space of image data */\n  colorSpace?: 'srgb';\n  /** load as premultiplied alpha  */\n  premultipliedAlpha?: boolean;\n  /** Whether to flip the image vertically */\n  flipY?: boolean;\n};\n\n/**\n * Abstract Texture interface\n * Texture Object\n * https://gpuweb.github.io/gpuweb/#gputexture\n */\nexport abstract class Texture extends Resource<TextureProps> {\n  static COPY_SRC = 0x01;\n  static COPY_DST = 0x02;\n  static TEXTURE = 0x04;\n  static STORAGE = 0x08;\n  static RENDER_ATTACHMENT = 0x10;\n\n  static CubeFaces: TextureCubeFace[] = ['+X', '-X', '+Y', '-Y', '+Z', '-Z'];\n\n  static override defaultProps: Required<TextureProps> = {\n    ...Resource.defaultProps,\n    data: null,\n    dimension: '2d',\n    format: 'rgba8unorm',\n    width: undefined!,\n    height: undefined!,\n    depth: 1,\n    mipmaps: false,\n    compressed: false,\n    usage: 0,\n    mipLevels: undefined!,\n    samples: undefined!,\n    sampler: {},\n    view: undefined!,\n    flipY: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'Texture';\n  }\n\n  override toString(): string {\n    return `Texture(${this.id},${this.format},${this.width}x${this.height})`;\n  }\n\n  /** dimension of this texture */\n  readonly dimension: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d';\n  /** format of this texture */\n  readonly format: TextureFormat;\n  /** width in pixels of this texture */\n  width: number;\n  /** height in pixels of this texture */\n  height: number;\n  /** depth of this texture */\n  depth: number;\n  /** mip levels in this texture */\n  mipLevels: number;\n\n  /** Default sampler for this texture */\n  abstract sampler: Sampler;\n  /** Default view for this texture */\n  abstract view: TextureView;\n\n  /** \"Time\" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */\n  updateTimestamp: number;\n\n  /** Do not use directly. Create with device.createTexture() */\n  constructor(device: Device, props: TextureProps) {\n    props = Texture.normalizeProps(device, props);\n    super(device, props, Texture.defaultProps);\n    this.dimension = this.props.dimension;\n    this.format = this.props.format;\n\n    // Size\n    this.width = this.props.width;\n    this.height = this.props.height;\n    this.depth = this.props.depth;\n\n    // Calculate size, if not provided\n    if (this.props.width === undefined || this.props.height === undefined) {\n      // @ts-ignore\n      const size = Texture.getTextureDataSize(this.props.data);\n      this.width = size?.width || 1;\n      this.height = size?.height || 1;\n    }\n\n    // mipLevels\n\n    // If mipmap generation is requested and mipLevels is not provided, initialize a full pyramid\n    if (this.props.mipmaps && this.props.mipLevels === undefined) {\n      this.props.mipLevels = 'pyramid';\n    }\n\n    // Auto-calculate the number of mip levels as a convenience\n    // TODO - Should we clamp to 1-getMipLevelCount?\n    this.mipLevels =\n      this.props.mipLevels === 'pyramid'\n        ? Texture.getMipLevelCount(this.width, this.height)\n        : this.props.mipLevels || 1;\n\n    // TODO - perhaps this should be set on async write completion?\n    this.updateTimestamp = device.incrementTimestamp();\n  }\n\n  /** Create a texture view for this texture */\n  abstract createView(props: TextureViewProps): TextureView;\n\n  /** Set sampler props associated with this texture */\n  abstract setSampler(sampler?: Sampler | SamplerProps): void;\n\n  /** Copy external image data into the texture */\n  abstract copyExternalImage(options: CopyExternalImageOptions): {width: number; height: number};\n\n  /**\n   * Create a new texture with the same parameters and optionally, a different size\n   * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.\n   * @note Does not copy contents of the texture\n   */\n  clone(size?: {width: number; height: number}): Texture {\n    return this.device.createTexture({...this.props, ...size});\n  }\n\n  /** Check if data is an external image */\n  static isExternalImage(data: unknown): data is ExternalImage {\n    return (\n      (typeof ImageData !== 'undefined' && data instanceof ImageData) ||\n      (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) ||\n      (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) ||\n      (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) ||\n      (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) ||\n      (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) ||\n      (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)\n    );\n  }\n\n  /** Determine size (width and height) of provided image data */\n  static getExternalImageSize(data: ExternalImage): {width: number; height: number} {\n    if (\n      (typeof ImageData !== 'undefined' && data instanceof ImageData) ||\n      (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) ||\n      (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) ||\n      (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)\n    ) {\n      return {width: data.width, height: data.height};\n    }\n    if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n      return {width: data.naturalWidth, height: data.naturalHeight};\n    }\n    if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n      return {width: data.videoWidth, height: data.videoHeight};\n    }\n    if (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) {\n      // TODO: is this the right choice for width and height?\n      return {width: data.displayWidth, height: data.displayHeight};\n    }\n    throw new Error('Unknown image type');\n  }\n\n  /** Check if texture data is a typed array */\n  static isTextureLevelData(data: TextureData): data is TextureLevelData {\n    const typedArray = (data as TextureLevelData)?.data;\n    return ArrayBuffer.isView(typedArray);\n  }\n\n  /** Get the size of the texture described by the provided TextureData */\n  static getTextureDataSize(\n    data: TextureData | TextureCubeData | TextureArrayData | TextureCubeArrayData | TypedArray\n  ): {width: number; height: number} | null {\n    if (!data) {\n      return null;\n    }\n    if (ArrayBuffer.isView(data)) {\n      return null;\n    }\n    // Recurse into arrays (array of miplevels)\n    if (Array.isArray(data)) {\n      return Texture.getTextureDataSize(data[0]);\n    }\n    if (Texture.isExternalImage(data)) {\n      return Texture.getExternalImageSize(data);\n    }\n    if (data && typeof data === 'object' && data.constructor === Object) {\n      const textureDataArray = Object.values(data) as Texture2DData[];\n      const untypedData = textureDataArray[0] as any;\n      return {width: untypedData.width, height: untypedData.height};\n    }\n    throw new Error('texture size deduction failed');\n  }\n\n  /**\n   * Normalize TextureData to an array of TextureLevelData / ExternalImages\n   * @param data\n   * @param options\n   * @returns array of TextureLevelData / ExternalImages\n   */\n  static normalizeTextureData(\n    data: Texture2DData,\n    options: {width: number; height: number; depth: number}\n  ): (TextureLevelData | ExternalImage)[] {\n    let lodArray: (TextureLevelData | ExternalImage)[];\n    if (ArrayBuffer.isView(data)) {\n      lodArray = [\n        {\n          // ts-expect-error does data really need to be Uint8ClampedArray?\n          data,\n          width: options.width,\n          height: options.height\n          // depth: options.depth\n        }\n      ];\n    } else if (!Array.isArray(data)) {\n      lodArray = [data];\n    } else {\n      lodArray = data;\n    }\n    return lodArray;\n  }\n\n  /** Calculate the number of mip levels for a texture of width and height */\n  static getMipLevelCount(width: number, height: number): number {\n    return Math.floor(Math.log2(Math.max(width, height))) + 1;\n  }\n\n  /** Convert luma.gl cubemap face constants to depth index */\n  static getCubeFaceDepth(face: TextureCubeFace): number {\n    // prettier-ignore\n    switch (face) {\n        case '+X': return  0;\n        case '-X': return  1;\n        case '+Y': return  2;\n        case '-Y': return  3;\n        case '+Z': return  4;\n        case '-Z': return  5;\n        default: throw new Error(face);\n      }\n  }\n\n  /** Default options */\n  protected static defaultCopyExternalImageOptions: Required<CopyExternalImageOptions> = {\n    image: undefined!,\n    sourceX: 0,\n    sourceY: 0,\n    width: undefined!,\n    height: undefined!,\n    depth: 1,\n    mipLevel: 0,\n    x: 0,\n    y: 0,\n    z: 0,\n    aspect: 'all',\n    colorSpace: 'srgb',\n    premultipliedAlpha: false,\n    flipY: false\n  };\n\n  /** Ensure we have integer coordinates */\n  protected static normalizeProps(device: Device, props: TextureProps): TextureProps {\n    const newProps = {...props};\n\n    // Allow device to override props (e.g. props.mipmaps)\n    const overriddenDefaultProps: Partial<TextureProps> =\n      device?.props?._resourceDefaults?.texture || {};\n    // TODO - Type issue with props.data circumvented with Object.assign\n    Object.assign(newProps, overriddenDefaultProps);\n\n    // Ensure we have integer coordinates\n    const {width, height} = newProps;\n    if (typeof width === 'number') {\n      newProps.width = Math.max(1, Math.ceil(width));\n    }\n    if (typeof height === 'number') {\n      newProps.height = Math.max(1, Math.ceil(height));\n    }\n    return newProps;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport type {Texture} from './texture';\nimport type {TextureFormat} from '../../gpu-type-utils/texture-formats';\nimport {Resource, ResourceProps} from './resource';\n\n/** Properties for initializing a texture view */\nexport type TextureViewProps = ResourceProps & {\n  /** The format of the texture view. Must be either the format of the texture or one of the viewFormats specified during its creation. */\n  format?: TextureFormat;\n  /** The dimension to view the texture as. */\n  dimension?: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d';\n  /** Which aspect(s) of the texture are accessible to the texture view. default \"all\"*/\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n  /** The first (most detailed) mipmap level accessible to the texture view.  default 0*/\n  baseMipLevel?: number;\n  /** How many mipmap levels, starting with baseMipLevel, are accessible to the texture view. */\n  mipLevelCount: number;\n  /** The index of the first array layer accessible to the texture view. default 0 */\n  baseArrayLayer?: number;\n  /** How many array layers, starting with baseArrayLayer, are accessible to the texture view. */\n  arrayLayerCount: number;\n};\n\n/** Immutable TextureView object */\nexport abstract class TextureView extends Resource<TextureViewProps> {\n  static override defaultProps: Required<TextureViewProps> = {\n    ...Resource.defaultProps,\n    format: undefined!,\n    dimension: undefined!,\n    aspect: 'all',\n    baseMipLevel: 0,\n    mipLevelCount: undefined!,\n    baseArrayLayer: 0,\n    arrayLayerCount: undefined!\n  };\n\n  abstract texture: Texture;\n\n  override get [Symbol.toStringTag](): string {\n    return 'TextureView';\n  }\n\n  /** Should not be constructed directly. Use `texture.createView(props)` */\n  constructor(device: Device, props: TextureViewProps & {texture: Texture}) {\n    super(device, props, TextureView.defaultProps);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n\nexport type ExternalTextureProps = ResourceProps & {\n  source: HTMLVideoElement; //  | null;\n  colorSpace?: 'srgb';\n};\nexport abstract class ExternalTexture extends Resource<ExternalTextureProps> {\n  static override defaultProps: Required<ExternalTextureProps> = {\n    ...Resource.defaultProps,\n    source: undefined!,\n    colorSpace: 'srgb'\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'ExternalTexture';\n  }\n\n  constructor(device: Device, props: ExternalTextureProps) {\n    super(device, props, ExternalTexture.defaultProps);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {CompilerMessage} from '../adapter/types/compiler-message';\n\n/** @returns annotated errors or warnings */\nexport function formatCompilerLog(\n  shaderLog: readonly CompilerMessage[],\n  source: string,\n  options?: {\n    /** Include source code in the log. Either just the lines before issues or all source code */\n    showSourceCode?: 'no' | 'issues' | 'all';\n    html?: boolean;\n  }\n): string {\n  let formattedLog = '';\n  const lines = source.split(/\\r?\\n/);\n  const log = shaderLog.slice().sort((a, b) => a.lineNum - b.lineNum);\n\n  switch (options?.showSourceCode || 'no') {\n    case 'all':\n      // Parse the error - note: browser and driver dependent\n      let currentMessage = 0;\n      for (let lineNum = 1; lineNum <= lines.length; lineNum++) {\n        formattedLog += getNumberedLine(lines[lineNum - 1], lineNum, options);\n        while (log.length > currentMessage && log[currentMessage].lineNum === lineNum) {\n          const message = log[currentMessage++];\n          formattedLog += formatCompilerMessage(message, lines, message.lineNum, {\n            ...options,\n            inlineSource: false\n          });\n        }\n      }\n      return formattedLog;\n\n    case 'issues':\n    case 'no':\n      // Parse the error - note: browser and driver dependent\n      for (const message of shaderLog) {\n        formattedLog += formatCompilerMessage(message, lines, message.lineNum, {\n          inlineSource: options?.showSourceCode !== 'no'\n        });\n      }\n      return formattedLog;\n  }\n}\n\n// Helpers\n\n/** Format one message */\nfunction formatCompilerMessage(\n  message: CompilerMessage,\n  lines: readonly string[],\n  lineNum: number,\n  options: {\n    inlineSource?: boolean;\n    html?: boolean;\n  }\n): string {\n  if (options?.inlineSource) {\n    const numberedLines = getNumberedLines(lines, lineNum);\n    // If we got error position on line add a `^^^` indicator on next line\n    const positionIndicator = message.linePos > 0 ? `${' '.repeat(message.linePos + 5)}^^^\\n` : '';\n    return `\n${numberedLines}${positionIndicator}${message.type.toUpperCase()}: ${message.message}\n\n`;\n  }\n  const color = message.type === 'error' ? 'red' : '#8B4000'; // dark orange\n  return options?.html\n    ? `<div class='luma-compiler-log-error' style=\"color:${color};\"><b> ${message.type.toUpperCase()}: ${\n        message.message\n      }</b></div>`\n    : `${message.type.toUpperCase()}: ${message.message}`;\n}\n\nfunction getNumberedLines(\n  lines: readonly string[],\n  lineNum: number,\n  options?: {html?: boolean}\n): string {\n  let numberedLines = '';\n  for (let lineIndex = lineNum - 2; lineIndex <= lineNum; lineIndex++) {\n    const sourceLine = lines[lineIndex - 1];\n    if (sourceLine !== undefined) {\n      numberedLines += getNumberedLine(sourceLine, lineNum, options);\n    }\n  }\n  return numberedLines;\n}\n\nfunction getNumberedLine(line: string, lineNum: number, options?: {html?: boolean}): string {\n  const escapedLine = options?.html ? escapeHTML(line) : line;\n  return `${padLeft(String(lineNum), 4)}: ${escapedLine}${options?.html ? '<br/>' : '\\n'}`;\n}\n\n/**\n * Pads a string with a number of spaces (space characters) to the left\n * @param {String} string - string to pad\n * @param {Number} digits - number of spaces to add\n * @return {String} string - The padded string\n */\nfunction padLeft(string: string, paddedLength: number): string {\n  let result = '';\n  for (let i = string.length; i < paddedLength; ++i) {\n    result += ' ';\n  }\n  return result + string;\n}\n\nfunction escapeHTML(unsafe: string): string {\n  return unsafe\n    .replaceAll('&', '&amp;')\n    .replaceAll('<', '&lt;')\n    .replaceAll('>', '&gt;')\n    .replaceAll('\"', '&quot;')\n    .replaceAll(\"'\", '&#039;');\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n// import { log } from '../../utils/log';\nimport {uid} from '../../utils/uid';\nimport {CompilerMessage} from '../types/compiler-message';\nimport {formatCompilerLog} from '../../adapter-utils/format-compiler-log';\n\n/**\n * Properties for a Shader\n */\nexport type ShaderProps = ResourceProps & {\n  /** Shader language (defaults to auto) */\n  language?: 'glsl' | 'wgsl' | 'auto';\n  /** Which stage are we compiling? Required for GLSL. Ignored for WGSL. */\n  stage?: 'vertex' | 'fragment' | 'compute';\n  /** Shader source code */\n  source: string;\n  /** Optional shader source map (WebGPU only) */\n  sourceMap?: string | null;\n  /** Optional shader entry point (WebGPU only) */\n  entryPoint?: string;\n  /** Show shader source in browser? Overrides the device.props.debugShaders setting */\n  debugShaders?: 'never' | 'errors' | 'warnings' | 'always';\n};\n\n/**\n * Immutable Shader object\n * In WebGPU the handle can be copied between threads\n */\nexport abstract class Shader extends Resource<ShaderProps> {\n  static override defaultProps: Required<ShaderProps> = {\n    ...Resource.defaultProps,\n    language: 'auto',\n    stage: undefined!,\n    source: '',\n    sourceMap: null,\n    entryPoint: 'main',\n    debugShaders: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'Shader';\n  }\n\n  /** The stage of this shader */\n  readonly stage: 'vertex' | 'fragment' | 'compute';\n  /** The source code of this shader */\n  readonly source: string;\n  /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */\n  compilationStatus: 'pending' | 'success' | 'error' = 'pending';\n\n  /** Create a new Shader instance */\n  constructor(device: Device, props: ShaderProps) {\n    props = {...props, debugShaders: props.debugShaders || device.props.debugShaders || 'errors'};\n    super(device, {id: getShaderIdFromProps(props), ...props}, Shader.defaultProps);\n    this.stage = this.props.stage;\n    this.source = this.props.source;\n  }\n\n  abstract get asyncCompilationStatus(): Promise<'pending' | 'success' | 'error'>;\n\n  /** Get compiler log asynchronously */\n  abstract getCompilationInfo(): Promise<readonly CompilerMessage[]>;\n\n  /** Get compiler log synchronously (WebGL only) */\n  getCompilationInfoSync(): readonly CompilerMessage[] | null {\n    return null;\n  }\n\n  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */\n  getTranslatedSource(): string | null {\n    return null;\n  }\n\n  // PORTABLE HELPERS\n\n  /** In browser logging of errors */\n  async debugShader(): Promise<void> {\n    const trigger = this.props.debugShaders;\n    switch (trigger) {\n      case 'never':\n        return;\n      case 'errors':\n        // On WebGL - Don't extract the log unless errors\n        if (this.compilationStatus === 'success') {\n          return;\n        }\n        break;\n      case 'warnings':\n      case 'always':\n        break;\n    }\n\n    const messages = await this.getCompilationInfo();\n    if (trigger === 'warnings' && messages?.length === 0) {\n      return;\n    }\n    this._displayShaderLog(messages);\n  }\n\n  // PRIVATE\n\n  /**\n   * In-browser UI logging of errors\n   * TODO - this HTML formatting code should not be in Device, should be pluggable\n   */\n  protected _displayShaderLog(messages: readonly CompilerMessage[]): void {\n    // Return if under Node.js / incomplete `document` polyfills\n    if (typeof document === 'undefined' || !document?.createElement) {\n      return;\n    }\n\n    const shaderName: string = getShaderName(this.source);\n    const shaderTitle: string = `${this.stage} ${shaderName}`;\n    let htmlLog = formatCompilerLog(messages, this.source, {showSourceCode: 'all', html: true});\n    // Show translated source if available\n    const translatedSource = this.getTranslatedSource();\n    if (translatedSource) {\n      htmlLog += `<br /><br /><h1>Translated Source</h1><br /><br /><code style=\"user-select:text;\"><pre>${translatedSource}</pre></code>`;\n    }\n    // Make it clickable so we can copy to clipboard\n    const button = document.createElement('Button');\n    button.innerHTML = `\n<h1>Shader Compilation Error in ${shaderTitle}</h1><br /><br />\n<code style=\"user-select:text;\"><pre>\n${htmlLog}\n</pre></code>`;\n    button.style.top = '10px';\n    button.style.left = '10px';\n    button.style.position = 'absolute';\n    button.style.zIndex = '9999';\n    button.style.width = '100%';\n    button.style.textAlign = 'left';\n    document.body.appendChild(button);\n\n    const errors = document.getElementsByClassName('luma-compiler-log-error');\n    errors[0]?.scrollIntoView();\n\n    // TODO - add a small embedded copy button (instead of main button)\n    button.onclick = () => {\n      // const source = this.source.replaceAll('\\n', '<br />');\n      const dataURI = `data:text/plain,${encodeURIComponent(this.source)}`;\n      navigator.clipboard.writeText(dataURI);\n    };\n\n    // TODO - add a small embedded close button\n  }\n}\n\n// HELPERS\n\n/** Deduce an id, from shader source, or supplied id, or shader type */\nfunction getShaderIdFromProps(props: ShaderProps): string {\n  return getShaderName(props.source) || props.id || uid(`unnamed ${props.stage}-shader`);\n}\n\n/** Extracts GLSLIFY style naming of shaders: `#define SHADER_NAME ...` */\nfunction getShaderName(shader: string, defaultName: string = 'unnamed'): string {\n  const SHADER_NAME_REGEXP = /#define[\\s*]SHADER_NAME[\\s*]([A-Za-z0-9_-]+)[\\s*]/;\n  const match = SHADER_NAME_REGEXP.exec(shader);\n  return match ? match[1] : defaultName;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {CompareFunction} from '../types/parameters';\nimport {Resource, ResourceProps} from './resource';\n\n/** Edge values sampling mode */\nexport type SamplerAddressMode = 'clamp-to-edge' | 'repeat' | 'mirror-repeat';\n\n/** Sampler filtering mode */\nexport type SamplerFilterMode = 'nearest' | 'linear';\n\n/**\n * Properties for initializing a sampler\n */\nexport type SamplerProps = ResourceProps & {\n  /** Comparison / shadow samplers are used with depth textures. See the `Sampler.compare` field */\n  type?: 'color-sampler' | 'comparison-sampler';\n  /** Edge value sampling in X direction */\n  addressModeU?: 'clamp-to-edge' | 'repeat' | 'mirror-repeat';\n  /** Edge value sampling in Y direction */\n  addressModeV?: 'clamp-to-edge' | 'repeat' | 'mirror-repeat';\n  /** Edge value sampling in Z direction */\n  addressModeW?: 'clamp-to-edge' | 'repeat' | 'mirror-repeat';\n\n  /** Magnification: the area of the fragment in texture space is smaller than a texel */\n  magFilter?: 'nearest' | 'linear';\n  /** Minification: the area of the fragment in texture space is larger than a texel */\n  minFilter?: 'nearest' | 'linear';\n  /** mipmapping: select between multiple mipmaps based on angle and size of the texture relative to the screen. */\n  mipmapFilter?: 'none' | 'nearest' | 'linear';\n  /** Affects the mipmap image selection */\n  lodMinClamp?: number;\n  /** Affects the mipmap image selection */\n  lodMaxClamp?: number;\n  /** Maximum number of samples that can be taken of the texture during any one texture fetch */\n  maxAnisotropy?: number;\n  /** How to compare reference values provided in shader shadow sampler calls with those pulled from the texture */\n  compare?: CompareFunction;\n};\n\nexport type SamplerParameters = Omit<SamplerProps, keyof ResourceProps>;\n\n/** Immutable Sampler object */\nexport abstract class Sampler extends Resource<SamplerProps> {\n  static override defaultProps: Required<SamplerProps> = {\n    ...Resource.defaultProps,\n    type: 'color-sampler',\n    addressModeU: 'clamp-to-edge',\n    addressModeV: 'clamp-to-edge',\n    addressModeW: 'clamp-to-edge',\n    magFilter: 'nearest',\n    minFilter: 'nearest',\n    mipmapFilter: 'none',\n    lodMinClamp: 0,\n    lodMaxClamp: 32, // Per WebGPU spec\n    compare: 'less-equal',\n    maxAnisotropy: 1\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'Sampler';\n  }\n\n  constructor(device: Device, props: SamplerProps) {\n    props = Sampler.normalizeProps(device, props);\n    super(device, props, Sampler.defaultProps);\n  }\n\n  protected static normalizeProps(device: Device, props: SamplerProps): SamplerProps {\n    const overriddenDefaultProps: Partial<SamplerProps> =\n      device?.props?._resourceDefaults?.sampler || {};\n    const newProps = {...props, ...overriddenDefaultProps};\n    return newProps;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {\n  ColorTextureFormat,\n  DepthStencilTextureFormat,\n  TextureFormat\n} from '../../gpu-type-utils/texture-formats';\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\nimport {Texture} from './texture';\nimport {TextureView} from './texture-view';\nimport {log} from '../../utils/log';\n\nexport type FramebufferProps = ResourceProps & {\n  width?: number;\n  height?: number;\n  colorAttachments?: (TextureView | Texture | ColorTextureFormat)[];\n  depthStencilAttachment?: (TextureView | Texture | DepthStencilTextureFormat) | null;\n};\n\n/**\n * Create new textures with correct size for all attachments.\n * @note resize() destroys existing textures (if size has changed).\n */\nexport abstract class Framebuffer extends Resource<FramebufferProps> {\n  static override defaultProps: Required<FramebufferProps> = {\n    ...Resource.defaultProps,\n    width: 1,\n    height: 1,\n    colorAttachments: [], // ['rgba8unorm'],\n    depthStencilAttachment: null // 'depth24plus-stencil8'\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'Framebuffer';\n  }\n\n  /** Width of all attachments in this framebuffer */\n  width: number;\n  /** Height of all attachments in this framebuffer */\n  height: number;\n  /** Color attachments */\n  abstract colorAttachments: TextureView[];\n  /** Depth-stencil attachment, if provided */\n  abstract depthStencilAttachment: TextureView | null;\n\n  constructor(device: Device, props: FramebufferProps = {}) {\n    super(device, props, Framebuffer.defaultProps);\n    this.width = this.props.width;\n    this.height = this.props.height;\n  }\n\n  /**\n   * Create a copy of this framebuffer with new attached textures, with same props but of the specified size.\n   * @note Does not copy contents of the attached textures.\n   */\n  clone(size?: {width: number; height: number}): Framebuffer {\n    const colorAttachments = this.colorAttachments.map(colorAttachment =>\n      colorAttachment.texture.clone(size)\n    );\n\n    const depthStencilAttachment =\n      this.depthStencilAttachment && this.depthStencilAttachment.texture.clone(size);\n\n    return this.device.createFramebuffer({...this.props, colorAttachments, depthStencilAttachment});\n  }\n\n  /**\n   * Resizes all attachments\n   * @note resize() destroys existing textures (if size has changed).\n   * @deprecated Use framebuffer.clone()\n   */\n  resize(size: {width: number; height: number}): void;\n  resize(size: [width: number, height: number]): void;\n  resize(): void;\n  resize(size?: {width: number; height: number} | [width: number, height: number]): void {\n    let updateSize: boolean = !size;\n    if (size) {\n      const [width, height] = Array.isArray(size) ? size : [size.width, size.height];\n      updateSize = updateSize || height !== this.height || width !== this.width;\n      this.width = width;\n      this.height = height;\n    }\n    if (updateSize) {\n      log.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)();\n      this.resizeAttachments(this.width, this.height);\n    }\n  }\n\n  /** Auto creates any textures */\n  protected autoCreateAttachmentTextures(): void {\n    if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment) {\n      throw new Error('Framebuffer has noattachments');\n    }\n\n    this.colorAttachments = this.props.colorAttachments.map((attachment, index) => {\n      if (typeof attachment === 'string') {\n        const texture = this.createColorTexture(attachment, index);\n        this.attachResource(texture);\n        return texture.view;\n      }\n      if (attachment instanceof Texture) {\n        return attachment.view;\n      }\n      return attachment;\n    });\n\n    const attachment = this.props.depthStencilAttachment;\n    if (attachment) {\n      if (typeof attachment === 'string') {\n        const texture = this.createDepthStencilTexture(attachment);\n        this.attachResource(texture);\n        this.depthStencilAttachment = texture.view;\n      } else if (attachment instanceof Texture) {\n        this.depthStencilAttachment = attachment.view;\n      } else {\n        this.depthStencilAttachment = attachment;\n      }\n    }\n  }\n\n  /** Create a color texture */\n  protected createColorTexture(format: TextureFormat, index: number): Texture {\n    return this.device.createTexture({\n      id: `${this.id}-color-attachment-${index}`,\n      usage: Texture.RENDER_ATTACHMENT,\n      format,\n      width: this.width,\n      height: this.height,\n      // TODO deprecated? - luma.gl v8 compatibility\n      sampler: {\n        magFilter: 'linear',\n        minFilter: 'linear'\n      }\n    });\n  }\n\n  /** Create depth stencil texture */\n  protected createDepthStencilTexture(format: TextureFormat): Texture {\n    return this.device.createTexture({\n      id: `${this.id}-depth-stencil-attachment`,\n      usage: Texture.RENDER_ATTACHMENT,\n      format,\n      width: this.width,\n      height: this.height,\n      mipmaps: false\n    });\n  }\n\n  /**\n   * Default implementation of resize\n   * Creates new textures with correct size for all attachments.\n   * and destroys existing textures if owned\n   */\n  protected resizeAttachments(width: number, height: number): void {\n    for (let i = 0; i < this.colorAttachments.length; ++i) {\n      if (this.colorAttachments[i]) {\n        const resizedTexture = this.colorAttachments[i].texture.clone({\n          width,\n          height\n        });\n        this.destroyAttachedResource(this.colorAttachments[i]);\n        this.colorAttachments[i] = resizedTexture.view;\n        this.attachResource(resizedTexture.view);\n      }\n    }\n\n    if (this.depthStencilAttachment) {\n      const resizedTexture = this.depthStencilAttachment.texture.clone({\n        width,\n        height\n      });\n      this.destroyAttachedResource(this.depthStencilAttachment);\n      this.depthStencilAttachment = resizedTexture.view;\n      this.attachResource(resizedTexture);\n    }\n\n    this.updateAttachments();\n  }\n\n  /** Implementation is expected to update any underlying binding (WebGL framebuffer attachment) */\n  protected abstract updateAttachments(): void;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport type {UniformValue} from '../types/uniforms';\nimport type {PrimitiveTopology, RenderPipelineParameters} from '../types/parameters';\nimport type {ShaderLayout, Binding} from '../types/shader-layout';\nimport type {BufferLayout} from '../types/buffer-layout';\n// import {normalizeAttributeMap} from '../helpers/attribute-bindings';\nimport {Resource, ResourceProps} from './resource';\nimport type {Shader} from './shader';\nimport type {RenderPass} from './render-pass';\nimport {VertexArray} from './vertex-array';\nimport {TransformFeedback} from './transform-feedback';\n\nexport type RenderPipelineProps = ResourceProps & {\n  // Shaders and shader layout\n\n  /** Compiled vertex shader */\n  vs?: Shader | null;\n  /** Name of vertex shader stage main function (defaults to 'main'). WGSL only */\n  vertexEntryPoint?: string; //\n  /** Constant values to apply to compiled vertex shader. Do not require re-compilation. (WGSL only) */\n  vsConstants?: Record<string, number>; // WGSL only\n  /** Compiled fragment shader */\n  fs?: Shader | null;\n  /** Name of fragment shader stage main function (defaults to 'main'). WGSL only */\n  fragmentEntryPoint?: string; // WGSL only\n  /** Constant values to apply to compiled fragment shader. Do not require re-compilation. (WGSL only) */\n  fsConstants?: Record<string, number>;\n\n  /** Describes the attributes and bindings exposed by the pipeline shader(s). */\n  shaderLayout?: ShaderLayout | null;\n  /** Describes the buffers accepted by this pipeline and how they are mapped to shader attributes. */\n  bufferLayout?: BufferLayout[]; // Record<string, Omit<BufferLayout, 'name'>\n\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology?: PrimitiveTopology;\n  /** Parameters that are controlled by pipeline */\n  parameters?: RenderPipelineParameters;\n\n  // /** Use instanced rendering? */\n  // isInstanced?: boolean;\n  // /** Number of instances */\n  // instanceCount?: number;\n  // /** Number of vertices */\n  // vertexCount?: number;\n\n  /** Buffers, Textures, Samplers for the shader bindings */\n  bindings?: Record<string, Binding>;\n  /** @deprecated uniforms (WebGL only) */\n  uniforms?: Record<string, UniformValue>;\n};\n\n/**\n * A compiled and linked shader program\n */\nexport abstract class RenderPipeline extends Resource<RenderPipelineProps> {\n  static override defaultProps: Required<RenderPipelineProps> = {\n    ...Resource.defaultProps,\n\n    vs: null,\n    vertexEntryPoint: 'vertexMain',\n    vsConstants: {},\n\n    fs: null,\n    fragmentEntryPoint: 'fragmentMain',\n    fsConstants: {},\n\n    shaderLayout: null,\n    bufferLayout: [],\n    topology: 'triangle-list',\n    parameters: {},\n\n    // isInstanced: false,\n    // instanceCount: 0,\n    // vertexCount: 0,\n\n    bindings: {},\n    uniforms: {}\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'RenderPipeline';\n  }\n\n  abstract readonly vs: Shader;\n  abstract readonly fs: Shader | null;\n\n  /** The merged layout */\n  shaderLayout: ShaderLayout;\n  /** Buffer map describing buffer interleaving etc */\n  readonly bufferLayout: BufferLayout[];\n  /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */\n  linkStatus: 'pending' | 'success' | 'error' = 'pending';\n  /** The hash of the pipeline */\n  hash: string = '';\n\n  constructor(device: Device, props: RenderPipelineProps) {\n    super(device, props, RenderPipeline.defaultProps);\n    this.shaderLayout = this.props.shaderLayout!;\n    this.bufferLayout = this.props.bufferLayout || [];\n  }\n\n  /** Set bindings (stored on pipeline and set before each call) */\n  abstract setBindings(\n    bindings: Record<string, Binding>,\n    options?: {disableWarnings?: boolean}\n  ): void;\n\n  /** Draw call. Returns false if the draw call was aborted (due to resources still initializing) */\n  abstract draw(options: {\n    /** Render pass to draw into (targeting screen or framebuffer) */\n    renderPass?: RenderPass;\n    /** Parameters to be set during draw call. Note that most parameters can only be overridden in WebGL. */\n    parameters?: RenderPipelineParameters;\n    /** Topology. Note can only be overridden in WebGL. */\n    topology?: PrimitiveTopology;\n    /** vertex attributes */\n    vertexArray: VertexArray;\n    /** Use instanced rendering? */\n    isInstanced?: boolean;\n    /** Number of \"rows\" in 'instance' buffers */\n    instanceCount?: number;\n    /** Number of \"rows\" in 'vertex' buffers */\n    vertexCount?: number;\n    /** Number of \"rows\" in index buffer */\n    indexCount?: number;\n    /** First vertex to draw from */\n    firstVertex?: number;\n    /** First index to draw from */\n    firstIndex?: number;\n    /** First instance to draw from */\n    firstInstance?: number;\n    baseVertex?: number;\n    /** Transform feedback. WebGL only. */\n    transformFeedback?: TransformFeedback;\n  }): boolean;\n\n  // DEPRECATED METHODS\n\n  /**\n   * Uniforms\n   * @deprecated Use uniforms buffers\n   * @note textures, samplers and uniform buffers should be set via `setBindings()`, these are not considered uniforms.\n   * @note In WebGL uniforms have a performance penalty, they are reset before each call to enable pipeline sharing.\n   */\n  setUniformsWebGL(uniforms: Record<string, UniformValue>): void {\n    throw new Error('Use uniform blocks');\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumberArray4, TypedArray} from '@math.gl/types';\nimport type {Device} from '../device';\nimport type {RenderPassParameters} from '../types/parameters';\n// import {Binding} from '../types/shader-layout';\nimport {Resource, ResourceProps} from './resource';\nimport {Framebuffer} from './framebuffer';\nimport {QuerySet} from './query-set';\n\n/**\n * Properties for a RenderPass instance is a required parameter to all draw calls.\n */\nexport type RenderPassProps = ResourceProps & {\n  /** Framebuffer specifies which textures to render into. Default gets framebuffer from canvas context. */\n  framebuffer?: Framebuffer | null;\n  /** Control viewport, scissor rect, blend constant and stencil ref */\n  parameters?: RenderPassParameters;\n\n  // TODO - API needs to be able to control multiple render targets\n\n  /** Clear value for color attachment, or false to preserve the previous value */\n  clearColor?: NumberArray4 | TypedArray | false;\n  /** Experimental: Clear color values for multiple color attachments. Must specify typed arrays. props.clearColor will be ignored. */\n  clearColors?: (TypedArray | false)[];\n  /** Clear value for depth attachment (true === `1`), or false to preserve the previous value. Must be between 0.0 (near) and 1.0 (far), inclusive. */\n  clearDepth?: number | false;\n  /** Clear value for stencil attachment (true === `0`), or false to preserve the previous value. Converted to the type and number of LSBs as the number of bits in the stencil aspect */\n  clearStencil?: number | false;\n\n  /** Indicates that the depth component is read only. */\n  depthReadOnly?: boolean;\n  /** Indicates that the stencil component is read only. */\n  stencilReadOnly?: boolean;\n\n  /** Whether to disable / discard the output of the rasterizer */\n  discard?: boolean;\n\n  /** QuerySet to write begin/end timestamps to */\n  occlusionQuerySet?: QuerySet;\n  /** QuerySet to write begin/end timestamps to */\n  timestampQuerySet?: QuerySet;\n  /** QuerySet index to write begin timestamp to. No timestamp is written if not provided. */\n  beginTimestampIndex?: number;\n  /** QuerySet index to write end timestamp to. No timestamp is written if not provided. */\n  endTimestampIndex?: number;\n};\n\n/**\n * A RenderPass instance is a required parameter to all draw calls.\n *\n * It holds a combination of\n * - render targets (specified via a framebuffer)\n * - clear colors, read/write, discard information for the framebuffer attachments\n * - a couple of mutable parameters ()\n */\nexport abstract class RenderPass extends Resource<RenderPassProps> {\n  /** TODO - should be [0, 0, 0, 0], update once deck.gl tests run clean */\n  static defaultClearColor: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth 1.0 represents the far plance */\n  static defaultClearDepth = 1;\n  /** Clears all stencil bits */\n  static defaultClearStencil = 0;\n\n  /** Default properties for RenderPass */\n  static override defaultProps: Required<RenderPassProps> = {\n    ...Resource.defaultProps,\n    framebuffer: null,\n    parameters: undefined!,\n    clearColor: RenderPass.defaultClearColor,\n    clearColors: undefined!,\n    clearDepth: RenderPass.defaultClearDepth,\n    clearStencil: RenderPass.defaultClearStencil,\n    depthReadOnly: false,\n    stencilReadOnly: false,\n    discard: false,\n\n    occlusionQuerySet: undefined!,\n    timestampQuerySet: undefined!,\n    beginTimestampIndex: undefined!,\n    endTimestampIndex: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'RenderPass';\n  }\n\n  constructor(device: Device, props: RenderPassProps) {\n    props = RenderPass.normalizeProps(device, props);\n    super(device, props, RenderPass.defaultProps);\n  }\n\n  /** Call when rendering is done in this pass. */\n  abstract end(): void;\n\n  /** A few parameters can be changed at any time (viewport, scissorRect, blendColor, stencilReference) */\n  abstract setParameters(parameters: RenderPassParameters): void;\n\n  // executeBundles(bundles: Iterable<GPURenderBundle>): void;\n\n  /** Being an occlusion query. Value will be stored in the occlusionQuerySet at the index. Occlusion queries cannot be nested. */\n  abstract beginOcclusionQuery(queryIndex: number): void;\n  /** End an occlusion query. Stores result in the index specified in beginOcclusionQuery. */\n  abstract endOcclusionQuery(): void;\n\n  /** Begins a labeled debug group containing subsequent commands */\n  abstract pushDebugGroup(groupLabel: string): void;\n  /** Ends the labeled debug group most recently started by pushDebugGroup() */\n  abstract popDebugGroup(): void;\n  /** Marks a point in a stream of commands with a label */\n  abstract insertDebugMarker(markerLabel: string): void;\n\n  protected static normalizeProps(device: Device, props: RenderPassProps): RenderPassProps {\n    // Intended to override e.g. set default clear values to true\n    const overriddenDefaultProps = device.props._resourceDefaults?.renderPass;\n    const newProps = {...overriddenDefaultProps, ...props};\n    return newProps;\n  }\n}\n\n// TODO - Can we align WebGL implementation with WebGPU API?\n// In WebGPU the following methods are on the renderpass instead of the renderpipeline\n// luma.gl keeps them on the pipeline for now, but that has some issues.\n\n// abstract setPipeline(pipeline: RenderPipeline): void {}\n// abstract setIndexBuffer()\n// abstract setVertexBuffer(slot: number, buffer: Buffer, offset: number): void;\n// abstract setBindings(bindings: Record<string, Binding>): void;\n// abstract setParameters(parameters: RenderPassParameters);\n// abstract draw(options: {\n// abstract drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): void;\n// abstract drawIndexedIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): void;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Resource, ResourceProps} from './resource';\nimport type {ComputeShaderLayout, Binding} from '../types/shader-layout';\nimport type {Device} from '../device';\nimport type {Shader} from './shader';\n\n/**\n * Properties for a compute pipeline\n */\nexport type ComputePipelineProps = ResourceProps & {\n  handle?: unknown;\n  /** Compiled shader object */\n  shader: Shader;\n  /** The entry point, defaults to main */\n  entryPoint?: string;\n  /** These are WGSL constant values - different from GLSL defines in that shader does not need to be recompiled */\n  constants?: Record<string, number>;\n  /** Describes the attributes and bindings exposed by the pipeline shader(s). */\n  shaderLayout?: ComputeShaderLayout | null;\n};\n\n/**\n * A compiled and linked shader program for compute\n */\nexport abstract class ComputePipeline extends Resource<ComputePipelineProps> {\n  static override defaultProps: Required<ComputePipelineProps> = {\n    ...Resource.defaultProps,\n    shader: undefined!,\n    entryPoint: undefined!,\n    constants: {},\n    shaderLayout: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'ComputePipeline';\n  }\n\n  hash: string = '';\n  /** The merged shader layout */\n  shaderLayout: ComputeShaderLayout;\n\n  constructor(device: Device, props: ComputePipelineProps) {\n    super(device, props, ComputePipeline.defaultProps);\n    this.shaderLayout = props.shaderLayout!;\n  }\n\n  /**\n   * @todo Use renderpass.setBindings() ?\n   * @todo Do we want to expose BindGroups in the API and remove this?\n   */\n  abstract setBindings(bindings: Record<string, Binding>): void;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Resource, ResourceProps} from './resource';\nimport {ComputePipeline} from './compute-pipeline';\nimport type {Device} from '../device';\nimport {Buffer} from './buffer';\nimport {QuerySet} from './query-set';\n\nexport type ComputePassProps = ResourceProps & {\n  /** QuerySet to write beging/end timestamps to */\n  timestampQuerySet?: QuerySet;\n  /** QuerySet index to write begin timestamp to. No timestamp is written if not provided. */\n  beginTimestampIndex?: number;\n  /** QuerySet index to write end timestamp to. No timestamp is written if not provided. */\n  endTimestampIndex?: number;\n};\n\nexport abstract class ComputePass extends Resource<ComputePassProps> {\n  static override defaultProps: Required<ComputePassProps> = {\n    ...Resource.defaultProps,\n    timestampQuerySet: undefined!,\n    beginTimestampIndex: undefined!,\n    endTimestampIndex: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'ComputePass';\n  }\n\n  constructor(device: Device, props: ComputePassProps) {\n    super(device, props, ComputePass.defaultProps);\n  }\n\n  abstract override destroy(): void;\n\n  abstract end(): void;\n\n  abstract setPipeline(pipeline: ComputePipeline): void;\n\n  /** Sets an array of bindings (uniform buffers, samplers, textures, ...) */\n  // abstract setBindings(bindings: Binding[]): void;\n\n  /**\n   * Dispatch work to be performed with the current ComputePipeline.\n   * @param x X dimension of the grid of workgroups to dispatch.\n   * @param y Y dimension of the grid of workgroups to dispatch.\n   * @param z Z dimension of the grid of workgroups to dispatch.\n   */\n  abstract dispatch(x: number, y?: number, z?: number): void;\n\n  /**\n   * Dispatch work to be performed with the current ComputePipeline.\n   * @param indirectBuffer buffer must be a tightly packed block of three 32-bit unsigned integer values (12 bytes total), given in the same order as the arguments for dispatch()\n   * @param indirectOffset\n   */\n  abstract dispatchIndirect(indirectBuffer: Buffer, indirectOffset?: number): void;\n\n  /** Begins a labeled debug group containing subsequent commands */\n  abstract pushDebugGroup(groupLabel: string): void;\n  /** Ends the labeled debug group most recently started by pushDebugGroup() */\n  abstract popDebugGroup(): void;\n  /** Marks a point in a stream of commands with a label */\n  abstract insertDebugMarker(markerLabel: string): void;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// import type {TypedArray} from '@math.gl/types';\nimport {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\nimport {Buffer} from './buffer';\nimport {Texture} from './texture';\nimport {QuerySet} from './query-set';\n\n// WEBGPU COMMAND ENCODER OPERATIONS\n\nexport type CopyBufferToBufferOptions = {\n  sourceBuffer: Buffer;\n  sourceOffset?: number;\n  destinationBuffer: Buffer;\n  destinationOffset?: number;\n  size: number;\n};\n\nexport type CopyBufferToTextureOptions = {\n  sourceBuffer: Buffer;\n  byteOffset?: number;\n  destinationTexture: Texture;\n  mipLevel?: number; //  = 0;\n  origin?: [number, number, number] | number[];\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n  bytesPerRow: number;\n  rowsPerImage: number;\n  size: [number, number, number] | number[];\n};\n\nexport type CopyTextureToBufferOptions = {\n  /** Texture to copy to/from. */\n  sourceTexture: Texture;\n  /**  Mip-map level of the texture to copy to/from. (Default 0) */\n  mipLevel?: number;\n  /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from.\n   * Together with `copySize`, defines the full copy sub-region.\n   */\n  /** Defines which aspects of the texture to copy to/from. */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n\n  /** Width to copy */\n  width?: number;\n  height?: number;\n  depthOrArrayLayers?: number;\n  origin?: number[];\n\n  /** Destination buffer */\n  destinationBuffer: Buffer;\n  /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */\n  byteOffset?: number;\n  /**\n   * The stride, in bytes, between the beginning of each block row and the subsequent block row.\n   * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).\n   */\n  bytesPerRow?: number;\n  /**\n   * Number of block rows per single image of the texture.\n   * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.\n   * Required if there are multiple images (i.e. the copy depth is more than one).\n   */\n  rowsPerImage?: number;\n};\n\nexport type CopyTextureToTextureOptions = {\n  /** Texture to copy to/from. */\n  sourceTexture: Texture;\n  /**  Mip-map level of the texture to copy to/from. (Default 0) */\n  mipLevel?: number;\n  /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */\n  origin?: number[];\n  /** Defines which aspects of the {@link GPUImageCopyTexture#texture} to copy to/from. */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n\n  /** Texture to copy to/from. */\n  destinationTexture: Texture;\n  /**  Mip-map level of the texture to copy to/from. (Default 0) */\n  destinationMipLevel?: number;\n  /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */\n  destinationOrigin?: number[];\n  /** Defines which aspects of the {@link GPUImageCopyTexture#texture} to copy to/from. */\n  destinationAspect?: 'all' | 'stencil-only' | 'depth-only';\n\n  /** Width to copy */\n  width?: number;\n  height?: number;\n  depthOrArrayLayers?: number;\n};\n\n// ADDITIONAL COMMAND ENCODER OPERATIONS DEFINED BY LUMA.GL\n\n/** Options for clearing a texture mip level */\nexport type ClearTextureOptions = {\n  /** Texture to Clear. */\n  texture: Texture;\n  /**  Mip-map level of the texture clear. (Default 0) */\n  mipLevel?: number;\n  /** Defines which aspects of the Texture to clear. */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n};\n\n// export type WriteBufferOptions = {\n//   buffer: Buffer;\n//   bufferOffset?: number;\n//   data: BufferSource;\n//   dataOffset?: number;\n//   size?: number;\n// };\n\n// export type WriteTextureOptions = {\n//   destination: Texture;\n//   mipLevel?: number; //  = 0;\n//   origin?: [number, number, number] | number[];\n//   aspect?: 'all' | 'stencil-only' | 'depth-only';\n//   data: BufferSource;\n//   // dataLayout;\n//   offset: number;\n//   bytesPerRow: number;\n//   rowsPerImage: number;\n//   size: [number, number, number] | number[];\n// };\n\nexport type CommandEncoderProps = ResourceProps & {\n  measureExecutionTime?: boolean;\n};\n\n/**\n * Encodes commands to queue that can be executed later\n */\nexport abstract class CommandEncoder extends Resource<CommandEncoderProps> {\n  static override defaultProps: Required<CommandEncoderProps> = {\n    ...Resource.defaultProps,\n    measureExecutionTime: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'CommandEncoder';\n  }\n\n  constructor(device: Device, props: CommandEncoderProps) {\n    super(device, props, CommandEncoder.defaultProps);\n  }\n\n  /** Completes recording of the commands sequence */\n  abstract finish(): void; // TODO - return the CommandBuffer?\n\n  /** Add a command that that copies data from a sub-region of a Buffer to a sub-region of another Buffer. */\n  abstract copyBufferToBuffer(options: CopyBufferToBufferOptions): void;\n\n  /** Add a command that copies data from a sub-region of a GPUBuffer to a sub-region of one or multiple continuous texture subresources. */\n  abstract copyBufferToTexture(options: CopyBufferToTextureOptions): void;\n\n  /** Add a command that copies data from a sub-region of one or multiple continuous texture subresources to a sub-region of a Buffer. */\n  abstract copyTextureToBuffer(options: CopyTextureToBufferOptions): void;\n\n  /** Add a command that copies data from a sub-region of one or multiple contiguous texture subresources to another sub-region of one or multiple continuous texture subresources. */\n  abstract copyTextureToTexture(options: CopyTextureToTextureOptions): void;\n\n  /** Add a command that clears a texture mip level. */\n  // abstract clearTexture(options: ClearTextureOptions): void;\n\n  // abstract readTexture(options: ReadTextureOptions): Promise<TypedArray>;\n\n  /** Reads results from a query set into a GPU buffer. Values are 64 bits so byteLength must be querySet.props.count * 8 */\n  abstract resolveQuerySet(\n    querySet: QuerySet,\n    destination: Buffer,\n    options?: {\n      firstQuery?: number;\n      queryCount?: number;\n      destinationOffset?: number;\n    }\n  ): void;\n\n  /** Begins a labeled debug group containing subsequent commands */\n  abstract pushDebugGroup(groupLabel: string): void;\n  /** Ends the labeled debug group most recently started by pushDebugGroup() */\n  abstract popDebugGroup(): void;\n  /** Marks a point in a stream of commands with a label */\n  abstract insertDebugMarker(markerLabel: string): void;\n\n  // TODO - luma.gl has these on the device, should we align with WebGPU API?\n  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;\n  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n\n// interface Queue {\n//   submit(commandBuffers);\n\n//   // onSubmittedWorkDone(): Promise<undefined>;\n\n//   writeBuffer(options: WriteBufferOptions): void;\n//   writeTexture(options: WriteTextureOptions): void;\n\n//   // copyExternalImageToTexture(\n//   //   GPUImageCopyExternalImage source,\n//   //   GPUImageCopyTextureTagged destination,\n//   //   GPUExtent3D copySize\n//   // ): void;\n// }\n\nexport type CommandBufferProps = ResourceProps & {};\n\n/**\n * Encodes commands to queue that can be executed later\n */\nexport abstract class CommandBuffer extends Resource<CommandBufferProps> {\n  static override defaultProps: Required<CommandBufferProps> = {\n    ...Resource.defaultProps\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'CommandBuffer';\n  }\n\n  constructor(device: Device, props: CommandBufferProps) {\n    super(device, props, CommandBuffer.defaultProps);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderDataType, ShaderAttributeType} from './shader-types';\nimport {VertexFormat, VertexType} from './vertex-formats';\n\n/** Information extracted from a ShaderAttributeInfo constant */\nexport type ShaderAttributeTypeInfo = {\n  /** WGSL-style primitive data type, f32, i32, u32 */\n  dataType: ShaderDataType;\n  /** Whether this is a normalized integer (that must be used as float) */\n  components: 1 | 2 | 3 | 4;\n  /** Length in bytes of the data for one vertex */\n  byteLength?: number;\n  /** Whether this is for integer or float vert */\n  integer: boolean;\n  /** Whether this data type is signed */\n  signed: boolean;\n  /** The simplest vertex format that matches the shader attribute's data type */\n  defaultVertexFormat: VertexFormat;\n};\n\n/** Decodes a vertex type, returning byte length and flags (integer, signed, normalized) */\nexport function decodeShaderAttributeType(\n  attributeType: ShaderAttributeType\n): ShaderAttributeTypeInfo {\n  const [dataType, components] = TYPE_INFO[attributeType];\n  const integer: boolean = dataType === 'i32' || dataType === 'u32';\n  const signed: boolean = dataType !== 'u32';\n\n  const byteLength = TYPE_SIZES[dataType] * components;\n  const defaultVertexFormat = getCompatibleVertexFormat(dataType, components);\n  return {\n    dataType,\n    components,\n    defaultVertexFormat,\n    byteLength,\n    integer,\n    signed\n  };\n}\n\n/** Get the \"default\" vertex format for a certain shader data type */\nfunction getCompatibleVertexFormat(\n  dataType: ShaderDataType,\n  components: 1 | 2 | 3 | 4\n): VertexFormat {\n  let vertexType: VertexType;\n  switch (dataType) {\n    case 'f32':\n      vertexType = 'float32';\n      break;\n    case 'i32':\n      vertexType = 'sint32';\n      break;\n    case 'u32':\n      vertexType = 'uint32';\n      break;\n    case 'f16':\n      return components <= 2 ? 'float16x2' : 'float16x4';\n  }\n  // TODO logic does not work for float16\n  if (components === 1) {\n    return vertexType;\n  }\n  return `${vertexType}x${components}`;\n}\n\n/** All valid shader attribute types. A table guarantees exhaustive list and fast execution */\nconst TYPE_INFO: Record<ShaderAttributeType, [ShaderDataType, 1 | 2 | 3 | 4]> = {\n  f32: ['f32', 1],\n  'vec2<f32>': ['f32', 2],\n  'vec3<f32>': ['f32', 3],\n  'vec4<f32>': ['f32', 4],\n  f16: ['f16', 1],\n  'vec2<f16>': ['f16', 2],\n  'vec3<f16>': ['f16', 3],\n  'vec4<f16>': ['f16', 4],\n  i32: ['i32', 1],\n  'vec2<i32>': ['i32', 2],\n  'vec3<i32>': ['i32', 3],\n  'vec4<i32>': ['i32', 4],\n  u32: ['u32', 1],\n  'vec2<u32>': ['u32', 2],\n  'vec3<u32>': ['u32', 3],\n  'vec4<u32>': ['u32', 4]\n};\n\nconst TYPE_SIZES: Record<ShaderDataType, number> = {\n  f32: 4,\n  f16: 2,\n  i32: 4,\n  u32: 4\n  // 'bool-webgl': 4,\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {VertexFormat, VertexType} from './vertex-formats';\nimport {decodeVertexType} from './decode-data-type';\n\nexport type VertexFormatInfo = {\n  /** Length in bytes */\n  byteLength: number;\n  /** Type of each component */\n  type: VertexType;\n  /** Number of components per vertex / row */\n  components: 1 | 2 | 3 | 4;\n  /** Is this an integer format (normalized integer formats are not integer) */\n  integer: boolean;\n  /** Is this a signed format? */\n  signed: boolean;\n  /** Is this a normalized format? */\n  normalized: boolean;\n  /** Is this a webgl only format? */\n  webglOnly?: boolean;\n};\n\n/**\n * Decodes a vertex format, returning type, components, byte  length and flags (integer, signed, normalized)\n */\nexport function decodeVertexFormat(format: VertexFormat): VertexFormatInfo {\n  // Strip the -webgl ending if present\n  let webglOnly: boolean | undefined;\n  if (format.endsWith('-webgl')) {\n    format.replace('-webgl', '');\n    webglOnly = true;\n  }\n  // split components from type\n  const [type_, count] = format.split('x');\n  const type = type_ as VertexType;\n  const components = (count ? parseInt(count) : 1) as 1 | 2 | 3 | 4;\n  // decode the type\n  const decodedType = decodeVertexType(type);\n  const result: VertexFormatInfo = {\n    type,\n    components,\n    byteLength: decodedType.byteLength * components,\n    integer: decodedType.integer,\n    signed: decodedType.signed,\n    normalized: decodedType.normalized\n  };\n  if (webglOnly) {\n    result.webglOnly = true;\n  }\n  return result;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log} from '../utils/log';\nimport type {ShaderLayout, AttributeDeclaration} from '../adapter/types/shader-layout';\nimport type {BufferLayout} from '../adapter/types/buffer-layout';\nimport type {ShaderDataType, ShaderAttributeType} from '../gpu-type-utils/shader-types';\nimport {decodeShaderAttributeType} from '../gpu-type-utils/decode-attribute-type';\nimport type {VertexFormat, VertexType} from '../gpu-type-utils/vertex-formats';\nimport {decodeVertexFormat} from '../gpu-type-utils/decode-vertex-format';\n\n/** Resolved info for a buffer / attribute combination to help backend configure it correctly */\nexport type AttributeInfo = {\n  /** Attribute name */\n  attributeName: string;\n  /** Location in shader */\n  location: number;\n  /** Type / precision used in shader (buffer values may be converted) */\n  shaderType: ShaderAttributeType;\n  /** Calculations are done in this type in the shader's attribute declaration */\n  shaderDataType: ShaderDataType;\n  /** Components refer to the number of components in the shader's attribute declaration */\n  shaderComponents: 1 | 2 | 3 | 4;\n  /** It is the shader attribute declaration that determines whether GPU will process as integer or float */\n  integer: boolean;\n\n  /** BufferName */\n  bufferName: string;\n  /** Format of buffer data */\n  vertexFormat: VertexFormat;\n  /** Memory data type refers to the data type in the buffer */\n  bufferDataType: VertexType;\n  /** Components refer to the number of components in the buffer's vertex format */\n  bufferComponents: 1 | 2 | 3 | 4;\n  /** Normalization is encoded in the buffer layout's vertex format... */\n  normalized: boolean;\n\n  /** If not specified, the step mode is inferred from the attribute name in the shader (contains string instance) */\n  stepMode: 'vertex' | 'instance';\n\n  /** The byteOffset is encoded in or calculated from the buffer layout */\n  byteOffset: number;\n  /** The byteStride is encoded in or calculated from the buffer layout */\n  byteStride: number;\n};\n\ntype BufferAttributeInfo = {\n  attributeName: string;\n  bufferName: string;\n  stepMode?: 'vertex' | 'instance';\n  vertexFormat: VertexFormat;\n  byteOffset: number;\n  byteStride: number;\n};\n\n/**\n * Map from \"attribute names\" to \"resolved attribute infos\"\n * containing information about both buffer layouts and shader attribute declarations\n */\nexport function getAttributeInfosFromLayouts(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[]\n): Record<string, AttributeInfo> {\n  const attributeInfos: Record<string, AttributeInfo> = {};\n  for (const attribute of shaderLayout.attributes) {\n    const attributeInfo = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);\n    if (attributeInfo) {\n      attributeInfos[attribute.name] = attributeInfo;\n    }\n  }\n  return attributeInfos;\n}\n\n/**\n * Array indexed by \"location\" holding \"resolved attribute infos\"\n */\nexport function getAttributeInfosByLocation(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[],\n  maxVertexAttributes: number = 16\n): AttributeInfo[] {\n  const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);\n  const locationInfos: AttributeInfo[] = new Array(maxVertexAttributes).fill(null);\n  for (const attributeInfo of Object.values(attributeInfos)) {\n    locationInfos[attributeInfo.location] = attributeInfo;\n  }\n  return locationInfos;\n}\n\n/**\n * Get the combined information from a shader layout and a buffer layout for a specific attribute\n */\nfunction getAttributeInfoFromLayouts(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[],\n  name: string\n): AttributeInfo | null {\n  const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name);\n  const bufferMapping: BufferAttributeInfo | null = getAttributeFromBufferLayout(\n    bufferLayout,\n    name\n  );\n\n  // TODO should no longer happen\n  if (!shaderDeclaration) {\n    //  || !bufferMapping\n    return null;\n  }\n\n  const attributeTypeInfo = decodeShaderAttributeType(shaderDeclaration.type);\n  const vertexFormat = bufferMapping?.vertexFormat || attributeTypeInfo.defaultVertexFormat;\n  const vertexFormatInfo = decodeVertexFormat(vertexFormat);\n\n  return {\n    attributeName: bufferMapping?.attributeName || shaderDeclaration.name,\n    bufferName: bufferMapping?.bufferName || shaderDeclaration.name,\n    location: shaderDeclaration.location,\n    shaderType: shaderDeclaration.type,\n    shaderDataType: attributeTypeInfo.dataType,\n    shaderComponents: attributeTypeInfo.components,\n    vertexFormat,\n    bufferDataType: vertexFormatInfo.type,\n    bufferComponents: vertexFormatInfo.components,\n    // normalized is a property of the buffer's vertex format\n    normalized: vertexFormatInfo.normalized,\n    // integer is a property of the shader declaration\n    integer: attributeTypeInfo.integer,\n    stepMode: bufferMapping?.stepMode || shaderDeclaration.stepMode || 'vertex',\n    byteOffset: bufferMapping?.byteOffset || 0,\n    byteStride: bufferMapping?.byteStride || 0\n  };\n}\n\nfunction getAttributeFromShaderLayout(\n  shaderLayout: ShaderLayout,\n  name: string\n): AttributeDeclaration | null {\n  const attribute = shaderLayout.attributes.find(attr => attr.name === name);\n  if (!attribute) {\n    log.warn(`shader layout attribute \"${name}\" not present in shader`);\n  }\n  return attribute || null;\n}\n\nfunction getAttributeFromBufferLayout(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  // Check that bufferLayouts are valid (each either has format or attribute)\n  checkBufferLayouts(bufferLayouts);\n\n  let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name);\n  if (bufferLayoutInfo) {\n    return bufferLayoutInfo;\n  }\n\n  bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name);\n  if (bufferLayoutInfo) {\n    return bufferLayoutInfo;\n  }\n\n  // Didn't find...\n  log.warn(`layout for attribute \"${name}\" not present in buffer layout`);\n  return null;\n}\n\n/** Check that bufferLayouts are valid (each either has format or attribute) */\nfunction checkBufferLayouts(bufferLayouts: BufferLayout[]) {\n  for (const bufferLayout of bufferLayouts) {\n    if (\n      (bufferLayout.attributes && bufferLayout.format) ||\n      (!bufferLayout.attributes && !bufferLayout.format)\n    ) {\n      log.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);\n    }\n  }\n}\n\n/** Get attribute from format shorthand if specified */\nfunction getAttributeFromShortHand(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  for (const bufferLayout of bufferLayouts) {\n    if (bufferLayout.format && bufferLayout.name === name) {\n      return {\n        attributeName: bufferLayout.name,\n        bufferName: name,\n        stepMode: bufferLayout.stepMode,\n        vertexFormat: bufferLayout.format,\n        // If offset is needed, use `attributes` field.\n        byteOffset: 0,\n        byteStride: bufferLayout.byteStride || 0\n      };\n    }\n  }\n  return null;\n}\n\n/**\n * Search attribute mappings (e.g. interleaved attributes) for buffer mapping.\n * Not the name of the buffer might be the same as one of the interleaved attributes.\n */\nfunction getAttributeFromAttributesList(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  for (const bufferLayout of bufferLayouts) {\n    let byteStride: number | undefined = bufferLayout.byteStride;\n\n    // Calculate a default byte stride if not provided\n    if (typeof bufferLayout.byteStride !== 'number') {\n      for (const attributeMapping of bufferLayout.attributes || []) {\n        const info = decodeVertexFormat(attributeMapping.format);\n        // @ts-ignore\n        byteStride += info.byteLength;\n      }\n    }\n\n    const attributeMapping = bufferLayout.attributes?.find(mapping => mapping.attribute === name);\n    if (attributeMapping) {\n      return {\n        attributeName: attributeMapping.attribute,\n        bufferName: bufferLayout.name,\n        stepMode: bufferLayout.stepMode,\n        vertexFormat: attributeMapping.format,\n        byteOffset: attributeMapping.byteOffset,\n        // @ts-ignore\n        byteStride\n      };\n    }\n  }\n\n  return null;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TypedArray} from '../../types';\nimport {\n  AttributeInfo,\n  getAttributeInfosByLocation\n} from '../../adapter-utils/get-attribute-from-layouts';\nimport type {Device} from '../device';\nimport type {Buffer} from './buffer';\nimport type {RenderPass} from './render-pass';\nimport type {RenderPipeline} from './render-pipeline';\nimport {Resource, ResourceProps} from './resource';\n\n/** Properties for initializing a VertexArray */\nexport type VertexArrayProps = ResourceProps & {\n  renderPipeline: RenderPipeline | null;\n};\n\n/**\n * Stores attribute bindings.\n * Makes it easy to share a render pipeline and use separate vertex arrays.\n * @note On WebGL, VertexArray allows non-constant bindings to be performed in advance\n * reducing the number of WebGL calls per draw call.\n * @note On WebGPU this is just a convenience class that collects the bindings.\n */\nexport abstract class VertexArray extends Resource<VertexArrayProps> {\n  static override defaultProps: Required<VertexArrayProps> = {\n    ...Resource.defaultProps,\n    renderPipeline: null\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'VertexArray';\n  }\n\n  /** Max number of vertex attributes */\n  readonly maxVertexAttributes: number;\n  /** Attribute infos indexed by location - TODO only needed by webgl module? */\n  protected readonly attributeInfos: AttributeInfo[];\n\n  /** Index buffer */\n  indexBuffer: Buffer | null = null;\n  /** Attributes indexed by buffer slot */\n  attributes: (Buffer | TypedArray | null)[];\n\n  constructor(device: Device, props: VertexArrayProps) {\n    super(device, props, VertexArray.defaultProps);\n    this.maxVertexAttributes = device.limits.maxVertexAttributes;\n    this.attributes = new Array(this.maxVertexAttributes).fill(null);\n    const {shaderLayout, bufferLayout} = props.renderPipeline || {};\n    if (!shaderLayout || !bufferLayout) {\n      throw new Error('VertexArray');\n    }\n    this.attributeInfos = getAttributeInfosByLocation(\n      shaderLayout,\n      bufferLayout,\n      this.maxVertexAttributes\n    );\n  }\n\n  /** Set attributes (stored on pipeline and set before each call) */\n  abstract setIndexBuffer(indices: Buffer | null): void;\n  /** Set attributes (stored on pipeline and set before each call) */\n  abstract setBuffer(bufferSlot: number, buffer: Buffer | null): void;\n\n  abstract bindBeforeRender(renderPass: RenderPass): void;\n  abstract unbindAfterRender(renderPass: RenderPass): void;\n\n  // DEPRECATED METHODS\n\n  /** @deprecated Set constant attributes (WebGL only) */\n  setConstantWebGL(location: number, value: TypedArray | null): void {\n    this.device.reportError(new Error('constant attributes not supported'));\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {PrimitiveTopology} from '../types/parameters';\nimport {ShaderLayout} from '../types/shader-layout';\nimport type {Buffer} from './buffer';\nimport {Resource, ResourceProps} from './resource';\n\n/** For bindRange */\nexport type BufferRange = {\n  buffer: Buffer;\n  byteOffset?: number;\n  byteLength?: number;\n};\n\n/** Configures a set of output buffers for pipeline (WebGL only) */\nexport type TransformFeedbackProps = ResourceProps & {\n  /** Layout of shader (for varyings) */\n  layout: ShaderLayout;\n  /** Buffer bindings (for varyings) */\n  buffers: Record<string, Buffer | BufferRange>;\n};\n\n/** Holds a set of output buffers for pipeline (WebGL only) */\nexport abstract class TransformFeedback extends Resource<TransformFeedbackProps> {\n  static override defaultProps: Required<TransformFeedbackProps> = {\n    ...Resource.defaultProps,\n    layout: undefined!,\n    buffers: {}\n  };\n\n  get [Symbol.toStringTag](): string {\n    return 'TransformFeedback';\n  }\n\n  constructor(device: Device, props: TransformFeedbackProps) {\n    super(device, props, TransformFeedback.defaultProps);\n  }\n\n  abstract begin(topology?: PrimitiveTopology): void;\n  abstract end(): void;\n\n  abstract setBuffers(buffers: Record<string, Buffer | BufferRange>): void;\n  abstract setBuffer(locationOrName: string | number, bufferOrRange: Buffer | BufferRange): void;\n  abstract getBuffer(locationOrName: string | number): Buffer | BufferRange | null;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n\n/**\n * Properties for creating a QuerySet\n * - 'timestamp' - query the GPU timestamp counter at the start and end of render passes\n *   timestamp queries are available if the 'timestamp-query' feature is present.\n * - 'occlusion' - query the number of fragment samples that pass all per-fragment tests for a set of drawing commands\n *   including scissor, sample mask, alpha to coverage, stencil, and depth tests\n */\nexport type QuerySetProps = ResourceProps & {\n  /**\n   * The type of query set\n   * occlusion - query the number of fragment samples that pass all the per-fragment tests for a set of drawing commands, including scissor, sample mask, alpha to coverage, stencil, and depth tests\n   * timestamp - query the GPU timestamp counter at the start and end of render passes\n   */\n  type: 'occlusion' | 'timestamp';\n  /** The number of queries managed by the query set */\n  count: number;\n};\n\n/** Immutable QuerySet object */\nexport abstract class QuerySet extends Resource<QuerySetProps> {\n  static override defaultProps: Required<QuerySetProps> = {\n    ...Resource.defaultProps,\n    type: undefined!,\n    count: undefined!\n  };\n\n  get [Symbol.toStringTag](): string {\n    return 'QuerySet';\n  }\n\n  constructor(device: Device, props: QuerySetProps) {\n    super(device, props, QuerySet.defaultProps);\n  }\n}\n", "import {Device} from '../device';\nimport {ShaderLayout} from '../types/shader-layout';\nimport {Resource, ResourceProps} from './resource';\n\nexport type PipelineLayoutProps = ResourceProps & {\n  shaderLayout: ShaderLayout;\n};\n\n/** Immutable PipelineLayout object */\nexport abstract class PipelineLayout extends Resource<PipelineLayoutProps> {\n  get [Symbol.toStringTag](): string {\n    return 'PipelineLayout';\n  }\n\n  constructor(device: Device, props: PipelineLayoutProps) {\n    super(device, props, PipelineLayout.defaultProps);\n  }\n\n  static override defaultProps: Required<PipelineLayoutProps> = {\n    ...Resource.defaultProps,\n    shaderLayout: {\n      attributes: [],\n      bindings: []\n    }\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderUniformType, ShaderDataType} from './shader-types';\n\nconst UNIFORM_FORMATS: Record<ShaderUniformType, {type: ShaderDataType; components: number}> = {\n  f32: {type: 'f32', components: 1},\n  i32: {type: 'i32', components: 1},\n  u32: {type: 'u32', components: 1},\n  // 'bool-webgl': {type: 'bool-webgl', components: 1},\n  'vec2<f32>': {type: 'f32', components: 2},\n  'vec3<f32>': {type: 'f32', components: 3},\n  'vec4<f32>': {type: 'f32', components: 4},\n  'vec2<i32>': {type: 'i32', components: 2},\n  'vec3<i32>': {type: 'i32', components: 3},\n  'vec4<i32>': {type: 'i32', components: 4},\n  'vec2<u32>': {type: 'u32', components: 2},\n  'vec3<u32>': {type: 'u32', components: 3},\n  'vec4<u32>': {type: 'u32', components: 4},\n  'mat2x2<f32>': {type: 'f32', components: 4},\n  'mat2x3<f32>': {type: 'f32', components: 6},\n  'mat2x4<f32>': {type: 'f32', components: 8},\n  'mat3x2<f32>': {type: 'f32', components: 6},\n  'mat3x3<f32>': {type: 'f32', components: 9},\n  'mat3x4<f32>': {type: 'f32', components: 12},\n  'mat4x2<f32>': {type: 'f32', components: 8},\n  'mat4x3<f32>': {type: 'f32', components: 12},\n  'mat4x4<f32>': {type: 'f32', components: 16}\n};\n\n/** Split a uniform type string into type and components */\nexport function decodeShaderUniformType(format: ShaderUniformType): {\n  type: ShaderDataType;\n  components: number;\n} {\n  const decoded = UNIFORM_FORMATS[format];\n  return decoded;\n}\n\n/** Align offset to 1, 2 or 4 elements (4, 8 or 16 bytes) */\nexport function alignTo(size: number, count: number): number {\n  // prettier-ignore\n  switch (count) {\n    case 1: return size; // Pad upwards to even multiple of 2\n    case 2: return size + (size % 2); // Pad upwards to even multiple of 2\n    default: return size + ((4 - (size % 4)) % 4); // Pad upwards to even multiple of 4\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TypedArray} from '../types';\n\nlet arrayBuffer: ArrayBuffer;\n\nexport function getScratchArrayBuffer(byteLength: number): ArrayBuffer {\n  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {\n    arrayBuffer = new ArrayBuffer(byteLength);\n  }\n  return arrayBuffer;\n}\n\nexport function getScratchArray(Type: any, length: number): TypedArray {\n  const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);\n  return new Type(scratchArrayBuffer, 0, length); // arrayBuffer, byteOffset, length (in elements)\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TypedArray, NumberArray} from '../types';\n\n/**\n * Check is an array is a typed array\n * @param value value to be tested\n * @returns input as TypedArray, or null\n * @todo this should be provided by @math.gl/types\n */\nexport function isTypedArray(value: unknown): value is TypedArray {\n  return ArrayBuffer.isView(value) && !(value instanceof DataView);\n}\n\n/**\n * Check is an array is a numeric array (typed array or array of numbers)\n * @param value value to be tested\n * @returns input as NumberArray, or null\n * @todo this should be provided by @math.gl/types\n */\nexport function isNumberArray(value: unknown): value is NumberArray {\n  if (Array.isArray(value)) {\n    return value.length === 0 || typeof value[0] === 'number';\n  }\n  return isTypedArray(value);\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderUniformType, ShaderDataType} from '../gpu-type-utils/shader-types';\nimport {decodeShaderUniformType, alignTo} from '../gpu-type-utils/decode-shader-types';\n\nimport type {UniformValue} from '../adapter/types/uniforms';\nimport {getScratchArrayBuffer} from '../utils/array-utils-flat';\nimport {isNumberArray} from '../utils/is-array';\nimport {log} from '../utils/log';\n\n/**\n * Smallest buffer size that can be used for uniform buffers.\n * TODO - does this depend on device?\n */\nconst minBufferSize: number = 1024;\n\n/**\n * Std140 layout for uniform buffers\n * Supports manual listing of uniforms\n */\nexport class UniformBufferLayout {\n  readonly layout: Record<string, {offset: number; size: number; type: ShaderDataType}> = {};\n\n  /** number of bytes needed for buffer allocation */\n  readonly byteLength: number;\n\n  /** Create a new UniformBufferLayout given a map of attributes. */\n  constructor(uniformTypes: Record<string, ShaderUniformType>) {\n    /** number of 4 byte slots taken */\n    let size: number = 0;\n\n    // Add layout (type, size and offset) definitions for each uniform in the layout\n    for (const [key, uniformType] of Object.entries(uniformTypes)) {\n      const typeAndComponents = decodeShaderUniformType(uniformType);\n      const {type, components: count} = typeAndComponents;\n      // First, align (bump) current offset to an even multiple of current object (1, 2, 4)\n      size = alignTo(size, count);\n      // Use the aligned size as the offset of the current uniform.\n      const offset = size;\n      // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset\n      size += count;\n      this.layout[key] = {type, size: count, offset};\n    }\n    size += (4 - (size % 4)) % 4;\n\n    const actualByteLength = size * 4;\n    this.byteLength = Math.max(actualByteLength, minBufferSize);\n  }\n\n  /** Get the data for the complete buffer */\n  getData(uniformValues: Record<string, UniformValue>): Uint8Array {\n    const bufferSize = Math.max(this.byteLength, minBufferSize);\n\n    // Allocate three typed arrays pointing at same memory\n    const arrayBuffer = getScratchArrayBuffer(bufferSize);\n    const typedArrays = {\n      i32: new Int32Array(arrayBuffer),\n      u32: new Uint32Array(arrayBuffer),\n      f32: new Float32Array(arrayBuffer),\n      // TODO not implemented\n      f16: new Uint16Array(arrayBuffer)\n    };\n    // TODO is this needed?\n    // typedArrays.i32.fill(0);\n\n    for (const [name, value] of Object.entries(uniformValues)) {\n      const uniformLayout = this.layout[name];\n      if (!uniformLayout) {\n        log.warn(`Supplied uniform value ${name} not present in uniform block layout`)();\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      const {type, size, offset} = uniformLayout;\n      const typedArray = typedArrays[type];\n      if (size === 1) {\n        if (typeof value !== 'number' && typeof value !== 'boolean') {\n          log.warn(\n            `Supplied value for single component uniform ${name} is not a number: ${value}`\n          )();\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // single value -> just set it\n        typedArray[offset] = Number(value);\n      } else {\n        if (!isNumberArray(value)) {\n          log.warn(\n            `Supplied value for multi component / array uniform ${name} is not a numeric array: ${value}`\n          )();\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // vector/matrix -> copy the supplied (typed) array, starting from offset\n        // TODO: we should limit or check size in case the supplied data overflows\n        typedArray.set(value, offset);\n      }\n    }\n\n    return new Uint8Array(arrayBuffer);\n  }\n\n  /** Does this layout have a field with specified name */\n  has(name: string) {\n    return Boolean(this.layout[name]);\n  }\n\n  /** Get offset and size for a field with specified name */\n  get(name: string): {offset: number; size: number} | undefined {\n    const layout = this.layout[name];\n    return layout;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {isNumberArray} from './is-array';\n\n/** Test if two arrays are deep equal, with a length limit that defaults to 16 */\nexport function arrayEqual(a: unknown, b: unknown, limit: number = 16) {\n  if (a !== b) {\n    return false;\n  }\n  const arrayA = a;\n  const arrayB = b;\n  if (!isNumberArray(arrayA)) {\n    return false;\n  }\n  if (isNumberArray(arrayB) && arrayA.length === arrayB.length) {\n    for (let i = 0; i < arrayA.length; ++i) {\n      if (arrayB[i] !== arrayA[i]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/** Copy a value */\nexport function arrayCopy<T>(a: T): T {\n  if (isNumberArray(a)) {\n    return a.slice() as T;\n  }\n  return a;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderUniformType} from '../gpu-type-utils/shader-types';\nimport type {UniformValue} from '../adapter/types/uniforms';\nimport {\n  ShaderLayout,\n  UniformInfo,\n  UniformBufferBindingLayout\n} from '../adapter/types/shader-layout';\nimport {arrayEqual, arrayCopy} from '../utils/array-equal';\n\n/**\n * A uniform block holds values of the of uniform values for one uniform block / buffer.\n * It also does some book keeping on what has changed, to minimize unnecessary writes to uniform buffers.\n */\nexport class UniformBlock<\n  TUniforms extends Record<string, UniformValue> = Record<string, UniformValue>\n> {\n  name: string;\n\n  uniforms: Record<keyof TUniforms, UniformValue> = {} as Record<keyof TUniforms, UniformValue>;\n  modifiedUniforms: Record<keyof TUniforms, boolean> = {} as Record<keyof TUniforms, boolean>;\n  modified: boolean = true;\n\n  readonly bindingLayout: Record<string, UniformInfo> = {};\n  needsRedraw: string | false = 'initialized';\n\n  constructor(props?: {\n    name?: string;\n    shaderLayout?: ShaderLayout;\n    uniformTypes?: Record<keyof TUniforms, Record<string, ShaderUniformType>>;\n  }) {\n    this.name = props?.name || 'unnamed';\n\n    // TODO - Extract uniform layout from the shaderLayout object\n    if (props?.name && props?.shaderLayout) {\n      const binding = props?.shaderLayout.bindings?.find(\n        binding_ => binding_.type === 'uniform' && binding_.name === props?.name\n      );\n      if (!binding) {\n        throw new Error(props?.name);\n      }\n\n      const uniformBlock = binding as UniformBufferBindingLayout;\n      for (const uniform of uniformBlock.uniforms || []) {\n        this.bindingLayout[uniform.name] = uniform;\n      }\n    }\n  }\n\n  /** Set a map of uniforms */\n  setUniforms(uniforms: Partial<TUniforms>): void {\n    for (const [key, value] of Object.entries(uniforms)) {\n      this._setUniform(key, value);\n      if (!this.needsRedraw) {\n        this.setNeedsRedraw(`${this.name}.${key}=${value}`);\n      }\n    }\n  }\n\n  setNeedsRedraw(reason: string): void {\n    this.needsRedraw = this.needsRedraw || reason;\n  }\n\n  /** Returns all uniforms */\n  getAllUniforms(): Record<string, UniformValue> {\n    // @ts-expect-error\n    this.modifiedUniforms = {};\n    this.needsRedraw = false;\n    return (this.uniforms || {}) as Record<string, UniformValue>;\n  }\n\n  /** Set a single uniform */\n  private _setUniform(key: keyof TUniforms, value: UniformValue) {\n    if (arrayEqual(this.uniforms[key], value)) {\n      return;\n    }\n    this.uniforms[key] = arrayCopy(value);\n    this.modifiedUniforms[key] = true;\n    this.modified = true;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderUniformType} from '../gpu-type-utils/shader-types';\nimport type {UniformValue} from '../adapter/types/uniforms';\nimport type {Device} from '../adapter/device';\nimport {Buffer} from '../adapter/resources/buffer';\nimport {log} from '../utils/log';\nimport {UniformBlock} from './uniform-block';\nimport {UniformBufferLayout} from './uniform-buffer-layout';\n\n/**\n * A uniform store holds a uniform values for one or more uniform blocks,\n * - It can generate binary data for any uniform buffer\n * - It can manage a uniform buffer for each block\n * - It can update managed uniform buffers with a single call\n * - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.\n */\nexport class UniformStore<\n  TPropGroups extends Record<string, Record<string, unknown>> = Record<\n    string,\n    Record<string, unknown>\n  >\n> {\n  /** Stores the uniform values for each uniform block */\n  uniformBlocks = new Map<keyof TPropGroups, UniformBlock>();\n  /** Can generate data for a uniform buffer for each block from data */\n  uniformBufferLayouts = new Map<keyof TPropGroups, UniformBufferLayout>();\n  /** Actual buffer for the blocks */\n  uniformBuffers = new Map<keyof TPropGroups, Buffer>();\n\n  /**\n   * Create a new UniformStore instance\n   * @param blocks\n   */\n  constructor(\n    blocks: Record<\n      keyof TPropGroups,\n      {\n        uniformTypes?: Record<string, ShaderUniformType>;\n        defaultProps?: Record<string, unknown>;\n        defaultUniforms?: Record<string, UniformValue>;\n      }\n    >\n  ) {\n    for (const [bufferName, block] of Object.entries(blocks)) {\n      const uniformBufferName = bufferName as keyof TPropGroups;\n\n      // Create a layout object to help us generate correctly formatted binary uniform buffers\n      const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes || {});\n      this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);\n\n      // Create a Uniform block to store the uniforms for each buffer.\n      const uniformBlock = new UniformBlock({name: bufferName});\n      uniformBlock.setUniforms(block.defaultUniforms || {});\n      this.uniformBlocks.set(uniformBufferName, uniformBlock);\n    }\n  }\n\n  /** Destroy any managed uniform buffers */\n  destroy(): void {\n    for (const uniformBuffer of this.uniformBuffers.values()) {\n      uniformBuffer.destroy();\n    }\n  }\n\n  /**\n   * Set uniforms\n   * Makes all properties partial\n   */\n  setUniforms(\n    uniforms: Partial<{[group in keyof TPropGroups]: Partial<TPropGroups[group]>}>\n  ): void {\n    for (const [blockName, uniformValues] of Object.entries(uniforms)) {\n      this.uniformBlocks.get(blockName)?.setUniforms(uniformValues);\n      // We leverage logging in updateUniformBuffers(), even though slightly less efficient\n      // this.updateUniformBuffer(blockName);\n    }\n\n    this.updateUniformBuffers();\n  }\n\n  /** Get the required minimum length of the uniform buffer */\n  getUniformBufferByteLength(uniformBufferName: keyof TPropGroups): number {\n    return this.uniformBufferLayouts.get(uniformBufferName)?.byteLength || 0;\n  }\n\n  /** Get formatted binary memory that can be uploaded to a buffer */\n  getUniformBufferData(uniformBufferName: keyof TPropGroups): Uint8Array {\n    const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms() || {};\n    // @ts-ignore\n    return this.uniformBufferLayouts.get(uniformBufferName)?.getData(uniformValues);\n  }\n\n  /**\n   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)\n   * The new buffer is initialized with current / supplied values\n   */\n  createUniformBuffer(\n    device: Device,\n    uniformBufferName: keyof TPropGroups,\n    uniforms?: Partial<{[group in keyof TPropGroups]: Partial<TPropGroups[group]>}>\n  ): Buffer {\n    if (uniforms) {\n      this.setUniforms(uniforms);\n    }\n    const byteLength = this.getUniformBufferByteLength(uniformBufferName);\n    const uniformBuffer = device.createBuffer({\n      usage: Buffer.UNIFORM | Buffer.COPY_DST,\n      byteLength\n    });\n    // Note that this clears the needs redraw flag\n    const uniformBufferData = this.getUniformBufferData(uniformBufferName);\n    uniformBuffer.write(uniformBufferData);\n    return uniformBuffer;\n  }\n\n  /** Get the managed uniform buffer. \"managed\" resources are destroyed when the uniformStore is destroyed. */\n  getManagedUniformBuffer(device: Device, uniformBufferName: keyof TPropGroups): Buffer {\n    if (!this.uniformBuffers.get(uniformBufferName)) {\n      const byteLength = this.getUniformBufferByteLength(uniformBufferName);\n      const uniformBuffer = device.createBuffer({\n        usage: Buffer.UNIFORM | Buffer.COPY_DST,\n        byteLength\n      });\n      this.uniformBuffers.set(uniformBufferName, uniformBuffer);\n    }\n    // this.updateUniformBuffers();\n    // @ts-ignore\n    return this.uniformBuffers.get(uniformBufferName);\n  }\n\n  /** Updates all uniform buffers where values have changed */\n  updateUniformBuffers(): false | string {\n    let reason: false | string = false;\n    for (const uniformBufferName of this.uniformBlocks.keys()) {\n      const bufferReason = this.updateUniformBuffer(uniformBufferName);\n      reason ||= bufferReason;\n    }\n    if (reason) {\n      log.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();\n    }\n    return reason;\n  }\n\n  /** Update one uniform buffer. Only updates if values have changed */\n  updateUniformBuffer(uniformBufferName: keyof TPropGroups): false | string {\n    const uniformBlock = this.uniformBlocks.get(uniformBufferName);\n    let uniformBuffer = this.uniformBuffers.get(uniformBufferName);\n\n    let reason: false | string = false;\n    if (uniformBuffer && uniformBlock?.needsRedraw) {\n      reason ||= uniformBlock.needsRedraw;\n      // This clears the needs redraw flag\n      const uniformBufferData = this.getUniformBufferData(uniformBufferName);\n\n      uniformBuffer = this.uniformBuffers.get(uniformBufferName);\n      uniformBuffer?.write(uniformBufferData);\n\n      // logging - TODO - don't query the values unnecessarily\n      const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms();\n      log.log(\n        4,\n        `Writing to uniform buffer ${String(uniformBufferName)}`,\n        uniformBufferData,\n        uniformValues\n      )();\n    }\n    return reason;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TypedArray, TypedArrayConstructor} from '../types';\nimport {VertexFormat} from './vertex-formats';\n\n// import {DataType} from '../types/vertex-formats';\n// type Omit<DataType, 'float16'> unfortunately breaks Typescript inferance\ntype DataType = 'uint8' | 'sint8' | 'uint16' | 'sint16' | 'uint32' | 'sint32' | 'float32';\ntype DataTypeNorm = 'unorm8' | 'snorm8' | 'unorm16' | 'snorm16';\n\nexport function getDataTypeFromTypedArray(\n  arrayOrType: TypedArray | TypedArrayConstructor\n): DataType {\n  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n  switch (type) {\n    case Float32Array:\n      return 'float32';\n    case Uint16Array:\n      return 'uint16';\n    case Uint32Array:\n      return 'uint32';\n    case Uint8Array:\n    case Uint8ClampedArray:\n      return 'uint8';\n    case Int8Array:\n      return 'sint8';\n    case Int16Array:\n      return 'sint16';\n    case Int32Array:\n      return 'sint32';\n    default:\n      // Failed to deduce data type from typed array\n      throw new Error(type.constructor.name);\n  }\n}\n\nexport function getTypedArrayFromDataType(\n  dataType: DataType | DataTypeNorm\n): TypedArrayConstructor {\n  switch (dataType) {\n    case 'float32':\n      return Float32Array;\n    case 'uint32':\n      return Uint32Array;\n    case 'sint32':\n      return Int32Array;\n    case 'uint16':\n    case 'unorm16':\n      return Uint16Array;\n    case 'sint16':\n    case 'snorm16':\n      return Int16Array;\n    case 'uint8':\n    case 'unorm8':\n      return Uint8Array;\n    case 'sint8':\n    case 'snorm8':\n      return Int8Array;\n    default:\n      // Failed to deduce typed array from data type\n      throw new Error(dataType);\n  }\n}\n\n/** Get the vertex format for an attribute with TypedArray and size */\nexport function getVertexFormatFromAttribute(\n  typedArray: TypedArray,\n  size: number,\n  normalized?: boolean\n): VertexFormat {\n  if (!size || size > 4) {\n    throw new Error(`size ${size}`);\n  }\n\n  const components = size as 1 | 2 | 3 | 4;\n  let dataType: DataType | DataTypeNorm = getDataTypeFromTypedArray(typedArray);\n\n  // TODO - Special cases for WebGL (not supported on WebGPU), overrides the check below\n  if (dataType === 'uint8' && normalized && components === 1) {\n    return 'unorm8-webgl';\n  }\n  if (dataType === 'uint8' && normalized && components === 3) {\n    return 'unorm8x3-webgl';\n  }\n\n  if (dataType === 'uint8' || dataType === 'sint8') {\n    if (components === 1 || components === 3) {\n      // WebGPU 8 bit formats must be aligned to 16 bit boundaries');\n      throw new Error(`size: ${size}`);\n    }\n    if (normalized) {\n      dataType = dataType.replace('int', 'norm') as 'unorm8' | 'snorm8';\n    }\n    return `${dataType}x${components}`;\n  }\n  if (dataType === 'uint16' || dataType === 'sint16') {\n    if (components === 1 || components === 3) {\n      // WebGPU 16 bit formats must be aligned to 32 bit boundaries\n      throw new Error(`size: ${size}`);\n    }\n    if (normalized) {\n      dataType = dataType.replace('int', 'norm') as 'unorm16' | 'snorm16';\n    }\n    return `${dataType}x${components}`;\n  }\n\n  if (components === 1) {\n    return dataType;\n  }\n\n  return `${dataType}x${components}`;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {BufferLayout} from '../adapter/types/buffer-layout';\nimport {log} from '../utils/log';\n\n/** BufferLayoutHelper is a helper class that should not be used directly by applications */\nexport class BufferLayoutHelper {\n  bufferLayouts: BufferLayout[];\n\n  constructor(bufferLayouts: BufferLayout[]) {\n    this.bufferLayouts = bufferLayouts;\n  }\n\n  getBufferLayout(name: string): BufferLayout | null {\n    return this.bufferLayouts.find(layout => layout.name === name) || null;\n  }\n\n  /** Get attribute names from a BufferLayout */\n  getAttributeNamesForBuffer(bufferLayout: BufferLayout): string[] {\n    return bufferLayout.attributes\n      ? bufferLayout.attributes?.map(layout => layout.attribute)\n      : [bufferLayout.name];\n  }\n\n  mergeBufferLayouts(\n    bufferLayouts1: BufferLayout[],\n    bufferLayouts2: BufferLayout[]\n  ): BufferLayout[] {\n    const mergedLayouts = [...bufferLayouts1];\n    for (const attribute of bufferLayouts2) {\n      const index = mergedLayouts.findIndex(attribute2 => attribute2.name === attribute.name);\n      if (index < 0) {\n        mergedLayouts.push(attribute);\n      } else {\n        mergedLayouts[index] = attribute;\n      }\n    }\n    return mergedLayouts;\n  }\n\n  getBufferIndex(bufferName: string): number {\n    const bufferIndex = this.bufferLayouts.findIndex(layout => layout.name === bufferName);\n\n    if (bufferIndex === -1) {\n      log.warn(`BufferLayout: Missing buffer for \"${bufferName}\".`)();\n    }\n\n    return bufferIndex;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {BufferLayout} from '../adapter/types/buffer-layout';\nimport {ShaderLayout} from '../adapter/types/shader-layout';\n\nexport function sortedBufferLayoutByShaderSourceLocations(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[]\n): BufferLayout[] {\n  const shaderLayoutMap = Object.fromEntries(\n    shaderLayout.attributes.map(attr => [attr.name, attr.location])\n  );\n\n  const sortedLayout = bufferLayout.slice();\n  sortedLayout.sort((a, b) => {\n    const attributeNamesA = a.attributes ? a.attributes.map(attr => attr.attribute) : [a.name];\n    const attributeNamesB = b.attributes ? b.attributes.map(attr => attr.attribute) : [b.name];\n    const minLocationA = Math.min(...attributeNamesA.map(name => shaderLayoutMap[name]));\n    const minLocationB = Math.min(...attributeNamesB.map(name => shaderLayoutMap[name]));\n\n    return minLocationA - minLocationB;\n  });\n\n  return sortedLayout;\n}\n"],
  "mappings": "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",
  "names": ["Buffer", "name", "name", "arrayBuffer", "Buffer", "Buffer", "import_env", "log", "attachment", "TYPE_SIZES", "name", "attributeMapping", "arrayBuffer", "name", "Buffer", "name", "name"]
}
