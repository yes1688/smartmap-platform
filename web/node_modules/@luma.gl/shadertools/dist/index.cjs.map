{
  "version": 3,
  "sources": ["../src/index.ts", "../src/lib/utils/assert.ts", "../src/lib/filters/prop-types.ts", "../src/module-injectors.ts", "../src/lib/shader-assembly/shader-injections.ts", "../src/lib/shader-module/shader-module.ts", "../src/lib/shader-module/shader-module-dependencies.ts", "../src/lib/shader-assembly/platform-defines.ts", "../src/lib/shader-transpiler/transpile-glsl-shader.ts", "../src/lib/shader-assembly/shader-hooks.ts", "../src/lib/glsl-utils/get-shader-info.ts", "../src/lib/shader-assembly/assemble-shaders.ts", "../src/lib/preprocessor/preprocessor.ts", "../src/lib/shader-assembler.ts", "../src/lib/glsl-utils/shader-utils.ts", "../src/lib/shader-generator/utils/capitalize.ts", "../src/lib/shader-generator/glsl/generate-glsl.ts", "../src/lib/shader-generator/wgsl/generate-wgsl.ts", "../src/lib/shader-generator/generate-shader.ts", "../src/lib/wgsl/get-shader-layout-wgsl.ts", "../src/modules/math/fp16/fp16-utils.ts", "../src/modules/math/fp64/fp64-utils.ts", "../src/modules/math/random/random.ts", "../src/modules/math/fp32/fp32.ts", "../src/modules/math/fp64/fp64-arithmetic-glsl.ts", "../src/modules/math/fp64/fp64-functions-glsl.ts", "../src/modules/math/fp64/fp64.ts", "../src/modules/engine/picking/picking.ts", "../src/modules/lighting/lights/lighting.ts", "../src/modules/lighting/lights/lighting-uniforms-glsl.ts", "../src/modules/lighting/lights/lighting-uniforms-wgsl.ts", "../src/modules/lighting/no-material/dirlight.ts", "../src/modules/lighting/phong-material/phong-shaders-glsl.ts", "../src/modules/lighting/phong-material/phong-shaders-wgsl.ts", "../src/modules/lighting/gouraud-material/gouraud-material.ts", "../src/modules/lighting/phong-material/phong-material.ts", "../src/modules/lighting/pbr-material/pbr-vertex-glsl.ts", "../src/modules/lighting/pbr-material/pbr-fragment-glsl.ts", "../src/modules/lighting/pbr-material/pbr-projection.ts", "../src/modules/lighting/pbr-material/pbr-material.ts", "../src/modules-webgl1/geometry/geometry.ts", "../src/modules-webgl1/project/project.ts", "../src/modules-webgl1/lighting/lights/lights-glsl.ts", "../src/modules-webgl1/lighting/lights/lights.ts", "../src/modules-webgl1/lighting/dirlight/dirlight.ts", "../src/modules-webgl1/lighting/phong-lighting/phong-lighting-glsl.ts", "../src/modules-webgl1/lighting/phong-lighting/phong-lighting.ts", "../src/modules-webgl1/lighting/pbr/pbr-vertex-glsl.ts", "../src/modules-webgl1/lighting/pbr/pbr-fragment-glsl.ts", "../src/modules-webgl1/lighting/pbr/pbr.ts"],
  "sourcesContent": ["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// shadertools exports\n\n/**\n * Marks GLSL shaders for syntax highlighting: glsl`...`\n * Install https://marketplace.visualstudio.com/items?itemName=boyswan.glsl-literal\n */\nexport type {PlatformInfo} from './lib/shader-assembly/platform-info';\n\n// ShaderModules\n\nexport type {ShaderModule} from './lib/shader-module/shader-module';\nexport type {ShaderPass} from './lib/shader-module/shader-pass';\nexport type {UniformTypes} from './lib/utils/uniform-types';\n\nexport {initializeShaderModule, initializeShaderModules} from './lib/shader-module/shader-module';\nexport {getShaderModuleUniforms} from './lib/shader-module/shader-module';\nexport {getShaderModuleDependencies} from './lib/shader-module/shader-module-dependencies';\nexport {checkShaderModuleDeprecations} from './lib/shader-module/shader-module';\n\nexport {getShaderModuleSource} from './lib/shader-assembly/assemble-shaders';\n\nexport {resolveModules as _resolveModules} from './lib/shader-module/shader-module-dependencies';\nexport {getDependencyGraph as _getDependencyGraph} from './lib/shader-module/shader-module-dependencies';\n\n// ShaderAssembler\nexport {ShaderAssembler} from './lib/shader-assembler';\nexport type {ShaderHook} from './lib/shader-assembly/shader-hooks';\nexport type {ShaderInjection} from './lib/shader-assembly/shader-injections';\n\n// SHADER HELPERS\n\n// Shader source introspection\nexport {getShaderInfo} from './lib/glsl-utils/get-shader-info';\nexport {\n  getQualifierDetails,\n  getPassthroughFS,\n  typeToChannelSuffix,\n  typeToChannelCount,\n  convertToVec4\n} from './lib/glsl-utils/shader-utils';\n\n// EXPERIMENTAL - Do not use in production applications\nexport type {ShaderGenerationOptions} from './lib/shader-generator/generate-shader';\nexport {generateShaderForModule} from './lib/shader-generator/generate-shader';\nexport {capitalize} from './lib/shader-generator/utils/capitalize';\n\n// TEST EXPORTS - Do not use in production applications\nexport {preprocess} from './lib/preprocessor/preprocessor';\nexport {assembleGLSLShaderPair} from './lib/shader-assembly/assemble-shaders';\nexport {combineInjects} from './lib/shader-assembly/shader-injections';\n\n// EXPERIMENTAL WGSL\nexport {getShaderLayoutFromWGSL} from './lib/wgsl/get-shader-layout-wgsl';\n\n// data utils\nexport {toHalfFloat, fromHalfFloat} from './modules/math/fp16/fp16-utils';\nexport {fp64ify, fp64LowPart, fp64ifyMatrix4} from './modules/math/fp64/fp64-utils';\n\n// math libraries\nexport {random} from './modules/math/random/random';\n\nexport {fp32} from './modules/math/fp32/fp32';\nexport {fp64, fp64arithmetic} from './modules/math/fp64/fp64';\n\n// engine shader modules\n\n// // projection\n// export type {ProjectionUniforms} from './modules/engine/project/project';\n// export {projection} from './modules/engine/project/project';\nexport type {PickingProps, PickingUniforms} from './modules/engine/picking/picking';\nexport {picking} from './modules/engine/picking/picking';\n\n// // lighting\nexport type {LightingProps, LightingUniforms} from './modules/lighting/lights/lighting';\nexport {lighting} from './modules/lighting/lights/lighting';\nexport {dirlight} from './modules/lighting/no-material/dirlight';\nexport type {GouraudMaterialProps} from './modules/lighting/gouraud-material/gouraud-material';\nexport {gouraudMaterial} from './modules/lighting/gouraud-material/gouraud-material';\nexport type {PhongMaterialProps} from './modules/lighting/phong-material/phong-material';\nexport {phongMaterial} from './modules/lighting/phong-material/phong-material';\nexport type {\n  PBRMaterialBindings,\n  PBRMaterialProps,\n  PBRMaterialUniforms\n} from './modules/lighting/pbr-material/pbr-material';\nexport type {PBRProjectionProps} from './modules/lighting/pbr-material/pbr-projection';\n\nexport {pbrMaterial} from './modules/lighting/pbr-material/pbr-material';\n\n// DEPRECATED - v8 legacy shader modules (non-uniform buffer)\n\n// math libraries\n// export {fp64, fp64arithmetic} from './modules-webgl1/math/fp64/fp64';\n\n// projection and lighting\nexport {geometry as geometry1} from './modules-webgl1/geometry/geometry';\nexport {project as project1} from './modules-webgl1/project/project';\n\nexport {lights as lights1} from './modules-webgl1/lighting/lights/lights';\nexport {dirlight as dirlight1} from './modules-webgl1/lighting/dirlight/dirlight';\nexport {\n  gouraudLighting,\n  phongLighting\n} from './modules-webgl1/lighting/phong-lighting/phong-lighting';\nexport {pbr} from './modules-webgl1/lighting/pbr/pbr';\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Recommendation is to ignore message but current test suite checks agains the\n// message so keep it for now.\nexport function assert(condition: unknown, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'shadertools: assertion failed.');\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {assert} from '../utils/assert';\n\n/**\n * For use by shader module and shader pass writers to describe the types of the\n * properties they expose (properties ultimately map to uniforms).\n */\nexport type PropType =\n  | {\n      type?: string;\n      value?: unknown;\n      max?: number;\n      min?: number;\n      softMax?: number;\n      softMin?: number;\n      hint?: string;\n      /** @deprecated internal uniform */\n      private?: boolean;\n    }\n  | number;\n\n/**\n * Internal property validators generated by processing the prop types ,\n * The `validate()` method can be used to validate the type of properties passed in to\n * shader module or shader pass\n */\nexport type PropValidator = {\n  type: string;\n  value?: unknown;\n  max?: number;\n  min?: number;\n  private?: boolean;\n  validate?(value: unknown, propDef: PropValidator): boolean;\n};\n\n/** Minimal validators for number and array types */\nconst DEFAULT_PROP_VALIDATORS: Record<string, PropValidator> = {\n  number: {\n    type: 'number',\n    validate(value: unknown, propType: PropType) {\n      return (\n        Number.isFinite(value) &&\n        typeof propType === 'object' &&\n        (propType.max === undefined || (value as number) <= propType.max) &&\n        (propType.min === undefined || (value as number) >= propType.min)\n      );\n    }\n  },\n  array: {\n    type: 'array',\n    validate(value: unknown, propType: PropType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n\n/**\n * Parse a list of property types into property definitions that can be used to validate\n * values passed in by applications.\n * @param propTypes\n * @returns\n */\nexport function makePropValidators(\n  propTypes: Record<string, PropType>\n): Record<string, PropValidator> {\n  const propValidators: Record<string, PropValidator> = {};\n  for (const [name, propType] of Object.entries(propTypes)) {\n    propValidators[name] = makePropValidator(propType);\n  }\n  return propValidators;\n}\n\n/**\n * Validate a map of user supplied properties against a map of validators\n * Inject default values when user doesn't supply a property\n * @param properties\n * @param propValidators\n * @returns\n */\nexport function getValidatedProperties(\n  properties: Record<string, unknown>,\n  propValidators: Record<string, PropValidator>,\n  errorMessage: string\n): Record<string, unknown> {\n  const validated: Record<string, unknown> = {};\n\n  for (const [key, propsValidator] of Object.entries(propValidators)) {\n    if (properties && key in properties && !propsValidator.private) {\n      if (propsValidator.validate) {\n        assert(\n          propsValidator.validate(properties[key], propsValidator),\n          `${errorMessage}: invalid ${key}`\n        );\n      }\n      validated[key] = properties[key];\n    } else {\n      // property not supplied - use default value\n      validated[key] = propsValidator.value;\n    }\n  }\n\n  // TODO - warn for unused properties that don't match a validator?\n\n  return validated;\n}\n\n/**\n * Creates a property validator for a prop type. Either contains:\n * - a valid prop type object ({type, ...})\n * - or just a default value, in which case type and name inference is used\n */\nfunction makePropValidator(propType: PropType): PropValidator {\n  let type = getTypeOf(propType);\n\n  if (type !== 'object') {\n    return {value: propType, ...DEFAULT_PROP_VALIDATORS[type], type};\n  }\n\n  // Special handling for objects\n  if (typeof propType === 'object') {\n    if (!propType) {\n      return {type: 'object', value: null};\n    }\n    if (propType.type !== undefined) {\n      return {...propType, ...DEFAULT_PROP_VALIDATORS[propType.type], type: propType.type};\n    }\n    // If no type and value this object is likely the value\n    if (propType.value === undefined) {\n      return {type: 'object', value: propType};\n    }\n\n    type = getTypeOf(propType.value);\n    return {...propType, ...DEFAULT_PROP_VALIDATORS[type], type};\n  }\n\n  throw new Error('props');\n}\n\n/**\n * \"improved\" version of javascript typeof that can distinguish arrays and null values\n */\nfunction getTypeOf(value: unknown): string {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const MODULE_INJECTORS_VS = /* glsl */ `\\\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n`;\n\nexport const MODULE_INJECTORS_FS = /* glsl */ `\\\n#ifdef MODULE_MATERIAL\n  fragColor = material_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  fragColor = lighting_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_FOG\n  fragColor = fog_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  fragColor = picking_filterHighlightColor(fragColor);\n  fragColor = picking_filterPickingColor(fragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../../module-injectors';\nimport {assert} from '../utils/assert';\n\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  vertex: MODULE_INJECTORS_VS,\n  fragment: MODULE_INJECTORS_FS\n};\n\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments: string[] = [];\n\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';\n\n/**\n *\n */\nexport type ShaderInjection = {\n  injection: string;\n  order: number;\n};\n\n/**\n *  ShaderInjections, parsed and split per shader\n */\nexport type ShaderInjections = {\n  vertex: Record<string, ShaderInjection>;\n  fragment: Record<string, ShaderInjection>;\n};\n\n/**\n *\n */\nexport function normalizeInjections(\n  injections: Record<string, string | ShaderInjection>\n): ShaderInjections {\n  const result: ShaderInjections = {vertex: {}, fragment: {}};\n\n  for (const hook in injections) {\n    let injection = injections[hook];\n    const stage = getHookStage(hook);\n    if (typeof injection === 'string') {\n      injection = {\n        order: 0,\n        injection\n      };\n    }\n\n    result[stage][hook] = injection;\n  }\n\n  return result;\n}\n\nfunction getHookStage(hook: string): 'vertex' | 'fragment' {\n  const type = hook.slice(0, 2);\n  switch (type) {\n    case 'vs':\n      return 'vertex';\n    case 'fs':\n      return 'fragment';\n    default:\n      throw new Error(type);\n  }\n}\n\n/**\n// A minimal shader injection/templating system.\n// RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n * @param source \n * @param type \n * @param inject \n * @param injectStandardStubs \n * @returns \n */\n// eslint-disable-next-line complexity\nexport function injectShader(\n  source: string,\n  stage: 'vertex' | 'fragment',\n  inject: Record<string, ShaderInjection[]>,\n  injectStandardStubs = false\n): string {\n  const isVertex = stage === 'vertex';\n\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a: ShaderInjection, b: ShaderInjection): number => a.order - b.order);\n    fragments.length = fragmentData.length;\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    const fragmentString = `${fragments.join('\\n')}\\n`;\n    switch (key) {\n      // declarations are injected before the main function\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // inject code at the beginning of the main function\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, (match: string) => match + fragmentString);\n        }\n        break;\n      // inject code at the end of main function\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, (match: string) => fragmentString + match);\n        }\n        break;\n      // declarations are injected before the main function\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // inject code at the beginning of the main function\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, (match: string) => match + fragmentString);\n        }\n        break;\n      // inject code at the end of main function\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, (match: string) => fragmentString + match);\n        }\n        break;\n\n      default:\n        // TODO(Tarek): I think this usage should be deprecated.\n\n        // inject code after key, leaving key in place\n        source = source.replace(key, (match: string) => match + fragmentString);\n    }\n  }\n\n  // Remove if it hasn't already been replaced\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, (match: string) => match + MODULE_INJECTORS[stage]);\n  }\n\n  return source;\n}\n\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects: any[]): Record<string, string> {\n  const result: Record<string, string> = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {UniformFormat} from '../../types';\nimport {\n  PropType,\n  PropValidator,\n  makePropValidators,\n  getValidatedProperties\n} from '../filters/prop-types';\nimport type {UniformTypes, UniformValue} from '../utils/uniform-types';\nimport {ShaderInjection, normalizeInjections} from '../shader-assembly/shader-injections';\n\n// To avoid dependency on core module, do not import `Binding` type.\n// The ShaderModule is not concerned with the type of `Binding`,\n// it is the repsonsibility of `splitUniformsAndBindings` in\n// ShaderInputs to type the result of `getUniforms()`\ntype Binding = unknown; // import type {Binding} from '@luma.gl/core';\n\nexport type UniformInfo = {\n  format?: UniformFormat;\n} & PropType;\n\n// Helper types\ntype BindingKeys<T> = {[K in keyof T]: T[K] extends UniformValue ? never : K}[keyof T];\ntype UniformKeys<T> = {[K in keyof T]: T[K] extends UniformValue ? K : never}[keyof T];\nexport type PickBindings<T> = {[K in BindingKeys<Required<T>>]: T[K]};\nexport type PickUniforms<T> = {[K in UniformKeys<Required<T>>]: T[K]};\n\n/**\n * A shader module definition object\n *\n * @note Needs to be initialized with `initializeShaderModules`\n * @note `UniformsT` & `BindingsT` are deduced from `PropsT` by default. If\n * a custom type for `UniformsT` is used, `BindingsT` should be also be provided.\n */\nexport type ShaderModule<\n  PropsT extends Record<string, any> = Record<string, any>,\n  UniformsT extends Record<string, UniformValue> = PickUniforms<PropsT>,\n  BindingsT extends Record<string, Binding> = PickBindings<PropsT>\n> = {\n  /** Used for type inference not for values */\n  props?: PropsT;\n  /** Used for type inference, not currently used for values */\n  uniforms?: UniformsT;\n  /** Used for type inference, not currently used for values */\n  bindings?: BindingsT;\n\n  name: string;\n\n  /** WGSL code */\n  source?: string;\n  /** GLSL fragment shader code */\n  fs?: string;\n  /** GLSL vertex shader code */\n  vs?: string;\n\n  /** Uniform shader types @note: Both order and types MUST match uniform block declarations in shader */\n  uniformTypes?: Required<UniformTypes<UniformsT>>; // Record<keyof UniformsT, UniformFormat>;\n  /** Uniform JS prop types  */\n  propTypes?: Record<keyof UniformsT, UniformInfo>;\n  /** Default uniform values */\n  defaultUniforms?: Required<UniformsT>; // Record<keyof UniformsT, UniformValue>;\n\n  /** Function that maps props to uniforms & bindings */\n  getUniforms?: (\n    props: Partial<PropsT>,\n    prevUniforms?: UniformsT\n  ) => Partial<UniformsT & BindingsT>;\n\n  defines?: Record<string, string | number>;\n  /** Injections */\n  inject?: Record<string, string | {injection: string; order: number}>;\n  dependencies?: ShaderModule<any, any>[];\n  /** Information on deprecated properties */\n  deprecations?: ShaderModuleDeprecation[];\n\n  /** The instance field contains information that is generated at run-time */\n  instance?: {\n    propValidators?: Record<string, PropValidator>;\n    parsedDeprecations: ShaderModuleDeprecation[];\n\n    normalizedInjections: {\n      vertex: Record<string, ShaderInjection>;\n      fragment: Record<string, ShaderInjection>;\n    };\n  };\n};\n\n/** Use to generate deprecations when shader module is used */\nexport type ShaderModuleDeprecation = {\n  type: string;\n  regex?: RegExp;\n  new: string;\n  old: string;\n  deprecated?: boolean;\n};\n\n// SHNDER MODULE API\n\nexport function initializeShaderModules(modules: ShaderModule[]): void {\n  modules.map((module: ShaderModule) => initializeShaderModule(module));\n}\n\nexport function initializeShaderModule(module: ShaderModule): void {\n  if (module.instance) {\n    return;\n  }\n\n  initializeShaderModules(module.dependencies || []);\n\n  const {\n    propTypes = {},\n    deprecations = [],\n    // defines = {},\n    inject = {}\n  } = module;\n\n  const instance: Required<ShaderModule>['instance'] = {\n    normalizedInjections: normalizeInjections(inject),\n    parsedDeprecations: parseDeprecationDefinitions(deprecations)\n  };\n\n  if (propTypes) {\n    instance.propValidators = makePropValidators(propTypes);\n  }\n\n  module.instance = instance;\n\n  // TODO(ib) - we need to apply the original prop types to the default uniforms\n  let defaultProps: ShaderModule['props'] = {};\n  if (propTypes) {\n    defaultProps = Object.entries(propTypes).reduce(\n      (obj: ShaderModule['props'], [key, propType]) => {\n        // @ts-expect-error\n        const value = propType?.value;\n        if (value) {\n          // @ts-expect-error\n          obj[key] = value;\n        }\n        return obj;\n      },\n      {} as ShaderModule['props']\n    );\n  }\n\n  module.defaultUniforms = {...module.defaultUniforms, ...defaultProps} as any;\n}\n\n/** Convert module props to uniforms */\nexport function getShaderModuleUniforms<\n  ShaderModuleT extends ShaderModule<Record<string, unknown>, Record<string, UniformValue>>\n>(\n  module: ShaderModuleT,\n  props?: ShaderModuleT['props'],\n  oldUniforms?: ShaderModuleT['uniforms']\n): Record<string, Binding | UniformValue> {\n  initializeShaderModule(module);\n\n  const uniforms = oldUniforms || {...module.defaultUniforms};\n  // If module has a getUniforms function, use it\n  if (props && module.getUniforms) {\n    return module.getUniforms(props, uniforms);\n  }\n\n  // Build uniforms from the uniforms array\n  // @ts-expect-error\n  return getValidatedProperties(props, module.instance?.propValidators, module.name);\n}\n\n/* TODO this looks like it was unused code\n  _defaultGetUniforms(opts: Record<string, any> = {}): Record<string, any> {\n    const uniforms: Record<string, any> = {};\n    const propTypes = this.uniforms;\n\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          assert(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);\n        }\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n\n    return uniforms;\n  }\n}\n*/\n// Warn about deprecated uniforms or functions\nexport function checkShaderModuleDeprecations(\n  shaderModule: ShaderModule,\n  shaderSource: string,\n  log: any\n): void {\n  shaderModule.deprecations?.forEach(def => {\n    if (def.regex?.test(shaderSource)) {\n      if (def.deprecated) {\n        log.deprecated(def.old, def.new)();\n      } else {\n        log.removed(def.old, def.new)();\n      }\n    }\n  });\n}\n\n// HELPERS\n\nfunction parseDeprecationDefinitions(deprecations: ShaderModuleDeprecation[]) {\n  deprecations.forEach(def => {\n    switch (def.type) {\n      case 'function':\n        def.regex = new RegExp(`\\\\b${def.old}\\\\(`);\n        break;\n      default:\n        def.regex = new RegExp(`${def.type} ${def.old};`);\n    }\n  });\n\n  return deprecations;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderModule, initializeShaderModules} from './shader-module';\n\n// import type {ShaderModule} from '../shader-module/shader-module';\n\ntype AbstractModule = {\n  name: string;\n  dependencies?: AbstractModule[];\n};\n\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param modules - Array of modules (inline modules or module names)\n * @return - Array of modules\n */\nexport function getShaderModuleDependencies<T extends AbstractModule>(modules: T[]): T[] {\n  initializeShaderModules(modules);\n  const moduleMap: Record<string, T> = {};\n  const moduleDepth: Record<string, number> = {};\n  getDependencyGraph({modules, level: 0, moduleMap, moduleDepth});\n\n  // Return a reverse sort so that dependencies come before the modules that use them\n  const dependencies = Object.keys(moduleDepth)\n    .sort((a, b) => moduleDepth[b] - moduleDepth[a])\n    .map(name => moduleMap[name]);\n  initializeShaderModules(dependencies);\n  return dependencies;\n}\n\n/**\n * Recursively checks module dependencies to calculate dependency level of each module.\n *\n * @param options.modules - Array of modules\n * @param options.level - Current level\n * @param options.moduleMap -\n * @param options.moduleDepth - Current level\n * @return - Map of module name to its level\n */\n// Adds another level of dependencies to the result map\nexport function getDependencyGraph<T extends AbstractModule>(options: {\n  modules: T[];\n  level: number;\n  moduleMap: Record<string, T>;\n  moduleDepth: Record<string, number>;\n}) {\n  const {modules, level, moduleMap, moduleDepth} = options;\n  if (level >= 5) {\n    throw new Error('Possible loop in shader dependency graph');\n  }\n\n  // Update level on all current modules\n  for (const module of modules) {\n    moduleMap[module.name] = module;\n    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {\n      moduleDepth[module.name] = level;\n    }\n  }\n\n  // Recurse\n  for (const module of modules) {\n    if (module.dependencies) {\n      getDependencyGraph({modules: module.dependencies, level: level + 1, moduleMap, moduleDepth});\n    }\n  }\n}\n\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param modules - Array of modules (inline modules or module names)\n * @return - Array of modules\n */\nexport function getShaderDependencies(modules: ShaderModule[]): ShaderModule[] {\n  initializeShaderModules(modules);\n  const moduleMap: Record<string, ShaderModule> = {};\n  const moduleDepth: Record<string, number> = {};\n  getDependencyGraph({modules, level: 0, moduleMap, moduleDepth});\n\n  // Return a reverse sort so that dependencies come before the modules that use them\n  modules = Object.keys(moduleDepth)\n    .sort((a, b) => moduleDepth[b] - moduleDepth[a])\n    .map(name => moduleMap[name]);\n  initializeShaderModules(modules);\n  return modules;\n}\n\n// DEPRECATED\n\n/**\n * Instantiate shader modules and resolve any dependencies\n * @deprecated Use getShaderDpendencies\n */\nexport function resolveModules(modules: ShaderModule[]): ShaderModule[] {\n  return getShaderDependencies(modules);\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {PlatformInfo} from './platform-info';\n\n/** Adds defines to help identify GPU architecture / platform */\nexport function getPlatformShaderDefines(platformInfo: PlatformInfo): string {\n  switch (platformInfo?.gpu.toLowerCase()) {\n    case 'apple':\n      return /* glsl */ `\\\n#define APPLE_GPU\n// Apple optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n\n    case 'nvidia':\n      return /* glsl */ `\\\n#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n`;\n\n    case 'intel':\n      return /* glsl */ `\\\n#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n\n    case 'amd':\n      // AMD Does not eliminate fp64 code\n      return /* glsl */ `\\\n#define AMD_GPU\n`;\n\n    default:\n      // We don't know what GPU it is, could be that the GPU driver or\n      // browser is not implementing UNMASKED_RENDERER constant and not\n      // reporting a correct name\n      return /* glsl */ `\\\n#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Headless Chrome's software shader 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// If the GPU doesn't have full 32 bits precision, will causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// TRANSPILATION TABLES\n\n/**\n * Transpiles GLSL 3.00 shader source code to target GLSL version (3.00 or 1.00)\n *\n * @note We always run transpiler even if same version e.g. 3.00 => 3.00\n * @note For texture sampling transpilation, apps need to use non-standard texture* calls in GLSL 3.00 source\n * RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\n */\nexport function transpileGLSLShader(source: string, stage: 'vertex' | 'fragment'): string {\n  const sourceGLSLVersion = Number(source.match(/^#version[ \\t]+(\\d+)/m)?.[1] || 100);\n  if (sourceGLSLVersion !== 300) {\n    // TODO - we splurge on a longer error message to help deck.gl custom layer developers\n    throw new Error('luma.gl v9 only supports GLSL 3.00 shader sources');\n  }\n\n  switch (stage) {\n    case 'vertex':\n      source = convertShader(source, ES300_VERTEX_REPLACEMENTS);\n      return source;\n    case 'fragment':\n      source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);\n      return source;\n    default:\n      // Unknown shader stage\n      throw new Error(stage);\n  }\n}\n\ntype GLSLReplacement = [RegExp, string];\n\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_REPLACEMENTS: GLSLReplacement[] = [\n  // Fix poorly formatted version directive\n  [/^(#version[ \\t]+(100|300[ \\t]+es))?[ \\t]*\\n/, '#version 300 es\\n'],\n  // The individual `texture...()` functions were replaced with `texture()` overloads\n  [/\\btexture(2D|2DProj|Cube)Lod(EXT)?\\(/g, 'textureLod('],\n  [/\\btexture(2D|2DProj|Cube)(EXT)?\\(/g, 'texture(']\n];\n\nconst ES300_VERTEX_REPLACEMENTS: GLSLReplacement[] = [\n  ...ES300_REPLACEMENTS,\n  // `attribute` keyword replaced with `in`\n  [makeVariableTextRegExp('attribute'), 'in $1'],\n  // `varying` keyword replaced with `out`\n  [makeVariableTextRegExp('varying'), 'out $1']\n];\n\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_FRAGMENT_REPLACEMENTS: GLSLReplacement[] = [\n  ...ES300_REPLACEMENTS,\n  // `varying` keyword replaced with `in`\n  [makeVariableTextRegExp('varying'), 'in $1']\n];\n\nfunction convertShader(source: string, replacements: GLSLReplacement[]) {\n  for (const [pattern, replacement] of replacements) {\n    source = source.replace(pattern, replacement);\n  }\n  return source;\n}\n\n/**\n * Creates a regexp that tests for a specific variable type\n * @example\n *   should match:\n *     in float weight;\n *     out vec4 positions[2];\n *   should not match:\n *     void f(out float a, in float b) {}\n */\nfunction makeVariableTextRegExp(qualifier: 'attribute' | 'varying' | 'in' | 'out'): RegExp {\n  return new RegExp(`\\\\b${qualifier}[ \\\\t]+(\\\\w+[ \\\\t]+\\\\w+(\\\\[\\\\w+\\\\])?;)`, 'g');\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderInjection} from './shader-injections';\n\n// A normalized hook function\n/**\n * The shader hook mechanism allows the application to create shaders\n * that can be automatically extended by the shader modules the application\n * includes.\n *\n * A shader hook function that shader modules can inject code into.\n * Shaders can call these functions, which will be no-ops by default.\n *\n * If a shader module injects code it will be executed upon the hook\n * function call.\n */\nexport type ShaderHook = {\n  /** `vs:` or `fs:` followed by the name and arguments of the function, e.g. `vs:MYHOOK_func(inout vec4 value)`. Hook name without arguments\n  will also be used as the name of the shader hook */\n  hook: string;\n  /** Code always included at the beginning of a hook function */\n  header: string;\n  /** Code always included at the end of a hook function */\n  footer: string;\n  /** To Be Documented */\n  signature?: string;\n};\n\n/** Normalized shader hooks per shader */\nexport type ShaderHooks = {\n  /** Normalized shader hooks for vertex shader */\n  vertex: Record<string, ShaderHook>;\n  /** Normalized shader hooks for fragment shader */\n  fragment: Record<string, ShaderHook>;\n};\n\n/** Generate hook source code */\nexport function getShaderHooks(\n  hookFunctions: Record<string, ShaderHook>,\n  hookInjections: Record<string, ShaderInjection[]>\n): string {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a: {order: number}, b: {order: number}): number => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n\n/**\n * Parse string based hook functions\n * And split per shader\n */\nexport function normalizeShaderHooks(hookFunctions: (string | ShaderHook)[]): ShaderHooks {\n  const result: ShaderHooks = {vertex: {}, fragment: {}};\n\n  for (const hookFunction of hookFunctions) {\n    let opts: ShaderHook;\n    let hook: string;\n    if (typeof hookFunction !== 'string') {\n      opts = hookFunction;\n      hook = opts.hook;\n    } else {\n      opts = {} as ShaderHook;\n      hook = hookFunction;\n    }\n    hook = hook.trim();\n    const [shaderStage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    const normalizedHook: ShaderHook = Object.assign(opts, {signature});\n    switch (shaderStage) {\n      case 'vs':\n        result.vertex[name] = normalizedHook;\n        break;\n      case 'fs':\n        result.fragment[name] = normalizedHook;\n        break;\n      default:\n        throw new Error(shaderStage);\n    }\n  }\n\n  return result;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/** Information extracted from shader source code */\nexport type ShaderInfo = {\n  name: string;\n  language: 'glsl' | 'wgsl';\n  version: number;\n};\n\n/** Extracts information from shader source code */\nexport function getShaderInfo(source: string, defaultName?: string): ShaderInfo {\n  return {\n    name: getShaderName(source, defaultName),\n    language: 'glsl',\n    version: getShaderVersion(source)\n  };\n}\n\n/** Extracts GLSLIFY style naming of shaders: `#define SHADER_NAME ...` */\nfunction getShaderName(shader: string, defaultName: string = 'unnamed'): string {\n  const SHADER_NAME_REGEXP = /#define[^\\S\\r\\n]*SHADER_NAME[^\\S\\r\\n]*([A-Za-z0-9_-]+)\\s*/;\n  const match = SHADER_NAME_REGEXP.exec(shader);\n  return match ? match[1] : defaultName;\n}\n\n/** returns GLSL shader version of given shader string */\nfunction getShaderVersion(source: string): 100 | 300 {\n  let version = 100;\n  const words = source.match(/[^\\s]+/g);\n  if (words && words.length >= 2 && words[0] === '#version') {\n    const parsedVersion = parseInt(words[1], 10);\n    if (Number.isFinite(parsedVersion)) {\n      version = parsedVersion;\n    }\n  }\n  if (version !== 100 && version !== 300) {\n    throw new Error(`Invalid GLSL version ${version}`);\n  }\n  return version;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {getShaderModuleDependencies} from '../shader-module/shader-module-dependencies';\nimport {PlatformInfo} from './platform-info';\nimport {getPlatformShaderDefines} from './platform-defines';\nimport {injectShader, DECLARATION_INJECT_MARKER} from './shader-injections';\nimport {transpileGLSLShader} from '../shader-transpiler/transpile-glsl-shader';\nimport {checkShaderModuleDeprecations} from '../shader-module/shader-module';\nimport type {ShaderInjection} from './shader-injections';\nimport type {ShaderModule} from '../shader-module/shader-module';\nimport {ShaderHook, normalizeShaderHooks, getShaderHooks} from './shader-hooks';\nimport {assert} from '../utils/assert';\nimport {getShaderInfo} from '../glsl-utils/get-shader-info';\n\n/** Define map */\nexport type ShaderDefine = string | number | boolean;\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n`;\n\n/**\n * Precision prologue to inject before functions are injected in shader\n * TODO - extract any existing prologue in the fragment source and move it up...\n */\nconst FRAGMENT_SHADER_PROLOGUE = /* glsl */ `\\\nprecision highp float;\n`;\n\n/**\n * Options for `ShaderAssembler.assembleShaders()`\n */\nexport type AssembleShaderProps = AssembleShaderOptions & {\n  platformInfo: PlatformInfo;\n  /** WGSL: single shader source. */\n  source?: string | null;\n  /** GLSL vertex shader source. */\n  vs?: string | null;\n  /** GLSL fragment shader source. */\n  fs?: string | null;\n};\n\nexport type AssembleShaderOptions = {\n  /** information about the platform (which shader language & version, extensions etc.) */\n  platformInfo: PlatformInfo;\n  /** Inject shader id #defines */\n  id?: string;\n  /** Modules to be injected */\n  modules?: ShaderModule[];\n  /** Defines to be injected */\n  defines?: Record<string, ShaderDefine>;\n  /** Hook functions */\n  hookFunctions?: (ShaderHook | string)[];\n  /** Code injections */\n  inject?: Record<string, string | ShaderInjection>;\n  /** Whether to inject prologue */\n  prologue?: boolean;\n  /** logger object */\n  log?: any;\n};\n\ntype AssembleStageOptions = {\n  /** Inject shader id #defines */\n  id?: string;\n  /** Vertex shader */\n  source: string;\n  stage: 'vertex' | 'fragment';\n  /** Modules to be injected */\n  modules: any[];\n  /** Defines to be injected */\n  defines?: Record<string, ShaderDefine>;\n  /** Hook functions */\n  hookFunctions?: (ShaderHook | string)[];\n  /** Code injections */\n  inject?: Record<string, string | ShaderInjection>;\n  /** Whether to inject prologue */\n  prologue?: boolean;\n  /** logger object */\n  log?: any;\n};\n\nexport type HookFunction = {hook: string; header: string; footer: string; signature?: string};\n\n/**\n * getUniforms function returned from the shader module system\n */\nexport type GetUniformsFunc = (opts: Record<string, any>) => Record<string, any>;\n\n/**\n * Inject a list of shader modules into a single shader source for WGSL\n */\nexport function assembleWGSLShader(\n  options: AssembleShaderOptions & {\n    /** Single WGSL shader */\n    source: string;\n  }\n): {\n  source: string;\n  getUniforms: GetUniformsFunc;\n} {\n  const modules = getShaderModuleDependencies(options.modules || []);\n\n  return {\n    source: assembleShaderWGSL(options.platformInfo, {\n      ...options,\n      source: options.source,\n      stage: 'vertex',\n      modules\n    }),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n\n/**\n * Injects dependent shader module sources into pair of main vertex/fragment shader sources for GLSL\n */\nexport function assembleGLSLShaderPair(\n  options: AssembleShaderOptions & {\n    /** Vertex shader */\n    vs: string;\n    /** Fragment shader */\n    fs?: string;\n  }\n): {\n  vs: string;\n  fs: string;\n  getUniforms: GetUniformsFunc;\n} {\n  const {vs, fs} = options;\n  const modules = getShaderModuleDependencies(options.modules || []);\n\n  return {\n    vs: assembleShaderGLSL(options.platformInfo, {\n      ...options,\n      source: vs,\n      stage: 'vertex',\n      modules\n    }),\n    fs: assembleShaderGLSL(options.platformInfo, {\n      ...options,\n      // @ts-expect-error\n      source: fs,\n      stage: 'fragment',\n      modules\n    }),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n\n/**\n * Pulls together complete source code for either a vertex or a fragment shader\n * adding prologues, requested module chunks, and any final injections.\n * @param gl\n * @param options\n * @returns\n */\nexport function assembleShaderWGSL(platformInfo: PlatformInfo, options: AssembleStageOptions) {\n  const {\n    // id,\n    source,\n    stage,\n    modules,\n    // defines = {},\n    hookFunctions = [],\n    inject = {},\n    log\n  } = options;\n\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  // const isVertex = type === 'vs';\n  // const sourceLines = source.split('\\n');\n\n  const coreSource = source;\n\n  // Combine Module and Application Defines\n  // const allDefines = {};\n  // modules.forEach(module => {\n  //   Object.assign(allDefines, module.getDefines());\n  // });\n  // Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = '';\n  //   prologue\n  //     ? `\\\n  // ${getShaderNameDefine({id, source, type})}\n  // ${getShaderType(type)}\n  // ${getPlatformShaderDefines(platformInfo)}\n  // ${getApplicationDefines(allDefines)}\n  // ${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n  // `\n  // `;\n\n  const hookFunctionMap = normalizeShaderHooks(hookFunctions);\n\n  // Add source of dependent modules in resolved order\n  const hookInjections: Record<string, ShaderInjection[]> = {};\n  const declInjections: Record<string, ShaderInjection[]> = {};\n  const mainInjections: Record<string, ShaderInjection[]> = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    const match = /^(v|f)s:(#)?([\\w-]+)$/.exec(key);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection as any];\n        } else {\n          mainInjections[key] = [injection as any];\n        }\n      } else {\n        hookInjections[key] = [injection as any];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection as any];\n    }\n  }\n\n  // TODO - hack until shadertool modules support WebGPU\n  const modulesToInject = modules;\n\n  for (const module of modulesToInject) {\n    if (log) {\n      checkShaderModuleDeprecations(module, coreSource, log);\n    }\n    const moduleSource = getShaderModuleSource(module, 'wgsl');\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n\n    const injections = module.injections?.[stage] || {};\n    for (const key in injections) {\n      const match = /^(v|f)s:#([\\w-]+)$/.exec(key);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource = injectShader(assembledSource, stage, declInjections);\n\n  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, stage, mainInjections);\n\n  return assembledSource;\n}\n\n/**\n * Pulls together complete source code for either a vertex or a fragment shader\n * adding prologues, requested module chunks, and any final injections.\n * @param gl\n * @param options\n * @returns\n */\nfunction assembleShaderGLSL(\n  platformInfo: PlatformInfo,\n  options: {\n    id?: string;\n    source: string;\n    language?: 'glsl' | 'wgsl';\n    stage: 'vertex' | 'fragment';\n    modules: ShaderModule[];\n    defines?: Record<string, ShaderDefine>;\n    hookFunctions?: any[];\n    inject?: Record<string, string | ShaderInjection>;\n    prologue?: boolean;\n    log?: any;\n  }\n) {\n  const {\n    id,\n    source,\n    stage,\n    language = 'glsl',\n    modules,\n    defines = {},\n    hookFunctions = [],\n    inject = {},\n    prologue = true,\n    log\n  } = options;\n\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const sourceVersion = language === 'glsl' ? getShaderInfo(source).version : -1;\n  const targetVersion = platformInfo.shaderLanguageVersion;\n\n  const sourceVersionDirective = sourceVersion === 100 ? '#version 100' : '#version 300 es';\n\n  const sourceLines = source.split('\\n');\n  // TODO : keep all pre-processor statements at the beginning of the shader.\n  const coreSource = sourceLines.slice(1).join('\\n');\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.defines);\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = '';\n  switch (language) {\n    case 'wgsl':\n      break;\n    case 'glsl':\n      assembledSource = prologue\n        ? `\\\n${sourceVersionDirective}\n\n// ----- PROLOGUE -------------------------\n${getShaderNameDefine({id, source, stage})}\n${`#define SHADER_TYPE_${stage.toUpperCase()}`}\n\n${getPlatformShaderDefines(platformInfo)}\n${stage === 'fragment' ? FRAGMENT_SHADER_PROLOGUE : ''}\n\n// ----- APPLICATION DEFINES -------------------------\n\n${getApplicationDefines(allDefines)}\n\n`\n        : `${sourceVersionDirective}\n`;\n      break;\n  }\n\n  const hookFunctionMap = normalizeShaderHooks(hookFunctions);\n\n  // Add source of dependent modules in resolved order\n  const hookInjections: Record<string, ShaderInjection[]> = {};\n  const declInjections: Record<string, ShaderInjection[]> = {};\n  const mainInjections: Record<string, ShaderInjection[]> = {};\n\n  for (const key in inject) {\n    const injection: ShaderInjection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    const match = /^(v|f)s:(#)?([\\w-]+)$/.exec(key);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    if (log) {\n      checkShaderModuleDeprecations(module, coreSource, log);\n    }\n    const moduleSource = getShaderModuleSource(module, stage);\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n\n    const injections = module.instance?.normalizedInjections[stage] || {};\n    for (const key in injections) {\n      const match = /^(v|f)s:#([\\w-]+)$/.exec(key);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n\n  assembledSource += '// ----- MAIN SHADER SOURCE -------------------------';\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource = injectShader(assembledSource, stage, declInjections);\n\n  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, stage, mainInjections);\n\n  if (language === 'glsl' && sourceVersion !== targetVersion) {\n    assembledSource = transpileGLSLShader(assembledSource, stage);\n  }\n\n  return assembledSource.trim();\n}\n\n/**\n * Returns a combined `getUniforms` covering the options for all the modules,\n * the created function will pass on options to the inidividual `getUniforms`\n * function of each shader module and combine the results into one object that\n * can be passed to setUniforms.\n * @param modules\n * @returns\n */\nexport function assembleGetUniforms(modules: ShaderModule[]) {\n  return function getUniforms(opts: Record<string, any>): Record<string, any> {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms?.(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\n/**\n * Generate \"glslify-compatible\" SHADER_NAME defines\n * These are understood by the GLSL error parsing function\n * If id is provided and no SHADER_NAME constant is present in source, create one\n */\nfunction getShaderNameDefine(options: {\n  id?: string;\n  source: string;\n  stage: 'vertex' | 'fragment';\n}): string {\n  const {id, source, stage} = options;\n  const injectShaderName = id && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${stage}`\n    : '';\n}\n\n/** Generates application defines from an object of key value pairs */\nfunction getApplicationDefines(defines: Record<string, ShaderDefine> = {}): string {\n  let sourceText = '';\n  for (const define in defines) {\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  return sourceText;\n}\n\n/** Extracts the source code chunk for the specified shader type from the named shader module */\nexport function getShaderModuleSource(\n  module: ShaderModule,\n  stage: 'vertex' | 'fragment' | 'wgsl'\n): string {\n  let moduleSource;\n  switch (stage) {\n    case 'vertex':\n      moduleSource = module.vs || '';\n      break;\n    case 'fragment':\n      moduleSource = module.fs || '';\n      break;\n    case 'wgsl':\n      moduleSource = module.source || '';\n      break;\n    default:\n      assert(false);\n  }\n\n  if (!module.name) {\n    throw new Error('Shader module must have a name');\n  }\n  const moduleName = module.name.toUpperCase().replace(/[^0-9a-z]/gi, '_');\n  let source = `\\\n// ----- MODULE ${module.name} ---------------\n\n`;\n  if (stage !== 'wgsl') {\n    source += `#define MODULE_${moduleName}\\n`;\n  }\n  source += `${moduleSource}\\n`;\n  return source;\n}\n\n/*\nfunction getHookFunctions(\n  hookFunctions: Record<string, HookFunction>,\n  hookInjections: Record<string, Injection[]>\n): string {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a: {order: number}, b: {order: number}): number => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n\nfunction normalizeHookFunctions(hookFunctions: (string | HookFunction)[]): {\n  vs: Record<string, HookFunction>;\n  fs: Record<string, HookFunction>;\n} {\n  const result: {vs: Record<string, any>; fs: Record<string, any>} = {\n    vs: {},\n    fs: {}\n  };\n\n  hookFunctions.forEach((hookFunction: string | HookFunction) => {\n    let opts: HookFunction;\n    let hook: string;\n    if (typeof hookFunction !== 'string') {\n      opts = hookFunction;\n      hook = opts.hook;\n    } else {\n      opts = {} as HookFunction;\n      hook = hookFunction;\n    }\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    if (stage !== 'vs' && stage !== 'fs') {\n      throw new Error(stage);\n    }\n    result[stage][name] = Object.assign(opts, {signature});\n  });\n\n  return result;\n}\n*/\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nconst IFDEF_REGEXP = /^\\s*\\#\\s*ifdef\\s*([a-zA-Z_]+)\\s*$/;\nconst ENDIF_REGEXP = /^\\s*\\#\\s*endif\\s*$/;\n\nexport type PreprocessorOptions = {\n  defines?: Record<string, boolean>;\n};\n\nexport function preprocess(source: string, options?: PreprocessorOptions): string {\n  const lines = source.split('\\n');\n  const output: string[] = [];\n\n  let conditional = true;\n  let currentDefine: string | null = null;\n  for (const line of lines) {\n    const matchIf = line.match(IFDEF_REGEXP);\n    const matchEnd = line.match(ENDIF_REGEXP);\n    if (matchIf) {\n      currentDefine = matchIf[1];\n      conditional = Boolean(options?.defines?.[currentDefine]);\n    } else if (matchEnd) {\n      conditional = true;\n    } else if (conditional) {\n      output.push(line);\n    }\n  }\n  return output.join('\\n');\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from './shader-module/shader-module';\nimport {initializeShaderModules} from './shader-module/shader-module';\nimport {\n  AssembleShaderProps,\n  GetUniformsFunc,\n  assembleWGSLShader,\n  assembleGLSLShaderPair\n} from './shader-assembly/assemble-shaders';\nimport {preprocess} from './preprocessor/preprocessor';\n\n/**\n * A stateful version of `assembleShaders` that can be used to assemble shaders.\n * Supports setting of default modules and hooks.\n */\nexport class ShaderAssembler {\n  /** Default ShaderAssembler instance */\n  static defaultShaderAssembler: ShaderAssembler;\n  /** Hook functions */\n  private readonly _hookFunctions: any[] = [];\n  /** Shader modules */\n  private _defaultModules: ShaderModule[] = [];\n\n  /**\n   * A default shader assembler instance - the natural place to register default modules and hooks\n   * @returns\n   */\n  static getDefaultShaderAssembler(): ShaderAssembler {\n    ShaderAssembler.defaultShaderAssembler =\n      ShaderAssembler.defaultShaderAssembler || new ShaderAssembler();\n    return ShaderAssembler.defaultShaderAssembler;\n  }\n\n  /**\n   * Add a default module that does not have to be provided with every call to assembleShaders()\n   */\n  addDefaultModule(module: ShaderModule): void {\n    if (\n      !this._defaultModules.find(\n        m => m.name === (typeof module === 'string' ? module : module.name)\n      )\n    ) {\n      this._defaultModules.push(module);\n    }\n  }\n\n  /**\n   * Remove a default module\n   */\n  removeDefaultModule(module: ShaderModule): void {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);\n  }\n\n  /**\n   * Register a shader hook\n   * @param hook\n   * @param opts\n   */\n  addShaderHook(hook: string, opts?: any): void {\n    if (opts) {\n      hook = Object.assign(opts, {hook});\n    }\n    this._hookFunctions.push(hook);\n  }\n\n  /**\n   * Assemble a WGSL unified shader\n   * @param platformInfo\n   * @param props\n   * @returns\n   */\n  assembleWGSLShader(props: AssembleShaderProps): {\n    source: string;\n    getUniforms: GetUniformsFunc;\n    modules: ShaderModule[];\n  } {\n    const modules = this._getModuleList(props.modules); // Combine with default modules\n    const hookFunctions = this._hookFunctions; // TODO - combine with default hook functions\n    const {source, getUniforms} = assembleWGSLShader({\n      ...props,\n      // @ts-expect-error\n      source: props.source,\n      modules,\n      hookFunctions\n    });\n    // WGSL does not have built-in preprocessing support (just compile time constants)\n    const preprocessedSource =\n      props.platformInfo.shaderLanguage === 'wgsl' ? preprocess(source) : source;\n    return {source: preprocessedSource, getUniforms, modules};\n  }\n\n  /**\n   * Assemble a pair of shaders into a single shader program\n   * @param platformInfo\n   * @param props\n   * @returns\n   */\n  assembleGLSLShaderPair(props: AssembleShaderProps): {\n    vs: string;\n    fs: string;\n    getUniforms: GetUniformsFunc;\n    modules: ShaderModule[];\n  } {\n    const modules = this._getModuleList(props.modules); // Combine with default modules\n    const hookFunctions = this._hookFunctions; // TODO - combine with default hook functions\n    const assembled = assembleGLSLShaderPair({\n      ...props,\n      // @ts-expect-error\n      vs: props.vs,\n      // @ts-expect-error\n      fs: props.fs,\n      modules,\n      hookFunctions\n    });\n\n    return {...assembled, modules};\n  }\n\n  /**\n   * Dedupe and combine with default modules\n   */\n  _getModuleList(appModules: ShaderModule[] = []): ShaderModule[] {\n    const modules = new Array<ShaderModule>(this._defaultModules.length + appModules.length);\n    const seen: Record<string, boolean> = {};\n    let count = 0;\n\n    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {\n      const module = this._defaultModules[i];\n      const name = module.name;\n      modules[count++] = module;\n      seen[name] = true;\n    }\n\n    for (let i = 0, len = appModules.length; i < len; ++i) {\n      const module = appModules[i];\n      const name = module.name;\n      if (!seen[name]) {\n        modules[count++] = module;\n        seen[name] = true;\n      }\n    }\n\n    modules.length = count;\n\n    initializeShaderModules(modules);\n    return modules;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nconst FS_GLES = /* glsl */ `\\\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}`;\nconst FS300 = `#version 300 es\\n${FS_GLES}`;\n\ntype QualifierInfo = {\n  qualifier: string;\n  type: string;\n  name: string;\n};\n\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(\n  line: string,\n  qualifiers: string | string[]\n): QualifierInfo | null {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, '').split(/\\s+/);\n  // TODO add support for precession qualifiers (highp, mediump and lowp)\n  const [qualifier, type, definition] = words;\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n  const name = definition.split(';')[0];\n  return {qualifier, type, name};\n}\n\n/**\n * Given the shader input and output variable names,\n * builds and return a pass through fragment shader.\n */\nexport function getPassthroughFS(options?: {\n  input?: string;\n  inputChannels?: 1 | 2 | 3 | 4;\n  output?: string;\n}): string {\n  const {input, inputChannels, output} = options || {};\n  if (!input) {\n    // Default shader\n    return FS300;\n  }\n  if (!inputChannels) {\n    throw new Error('inputChannels');\n  }\n  const inputType = channelCountToType(inputChannels);\n  const outputValue = convertToVec4(input, inputChannels);\n  return `\\\n#version 300 es\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n}\n\n/** convert glsl type to suffix */\nexport function typeToChannelSuffix(type: string): 'x' | 'xy' | 'xyz' | 'xyzw' {\n  // prettier-ignore\n  switch (type) {\n    case 'float': return 'x';\n    case 'vec2': return 'xy';\n    case 'vec3': return 'xyz';\n    case 'vec4': return 'xyzw';\n    default:\n      throw new Error(type);\n  }\n}\n\n/** convert glsl type to channel count */\nexport function typeToChannelCount(type: string): 1 | 2 | 3 | 4 {\n  // prettier-ignore\n  switch (type) {\n    case 'float': return 1;\n    case 'vec2': return 2;\n    case 'vec3': return 3;\n    case 'vec4': return 4;\n    default:\n      throw new Error(type);\n  }\n}\nfunction channelCountToType(channels: 1 | 2 | 3 | 4): 'float' | 'vec2' | 'vec3' | 'vec4' {\n  // prettier-ignore\n  switch (channels) {\n    case 1: return 'float';\n    case 2: return 'vec2';\n    case 3: return 'vec3';\n    case 4: return 'vec4';\n    default:\n      throw new Error(`invalid channels: ${channels}`);\n  }\n}\n\n/** Returns glsl instruction for converting to vec4 */\nexport function convertToVec4(variable: string, channels: 1 | 2 | 3 | 4): string {\n  // prettier-ignore\n  switch (channels) {\n    case 1: return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n    case 2: return `vec4(${variable}, 0.0, 1.0)`;\n    case 3: return `vec4(${variable}, 1.0)`;\n    case 4: return variable;\n    default:\n      throw new Error(`invalid channels: ${channels}`);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/**\n * Capitalize first letter of a string\n * @param {string} str\n * @returns {string}\n */\nexport function capitalize(str: string): string {\n  return typeof str === 'string' ? str.charAt(0).toUpperCase() + str.slice(1) : str;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {UniformFormat} from '../../../types';\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport {capitalize} from '../utils/capitalize';\n\nexport type GLSLGenerationOptions = {\n  shaderLanguage: 'glsl';\n  uniforms: 'scoped-interface-blocks' | 'unscoped-interface-blocks' | 'uniforms';\n};\n\nexport function generateGLSLForModule(module: ShaderModule, options: GLSLGenerationOptions) {\n  return generateGLSLUniformDeclarations(module, options);\n}\n\nfunction generateGLSLUniformDeclarations(\n  module: ShaderModule,\n  options: GLSLGenerationOptions\n): string {\n  const glsl: string[] = [];\n\n  // => uniform UniformBlockName {\n  switch (options.uniforms) {\n    case 'scoped-interface-blocks':\n    case 'unscoped-interface-blocks':\n      glsl.push(`uniform ${capitalize(module.name)} {`);\n      break;\n    case 'uniforms':\n    // ignore\n  }\n\n  for (const [uniformName, uniformFormat] of Object.entries(module.uniformTypes || {})) {\n    const glslUniformType = getGLSLUniformType(uniformFormat);\n    switch (options.uniforms) {\n      case 'scoped-interface-blocks':\n        // => uniform UniformBlockName {\n        glsl.push(`  ${glslUniformType} ${uniformName};`);\n        break;\n      case 'unscoped-interface-blocks':\n        // => uniform UniformBlockName {\n        glsl.push(`  ${glslUniformType} ${module.name}_${uniformName};`);\n        break;\n      case 'uniforms':\n        glsl.push(`uniform ${glslUniformType} ${module.name}_${uniformName};`);\n    }\n  }\n\n  switch (options.uniforms) {\n    case 'scoped-interface-blocks':\n      glsl.push(`} ${module.name};`);\n      break;\n    case 'unscoped-interface-blocks':\n      glsl.push('};');\n      break;\n    case 'uniforms':\n    // ignore\n  }\n\n  // final new line\n  glsl.push('');\n\n  return glsl.join('\\n');\n}\n\n/** Map a luma.gl WebGPU style uniform type to GLSL */\nfunction getGLSLUniformType(uniformFormat: UniformFormat): string {\n  const UNIFORM_TYPE_TO_GLSL: Record<UniformFormat, string> = {\n    f32: 'float',\n    i32: 'int',\n    u32: 'uint',\n    'vec2<f32>': 'vec2',\n    'vec3<f32>': 'vec3',\n    'vec4<f32>': 'vec4',\n    'vec2<i32>': 'ivec2',\n    'vec3<i32>': 'ivec3',\n    'vec4<i32>': 'ivec4',\n    'vec2<u32>': 'uvec2',\n    'vec3<u32>': 'uvec3',\n    'vec4<u32>': 'uvec4',\n    'mat2x2<f32>': 'mat2',\n    'mat2x3<f32>': 'mat2x3',\n    'mat2x4<f32>': 'mat2x4',\n    'mat3x2<f32>': 'mat3x2',\n    'mat3x3<f32>': 'mat3',\n    'mat3x4<f32>': 'mat3x4',\n    'mat4x2<f32>': 'mat4x2',\n    'mat4x3<f32>': 'mat4x3',\n    'mat4x4<f32>': 'mat4'\n  };\n\n  const glsl = UNIFORM_TYPE_TO_GLSL[uniformFormat];\n  return glsl;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport {capitalize} from '../utils/capitalize';\n\nexport type WGSLGenerationOptions = {\n  shaderLanguage: 'wgsl';\n};\n\nexport function generateWGSLForModule(module: ShaderModule, options: WGSLGenerationOptions) {\n  return generateWGSLUniformDeclarations(module, options);\n}\n\nexport function generateWGSLUniformDeclarations(\n  module: ShaderModule,\n  options: WGSLGenerationOptions\n) {\n  const wgsl: string[] = [];\n\n  // => uniform UniformBlockName {\n  wgsl.push(`struct ${capitalize(module.name)} {`);\n\n  for (const [uniformName, uniformFormat] of Object.entries(module?.uniformTypes || {})) {\n    const wgslUniformType = uniformFormat;\n    wgsl.push(`  ${uniformName} : ${wgslUniformType};`);\n  }\n  wgsl.push('};');\n\n  wgsl.push(`var<uniform> ${module.name} : ${capitalize(module.name)};`);\n\n  return wgsl.join('\\n');\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderModule} from '../shader-module/shader-module';\n\nimport type {GLSLGenerationOptions} from './glsl/generate-glsl';\nimport {generateGLSLForModule} from './glsl/generate-glsl';\n\nimport type {WGSLGenerationOptions} from './wgsl/generate-wgsl';\nimport {generateWGSLForModule} from './wgsl/generate-wgsl';\n\n/** Options for how to generate shader code from a module */\nexport type ShaderGenerationOptions = GLSLGenerationOptions | WGSLGenerationOptions;\n\n/** Generates shader code for a module */\nexport function generateShaderForModule(\n  module: ShaderModule<Record<string, unknown>>,\n  options: ShaderGenerationOptions\n): string {\n  switch (options.shaderLanguage) {\n    case 'glsl':\n      return generateGLSLForModule(module, options);\n    case 'wgsl':\n      return generateWGSLForModule(module, options);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderAttributeType, ShaderLayout, log} from '@luma.gl/core';\nimport {WgslReflect} from 'wgsl_reflect';\n\n/**\n * Parse a ShaderLayout from WGSL shader source code.\n * @param source WGSL source code (can contain both @vertex and @fragment entry points)\n * @returns\n */\nexport function getShaderLayoutFromWGSL(source: string): ShaderLayout {\n  const shaderLayout: ShaderLayout = {attributes: [], bindings: []};\n\n  let parsedWGSL: WgslReflect;\n  try {\n    parsedWGSL = parseWGSL(source);\n  } catch (error: any) {\n    log.error(error.message)();\n    return shaderLayout;\n  }\n\n  for (const uniform of parsedWGSL.uniforms) {\n    const members = [];\n    for (const attribute of (uniform.type as any)?.members || []) {\n      members.push({\n        name: attribute.name,\n        type: getType(attribute.type)\n      });\n    }\n\n    shaderLayout.bindings.push({\n      type: 'uniform',\n      name: uniform.name,\n      group: uniform.group,\n      location: uniform.binding,\n      // @ts-expect-error TODO - unused for now but needs fixing\n      members\n    });\n  }\n\n  for (const texture of parsedWGSL.textures) {\n    shaderLayout.bindings.push({\n      type: 'texture',\n      name: texture.name,\n      group: texture.group,\n      location: texture.binding\n    });\n  }\n\n  for (const sampler of parsedWGSL.samplers) {\n    shaderLayout.bindings.push({\n      type: 'sampler',\n      name: sampler.name,\n      group: sampler.group,\n      location: sampler.binding\n    });\n  }\n\n  const vertex = parsedWGSL.entry.vertex[0]; // \"main\"\n\n  // Vertex shader inputs\n  const attributeCount = vertex?.inputs.length || 0; // inputs to \"main\"\n  for (let i = 0; i < attributeCount; i++) {\n    const wgslAttribute = vertex.inputs[i];\n\n    // locationType can be \"builtin\"\n    if (wgslAttribute.locationType === 'location') {\n      const type = getType(wgslAttribute.type);\n\n      shaderLayout.attributes.push({\n        name: wgslAttribute.name,\n        location: Number(wgslAttribute.location),\n        type\n      });\n    }\n  }\n  return shaderLayout;\n}\n\n/** Get a valid shader attribute type string from a wgsl-reflect type */\nfunction getType(type: any): ShaderAttributeType {\n  return type.format ? `${type.name}<${type.format.name}>` : type.name;\n}\n\nfunction parseWGSL(source: string): WgslReflect {\n  try {\n    return new WgslReflect(source);\n  } catch (error: any) {\n    if (error instanceof Error) {\n      throw error;\n    }\n    let message = 'WGSL parse error';\n    if (typeof error === 'object' && error?.message) {\n      message += `: ${error.message} `;\n    }\n    if (typeof error === 'object' && error?.token) {\n      message += error.token.line || '';\n    }\n    throw new Error(message, {cause: error});\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Forked from THREE.js under MIT license\n// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nimport {clamp} from '@math.gl/core';\n\n/** Pre-calculated tables for float16 conversion */\ntype Float16Tables = {\n  // float32 to float16 helpers\n  baseTable: Uint32Array;\n  shiftTable: Uint32Array;\n  // float16 to float32 helpers\n  mantissaTable: Uint32Array;\n  exponentTable: Uint32Array;\n  offsetTable: Uint32Array;\n};\n\n/**  */\nlet float16Tables: Float16Tables | null = null;\n\n/** Storage that can be viewed both as float and integer */\nconst buffer = new ArrayBuffer(4);\nconst floatView = new Float32Array(buffer);\nconst uint32View = new Uint32Array(buffer);\n\n/**\n * float32 to float16\n * @param val\n * @returns\n */\nexport function toHalfFloat(val: number): number {\n  float16Tables ||= generateFloat16Tables();\n\n  // if ( Math.abs( val ) > 65504 ) console.warn( 'toHalfFloat(): Value out of range.' );\n\n  val = clamp(val, -65504, 65504);\n\n  floatView[0] = val;\n  const f = uint32View[0];\n  const e = (f >> 23) & 0x1ff;\n  return float16Tables.baseTable[e] + ((f & 0x007fffff) >> float16Tables.shiftTable[e]);\n}\n\n/**\n * float16 to float32\n * @param val\n * @returns\n */\nexport function fromHalfFloat(val: number): number {\n  float16Tables ||= generateFloat16Tables();\n\n  const m = val >> 10;\n  uint32View[0] =\n    float16Tables.mantissaTable[float16Tables.offsetTable[m] + (val & 0x3ff)] +\n    float16Tables.exponentTable[m];\n  return floatView[0];\n}\n\nfunction generateFloat16Tables(): Float16Tables {\n  // float32 to float16 helpers\n\n  const baseTable = new Uint32Array(512);\n  const shiftTable = new Uint32Array(512);\n\n  for (let i = 0; i < 256; ++i) {\n    const e = i - 127;\n\n    // very small number (0, -0)\n\n    if (e < -27) {\n      baseTable[i] = 0x0000;\n      baseTable[i | 0x100] = 0x8000;\n      shiftTable[i] = 24;\n      shiftTable[i | 0x100] = 24;\n\n      // small number (denorm)\n    } else if (e < -14) {\n      baseTable[i] = 0x0400 >> (-e - 14);\n      baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n      shiftTable[i] = -e - 1;\n      shiftTable[i | 0x100] = -e - 1;\n\n      // normal number\n    } else if (e <= 15) {\n      baseTable[i] = (e + 15) << 10;\n      baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n      shiftTable[i] = 13;\n      shiftTable[i | 0x100] = 13;\n\n      // large number (Infinity, -Infinity)\n    } else if (e < 128) {\n      baseTable[i] = 0x7c00;\n      baseTable[i | 0x100] = 0xfc00;\n      shiftTable[i] = 24;\n      shiftTable[i | 0x100] = 24;\n\n      // stay (NaN, Infinity, -Infinity)\n    } else {\n      baseTable[i] = 0x7c00;\n      baseTable[i | 0x100] = 0xfc00;\n      shiftTable[i] = 13;\n      shiftTable[i | 0x100] = 13;\n    }\n  }\n\n  // float16 to float32 helpers\n\n  const mantissaTable = new Uint32Array(2048);\n  const exponentTable = new Uint32Array(64);\n  const offsetTable = new Uint32Array(64);\n\n  for (let i = 1; i < 1024; ++i) {\n    let m = i << 13; // zero pad mantissa bits\n    let e = 0; // zero exponent\n\n    // normalized\n    while ((m & 0x00800000) === 0) {\n      m <<= 1;\n      e -= 0x00800000; // decrement exponent\n    }\n\n    m &= ~0x00800000; // clear leading 1 bit\n    e += 0x38800000; // adjust bias\n\n    mantissaTable[i] = m | e;\n  }\n\n  for (let i = 1024; i < 2048; ++i) {\n    mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n  }\n\n  for (let i = 1; i < 31; ++i) {\n    exponentTable[i] = i << 23;\n  }\n\n  exponentTable[31] = 0x47800000;\n  exponentTable[32] = 0x80000000;\n\n  for (let i = 33; i < 63; ++i) {\n    exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n  }\n\n  exponentTable[63] = 0xc7800000;\n\n  for (let i = 1; i < 64; ++i) {\n    if (i !== 32) {\n      offsetTable[i] = 1024;\n    }\n  }\n\n  return {baseTable, shiftTable, mantissaTable, exponentTable, offsetTable};\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumericArray} from '@math.gl/types';\n\n/**\n * Calculate WebGL 64 bit float\n * @param a  - the input float number\n * @param out - the output array. If not supplied, a new array is created.\n * @param startIndex - the index in the output array to fill from. Default 0.\n * @returns - the fp64 representation of the input number\n */\nexport function fp64ify(a: number, out: NumericArray = [], startIndex: number = 0): NumericArray {\n  const hiPart = Math.fround(a);\n  const loPart = a - hiPart;\n  out[startIndex] = hiPart;\n  out[startIndex + 1] = loPart;\n  return out;\n}\n\n/**\n * Calculate the low part of a WebGL 64 bit float\n * @param a the input float number\n * @returns the lower 32 bit of the number\n */\nexport function fp64LowPart(a: number): number {\n  return a - Math.fround(a);\n}\n\n/**\n * Calculate WebGL 64 bit matrix (transposed \"Float64Array\")\n * @param matrix  the input matrix\n * @returns the fp64 representation of the input matrix\n */\nexport function fp64ifyMatrix4(matrix: NumericArray): Float32Array {\n  // Transpose the projection matrix to column major for GLSL.\n  const matrixFP64 = new Float32Array(32);\n  for (let i = 0; i < 4; ++i) {\n    for (let j = 0; j < 4; ++j) {\n      const index = i * 4 + j;\n      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);\n    }\n  }\n  return matrixFP64;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\n\nconst fs = /* glsl */ `\\\nfloat random(vec3 scale, float seed) {\n  /* use the fragment position for a different seed per-pixel */\n  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n`;\n\n/** Quick random generator for fragment shaders */\nexport const random = {\n  name: 'random',\n  fs\n} as const satisfies ShaderModule<{}, {}>;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// import {ShaderModule} from '../../types';\n\nconst fp32shader = /* glsl */ `\\\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n\n// All these functions are for substituting tan() function from Intel GPU only\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n\n    // 2pi range reduction\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n`;\n\n/**\n * 32 bit math library (fixups for GPUs)\n */\nexport const fp32 = {\n  name: 'fp32',\n  vs: fp32shader\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const fp64arithmeticShader = /* glsl */ `\\\n\nuniform fp64arithmeticUniforms {\n  uniform float ONE;\n} fp64;\n\n/*\nAbout LUMA_FP64_CODE_ELIMINATION_WORKAROUND\n\nThe purpose of this workaround is to prevent shader compilers from\noptimizing away necessary arithmetic operations by swapping their sequences\nor transform the equation to some 'equivalent' form.\n\nThe method is to multiply an artifical variable, ONE, which will be known to\nthe compiler to be 1 only at runtime. The whole expression is then represented\nas a polynomial with respective to ONE. In the coefficients of all terms, only one a\nand one b should appear\n\nerr = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE\n*/\n\n// Divide float number to high and low floats to extend fraction bits\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float a_hi = t * fp64.ONE - (t - a);\n  float a_lo = a * fp64.ONE - a_hi;\n#else\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n#endif\n  return vec2(a_hi, a_lo);\n}\n\n// Divide float number again when high float uses too many fraction bits\nvec2 split2(vec2 a) {\n  vec2 b = split(a.x);\n  b.y += a.y;\n  return b;\n}\n\n// Special sum operation when a > b\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float sum = (a + b) * fp64.ONE;\n  float err = b - (sum - a) * fp64.ONE;\n#else\n  float sum = a + b;\n  float err = b - (sum - a);\n#endif\n  return vec2(sum, err);\n}\n\n// General sum operation\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * fp64.ONE - a) * fp64.ONE;\n  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * fp64.ONE - a) * fp64.ONE;\n  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *\n    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;\n#else\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\n  return vec2(prod, err);\n}\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  // y component is for the error\n  prod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  prod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\n  vec2 yn = a * xn;\n#endif\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  return sum_fp64(split(yn), prod);\n#else\n  return sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const fp64functionShader = /* glsl */ `\\\nconst vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\n/* k_power controls how much range reduction we would like to have\nRange reduction uses the following method:\nassume a = k_power * r + m * log(2), k and m being integers.\nSet k_power = 4 (we can choose other k to trade accuracy with performance.\nwe only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k_power;\n*/\n\nvec2 exp_fp64(vec2 a) {\n  // We need to make sure these two numbers match\n  // as bit-wise shift is not available in GLSL 1.0\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n  // s = sum_fp64(s, t);\n  // p = mul_fp64(p, r);\n  // t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);\n\n  // s = sum_fp64(s, t);\n  // p = mul_fp64(p, r);\n  // t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);\n\n  s = sum_fp64(s, t);\n\n\n  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(fp64.ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n//   return r;\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(fp64.ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n  /* keep the following commented code in case we need them\n  for extra accuracy from the Taylor expansion*/\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);\n  // s = sum_fp64(s, t);\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);\n  // s = sum_fp64(s, t);\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n  /* keep the following commented code in case we need them\n  for extra accuracy from the Taylor expansion*/\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);\n  // s = sum_fp64(s, t);\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);\n  // s = sum_fp64(s, t);\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    // We just can't get PI/16 * 3.0 very accurately.\n    // so let's just store it\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\n// Vector functions\n// vec2 functions\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\n\n// vec3 functions\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\n\n// vec4 functions\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\n\nimport {fp64ify, fp64LowPart, fp64ifyMatrix4} from '../../../modules/math/fp64/fp64-utils';\nimport {fp64arithmeticShader} from './fp64-arithmetic-glsl';\nimport {fp64functionShader} from './fp64-functions-glsl';\n\ntype FP64Props = {};\ntype FP64Uniforms = {ONE: number};\ntype FP64Bindings = {};\n\ntype FP64Utilities = {\n  fp64ify: typeof fp64ify;\n  fp64LowPart: typeof fp64LowPart;\n  fp64ifyMatrix4: typeof fp64ifyMatrix4;\n};\n\nconst defaultUniforms: FP64Uniforms = {\n  // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND\n  ONE: 1.0\n};\n\n/**\n * 64bit arithmetic: add, sub, mul, div (small subset of fp64 module)\n */\nexport const fp64arithmetic: ShaderModule<FP64Props, FP64Uniforms, FP64Bindings> & FP64Utilities = {\n  name: 'fp64arithmetic',\n  vs: fp64arithmeticShader,\n  defaultUniforms,\n  uniformTypes: {ONE: 'f32'},\n\n  // Additional Functions\n  fp64ify,\n  fp64LowPart,\n  fp64ifyMatrix4\n};\n\n/**\n * Full 64 bit math library\n */\nexport const fp64: ShaderModule<{}> & FP64Utilities = {\n  name: 'fp64',\n  vs: fp64functionShader,\n  dependencies: [fp64arithmetic],\n\n  // Additional Functions\n  fp64ify,\n  fp64LowPart,\n  fp64ifyMatrix4\n};\n\nexport {fp64ify, fp64LowPart, fp64ifyMatrix4};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport type {NumberArray3, NumberArray4} from '@math.gl/core';\n\n// cyan color\nconst DEFAULT_HIGHLIGHT_COLOR: NumberArray4 = [0, 1, 1, 1];\n\n/**\n * Props for the picking module, which depending on mode renders picking colors or highlighted item.\n * When active, renders picking colors, assumed to be rendered to off-screen \"picking\" buffer.\n * When inactive, renders normal colors, with the exception of selected object which is rendered with highlight\n */\nexport type PickingProps = {\n  /** Are we picking? I.e. rendering picking colors? */\n  isActive?: boolean;\n  /** Set to true when picking an attribute value instead of object index */\n  isAttribute?: boolean;\n  /** Set to a picking color to visually highlight that item, or `null` to explicitly clear **/\n  highlightedObjectColor?: NumberArray3 | null;\n  /** Color of visual highlight of \"selected\" item */\n  highlightColor?: NumberArray3 | NumberArray4;\n  /** Color range 0-1 or 0-255 */\n  useFloatColors?: boolean;\n};\n\n/**\n * Uniforms for the picking module, which renders picking colors and highlighted item.\n * When active, renders picking colors, assumed to be rendered to off-screen \"picking\" buffer.\n * When inactive, renders normal colors, with the exception of selected object which is rendered with highlight\n */\nexport type PickingUniforms = {\n  /**\n   * When true, renders picking colors. Set when rendering to off-screen \"picking\" buffer.\n   * When false, renders normal colors, with the exception of selected object which is rendered with highlight\n   */\n  isActive?: boolean;\n  /** Set to true when picking an attribute value instead of object index */\n  isAttribute?: boolean;\n  /** Color range 0-1 or 0-255 */\n  useFloatColors?: boolean;\n  /** Do we have a highlighted item? */\n  isHighlightActive?: boolean;\n  /** Set to a picking color to visually highlight that item */\n  highlightedObjectColor?: NumberArray3;\n  /** Color of visual highlight of \"selected\" item */\n  highlightColor?: NumberArray4;\n};\n\nconst vs = /* glsl */ `\\\nuniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n`;\n\nconst fs = /* glsl */ `\\\nuniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n`;\n\n/**\n * Provides support for color-coding-based picking and highlighting.\n * In particular, supports picking a specific instance in an instanced\n * draw call and highlighting an instance based on its picking color,\n * and correspondingly, supports picking and highlighting groups of\n * primitives with the same picking color in non-instanced draw-calls\n */\nexport const picking = {\n  props: {} as PickingProps,\n  uniforms: {} as PickingUniforms,\n\n  name: 'picking',\n\n  uniformTypes: {\n    isActive: 'f32',\n    isAttribute: 'f32',\n    isHighlightActive: 'f32',\n    useFloatColors: 'f32',\n    highlightedObjectColor: 'vec3<f32>',\n    highlightColor: 'vec4<f32>'\n  },\n  defaultUniforms: {\n    isActive: false,\n    isAttribute: false,\n    isHighlightActive: false,\n    useFloatColors: true,\n    highlightedObjectColor: [0, 0, 0],\n    highlightColor: DEFAULT_HIGHLIGHT_COLOR\n  },\n\n  vs,\n  fs,\n  getUniforms\n} as const satisfies ShaderModule<PickingProps, PickingUniforms>;\n\nfunction getUniforms(opts: PickingProps = {}, prevUniforms?: PickingUniforms): PickingUniforms {\n  const uniforms = {} as PickingUniforms;\n\n  if (opts.highlightedObjectColor === undefined) {\n    // Unless highlightedObjectColor explicitly null or set, do not update state\n  } else if (opts.highlightedObjectColor === null) {\n    uniforms.isHighlightActive = false;\n  } else {\n    uniforms.isHighlightActive = true;\n    const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3) as NumberArray3;\n    uniforms.highlightedObjectColor = highlightedObjectColor;\n  }\n\n  if (opts.highlightColor) {\n    const color = Array.from(opts.highlightColor, x => x / 255);\n    if (!Number.isFinite(color[3])) {\n      color[3] = 1;\n    }\n    uniforms.highlightColor = color as NumberArray4;\n  }\n\n  if (opts.isActive !== undefined) {\n    uniforms.isActive = Boolean(opts.isActive);\n    uniforms.isAttribute = Boolean(opts.isAttribute);\n  }\n\n  if (opts.useFloatColors !== undefined) {\n    uniforms.useFloatColors = Boolean(opts.useFloatColors);\n  }\n\n  return uniforms;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log} from '@luma.gl/core';\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport {lightingUniformsGLSL} from './lighting-uniforms-glsl';\nimport {lightingUniformsWGSL} from './lighting-uniforms-wgsl';\nimport type {NumberArray3} from '@math.gl/core';\n\n/** Max number of supported lights (in addition to ambient light */\nconst MAX_LIGHTS = 3;\n\n/** Whether to divide */\nconst COLOR_FACTOR = 255.0;\n\n/** Shader type field for lights */\n// eslint-disable-next-line no-shadow\nexport enum LIGHT_TYPE {\n  POINT = 0,\n  DIRECTIONAL = 1\n}\n\n/** Lighting helper types */\n\nexport type Light = AmbientLight | PointLight | DirectionalLight;\n\nexport type AmbientLight = {\n  type: 'ambient';\n  color?: Readonly<NumberArray3>;\n  intensity?: number;\n};\n\nexport type PointLight = {\n  type: 'point';\n  position: Readonly<NumberArray3>;\n  color?: Readonly<NumberArray3>;\n  intensity?: number;\n  attenuation?: Readonly<NumberArray3>;\n};\n\nexport type DirectionalLight = {\n  type: 'directional';\n  direction: Readonly<NumberArray3>;\n  color?: Readonly<NumberArray3>;\n  intensity?: number;\n};\n\nexport type LightingProps = {\n  enabled?: boolean;\n  lights?: Light[];\n  /** @deprecated */\n  ambientLight?: AmbientLight;\n  /** @deprecated */\n  pointLights?: PointLight[];\n  /** @deprecated */\n  directionalLights?: DirectionalLight[];\n};\n\nexport type LightingUniforms = {\n  enabled: number;\n  ambientLightColor: Readonly<NumberArray3>;\n  directionalLightCount: number;\n  pointLightCount: number;\n  lightType: number; // [];\n  lightColor0: Readonly<NumberArray3>;\n  lightPosition0: Readonly<NumberArray3>;\n  lightDirection0: Readonly<NumberArray3>;\n  lightAttenuation0: Readonly<NumberArray3>;\n  lightColor1: Readonly<NumberArray3>;\n  lightPosition1: Readonly<NumberArray3>;\n  lightDirection1: Readonly<NumberArray3>;\n  lightAttenuation1: Readonly<NumberArray3>;\n  lightColor2: Readonly<NumberArray3>;\n  lightPosition2: Readonly<NumberArray3>;\n  lightDirection2: Readonly<NumberArray3>;\n  lightAttenuation2: Readonly<NumberArray3>;\n};\n\n/** UBO ready lighting module */\nexport const lighting = {\n  props: {} as LightingProps,\n  uniforms: {} as LightingUniforms,\n\n  name: 'lighting',\n\n  defines: {\n    MAX_LIGHTS\n  },\n\n  uniformTypes: {\n    enabled: 'i32',\n    lightType: 'i32',\n\n    directionalLightCount: 'i32',\n    pointLightCount: 'i32',\n\n    ambientLightColor: 'vec3<f32>',\n\n    // TODO define as arrays once we have appropriate uniformTypes\n    lightColor0: 'vec3<f32>',\n    lightPosition0: 'vec3<f32>',\n    // TODO - could combine direction and attenuation\n    lightDirection0: 'vec3<f32>',\n    lightAttenuation0: 'vec3<f32>',\n\n    lightColor1: 'vec3<f32>',\n    lightPosition1: 'vec3<f32>',\n    lightDirection1: 'vec3<f32>',\n    lightAttenuation1: 'vec3<f32>',\n    lightColor2: 'vec3<f32>',\n    lightPosition2: 'vec3<f32>',\n    lightDirection2: 'vec3<f32>',\n    lightAttenuation2: 'vec3<f32>'\n  },\n\n  defaultUniforms: {\n    enabled: 1,\n    lightType: LIGHT_TYPE.POINT,\n\n    directionalLightCount: 0,\n    pointLightCount: 0,\n\n    ambientLightColor: [0.1, 0.1, 0.1],\n    lightColor0: [1, 1, 1],\n    lightPosition0: [1, 1, 2],\n    // TODO - could combine direction and attenuation\n    lightDirection0: [1, 1, 1],\n    lightAttenuation0: [1, 0, 0],\n\n    lightColor1: [1, 1, 1],\n    lightPosition1: [1, 1, 2],\n    lightDirection1: [1, 1, 1],\n    lightAttenuation1: [1, 0, 0],\n    lightColor2: [1, 1, 1],\n    lightPosition2: [1, 1, 2],\n    lightDirection2: [1, 1, 1],\n    lightAttenuation2: [1, 0, 0]\n  },\n  source: lightingUniformsWGSL,\n  vs: lightingUniformsGLSL,\n  fs: lightingUniformsGLSL,\n\n  getUniforms\n} as const satisfies ShaderModule<LightingProps, LightingUniforms, {}>;\n\nfunction getUniforms(\n  props?: LightingProps,\n  prevUniforms: Partial<LightingUniforms> = {}\n): LightingUniforms {\n  // Copy props so we can modify\n  props = props ? {...props} : props;\n\n  // TODO legacy\n  if (!props) {\n    return {...lighting.defaultUniforms};\n  }\n  // Support for array of lights. Type of light is detected by type field\n  if (props.lights) {\n    props = {...props, ...extractLightTypes(props.lights), lights: undefined};\n  }\n\n  // Specify lights separately\n  const {ambientLight, pointLights, directionalLights} = props || {};\n  const hasLights =\n    ambientLight ||\n    (pointLights && pointLights.length > 0) ||\n    (directionalLights && directionalLights.length > 0);\n\n  // TODO - this may not be the correct decision\n  if (!hasLights) {\n    return {...lighting.defaultUniforms, enabled: 0};\n  }\n\n  const uniforms = {\n    ...lighting.defaultUniforms,\n    ...prevUniforms,\n    ...getLightSourceUniforms({ambientLight, pointLights, directionalLights})\n  };\n\n  if (props.enabled !== undefined) {\n    uniforms.enabled = props.enabled ? 1 : 0;\n  }\n\n  return uniforms;\n}\n\nfunction getLightSourceUniforms({\n  ambientLight,\n  pointLights = [],\n  directionalLights = []\n}: LightingProps): Partial<LightingUniforms> {\n  const lightSourceUniforms: Partial<LightingUniforms> = {};\n\n  lightSourceUniforms.ambientLightColor = convertColor(ambientLight);\n\n  let currentLight: 0 | 1 | 2 = 0;\n\n  for (const pointLight of pointLights) {\n    lightSourceUniforms.lightType = LIGHT_TYPE.POINT;\n\n    const i = currentLight as 0 | 1 | 2;\n    lightSourceUniforms[`lightColor${i}`] = convertColor(pointLight);\n    lightSourceUniforms[`lightPosition${i}`] = pointLight.position;\n    lightSourceUniforms[`lightAttenuation${i}`] = pointLight.attenuation || [1, 0, 0];\n    currentLight++;\n  }\n\n  for (const directionalLight of directionalLights) {\n    lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;\n\n    const i = currentLight as 0 | 1 | 2;\n    lightSourceUniforms[`lightColor${i}`] = convertColor(directionalLight);\n    lightSourceUniforms[`lightDirection${i}`] = directionalLight.direction;\n    currentLight++;\n  }\n\n  if (currentLight > MAX_LIGHTS) {\n    log.warn('MAX_LIGHTS exceeded')();\n  }\n\n  lightSourceUniforms.directionalLightCount = directionalLights.length;\n  lightSourceUniforms.pointLightCount = pointLights.length;\n\n  return lightSourceUniforms;\n}\n\nfunction extractLightTypes(lights: Light[]): LightingProps {\n  const lightSources: LightingProps = {pointLights: [], directionalLights: []};\n  for (const light of lights || []) {\n    switch (light.type) {\n      case 'ambient':\n        // Note: Only uses last ambient light\n        // TODO - add ambient light sources on CPU?\n        lightSources.ambientLight = light;\n        break;\n      case 'directional':\n        lightSources.directionalLights?.push(light);\n        break;\n      case 'point':\n        lightSources.pointLights?.push(light);\n        break;\n      default:\n      // eslint-disable-next-line\n      // console.warn(light.type);\n    }\n  }\n  return lightSources;\n}\n\n/** Take color 0-255 and intensity as input and output 0.0-1.0 range */\nfunction convertColor(\n  colorDef: {color?: Readonly<NumberArray3>; intensity?: number} = {}\n): NumberArray3 {\n  const {color = [0, 0, 0], intensity = 1.0} = colorDef;\n  return color.map(component => (component * intensity) / COLOR_FACTOR) as NumberArray3;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const lightingUniformsGLSL = /* glsl */ `\\\nprecision highp int;\n\n// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  vec3 color;\n};\n\nstruct PointLight {\n  vec3 color;\n  vec3 position;\n  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform lightingUniforms {\n  int enabled;\n  int lightType;\n\n  int directionalLightCount;\n  int pointLightCount;\n\n  vec3 ambientColor;\n\n  vec3 lightColor0;\n  vec3 lightPosition0;\n  vec3 lightDirection0;\n  vec3 lightAttenuation0;\n\n  vec3 lightColor1;\n  vec3 lightPosition1;\n  vec3 lightDirection1;\n  vec3 lightAttenuation1;\n\n  vec3 lightColor2;\n  vec3 lightPosition2;\n  vec3 lightDirection2;\n  vec3 lightAttenuation2;\n} lighting;\n\nPointLight lighting_getPointLight(int index) {\n  switch (index) {\n    case 0:\n      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);\n    case 1:\n      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);\n    case 2:\n    default:  \n      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);\n  }\n}\n\nDirectionalLight lighting_getDirectionalLight(int index) {\n  switch (index) {\n    case 0:\n      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);\n    case 1:\n      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);\n    case 2:\n    default:   \n      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);\n  }\n} \n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n// #endif\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const lightingUniformsWGSL = /* wgsl */ `\\\n// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  color: vec3<f32>,\n};\n\nstruct PointLight {\n  color: vec3<f32>,\n  position: vec3<f32>,\n  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  color: vec3<f32>,\n  direction: vec3<f32>,\n};\n\nstruct lightingUniforms {\n  enabled: i32,\n  pointLightCount: i32,\n  directionalLightCount: i32,\n\n  ambientColor: vec3<f32>,\n\n  // TODO - support multiple lights by uncommenting arrays below\n  lightType: i32,\n  lightColor: vec3<f32>,\n  lightDirection: vec3<f32>,\n  lightPosition: vec3<f32>,\n  lightAttenuation: vec3<f32>,\n\n  // AmbientLight ambientLight;\n  // PointLight pointLight[MAX_LIGHTS];\n  // DirectionalLight directionalLight[MAX_LIGHTS];\n};\n\n// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)\n@binding(1) @group(0) var<uniform> lighting : lightingUniforms;\n\nfn lighting_getPointLight(index: i32) -> PointLight {\n  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);\n}\n\nfn lighting_getDirectionalLight(index: i32) -> DirectionalLight {\n  return DirectionalLight(lighting.lightColor, lighting.lightDirection);\n} \n\nfn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumberArray3} from '@math.gl/core';\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\n\nexport type DirlightProps = {\n  lightDirection?: NumberArray3;\n};\n\nexport type DirlightUniforms = DirlightProps;\n\n// TODO\nexport const SOURCE_WGSL = /* WGSL */ `\\  \nstruct dirlightUniforms {\n  lightDirection: vec3<f32>,\n};\n\nalias DirlightNormal = vec3<f32>;\n\nstruct DirlightInputs {\n  normal: DirlightNormal,\n};\n\n@binding(1) @group(0) var<uniform> dirlight : dirlightUniforms;\n\n// For vertex\nfn dirlight_setNormal(normal: vec3<f32>) -> DirlightNormal {\n  return normalize(normal);\n}\n\n// Returns color attenuated by angle from light source\nfn dirlight_filterColor(color: vec4<f32>, inputs: DirlightInputs) -> vec4<f32> {\n  // TODO - fix default light direction\n  // let lightDirection = dirlight.lightDirection;\n  let lightDirection = vec3<f32>(1, 1, 1);\n  let d: f32 = abs(dot(inputs.normal, normalize(lightDirection)));\n  return vec4<f32>(color.rgb * d, color.a);\n}\n`;\n\nconst VS_GLSL = /* glsl */ `\\\nout vec3 dirlight_vNormal;\n\nvoid dirlight_setNormal(vec3 normal) {\n  dirlight_vNormal = normalize(normal);\n}\n`;\n\nconst FS_GLSL = /* glsl */ `\\\nuniform dirlightUniforms {\n  vec3 lightDirection;\n} dirlight;\n\nin vec3 dirlight_vNormal;\n\n// Returns color attenuated by angle from light source\nvec4 dirlight_filterColor(vec4 color) {\n  float d = abs(dot(dirlight_vNormal, normalize(dirlight.lightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n`;\n\n/**\n * Cheap lighting - single directional light, single dot product, one uniform\n */\nexport const dirlight = {\n  props: {} as DirlightProps,\n  uniforms: {} as DirlightUniforms,\n\n  name: 'dirlight',\n  dependencies: [],\n  source: SOURCE_WGSL,\n  vs: VS_GLSL,\n  fs: FS_GLSL,\n\n  // fragmentInputs: [\n  //   {\n  //     name: 'dirlight_vNormal',\n  //     type: 'vec3<f32>'\n  //   }\n  // ],\n  uniformTypes: {\n    lightDirection: 'vec3<f32>'\n  },\n  defaultUniforms: {\n    lightDirection: [1, 1, 2]\n  },\n  getUniforms\n} as const satisfies ShaderModule<DirlightProps, DirlightUniforms>;\n\nfunction getUniforms(opts: DirlightProps = dirlight.defaultUniforms): DirlightUniforms {\n  const uniforms: Record<string, unknown> = {};\n  if (opts.lightDirection) {\n    // eslint-disable-next-line camelcase\n    uniforms.dirlight_uLightDirection = opts.lightDirection;\n  }\n  return uniforms;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const PHONG_VS = /* glsl */ `\\\nuniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n`;\n\nexport const PHONG_FS = /* glsl */ `\\\nuniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n  vec3 halfway_direction = normalize(light_direction + view_direction);\n  float lambertian = dot(light_direction, normal_worldspace);\n  float specular = 0.0;\n  if (lambertian > 0.0) {\n    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, material.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  vec3 view_direction = normalize(cameraPosition - position_worldspace);\n  lightColor = material.ambient * surfaceColor * lighting.ambientColor;\n\n  for (int i = 0; i < lighting.pointLightCount; i++) {\n    PointLight pointLight = lighting_getPointLight(i);\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);\n  }\n\n  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);\n  for (int i = lighting.pointLightCount; i < totalLights; i++) {\n    DirectionalLight directionalLight = lighting_getDirectionalLight(i);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n}\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const PHONG_WGSL = /* wgsl */ `\\\nstruct phongMaterialUniforms {\n  ambient: f32,\n  diffuse: f32,\n  shininess: f32,\n  specularColor: vec3<f32>,\n};\n\n@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;\n\nfn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {\n  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);\n  var lambertian: f32 = dot(light_direction, normal_worldspace);\n  var specular: f32 = 0.0;\n  if (lambertian > 0.0) {\n    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, phongMaterial.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;\n}\n\nfn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {\n  var lightColor: vec3<f32> = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);\n  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;\n\n  if (lighting.lightType == 0) {\n    let pointLight: PointLight  = lighting_getPointLight(0);\n    let light_position_worldspace: vec3<f32> = pointLight.position;\n    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  } else if (lighting.lightType == 1) {\n    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n  /*\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.pointLightCount) {\n      break;\n    }\n    PointLight pointLight = lighting.pointLight[i];\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  }\n\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.directionalLightCount) {\n      break;\n    }\n    DirectionalLight directionalLight = lighting.directionalLight[i];\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  */\n}\n\nfn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{\n  var lightColor = vec3<f32>(0, 0, 0);\n  let surfaceColor = vec3<f32>(0, 0, 0);\n\n  if (lighting.enabled == 0) {\n    let view_direction = normalize(cameraPosition - position_worldspace);\n\n    switch (lighting.lightType) {\n      case 0, default: {\n        let pointLight: PointLight = lighting_getPointLight(0);\n        let light_position_worldspace: vec3<f32> = pointLight.position;\n        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n      }\n      case 1: {\n        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n      }\n    }\n  }\n  return lightColor;\n}\n`;\n\n// TODO - handle multiple lights\n/**\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting.pointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_getPointLight(i);\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting.directionalLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_getDirectionalLight(i);\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n    /**\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting.pointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_getPointLight(i);\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting.directionalLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_getDirectionalLight(i);\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  */\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {NumberArray3} from '@math.gl/types';\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport {lighting} from '../lights/lighting';\nimport {PHONG_VS, PHONG_FS} from '../phong-material/phong-shaders-glsl';\nimport {PHONG_WGSL} from '../phong-material/phong-shaders-wgsl';\n\nexport type GouraudMaterialProps = {\n  ambient?: number;\n  diffuse?: number;\n  /** Specularity exponent */\n  shininess?: number;\n  specularColor?: [number, number, number];\n};\n\n/** In Gouraud shading, color is calculated for each triangle vertex normal, and then color is interpolated colors across the triangle */\nexport const gouraudMaterial: ShaderModule<GouraudMaterialProps> = {\n  props: {} as GouraudMaterialProps,\n\n  name: 'gouraudMaterial',\n  // Note these are switched between phong and gouraud\n  vs: PHONG_FS.replace('phongMaterial', 'gouraudMaterial'),\n  fs: PHONG_VS.replace('phongMaterial', 'gouraudMaterial'),\n  source: PHONG_WGSL.replaceAll('phongMaterial', 'gouraudMaterial'),\n  defines: {\n    LIGHTING_VERTEX: 1\n  },\n  dependencies: [lighting],\n  uniformTypes: {\n    ambient: 'f32',\n    diffuse: 'f32',\n    shininess: 'f32',\n    specularColor: 'vec3<f32>'\n  },\n  defaultUniforms: {\n    ambient: 0.35,\n    diffuse: 0.6,\n    shininess: 32,\n    specularColor: [0.15, 0.15, 0.15]\n  },\n\n  getUniforms(props: GouraudMaterialProps) {\n    const uniforms = {...props};\n    if (uniforms.specularColor) {\n      uniforms.specularColor = uniforms.specularColor.map(x => x / 255) as NumberArray3;\n    }\n    return {...gouraudMaterial.defaultUniforms, ...uniforms};\n  }\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {NumberArray3} from '@math.gl/types';\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport {lighting} from '../lights/lighting';\nimport {PHONG_WGSL} from './phong-shaders-wgsl';\nimport {PHONG_VS, PHONG_FS} from './phong-shaders-glsl';\n\nexport type PhongMaterialProps = {\n  ambient?: number;\n  diffuse?: number;\n  /** Specularity exponent */\n  shininess?: number;\n  specularColor?: NumberArray3;\n};\n\n/** In Phong shading, the normal vector is linearly interpolated across the surface of the polygon from the polygon's vertex normals. */\nexport const phongMaterial: ShaderModule<PhongMaterialProps> = {\n  name: 'phongMaterial',\n  dependencies: [lighting],\n  // Note these are switched between phong and gouraud\n  source: PHONG_WGSL,\n  vs: PHONG_VS,\n  fs: PHONG_FS,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  uniformTypes: {\n    ambient: 'f32',\n    diffuse: 'f32',\n    shininess: 'f32',\n    specularColor: 'vec3<f32>'\n  },\n  defaultUniforms: {\n    ambient: 0.35,\n    diffuse: 0.6,\n    shininess: 32,\n    specularColor: [0.15, 0.15, 0.15]\n  },\n  getUniforms(props?: PhongMaterialProps) {\n    const uniforms = {...props};\n    if (uniforms.specularColor) {\n      uniforms.specularColor = uniforms.specularColor.map(x => x / 255) as NumberArray3;\n    }\n    return {...phongMaterial.defaultUniforms, ...uniforms};\n  }\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const vs = /* glsl */ `\\\nout vec3 pbr_vPosition;\nout vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nout mat3 pbr_vTBN;\n# else\nout vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = pbrProjection.modelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else // HAS_TANGENTS != 1\n  pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Attribution:\n// MIT license, Copyright (c) 2016-2017 Mohamad Moneimne and Contributors\n\n// This fragment shader defines a reference implementation for Physically Based Shading of\n// a microfacet surface material defined by a glTF model.\n\n// TODO - better do the checks outside of shader\n\nexport const fs = /* glsl */ `\\\nprecision highp float;\n\nuniform pbrMaterialUniforms {\n  // Material is unlit\n  bool unlit;\n\n  // Base color map\n  bool baseColorMapEnabled;\n  vec4 baseColorFactor;\n\n  bool normalMapEnabled;  \n  float normalScale; // #ifdef HAS_NORMALMAP\n\n  bool emissiveMapEnabled;\n  vec3 emissiveFactor; // #ifdef HAS_EMISSIVEMAP\n\n  vec2 metallicRoughnessValues;\n  bool metallicRoughnessMapEnabled;\n\n  bool occlusionMapEnabled;\n  float occlusionStrength; // #ifdef HAS_OCCLUSIONMAP\n  \n  bool alphaCutoffEnabled;\n  float alphaCutoff; // #ifdef ALPHA_CUTOFF\n  \n  // IBL\n  bool IBLenabled;\n  vec2 scaleIBLAmbient; // #ifdef USE_IBL\n  \n  // debugging flags used for shader output of intermediate PBR variables\n  // #ifdef PBR_DEBUG\n  vec4 scaleDiffBaseMR;\n  vec4 scaleFGDSpec;\n  // #endif\n} pbrMaterial;\n\n// Samplers\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D pbr_baseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D pbr_normalSampler;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D pbr_emissiveSampler;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D pbr_metallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D pbr_occlusionSampler;\n#endif\n#ifdef USE_IBL\nuniform samplerCube pbr_diffuseEnvSampler;\nuniform samplerCube pbr_specularEnvSampler;\nuniform sampler2D pbr_brdfLUT;\n#endif\n\n// Inputs from vertex shader\n\nin vec3 pbr_vPosition;\nin vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nin mat3 pbr_vTBN;\n#else\nin vec3 pbr_vNormal;\n#endif\n#endif\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo {\n  float NdotL;                  // cos angle between normal and light direction\n  float NdotV;                  // cos angle between normal and view direction\n  float NdotH;                  // cos angle between normal and half vector\n  float LdotH;                  // cos angle between light direction and half vector\n  float VdotH;                  // cos angle between view direction and half vector\n  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n  float metalness;              // metallic value at the surface\n  vec3 reflectance0;            // full reflectance color (normal incidence angle)\n  vec3 reflectance90;           // reflectance color at grazing angle\n  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n  vec3 diffuseColor;            // color contribution from diffuse lighting\n  vec3 specularColor;           // color contribution from specular lighting\n  vec3 n;                       // normal at surface point\n  vec3 v;                       // vector from surface point to camera\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else // SRGB_FAST_APPROXIMATION\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif //SRGB_FAST_APPROXIMATION\n  return vec4(linOut,srgbIn.w);;\n#else //MANUAL_SRGB\n  return srgbIn;\n#endif //MANUAL_SRGB\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n  // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else // HAS_TANGENTS\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));\n#else\n  // The tbn matrix is linearly interpolated, so we need to re-normalize\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0; // resolution of 512x512\n  float lod = (pbrInfo.perceptualRoughness * mipCount);\n  // retrieve a scale and bias to F0. See [1], Figure 3\n  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,\n    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;\n  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);\n\n  // For presentation, this allows us to disable IBL terms\n  diffuse *= pbrMaterial.scaleIBLAmbient.x;\n  specular *= pbrMaterial.scaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n// Basic Lambertian diffuse\n// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog\n// See also [1], Equation 1\nvec3 diffuse(PBRInfo pbrInfo)\n{\n  return pbrInfo.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(PBRInfo pbrInfo)\n{\n  return pbrInfo.reflectance0 +\n    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *\n    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);\n}\n\n// This calculates the specular geometric attenuation (aka G()),\n// where rougher material will reflect less light back to the viewer.\n// This implementation is based on [1] Equation 4, and we adopt their modifications to\n// alphaRoughness as input as originally proposed in [2].\nfloat geometricOcclusion(PBRInfo pbrInfo)\n{\n  float NdotL = pbrInfo.NdotL;\n  float NdotV = pbrInfo.NdotV;\n  float r = pbrInfo.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n// The following equation(s) model the distribution of microfacet normals across\n// the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface\n// for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes\n// from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(PBRInfo pbrInfo)\n{\n  float roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;\n  float f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInfo) {\n  pbrInfo.NdotL = 1.0;\n  pbrInfo.NdotH = 0.0;\n  pbrInfo.LdotH = 0.0;\n  pbrInfo.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInfo, vec3 lightDirection) {\n  vec3 n = pbrInfo.n;\n  vec3 v = pbrInfo.v;\n  vec3 l = normalize(lightDirection);             // Vector from surface point to light\n  vec3 h = normalize(l+v);                        // Half vector between both l and v\n\n  pbrInfo.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInfo, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInfo, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInfo, vec3 lightColor) {\n  // Calculate the shading terms for the microfacet specular shading model\n  vec3 F = specularReflection(pbrInfo);\n  float G = geometricOcclusion(pbrInfo);\n  float D = microfacetDistribution(pbrInfo);\n\n  // Calculation of analytical lighting contribution\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInfo);\n  vec3 specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);\n  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n  // The albedo may be defined from a base texture or a flat color\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture(pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;\n#else\n  vec4 baseColor = pbrMaterial.baseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < pbrMaterial.alphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbrMaterial.unlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    float perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;\n    float metallic = pbrMaterial.metallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    vec4 mrSample = texture(pbr_metallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    // For typical incident reflectance range (between 4% to 100%) set the grazing\n    // reflectance to 100% for typical fresnel effect.\n    // For very low reflectance range on highly diffuse objects (below 4%),\n    // incrementally reduce grazing reflecance to 0%.\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();                          // normal at surface point\n    vec3 v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInfo = PBRInfo(\n      0.0, // NdotL\n      NdotV,\n      0.0, // NdotH\n      0.0, // LdotH\n      0.0, // VdotH\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n\n#ifdef USE_LIGHTS\n    // Apply ambient light\n    PBRInfo_setAmbientLight(pbrInfo);\n    color += calculateFinalColor(pbrInfo, lighting.ambientColor);\n\n    // Apply directional light\n    for(int i = 0; i < lighting.directionalLightCount; i++) {\n      if (i < lighting.directionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInfo, lighting_getDirectionalLight(i).direction);\n        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);\n      }\n    }\n\n    // Apply point light\n    for(int i = 0; i < lighting.pointLightCount; i++) {\n      if (i < lighting.pointLightCount) {\n        PBRInfo_setPointLight(pbrInfo, lighting_getPointLight(i));\n        float attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));\n        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);\n      }\n    }\n#endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n    if (pbrMaterial.IBLenabled) {\n      color += getIBLContribution(pbrInfo, n, reflection);\n    }\n#endif\n\n // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSIONMAP\n    if (pbrMaterial.occlusionMapEnabled) {\n      float ao = texture(pbr_occlusionSampler, pbr_vUV).r;\n      color = mix(color, color * ao, pbrMaterial.occlusionStrength);\n    }\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    if (pbrMaterial.emissiveMapEnabled) {\n      vec3 emissive = SRGBtoLINEAR(texture(pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;\n      color += emissive;\n    }\n#endif\n\n    // This section uses mix to override final color for reference app visualization\n    // of various parameters in the lighting equation.\n#ifdef PBR_DEBUG\n    // TODO: Figure out how to debug multiple lights\n\n    // color = mix(color, F, pbr_scaleFGDSpec.x);\n    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);\n    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);\n    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);\n\n    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);\n    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), pbrMaterial.scaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable camelcase */\n\nimport type {NumberArray3, NumberArray16} from '@math.gl/core';\n\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\n\nconst uniformBlock = /* glsl */ `\\\nuniform pbrProjectionUniforms {\n  mat4 modelViewProjectionMatrix;\n  mat4 modelMatrix;\n  mat4 normalMatrix;\n  vec3 camera;\n} pbrProjection;\n`;\n\nexport type PBRProjectionProps = {\n  modelViewProjectionMatrix: NumberArray16;\n  modelMatrix: NumberArray16;\n  normalMatrix: NumberArray16;\n  camera: NumberArray3;\n};\n\nexport const pbrProjection: ShaderModule<PBRProjectionProps> = {\n  name: 'pbrProjection',\n  vs: uniformBlock,\n  fs: uniformBlock,\n  // TODO why is this needed?\n  getUniforms: props => props,\n  uniformTypes: {\n    modelViewProjectionMatrix: 'mat4x4<f32>',\n    modelMatrix: 'mat4x4<f32>',\n    normalMatrix: 'mat4x4<f32>',\n    camera: 'vec3<i32>'\n  }\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable camelcase */\n\nimport type {Texture} from '@luma.gl/core';\nimport type {\n  Vector2,\n  Vector3,\n  Vector4,\n  NumberArray2,\n  NumberArray3,\n  NumberArray4\n} from '@math.gl/core';\n\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport {lighting} from '../lights/lighting';\n\nimport {vs} from './pbr-vertex-glsl';\nimport {fs} from './pbr-fragment-glsl';\nimport {pbrProjection} from './pbr-projection';\n\n/** Non-uniform block bindings for pbr module */\nexport type PBRMaterialBindings = {\n  // Samplers\n  pbr_baseColorSampler?: Texture | null; // #ifdef HAS_BASECOLORMAP\n  pbr_normalSampler?: Texture | null; // #ifdef HAS_NORMALMAP\n  pbr_emissiveSampler?: Texture | null; // #ifdef HAS_EMISSIVEMAP\n  pbr_metallicRoughnessSampler?: Texture | null; // #ifdef HAS_METALROUGHNESSMAP\n  pbr_occlusionSampler?: Texture | null; // #ifdef HAS_OCCLUSIONMAP\n\n  // IBL Samplers\n  pbr_diffuseEnvSampler?: Texture | null; // #ifdef USE_IBL (samplerCube)\n  pbr_specularEnvSampler?: Texture | null; // #ifdef USE_IBL (samplerCube)\n  pbr_BrdfLUT?: Texture | null; // #ifdef USE_IBL\n};\n\nexport type PBRMaterialUniforms = {\n  unlit?: boolean;\n\n  // Base color map\n  baseColorMapEnabled?: boolean;\n  baseColorFactor?: Readonly<Vector4 | NumberArray4>;\n\n  normalMapEnabled?: boolean;\n  normalScale?: number; // #ifdef HAS_NORMALMAP\n\n  emissiveMapEnabled?: boolean;\n  emissiveFactor?: Readonly<Vector3 | NumberArray3>; // #ifdef HAS_EMISSIVEMAP\n\n  metallicRoughnessValues?: Readonly<Vector2 | NumberArray2>;\n  metallicRoughnessMapEnabled?: boolean;\n\n  occlusionMapEnabled?: boolean;\n  occlusionStrength?: number; // #ifdef HAS_OCCLUSIONMAP\n\n  alphaCutoffEnabled?: boolean;\n  alphaCutoff?: number; // #ifdef ALPHA_CUTOFF\n\n  // IBL\n  IBLenabled?: boolean;\n  scaleIBLAmbient?: Readonly<Vector2 | NumberArray2>; // #ifdef USE_IBL\n\n  // debugging flags used for shader output of intermediate PBR variables\n  // #ifdef PBR_DEBUG\n  scaleDiffBaseMR?: Readonly<Vector4 | NumberArray4>;\n  scaleFGDSpec?: Readonly<Vector4 | NumberArray4>;\n};\n\nexport type PBRMaterialProps = PBRMaterialBindings & PBRMaterialUniforms;\n\n/**\n * An implementation of PBR (Physically-Based Rendering).\n * Physically Based Shading of a microfacet surface defined by a glTF material.\n */\nexport const pbrMaterial = {\n  props: {} as PBRMaterialProps,\n  uniforms: {} as PBRMaterialUniforms,\n\n  name: 'pbrMaterial',\n  dependencies: [lighting, pbrProjection],\n  vs,\n  fs,\n\n  defines: {\n    LIGHTING_FRAGMENT: 1\n    // TODO defining these as 0 breaks shader\n    // HAS_NORMALMAP: 0\n    // HAS_EMISSIVEMAP: 0,\n    // HAS_OCCLUSIONMAP: 0,\n    // HAS_BASECOLORMAP: 0,\n    // HAS_METALROUGHNESSMAP: 0,\n    // ALPHA_CUTOFF: 0\n    // USE_IBL: 0\n    // PBR_DEBUG: 0\n  },\n  getUniforms: props => props,\n  uniformTypes: {\n    // Material is unlit\n    unlit: 'i32',\n\n    // Base color map\n    baseColorMapEnabled: 'i32',\n    baseColorFactor: 'vec4<f32>',\n\n    normalMapEnabled: 'i32',\n    normalScale: 'f32', // #ifdef HAS_NORMALMAP\n\n    emissiveMapEnabled: 'i32',\n    emissiveFactor: 'vec3<f32>', // #ifdef HAS_EMISSIVEMAP\n\n    metallicRoughnessValues: 'vec2<f32>',\n    metallicRoughnessMapEnabled: 'i32',\n\n    occlusionMapEnabled: 'i32',\n    occlusionStrength: 'f32', // #ifdef HAS_OCCLUSIONMAP\n\n    alphaCutoffEnabled: 'i32',\n    alphaCutoff: 'f32', // #ifdef ALPHA_CUTOFF\n\n    // IBL\n    IBLenabled: 'i32',\n    scaleIBLAmbient: 'vec2<f32>', // #ifdef USE_IBL\n\n    // debugging flags used for shader output of intermediate PBR variables\n    // #ifdef PBR_DEBUG\n    scaleDiffBaseMR: 'vec4<f32>',\n    scaleFGDSpec: 'vec4<f32>'\n  }\n} as const satisfies ShaderModule<PBRMaterialProps, PBRMaterialUniforms, PBRMaterialBindings>;\n", "// import {ShaderModule} from '../../types';\n\n// TODO - reuse normal from geometry module\nconst vs = /* glsl */ `\\\nvarying vec4 geometry_vPosition;\nvarying vec3 geometry_vNormal;\n\nvoid geometry_setNormal(vec3 normal) {\n  geometry_vNormal = normal;\n}\n\nvoid geometry_setPosition(vec4 position) {\n  geometry_vPosition = position;\n}\n\nvoid geometry_setPosition(vec3 position) {\n  geometry_vPosition = vec4(position, 1.);\n}\n`;\n\nconst fs = /* glsl */ `\\\nvarying vec4 geometry_vPosition;\nvarying vec3 geometry_vNormal;\n\nvec4 geometry_getPosition() {\n  return geometry_vPosition;\n}\n\nvec3 geometry_getNormal() {\n  return geometry_vNormal;\n}\n`;\n\n/**\n * Geometry varyings\n */\nexport const geometry = {\n  name: 'geometry',\n  vs,\n  fs\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Vector3, Matrix4} from '@math.gl/core';\nimport {ShaderModule} from '../../lib/shader-module/shader-module';\nimport type {NumberArray3, NumberArray16} from '@math.gl/core';\n\ntype ProjectionProps = {\n  modelMatrix?: Readonly<Matrix4 | NumberArray16>;\n  viewMatrix?: Readonly<Matrix4 | NumberArray16>;\n  projectionMatrix?: Readonly<Matrix4 | NumberArray16>;\n  cameraPositionWorld?: Readonly<Vector3 | NumberArray3>;\n};\n\nconst IDENTITY_MATRIX: NumberArray16 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\nconst DEFAULT_MODULE_OPTIONS: ProjectionProps = {\n  modelMatrix: IDENTITY_MATRIX,\n  viewMatrix: IDENTITY_MATRIX,\n  projectionMatrix: IDENTITY_MATRIX,\n  cameraPositionWorld: [0, 0, 0]\n};\n\nfunction getUniforms(opts: ProjectionProps = DEFAULT_MODULE_OPTIONS, prevUniforms = {}) {\n  // const viewProjectionInverse = viewProjection.invert();\n  // viewInverseMatrix: view.invert(),\n  // viewProjectionInverseMatrix: viewProjectionInverse\n\n  const uniforms: Record<string, any> = {};\n  if (opts.modelMatrix !== undefined) {\n    uniforms.modelMatrix = opts.modelMatrix;\n  }\n  if (opts.viewMatrix !== undefined) {\n    uniforms.viewMatrix = opts.viewMatrix;\n  }\n  if (opts.projectionMatrix !== undefined) {\n    uniforms.projectionMatrix = opts.projectionMatrix;\n  }\n  if (opts.cameraPositionWorld !== undefined) {\n    uniforms.cameraPositionWorld = opts.cameraPositionWorld;\n  }\n\n  // COMPOSITE UNIFORMS\n  if (opts.projectionMatrix !== undefined && opts.viewMatrix !== undefined) {\n    uniforms.viewProjectionMatrix = new Matrix4(opts.projectionMatrix).multiplyRight(\n      opts.viewMatrix\n    );\n  }\n\n  return uniforms;\n}\n\nconst common = /* glsl */ `\\\nvarying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n`;\n\nconst vs = `\\\n${common}\n\n// Unprefixed uniforms\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n`;\n\nconst fs = `\n${common}\\\n`;\n\n/**\n * Projects coordinates\n */\nexport const project = {\n  name: 'project',\n  getUniforms,\n  vs,\n  fs\n} as const satisfies ShaderModule<ProjectionProps, ProjectionProps>;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const lightingShader = /* glsl */ `\\\n#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n\n // Constant-Linear-Exponential\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumberArray} from '../../../types';\nimport {lightingShader} from './lights-glsl';\n\n/* eslint-disable camelcase */\n\ntype LightSources = {\n  ambientLight?: {\n    color: Readonly<NumberArray>;\n    intensity: number;\n  };\n  pointLights?: {\n    color: Readonly<NumberArray>;\n    intensity: number;\n    position: NumberArray;\n    attenuation: number;\n  }[];\n  directionalLights?: {\n    color: Readonly<NumberArray>;\n    intensity: number;\n    position: NumberArray;\n    direction: NumberArray;\n  }[];\n};\n\nexport type LightsOptions = {\n  lightSources?: LightSources;\n};\n\nconst INITIAL_MODULE_OPTIONS: Required<LightsOptions> = {\n  lightSources: {}\n};\n\n// Take color 0-255 and intensity as input and output 0.0-1.0 range\nfunction convertColor(\n  colorDef: {color?: Readonly<NumberArray>; intensity?: number} = {}\n): NumberArray {\n  const {color = [0, 0, 0], intensity = 1.0} = colorDef;\n  return color.map(component => (component * intensity) / 255.0);\n}\n\nfunction getLightSourceUniforms({\n  ambientLight,\n  pointLights = [],\n  directionalLights = []\n}: LightSources): Record<string, any> {\n  const lightSourceUniforms: Record<string, any> = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);\n    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;\n    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [\n      1, 0, 0\n    ];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] =\n      convertColor(directionalLight);\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] =\n      directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n\n  return lightSourceUniforms;\n}\n\n// eslint-disable-next-line complexity\nfunction getUniforms(opts: LightsOptions = INITIAL_MODULE_OPTIONS): Record<string, any> {\n  // Specify lights separately\n  if ('lightSources' in opts) {\n    const {ambientLight, pointLights, directionalLights} = opts.lightSources || {};\n    const hasLights =\n      ambientLight ||\n      (pointLights && pointLights.length > 0) ||\n      (directionalLights && directionalLights.length > 0);\n\n    if (!hasLights) {\n      return {lighting_uEnabled: false};\n    }\n\n    return Object.assign(\n      {},\n      getLightSourceUniforms({ambientLight, pointLights, directionalLights}),\n      {\n        lighting_uEnabled: true\n      }\n    );\n  }\n\n  // Support for array of lights. Type of light is detected by type field\n  if ('lights' in opts) {\n    const lightSources: LightSources = {pointLights: [], directionalLights: []};\n    // @ts-expect-error\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          // Note: Only uses last ambient light\n          // TODO - add ambient light sources on CPU?\n          lightSources.ambientLight = light;\n          break;\n        case 'directional':\n          lightSources.directionalLights?.push(light);\n          break;\n        case 'point':\n          lightSources.pointLights?.push(light);\n          break;\n        default:\n        // eslint-disable-next-line\n        // console.warn(light.type);\n      }\n    }\n\n    // Call the `opts.lightSources`` version\n    return getUniforms({lightSources});\n  }\n\n  return {};\n}\n\n/**\n * An implementation of PBR (Physically-Based Rendering).\n * Physically Based Shading of a microfacet surface defined by a glTF material.\n */\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport type {NumericArray} from '../../../types';\nimport {project} from '../../project/project';\n\n/* eslint-disable camelcase */\n\nexport type DirlightOptions = {\n  lightDirection?: NumericArray;\n};\n\nconst DEFAULT_MODULE_OPTIONS: Required<DirlightOptions> = {\n  lightDirection: new Float32Array([1, 1, 2])\n};\n\nfunction getUniforms(opts: DirlightOptions = DEFAULT_MODULE_OPTIONS): Record<string, any> {\n  const uniforms = {};\n  if (opts.lightDirection) {\n    // @ts-expect-error TODO add types\n    uniforms.dirlight_uLightDirection = opts.lightDirection;\n  }\n  return uniforms;\n}\n\nconst fs = /* glsl */ `\\\nuniform vec3 dirlight_uLightDirection;\n\n/*\n * Returns color attenuated by angle from light source\n */\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n`;\n\n/**\n * Cheap lighting - single directional light, single dot product, one uniform\n */\nexport const dirlight: ShaderModule = {\n  name: 'dirlight',\n  // vs // TODO - reuse normal from geometry module\n  fs,\n  getUniforms,\n  dependencies: [project]\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const lightingShader = /* glsl */ `\\\n\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {lights} from '../lights/lights';\nimport {lightingShader} from './phong-lighting-glsl';\n\n/* eslint-disable camelcase */\n\nexport type PhongLightingProps = {\n  ambient?: number;\n  diffuse?: number;\n  shininess?: number;\n  specularColor?: [number, number, number];\n};\n\nconst INITIAL_MODULE_OPTIONS: {material?: PhongLightingProps} = {};\n\nfunction getMaterialUniforms(material: PhongLightingProps) {\n  const {ambient = 0.35, diffuse = 0.6, shininess = 32, specularColor = [30, 30, 30]} = material;\n\n  return {\n    lighting_uAmbient: ambient,\n    lighting_uDiffuse: diffuse,\n    lighting_uShininess: shininess,\n    lighting_uSpecularColor: specularColor.map(x => x / 255)\n  };\n}\n\nfunction getUniforms(\n  opts: {material?: PhongLightingProps} = INITIAL_MODULE_OPTIONS\n): Record<string, any> {\n  if (!('material' in opts)) {\n    return {};\n  }\n\n  const {material} = opts;\n\n  if (!material) {\n    return {lighting_uEnabled: false};\n  }\n\n  return getMaterialUniforms(material);\n}\n\nexport const gouraudLighting = {\n  name: 'gouraud-lighting',\n  dependencies: [lights],\n  vs: lightingShader,\n  defines: {\n    LIGHTING_VERTEX: 1\n  },\n  getUniforms\n};\n\nexport const phongLighting = {\n  name: 'phong-lighting',\n  dependencies: [lights],\n  fs: lightingShader,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  getUniforms\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const vs = /* glsl */ `\\\nuniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\nout vec3 pbr_vPosition;\nout vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nout mat3 pbr_vTBN;\n# else\nout vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = u_ModelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else // HAS_TANGENTS != 1\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Attribution:\n// MIT license, Copyright (c) 2016-2017 Mohamad Moneimne and Contributors\n\n// This fragment shader defines a reference implementation for Physically Based Shading of\n// a microfacet surface material defined by a glTF model.\n//\n\n// TODO - better do the checks outside of shader\n\nexport const fs = /* glsl */ `\\\nprecision highp float;\n\nuniform bool pbr_uUnlit;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n\n// debugging flags used for shader output of intermediate PBR variables\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nin vec3 pbr_vPosition;\n\nin vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nin mat3 pbr_vTBN;\n#else\nin vec3 pbr_vNormal;\n#endif\n#endif\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo\n{\n  float NdotL;                  // cos angle between normal and light direction\n  float NdotV;                  // cos angle between normal and view direction\n  float NdotH;                  // cos angle between normal and half vector\n  float LdotH;                  // cos angle between light direction and half vector\n  float VdotH;                  // cos angle between view direction and half vector\n  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n  float metalness;              // metallic value at the surface\n  vec3 reflectance0;            // full reflectance color (normal incidence angle)\n  vec3 reflectance90;           // reflectance color at grazing angle\n  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n  vec3 diffuseColor;            // color contribution from diffuse lighting\n  vec3 specularColor;           // color contribution from specular lighting\n  vec3 n;                       // normal at surface point\n  vec3 v;                       // vector from surface point to camera\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else //SRGB_FAST_APPROXIMATION\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif //SRGB_FAST_APPROXIMATION\n  return vec4(linOut,srgbIn.w);;\n#else //MANUAL_SRGB\n  return srgbIn;\n#endif //MANUAL_SRGB\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n  // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else // HAS_TANGENTS\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture(u_NormalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  // The tbn matrix is linearly interpolated, so we need to re-normalize\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0; // resolution of 512x512\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\n  // retrieve a scale and bias to F0. See [1], Figure 3\n  vec3 brdf = SRGBtoLINEAR(texture(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n\n  // For presentation, this allows us to disable IBL terms\n  diffuse *= u_ScaleIBLAmbient.x;\n  specular *= u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n// Basic Lambertian diffuse\n// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog\n// See also [1], Equation 1\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n// This calculates the specular geometric attenuation (aka G()),\n// where rougher material will reflect less light back to the viewer.\n// This implementation is based on [1] Equation 4, and we adopt their modifications to\n// alphaRoughness as input as originally proposed in [2].\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float r = pbrInputs.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n// The following equation(s) model the distribution of microfacet normals across\n// the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface\n// for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes\n// from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL = 1.0;\n  pbrInputs.NdotH = 0.0;\n  pbrInputs.LdotH = 0.0;\n  pbrInputs.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 l = normalize(lightDirection);             // Vector from surface point to light\n  vec3 h = normalize(l+v);                        // Half vector between both l and v\n\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  // Calculate the shading terms for the microfacet specular shading model\n  vec3 F = specularReflection(pbrInputs);\n  float G = geometricOcclusion(pbrInputs);\n  float D = microfacetDistribution(pbrInputs);\n\n  // Calculation of analytical lighting contribution\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n  // The albedo may be defined from a base texture or a flat color\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor = u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbr_uUnlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    float perceptualRoughness = u_MetallicRoughnessValues.y;\n    float metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    vec4 mrSample = texture(u_MetallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    // For typical incident reflectance range (between 4% to 100%) set the grazing\n    // reflectance to 100% for typical fresnel effect.\n    // For very low reflectance range on highly diffuse objects (below 4%),\n    // incrementally reduce grazing reflecance to 0%.\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();                          // normal at surface point\n    vec3 v = normalize(u_Camera - pbr_vPosition);  // Vector from surface point to camera\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInputs = PBRInfo(\n      0.0, // NdotL\n      NdotV,\n      0.0, // NdotH\n      0.0, // LdotH\n      0.0, // VdotH\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n#ifdef USE_LIGHTS\n    // Apply ambient light\n    PBRInfo_setAmbientLight(pbrInputs);\n    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n\n    // Apply directional light\n    for(int i = 0; i < lighting_uDirectionalLightCount; i++) {\n      if (i < lighting_uDirectionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n      }\n    }\n\n    // Apply point light\n    for(int i = 0; i < lighting_uPointLightCount; i++) {\n      if (i < lighting_uPointLightCount) {\n        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n      }\n    }\n#endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n    color += getIBLContribution(pbrInputs, n, reflection);\n#endif\n\n    // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSIONMAP\n    float ao = texture(u_OcclusionSampler, pbr_vUV).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    vec3 emissive = SRGBtoLINEAR(texture(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n    // This section uses mix to override final color for reference app visualization\n    // of various parameters in the lighting equation.\n#ifdef PBR_DEBUG\n    // TODO: Figure out how to debug multiple lights\n\n    // color = mix(color, F, u_ScaleFGDSpec.x);\n    // color = mix(color, vec3(G), u_ScaleFGDSpec.y);\n    // color = mix(color, vec3(D), u_ScaleFGDSpec.z);\n    // color = mix(color, specContrib, u_ScaleFGDSpec.w);\n\n    // color = mix(color, diffuseContrib, u_ScaleDiffBaseMR.x);\n    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n`;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {lights} from '../lights/lights';\n\nimport {vs} from './pbr-vertex-glsl';\nimport {fs} from './pbr-fragment-glsl';\n\n/**\n * An implementation of PBR (Physically-Based Rendering).\n * Physically Based Shading of a microfacet surface defined by a glTF material.\n */\nexport const pbr = {\n  name: 'pbr',\n  vs,\n  fs,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  dependencies: [lights],\n  getUniforms: (props: any) => props\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;mBAAAA;EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACMM,SAAU,OAAO,WAAoB,SAAgB;AACzD,MAAI,CAAC,WAAW;AACd,UAAM,IAAI,MAAM,WAAW,gCAAgC;EAC7D;AACF;;;AC6BA,IAAM,0BAAyD;EAC7D,QAAQ;IACN,MAAM;IACN,SAAS,OAAgB,UAAkB;AACzC,aACE,OAAO,SAAS,KAAK,KACrB,OAAO,aAAa,aACnB,SAAS,QAAQ,UAAc,SAAoB,SAAS,SAC5D,SAAS,QAAQ,UAAc,SAAoB,SAAS;IAEjE;;EAEF,OAAO;IACL,MAAM;IACN,SAAS,OAAgB,UAAkB;AACzC,aAAO,MAAM,QAAQ,KAAK,KAAK,YAAY,OAAO,KAAK;IACzD;;;AAUE,SAAU,mBACd,WAAmC;AAEnC,QAAM,iBAAgD,CAAA;AACtD,aAAW,CAAC,MAAM,QAAQ,KAAK,OAAO,QAAQ,SAAS,GAAG;AACxD,mBAAe,IAAI,IAAI,kBAAkB,QAAQ;EACnD;AACA,SAAO;AACT;AASM,SAAU,uBACd,YACA,gBACA,cAAoB;AAEpB,QAAM,YAAqC,CAAA;AAE3C,aAAW,CAAC,KAAK,cAAc,KAAK,OAAO,QAAQ,cAAc,GAAG;AAClE,QAAI,cAAc,OAAO,cAAc,CAAC,eAAe,SAAS;AAC9D,UAAI,eAAe,UAAU;AAC3B,eACE,eAAe,SAAS,WAAW,GAAG,GAAG,cAAc,GACvD,GAAG,yBAAyB,KAAK;MAErC;AACA,gBAAU,GAAG,IAAI,WAAW,GAAG;IACjC,OAAO;AAEL,gBAAU,GAAG,IAAI,eAAe;IAClC;EACF;AAIA,SAAO;AACT;AAOA,SAAS,kBAAkB,UAAkB;AAC3C,MAAI,OAAO,UAAU,QAAQ;AAE7B,MAAI,SAAS,UAAU;AACrB,WAAO,EAAC,OAAO,UAAU,GAAG,wBAAwB,IAAI,GAAG,KAAI;EACjE;AAGA,MAAI,OAAO,aAAa,UAAU;AAChC,QAAI,CAAC,UAAU;AACb,aAAO,EAAC,MAAM,UAAU,OAAO,KAAI;IACrC;AACA,QAAI,SAAS,SAAS,QAAW;AAC/B,aAAO,EAAC,GAAG,UAAU,GAAG,wBAAwB,SAAS,IAAI,GAAG,MAAM,SAAS,KAAI;IACrF;AAEA,QAAI,SAAS,UAAU,QAAW;AAChC,aAAO,EAAC,MAAM,UAAU,OAAO,SAAQ;IACzC;AAEA,WAAO,UAAU,SAAS,KAAK;AAC/B,WAAO,EAAC,GAAG,UAAU,GAAG,wBAAwB,IAAI,GAAG,KAAI;EAC7D;AAEA,QAAM,IAAI,MAAM,OAAO;AACzB;AAKA,SAAS,UAAU,OAAc;AAC/B,MAAI,MAAM,QAAQ,KAAK,KAAK,YAAY,OAAO,KAAK,GAAG;AACrD,WAAO;EACT;AACA,SAAO,OAAO;AAChB;;;ACjJO,IAAM;;EAAiC;;;;;AAMvC,IAAM;;EAAiC;;;;;;;;;;;;;;;;;;;;;;;;ACF9C,IAAM,mBAAmB;EACvB,QAAQ;EACR,UAAU;;AAGZ,IAAM,sBAAsB;AAC5B,IAAM,oBAAoB;AAC1B,IAAM,YAAsB,CAAA;AAErB,IAAM,4BAA4B;AAqBnC,SAAU,oBACd,YAAoD;AAEpD,QAAM,SAA2B,EAAC,QAAQ,CAAA,GAAI,UAAU,CAAA,EAAE;AAE1D,aAAW,QAAQ,YAAY;AAC7B,QAAI,YAAY,WAAW,IAAI;AAC/B,UAAM,QAAQ,aAAa,IAAI;AAC/B,QAAI,OAAO,cAAc,UAAU;AACjC,kBAAY;QACV,OAAO;QACP;;IAEJ;AAEA,WAAO,KAAK,EAAE,IAAI,IAAI;EACxB;AAEA,SAAO;AACT;AAEA,SAAS,aAAa,MAAY;AAChC,QAAM,OAAO,KAAK,MAAM,GAAG,CAAC;AAC5B,UAAQ,MAAM;IACZ,KAAK;AACH,aAAO;IACT,KAAK;AACH,aAAO;IACT;AACE,YAAM,IAAI,MAAM,IAAI;EACxB;AACF;AAYM,SAAU,aACd,QACA,OACA,QACA,sBAAsB,OAAK;AAE3B,QAAM,WAAW,UAAU;AAE3B,aAAW,OAAO,QAAQ;AACxB,UAAM,eAAe,OAAO,GAAG;AAC/B,iBAAa,KAAK,CAAC,GAAoB,MAA+B,EAAE,QAAQ,EAAE,KAAK;AACvF,cAAU,SAAS,aAAa;AAChC,aAAS,IAAI,GAAG,MAAM,aAAa,QAAQ,IAAI,KAAK,EAAE,GAAG;AACvD,gBAAU,CAAC,IAAI,aAAa,CAAC,EAAE;IACjC;AACA,UAAM,iBAAiB,GAAG,UAAU,KAAK,IAAI;;AAC7C,YAAQ,KAAK;MAEX,KAAK;AACH,YAAI,UAAU;AACZ,mBAAS,OAAO,QAAQ,2BAA2B,cAAc;QACnE;AACA;MAEF,KAAK;AACH,YAAI,UAAU;AACZ,mBAAS,OAAO,QAAQ,qBAAqB,CAAC,UAAkB,QAAQ,cAAc;QACxF;AACA;MAEF,KAAK;AACH,YAAI,UAAU;AACZ,mBAAS,OAAO,QAAQ,mBAAmB,CAAC,UAAkB,iBAAiB,KAAK;QACtF;AACA;MAEF,KAAK;AACH,YAAI,CAAC,UAAU;AACb,mBAAS,OAAO,QAAQ,2BAA2B,cAAc;QACnE;AACA;MAEF,KAAK;AACH,YAAI,CAAC,UAAU;AACb,mBAAS,OAAO,QAAQ,qBAAqB,CAAC,UAAkB,QAAQ,cAAc;QACxF;AACA;MAEF,KAAK;AACH,YAAI,CAAC,UAAU;AACb,mBAAS,OAAO,QAAQ,mBAAmB,CAAC,UAAkB,iBAAiB,KAAK;QACtF;AACA;MAEF;AAIE,iBAAS,OAAO,QAAQ,KAAK,CAAC,UAAkB,QAAQ,cAAc;IAC1E;EACF;AAGA,WAAS,OAAO,QAAQ,2BAA2B,EAAE;AAGrD,MAAI,qBAAqB;AACvB,aAAS,OAAO,QAAQ,UAAU,CAAC,UAAkB,QAAQ,iBAAiB,KAAK,CAAC;EACtF;AAEA,SAAO;AACT;AAGM,SAAU,eAAe,SAAc;AAC3C,QAAM,SAAiC,CAAA;AACvC,SAAO,MAAM,QAAQ,OAAO,KAAK,QAAQ,SAAS,CAAC;AACnD,UAAQ,QAAQ,YAAS;AACvB,eAAW,OAAO,QAAQ;AACxB,aAAO,GAAG,IAAI,OAAO,GAAG,IAAI,GAAG,OAAO,GAAG;EAAM,OAAO,GAAG,MAAM,OAAO,GAAG;IAC3E;EACF,CAAC;AACD,SAAO;AACT;;;AC/DM,SAAU,wBAAwB,SAAuB;AAC7D,UAAQ,IAAI,CAACC,YAAyB,uBAAuBA,OAAM,CAAC;AACtE;AAEM,SAAU,uBAAuBA,SAAoB;AACzD,MAAIA,QAAO,UAAU;AACnB;EACF;AAEA,0BAAwBA,QAAO,gBAAgB,CAAA,CAAE;AAEjD,QAAM;IACJ,YAAY,CAAA;IACZ,eAAe,CAAA;;IAEf,SAAS,CAAA;EAAE,IACTA;AAEJ,QAAM,WAA+C;IACnD,sBAAsB,oBAAoB,MAAM;IAChD,oBAAoB,4BAA4B,YAAY;;AAG9D,MAAI,WAAW;AACb,aAAS,iBAAiB,mBAAmB,SAAS;EACxD;AAEA,EAAAA,QAAO,WAAW;AAGlB,MAAI,eAAsC,CAAA;AAC1C,MAAI,WAAW;AACb,mBAAe,OAAO,QAAQ,SAAS,EAAE,OACvC,CAAC,KAA4B,CAAC,KAAK,QAAQ,MAAK;AAE9C,YAAM,QAAQ,qCAAU;AACxB,UAAI,OAAO;AAET,YAAI,GAAG,IAAI;MACb;AACA,aAAO;IACT,GACA,CAAA,CAA2B;EAE/B;AAEA,EAAAA,QAAO,kBAAkB,EAAC,GAAGA,QAAO,iBAAiB,GAAG,aAAY;AACtE;AAGM,SAAU,wBAGdA,SACA,OACA,aAAuC;AA5JzC;AA8JE,yBAAuBA,OAAM;AAE7B,QAAM,WAAW,eAAe,EAAC,GAAGA,QAAO,gBAAe;AAE1D,MAAI,SAASA,QAAO,aAAa;AAC/B,WAAOA,QAAO,YAAY,OAAO,QAAQ;EAC3C;AAIA,SAAO,uBAAuB,QAAO,KAAAA,QAAO,aAAP,mBAAiB,gBAAgBA,QAAO,IAAI;AACnF;AAwBM,SAAU,8BACd,cACA,cACAC,MAAQ;AApMV;AAsME,qBAAa,iBAAb,mBAA2B,QAAQ,SAAM;AAtM3C,QAAAC;AAuMI,SAAIA,MAAA,IAAI,UAAJ,gBAAAA,IAAW,KAAK,eAAe;AACjC,UAAI,IAAI,YAAY;AAClB,QAAAD,KAAI,WAAW,IAAI,KAAK,IAAI,GAAG,EAAC;MAClC,OAAO;AACL,QAAAA,KAAI,QAAQ,IAAI,KAAK,IAAI,GAAG,EAAC;MAC/B;IACF;EACF;AACF;AAIA,SAAS,4BAA4B,cAAuC;AAC1E,eAAa,QAAQ,SAAM;AACzB,YAAQ,IAAI,MAAM;MAChB,KAAK;AACH,YAAI,QAAQ,IAAI,OAAO,MAAM,IAAI,QAAQ;AACzC;MACF;AACE,YAAI,QAAQ,IAAI,OAAO,GAAG,IAAI,QAAQ,IAAI,MAAM;IACpD;EACF,CAAC;AAED,SAAO;AACT;;;ACtMM,SAAU,4BAAsD,SAAY;AAChF,0BAAwB,OAAO;AAC/B,QAAM,YAA+B,CAAA;AACrC,QAAM,cAAsC,CAAA;AAC5C,qBAAmB,EAAC,SAAS,OAAO,GAAG,WAAW,YAAW,CAAC;AAG9D,QAAM,eAAe,OAAO,KAAK,WAAW,EACzC,KAAK,CAAC,GAAG,MAAM,YAAY,CAAC,IAAI,YAAY,CAAC,CAAC,EAC9C,IAAI,UAAQ,UAAU,IAAI,CAAC;AAC9B,0BAAwB,YAAY;AACpC,SAAO;AACT;AAYM,SAAU,mBAA6C,SAK5D;AACC,QAAM,EAAC,SAAS,OAAO,WAAW,YAAW,IAAI;AACjD,MAAI,SAAS,GAAG;AACd,UAAM,IAAI,MAAM,0CAA0C;EAC5D;AAGA,aAAWE,WAAU,SAAS;AAC5B,cAAUA,QAAO,IAAI,IAAIA;AACzB,QAAI,YAAYA,QAAO,IAAI,MAAM,UAAa,YAAYA,QAAO,IAAI,IAAI,OAAO;AAC9E,kBAAYA,QAAO,IAAI,IAAI;IAC7B;EACF;AAGA,aAAWA,WAAU,SAAS;AAC5B,QAAIA,QAAO,cAAc;AACvB,yBAAmB,EAAC,SAASA,QAAO,cAAc,OAAO,QAAQ,GAAG,WAAW,YAAW,CAAC;IAC7F;EACF;AACF;AAcM,SAAU,sBAAsB,SAAuB;AAC3D,0BAAwB,OAAO;AAC/B,QAAM,YAA0C,CAAA;AAChD,QAAM,cAAsC,CAAA;AAC5C,qBAAmB,EAAC,SAAS,OAAO,GAAG,WAAW,YAAW,CAAC;AAG9D,YAAU,OAAO,KAAK,WAAW,EAC9B,KAAK,CAAC,GAAG,MAAM,YAAY,CAAC,IAAI,YAAY,CAAC,CAAC,EAC9C,IAAI,UAAQ,UAAU,IAAI,CAAC;AAC9B,0BAAwB,OAAO;AAC/B,SAAO;AACT;AAQM,SAAU,eAAe,SAAuB;AACpD,SAAO,sBAAsB,OAAO;AACtC;;;ACvGM,SAAU,yBAAyB,cAA0B;AACjE,UAAQ,6CAAc,IAAI,eAAe;IACvC,KAAK;AACH;;QAAkB;;;;;;;;IASpB,KAAK;AACH;;QAAkB;;;;;IAMpB,KAAK;AACH;;QAAkB;;;;;;;;;IAUpB,KAAK;AAEH;;QAAkB;;;IAIpB;AAIE;;QAAkB;;;;;;;;;EAStB;AACF;;;AC5CM,SAAU,oBAAoB,QAAgB,OAA4B;AAbhF;AAcE,QAAM,oBAAoB,SAAO,YAAO,MAAM,uBAAuB,MAApC,mBAAwC,OAAM,GAAG;AAClF,MAAI,sBAAsB,KAAK;AAE7B,UAAM,IAAI,MAAM,mDAAmD;EACrE;AAEA,UAAQ,OAAO;IACb,KAAK;AACH,eAAS,cAAc,QAAQ,yBAAyB;AACxD,aAAO;IACT,KAAK;AACH,eAAS,cAAc,QAAQ,2BAA2B;AAC1D,aAAO;IACT;AAEE,YAAM,IAAI,MAAM,KAAK;EACzB;AACF;AAKA,IAAM,qBAAwC;;EAE5C,CAAC,+CAA+C,mBAAmB;;EAEnE,CAAC,yCAAyC,aAAa;EACvD,CAAC,sCAAsC,UAAU;;AAGnD,IAAM,4BAA+C;EACnD,GAAG;;EAEH,CAAC,uBAAuB,WAAW,GAAG,OAAO;;EAE7C,CAAC,uBAAuB,SAAS,GAAG,QAAQ;;AAI9C,IAAM,8BAAiD;EACrD,GAAG;;EAEH,CAAC,uBAAuB,SAAS,GAAG,OAAO;;AAG7C,SAAS,cAAc,QAAgB,cAA+B;AACpE,aAAW,CAAC,SAAS,WAAW,KAAK,cAAc;AACjD,aAAS,OAAO,QAAQ,SAAS,WAAW;EAC9C;AACA,SAAO;AACT;AAWA,SAAS,uBAAuB,WAAiD;AAC/E,SAAO,IAAI,OAAO,MAAM,mDAAmD,GAAG;AAChF;;;ACtCM,SAAU,eACd,eACA,gBAAiD;AAEjD,MAAI,SAAS;AACb,aAAW,YAAY,eAAe;AACpC,UAAM,eAAe,cAAc,QAAQ;AAC3C,cAAU,QAAQ,aAAa;;AAC/B,QAAI,aAAa,QAAQ;AACvB,gBAAU,KAAK,aAAa;IAC9B;AACA,QAAI,eAAe,QAAQ,GAAG;AAC5B,YAAM,aAAa,eAAe,QAAQ;AAC1C,iBAAW,KAAK,CAAC,GAAoB,MAA+B,EAAE,QAAQ,EAAE,KAAK;AACrF,iBAAW,aAAa,YAAY;AAClC,kBAAU,KAAK,UAAU;;MAC3B;IACF;AACA,QAAI,aAAa,QAAQ;AACvB,gBAAU,KAAK,aAAa;IAC9B;AACA,cAAU;EACZ;AAEA,SAAO;AACT;AAMM,SAAU,qBAAqB,eAAsC;AACzE,QAAM,SAAsB,EAAC,QAAQ,CAAA,GAAI,UAAU,CAAA,EAAE;AAErD,aAAW,gBAAgB,eAAe;AACxC,QAAI;AACJ,QAAI;AACJ,QAAI,OAAO,iBAAiB,UAAU;AACpC,aAAO;AACP,aAAO,KAAK;IACd,OAAO;AACL,aAAO,CAAA;AACP,aAAO;IACT;AACA,WAAO,KAAK,KAAI;AAChB,UAAM,CAAC,aAAa,SAAS,IAAI,KAAK,MAAM,GAAG;AAC/C,UAAM,OAAO,KAAK,QAAQ,QAAQ,EAAE;AACpC,UAAM,iBAA6B,OAAO,OAAO,MAAM,EAAC,UAAS,CAAC;AAClE,YAAQ,aAAa;MACnB,KAAK;AACH,eAAO,OAAO,IAAI,IAAI;AACtB;MACF,KAAK;AACH,eAAO,SAAS,IAAI,IAAI;AACxB;MACF;AACE,cAAM,IAAI,MAAM,WAAW;IAC/B;EACF;AAEA,SAAO;AACT;;;ACxFM,SAAU,cAAc,QAAgB,aAAoB;AAChE,SAAO;IACL,MAAM,cAAc,QAAQ,WAAW;IACvC,UAAU;IACV,SAAS,iBAAiB,MAAM;;AAEpC;AAGA,SAAS,cAAc,QAAgB,cAAsB,WAAS;AACpE,QAAM,qBAAqB;AAC3B,QAAM,QAAQ,mBAAmB,KAAK,MAAM;AAC5C,SAAO,QAAQ,MAAM,CAAC,IAAI;AAC5B;AAGA,SAAS,iBAAiB,QAAc;AACtC,MAAI,UAAU;AACd,QAAM,QAAQ,OAAO,MAAM,SAAS;AACpC,MAAI,SAAS,MAAM,UAAU,KAAK,MAAM,CAAC,MAAM,YAAY;AACzD,UAAM,gBAAgB,SAAS,MAAM,CAAC,GAAG,EAAE;AAC3C,QAAI,OAAO,SAAS,aAAa,GAAG;AAClC,gBAAU;IACZ;EACF;AACA,MAAI,YAAY,OAAO,YAAY,KAAK;AACtC,UAAM,IAAI,MAAM,wBAAwB,SAAS;EACnD;AACA,SAAO;AACT;;;ACtBA,IAAM,6BAA6B;;EAAO;;AAM1C,IAAM;;EAAsC;;;AAkEtC,SAAU,mBACd,SAGC;AAKD,QAAM,UAAU,4BAA4B,QAAQ,WAAW,CAAA,CAAE;AAEjE,SAAO;IACL,QAAQ,mBAAmB,QAAQ,cAAc;MAC/C,GAAG;MACH,QAAQ,QAAQ;MAChB,OAAO;MACP;KACD;IACD,aAAa,oBAAoB,OAAO;;AAE5C;AAKM,SAAU,uBACd,SAKC;AAMD,QAAM,EAAC,IAAAC,KAAI,IAAAC,IAAE,IAAI;AACjB,QAAM,UAAU,4BAA4B,QAAQ,WAAW,CAAA,CAAE;AAEjE,SAAO;IACL,IAAI,mBAAmB,QAAQ,cAAc;MAC3C,GAAG;MACH,QAAQD;MACR,OAAO;MACP;KACD;IACD,IAAI,mBAAmB,QAAQ,cAAc;MAC3C,GAAG;;MAEH,QAAQC;MACR,OAAO;MACP;KACD;IACD,aAAa,oBAAoB,OAAO;;AAE5C;AASM,SAAU,mBAAmB,cAA4B,SAA6B;AA5J5F;AA6JE,QAAM;;IAEJ;IACA;IACA;;IAEA,gBAAgB,CAAA;IAChB,SAAS,CAAA;IACT,KAAAC;EAAG,IACD;AAEJ,SAAO,OAAO,WAAW,UAAU,gCAAgC;AAKnE,QAAM,aAAa;AAYnB,MAAI,kBAAkB;AAWtB,QAAM,kBAAkB,qBAAqB,aAAa;AAG1D,QAAM,iBAAoD,CAAA;AAC1D,QAAM,iBAAoD,CAAA;AAC1D,QAAM,iBAAoD,CAAA;AAE1D,aAAW,OAAO,QAAQ;AACxB,UAAM,YACJ,OAAO,OAAO,GAAG,MAAM,WAAW,EAAC,WAAW,OAAO,GAAG,GAAG,OAAO,EAAC,IAAI,OAAO,GAAG;AACnF,UAAM,QAAQ,wBAAwB,KAAK,GAAG;AAC9C,QAAI,OAAO;AACT,YAAM,OAAO,MAAM,CAAC;AACpB,YAAM,OAAO,MAAM,CAAC;AACpB,UAAI,MAAM;AACR,YAAI,SAAS,QAAQ;AACnB,yBAAe,GAAG,IAAI,CAAC,SAAgB;QACzC,OAAO;AACL,yBAAe,GAAG,IAAI,CAAC,SAAgB;QACzC;MACF,OAAO;AACL,uBAAe,GAAG,IAAI,CAAC,SAAgB;MACzC;IACF,OAAO;AAEL,qBAAe,GAAG,IAAI,CAAC,SAAgB;IACzC;EACF;AAGA,QAAM,kBAAkB;AAExB,aAAWC,WAAU,iBAAiB;AACpC,QAAID,MAAK;AACP,oCAA8BC,SAAQ,YAAYD,IAAG;IACvD;AACA,UAAM,eAAe,sBAAsBC,SAAQ,MAAM;AAEzD,uBAAmB;AAEnB,UAAM,eAAa,KAAAA,QAAO,eAAP,mBAAoB,WAAU,CAAA;AACjD,eAAW,OAAO,YAAY;AAC5B,YAAM,QAAQ,qBAAqB,KAAK,GAAG;AAC3C,UAAI,OAAO;AACT,cAAM,OAAO,MAAM,CAAC;AACpB,cAAM,gBAAgB,SAAS,SAAS,iBAAiB;AACzD,sBAAc,GAAG,IAAI,cAAc,GAAG,KAAK,CAAA;AAC3C,sBAAc,GAAG,EAAE,KAAK,WAAW,GAAG,CAAC;MACzC,OAAO;AACL,uBAAe,GAAG,IAAI,eAAe,GAAG,KAAK,CAAA;AAC7C,uBAAe,GAAG,EAAE,KAAK,WAAW,GAAG,CAAC;MAC1C;IACF;EACF;AAGA,qBAAmB;AAEnB,oBAAkB,aAAa,iBAAiB,OAAO,cAAc;AAErE,qBAAmB,eAAe,gBAAgB,KAAK,GAAG,cAAc;AAGxE,qBAAmB;AAGnB,oBAAkB,aAAa,iBAAiB,OAAO,cAAc;AAErE,SAAO;AACT;AASA,SAAS,mBACP,cACA,SAWC;AA/RH;AAiSE,QAAM,EACJ,IACA,QACA,OACA,WAAW,QACX,SACA,UAAU,CAAA,GACV,gBAAgB,CAAA,GAChB,SAAS,CAAA,GACT,WAAW,MACX,KAAAD,KAAG,IACD;AAEJ,SAAO,OAAO,WAAW,UAAU,gCAAgC;AAEnE,QAAM,gBAAgB,aAAa,SAAS,cAAc,MAAM,EAAE,UAAU;AAC5E,QAAM,gBAAgB,aAAa;AAEnC,QAAM,yBAAyB,kBAAkB,MAAM,iBAAiB;AAExE,QAAM,cAAc,OAAO,MAAM,IAAI;AAErC,QAAM,aAAa,YAAY,MAAM,CAAC,EAAE,KAAK,IAAI;AAGjD,QAAM,aAAa,CAAA;AACnB,UAAQ,QAAQ,CAAAC,YAAS;AACvB,WAAO,OAAO,YAAYA,QAAO,OAAO;EAC1C,CAAC;AACD,SAAO,OAAO,YAAY,OAAO;AAKjC,MAAI,kBAAkB;AACtB,UAAQ,UAAU;IAChB,KAAK;AACH;IACF,KAAK;AACH,wBAAkB,WACd,GACR;;;EAGA,oBAAoB,EAAC,IAAI,QAAQ,MAAK,CAAC;EACvC,uBAAuB,MAAM,YAAW;;EAExC,yBAAyB,YAAY;EACrC,UAAU,aAAa,2BAA2B;;;;EAIlD,sBAAsB,UAAU;;IAGxB,GAAG;;AAEP;EACJ;AAEA,QAAM,kBAAkB,qBAAqB,aAAa;AAG1D,QAAM,iBAAoD,CAAA;AAC1D,QAAM,iBAAoD,CAAA;AAC1D,QAAM,iBAAoD,CAAA;AAE1D,aAAW,OAAO,QAAQ;AACxB,UAAM,YACJ,OAAO,OAAO,GAAG,MAAM,WAAW,EAAC,WAAW,OAAO,GAAG,GAAG,OAAO,EAAC,IAAI,OAAO,GAAG;AACnF,UAAM,QAAQ,wBAAwB,KAAK,GAAG;AAC9C,QAAI,OAAO;AACT,YAAM,OAAO,MAAM,CAAC;AACpB,YAAM,OAAO,MAAM,CAAC;AACpB,UAAI,MAAM;AACR,YAAI,SAAS,QAAQ;AACnB,yBAAe,GAAG,IAAI,CAAC,SAAS;QAClC,OAAO;AACL,yBAAe,GAAG,IAAI,CAAC,SAAS;QAClC;MACF,OAAO;AACL,uBAAe,GAAG,IAAI,CAAC,SAAS;MAClC;IACF,OAAO;AAEL,qBAAe,GAAG,IAAI,CAAC,SAAS;IAClC;EACF;AAEA,aAAWA,WAAU,SAAS;AAC5B,QAAID,MAAK;AACP,oCAA8BC,SAAQ,YAAYD,IAAG;IACvD;AACA,UAAM,eAAe,sBAAsBC,SAAQ,KAAK;AAExD,uBAAmB;AAEnB,UAAM,eAAa,KAAAA,QAAO,aAAP,mBAAiB,qBAAqB,WAAU,CAAA;AACnE,eAAW,OAAO,YAAY;AAC5B,YAAM,QAAQ,qBAAqB,KAAK,GAAG;AAC3C,UAAI,OAAO;AACT,cAAM,OAAO,MAAM,CAAC;AACpB,cAAM,gBAAgB,SAAS,SAAS,iBAAiB;AACzD,sBAAc,GAAG,IAAI,cAAc,GAAG,KAAK,CAAA;AAC3C,sBAAc,GAAG,EAAE,KAAK,WAAW,GAAG,CAAC;MACzC,OAAO;AACL,uBAAe,GAAG,IAAI,eAAe,GAAG,KAAK,CAAA;AAC7C,uBAAe,GAAG,EAAE,KAAK,WAAW,GAAG,CAAC;MAC1C;IACF;EACF;AAEA,qBAAmB;AAGnB,qBAAmB;AAEnB,oBAAkB,aAAa,iBAAiB,OAAO,cAAc;AAErE,qBAAmB,eAAe,gBAAgB,KAAK,GAAG,cAAc;AAGxE,qBAAmB;AAGnB,oBAAkB,aAAa,iBAAiB,OAAO,cAAc;AAErE,MAAI,aAAa,UAAU,kBAAkB,eAAe;AAC1D,sBAAkB,oBAAoB,iBAAiB,KAAK;EAC9D;AAEA,SAAO,gBAAgB,KAAI;AAC7B;AAUM,SAAU,oBAAoB,SAAuB;AACzD,SAAO,SAASC,aAAY,MAAyB;AAhbvD;AAibI,UAAM,WAAW,CAAA;AACjB,eAAWD,WAAU,SAAS;AAG5B,YAAM,kBAAiB,KAAAA,QAAO,gBAAP,wBAAAA,SAAqB,MAAM;AAClD,aAAO,OAAO,UAAU,cAAc;IACxC;AACA,WAAO;EACT;AACF;AAOA,SAAS,oBAAoB,SAI5B;AACC,QAAM,EAAC,IAAI,QAAQ,MAAK,IAAI;AAC5B,QAAM,mBAAmB,MAAM,OAAO,QAAQ,aAAa,MAAM;AACjE,SAAO,mBACH;sBACgB,MAAM,UACtB;AACN;AAGA,SAAS,sBAAsB,UAAwC,CAAA,GAAE;AACvE,MAAI,aAAa;AACjB,aAAW,UAAU,SAAS;AAC5B,UAAM,QAAQ,QAAQ,MAAM;AAC5B,QAAI,SAAS,OAAO,SAAS,KAAK,GAAG;AACnC,oBAAc,WAAW,OAAO,YAAW,KAAM,QAAQ,MAAM;;IACjE;EACF;AACA,SAAO;AACT;AAGM,SAAU,sBACdA,SACA,OAAqC;AAErC,MAAI;AACJ,UAAQ,OAAO;IACb,KAAK;AACH,qBAAeA,QAAO,MAAM;AAC5B;IACF,KAAK;AACH,qBAAeA,QAAO,MAAM;AAC5B;IACF,KAAK;AACH,qBAAeA,QAAO,UAAU;AAChC;IACF;AACE,aAAO,KAAK;EAChB;AAEA,MAAI,CAACA,QAAO,MAAM;AAChB,UAAM,IAAI,MAAM,gCAAgC;EAClD;AACA,QAAM,aAAaA,QAAO,KAAK,YAAW,EAAG,QAAQ,eAAe,GAAG;AACvE,MAAI,SAAS,mBACGA,QAAO;;;AAGvB,MAAI,UAAU,QAAQ;AACpB,cAAU,kBAAkB;;EAC9B;AACA,YAAU,GAAG;;AACb,SAAO;AACT;;;ACvfA,IAAM,eAAe;AACrB,IAAM,eAAe;AAMf,SAAU,WAAW,QAAgB,SAA6B;AAXxE;AAYE,QAAM,QAAQ,OAAO,MAAM,IAAI;AAC/B,QAAM,SAAmB,CAAA;AAEzB,MAAI,cAAc;AAClB,MAAI,gBAA+B;AACnC,aAAW,QAAQ,OAAO;AACxB,UAAM,UAAU,KAAK,MAAM,YAAY;AACvC,UAAM,WAAW,KAAK,MAAM,YAAY;AACxC,QAAI,SAAS;AACX,sBAAgB,QAAQ,CAAC;AACzB,oBAAc,SAAQ,wCAAS,YAAT,mBAAmB,cAAc;IACzD,WAAW,UAAU;AACnB,oBAAc;IAChB,WAAW,aAAa;AACtB,aAAO,KAAK,IAAI;IAClB;EACF;AACA,SAAO,OAAO,KAAK,IAAI;AACzB;;;ACZM,IAAO,mBAAP,MAAsB;;EAIT,iBAAwB,CAAA;;EAEjC,kBAAkC,CAAA;;;;;EAM1C,OAAO,4BAAyB;AAC9B,qBAAgB,yBACd,iBAAgB,0BAA0B,IAAI,iBAAe;AAC/D,WAAO,iBAAgB;EACzB;;;;EAKA,iBAAiBE,SAAoB;AACnC,QACE,CAAC,KAAK,gBAAgB,KACpB,OAAK,EAAE,UAAU,OAAOA,YAAW,WAAWA,UAASA,QAAO,KAAK,GAErE;AACA,WAAK,gBAAgB,KAAKA,OAAM;IAClC;EACF;;;;EAKA,oBAAoBA,SAAoB;AACtC,UAAM,aAAa,OAAOA,YAAW,WAAWA,UAASA,QAAO;AAChE,SAAK,kBAAkB,KAAK,gBAAgB,OAAO,OAAK,EAAE,SAAS,UAAU;EAC/E;;;;;;EAOA,cAAc,MAAc,MAAU;AACpC,QAAI,MAAM;AACR,aAAO,OAAO,OAAO,MAAM,EAAC,KAAI,CAAC;IACnC;AACA,SAAK,eAAe,KAAK,IAAI;EAC/B;;;;;;;EAQA,mBAAmB,OAA0B;AAK3C,UAAM,UAAU,KAAK,eAAe,MAAM,OAAO;AACjD,UAAM,gBAAgB,KAAK;AAC3B,UAAM,EAAC,QAAQ,aAAAC,aAAW,IAAI,mBAAmB;MAC/C,GAAG;;MAEH,QAAQ,MAAM;MACd;MACA;KACD;AAED,UAAM,qBACJ,MAAM,aAAa,mBAAmB,SAAS,WAAW,MAAM,IAAI;AACtE,WAAO,EAAC,QAAQ,oBAAoB,aAAAA,cAAa,QAAO;EAC1D;;;;;;;EAQA,uBAAuB,OAA0B;AAM/C,UAAM,UAAU,KAAK,eAAe,MAAM,OAAO;AACjD,UAAM,gBAAgB,KAAK;AAC3B,UAAM,YAAY,uBAAuB;MACvC,GAAG;;MAEH,IAAI,MAAM;;MAEV,IAAI,MAAM;MACV;MACA;KACD;AAED,WAAO,EAAC,GAAG,WAAW,QAAO;EAC/B;;;;EAKA,eAAe,aAA6B,CAAA,GAAE;AAC5C,UAAM,UAAU,IAAI,MAAoB,KAAK,gBAAgB,SAAS,WAAW,MAAM;AACvF,UAAM,OAAgC,CAAA;AACtC,QAAI,QAAQ;AAEZ,aAAS,IAAI,GAAG,MAAM,KAAK,gBAAgB,QAAQ,IAAI,KAAK,EAAE,GAAG;AAC/D,YAAMD,UAAS,KAAK,gBAAgB,CAAC;AACrC,YAAM,OAAOA,QAAO;AACpB,cAAQ,OAAO,IAAIA;AACnB,WAAK,IAAI,IAAI;IACf;AAEA,aAAS,IAAI,GAAG,MAAM,WAAW,QAAQ,IAAI,KAAK,EAAE,GAAG;AACrD,YAAMA,UAAS,WAAW,CAAC;AAC3B,YAAM,OAAOA,QAAO;AACpB,UAAI,CAAC,KAAK,IAAI,GAAG;AACf,gBAAQ,OAAO,IAAIA;AACnB,aAAK,IAAI,IAAI;MACf;IACF;AAEA,YAAQ,SAAS;AAEjB,4BAAwB,OAAO;AAC/B,WAAO;EACT;;AApII,IAAO,kBAAP;;AAEJ,cAFW,iBAEJ;;;AChBT,IAAM;;EAAqB;;;;;AAK3B,IAAM,QAAQ;EAAoB;AAS5B,SAAU,oBACd,MACA,YAA6B;AAE7B,eAAa,MAAM,QAAQ,UAAU,IAAI,aAAa,CAAC,UAAU;AACjE,QAAM,QAAQ,KAAK,QAAQ,QAAQ,EAAE,EAAE,MAAM,KAAK;AAElD,QAAM,CAAC,WAAW,MAAM,UAAU,IAAI;AACtC,MAAI,CAAC,WAAW,SAAS,SAAS,KAAK,CAAC,QAAQ,CAAC,YAAY;AAC3D,WAAO;EACT;AACA,QAAM,OAAO,WAAW,MAAM,GAAG,EAAE,CAAC;AACpC,SAAO,EAAC,WAAW,MAAM,KAAI;AAC/B;AAMM,SAAU,iBAAiB,SAIhC;AACC,QAAM,EAAC,OAAO,eAAe,OAAM,IAAI,WAAW,CAAA;AAClD,MAAI,CAAC,OAAO;AAEV,WAAO;EACT;AACA,MAAI,CAAC,eAAe;AAClB,UAAM,IAAI,MAAM,eAAe;EACjC;AACA,QAAM,YAAY,mBAAmB,aAAa;AAClD,QAAM,cAAc,cAAc,OAAO,aAAa;AACtD,SAAO;KAEJ,aAAa;WACP;;IAEP,YAAY;;AAEhB;AAGM,SAAU,oBAAoB,MAAY;AAE9C,UAAQ,MAAM;IACZ,KAAK;AAAS,aAAO;IACrB,KAAK;AAAQ,aAAO;IACpB,KAAK;AAAQ,aAAO;IACpB,KAAK;AAAQ,aAAO;IACpB;AACE,YAAM,IAAI,MAAM,IAAI;EACxB;AACF;AAGM,SAAU,mBAAmB,MAAY;AAE7C,UAAQ,MAAM;IACZ,KAAK;AAAS,aAAO;IACrB,KAAK;AAAQ,aAAO;IACpB,KAAK;AAAQ,aAAO;IACpB,KAAK;AAAQ,aAAO;IACpB;AACE,YAAM,IAAI,MAAM,IAAI;EACxB;AACF;AACA,SAAS,mBAAmB,UAAuB;AAEjD,UAAQ,UAAU;IAChB,KAAK;AAAG,aAAO;IACf,KAAK;AAAG,aAAO;IACf,KAAK;AAAG,aAAO;IACf,KAAK;AAAG,aAAO;IACf;AACE,YAAM,IAAI,MAAM,qBAAqB,UAAU;EACnD;AACF;AAGM,SAAU,cAAc,UAAkB,UAAuB;AAErE,UAAQ,UAAU;IAChB,KAAK;AAAG,aAAO,QAAQ;IACvB,KAAK;AAAG,aAAO,QAAQ;IACvB,KAAK;AAAG,aAAO,QAAQ;IACvB,KAAK;AAAG,aAAO;IACf;AACE,YAAM,IAAI,MAAM,qBAAqB,UAAU;EACnD;AACF;;;ACpGM,SAAU,WAAW,KAAW;AACpC,SAAO,OAAO,QAAQ,WAAW,IAAI,OAAO,CAAC,EAAE,YAAW,IAAK,IAAI,MAAM,CAAC,IAAI;AAChF;;;ACEM,SAAU,sBAAsBE,SAAsB,SAA8B;AACxF,SAAO,gCAAgCA,SAAQ,OAAO;AACxD;AAEA,SAAS,gCACPA,SACA,SAA8B;AAE9B,QAAM,OAAiB,CAAA;AAGvB,UAAQ,QAAQ,UAAU;IACxB,KAAK;IACL,KAAK;AACH,WAAK,KAAK,WAAW,WAAWA,QAAO,IAAI,KAAK;AAChD;IACF,KAAK;EAEP;AAEA,aAAW,CAAC,aAAa,aAAa,KAAK,OAAO,QAAQA,QAAO,gBAAgB,CAAA,CAAE,GAAG;AACpF,UAAM,kBAAkB,mBAAmB,aAAa;AACxD,YAAQ,QAAQ,UAAU;MACxB,KAAK;AAEH,aAAK,KAAK,KAAK,mBAAmB,cAAc;AAChD;MACF,KAAK;AAEH,aAAK,KAAK,KAAK,mBAAmBA,QAAO,QAAQ,cAAc;AAC/D;MACF,KAAK;AACH,aAAK,KAAK,WAAW,mBAAmBA,QAAO,QAAQ,cAAc;IACzE;EACF;AAEA,UAAQ,QAAQ,UAAU;IACxB,KAAK;AACH,WAAK,KAAK,KAAKA,QAAO,OAAO;AAC7B;IACF,KAAK;AACH,WAAK,KAAK,IAAI;AACd;IACF,KAAK;EAEP;AAGA,OAAK,KAAK,EAAE;AAEZ,SAAO,KAAK,KAAK,IAAI;AACvB;AAGA,SAAS,mBAAmB,eAA4B;AACtD,QAAM,uBAAsD;IAC1D,KAAK;IACL,KAAK;IACL,KAAK;IACL,aAAa;IACb,aAAa;IACb,aAAa;IACb,aAAa;IACb,aAAa;IACb,aAAa;IACb,aAAa;IACb,aAAa;IACb,aAAa;IACb,eAAe;IACf,eAAe;IACf,eAAe;IACf,eAAe;IACf,eAAe;IACf,eAAe;IACf,eAAe;IACf,eAAe;IACf,eAAe;;AAGjB,QAAM,OAAO,qBAAqB,aAAa;AAC/C,SAAO;AACT;;;ACnFM,SAAU,sBAAsBC,SAAsB,SAA8B;AACxF,SAAO,gCAAgCA,SAAQ,OAAO;AACxD;AAEM,SAAU,gCACdA,SACA,SAA8B;AAE9B,QAAM,OAAiB,CAAA;AAGvB,OAAK,KAAK,UAAU,WAAWA,QAAO,IAAI,KAAK;AAE/C,aAAW,CAAC,aAAa,aAAa,KAAK,OAAO,SAAQA,WAAA,gBAAAA,QAAQ,iBAAgB,CAAA,CAAE,GAAG;AACrF,UAAM,kBAAkB;AACxB,SAAK,KAAK,KAAK,iBAAiB,kBAAkB;EACpD;AACA,OAAK,KAAK,IAAI;AAEd,OAAK,KAAK,gBAAgBA,QAAO,UAAU,WAAWA,QAAO,IAAI,IAAI;AAErE,SAAO,KAAK,KAAK,IAAI;AACvB;;;ACjBM,SAAU,wBACdC,SACA,SAAgC;AAEhC,UAAQ,QAAQ,gBAAgB;IAC9B,KAAK;AACH,aAAO,sBAAsBA,SAAQ,OAAO;IAC9C,KAAK;AACH,aAAO,sBAAsBA,SAAQ,OAAO;EAChD;AACF;;;ACtBA,kBAAqD;AACrD,0BAA0B;AAOpB,SAAU,wBAAwB,QAAc;AAZtD;AAaE,QAAM,eAA6B,EAAC,YAAY,CAAA,GAAI,UAAU,CAAA,EAAE;AAEhE,MAAI;AACJ,MAAI;AACF,iBAAa,UAAU,MAAM;EAC/B,SAAS,OAAP;AACA,oBAAI,MAAM,MAAM,OAAO,EAAC;AACxB,WAAO;EACT;AAEA,aAAW,WAAW,WAAW,UAAU;AACzC,UAAM,UAAU,CAAA;AAChB,eAAW,eAAc,aAAQ,SAAR,mBAAsB,YAAW,CAAA,GAAI;AAC5D,cAAQ,KAAK;QACX,MAAM,UAAU;QAChB,MAAM,QAAQ,UAAU,IAAI;OAC7B;IACH;AAEA,iBAAa,SAAS,KAAK;MACzB,MAAM;MACN,MAAM,QAAQ;MACd,OAAO,QAAQ;MACf,UAAU,QAAQ;;MAElB;KACD;EACH;AAEA,aAAW,WAAW,WAAW,UAAU;AACzC,iBAAa,SAAS,KAAK;MACzB,MAAM;MACN,MAAM,QAAQ;MACd,OAAO,QAAQ;MACf,UAAU,QAAQ;KACnB;EACH;AAEA,aAAW,WAAW,WAAW,UAAU;AACzC,iBAAa,SAAS,KAAK;MACzB,MAAM;MACN,MAAM,QAAQ;MACd,OAAO,QAAQ;MACf,UAAU,QAAQ;KACnB;EACH;AAEA,QAAM,SAAS,WAAW,MAAM,OAAO,CAAC;AAGxC,QAAM,kBAAiB,iCAAQ,OAAO,WAAU;AAChD,WAAS,IAAI,GAAG,IAAI,gBAAgB,KAAK;AACvC,UAAM,gBAAgB,OAAO,OAAO,CAAC;AAGrC,QAAI,cAAc,iBAAiB,YAAY;AAC7C,YAAM,OAAO,QAAQ,cAAc,IAAI;AAEvC,mBAAa,WAAW,KAAK;QAC3B,MAAM,cAAc;QACpB,UAAU,OAAO,cAAc,QAAQ;QACvC;OACD;IACH;EACF;AACA,SAAO;AACT;AAGA,SAAS,QAAQ,MAAS;AACxB,SAAO,KAAK,SAAS,GAAG,KAAK,QAAQ,KAAK,OAAO,UAAU,KAAK;AAClE;AAEA,SAAS,UAAU,QAAc;AAC/B,MAAI;AACF,WAAO,IAAI,gCAAY,MAAM;EAC/B,SAAS,OAAP;AACA,QAAI,iBAAiB,OAAO;AAC1B,YAAM;IACR;AACA,QAAI,UAAU;AACd,QAAI,OAAO,UAAU,aAAY,+BAAO,UAAS;AAC/C,iBAAW,KAAK,MAAM;IACxB;AACA,QAAI,OAAO,UAAU,aAAY,+BAAO,QAAO;AAC7C,iBAAW,MAAM,MAAM,QAAQ;IACjC;AACA,UAAM,IAAI,MAAM,SAAS,EAAC,OAAO,MAAK,CAAC;EACzC;AACF;;;AC/FA,IAAAC,eAAoB;AAcpB,IAAI,gBAAsC;AAG1C,IAAM,SAAS,IAAI,YAAY,CAAC;AAChC,IAAM,YAAY,IAAI,aAAa,MAAM;AACzC,IAAM,aAAa,IAAI,YAAY,MAAM;AAOnC,SAAU,YAAY,KAAW;AACrC,oBAAkB,sBAAqB;AAIvC,YAAM,oBAAM,KAAK,QAAQ,KAAK;AAE9B,YAAU,CAAC,IAAI;AACf,QAAM,IAAI,WAAW,CAAC;AACtB,QAAM,IAAK,KAAK,KAAM;AACtB,SAAO,cAAc,UAAU,CAAC,MAAM,IAAI,YAAe,cAAc,WAAW,CAAC;AACrF;AAOM,SAAU,cAAc,KAAW;AACvC,oBAAkB,sBAAqB;AAEvC,QAAM,IAAI,OAAO;AACjB,aAAW,CAAC,IACV,cAAc,cAAc,cAAc,YAAY,CAAC,KAAK,MAAM,KAAM,IACxE,cAAc,cAAc,CAAC;AAC/B,SAAO,UAAU,CAAC;AACpB;AAEA,SAAS,wBAAqB;AAG5B,QAAM,YAAY,IAAI,YAAY,GAAG;AACrC,QAAM,aAAa,IAAI,YAAY,GAAG;AAEtC,WAAS,IAAI,GAAG,IAAI,KAAK,EAAE,GAAG;AAC5B,UAAM,IAAI,IAAI;AAId,QAAI,IAAI,KAAK;AACX,gBAAU,CAAC,IAAI;AACf,gBAAU,IAAI,GAAK,IAAI;AACvB,iBAAW,CAAC,IAAI;AAChB,iBAAW,IAAI,GAAK,IAAI;IAG1B,WAAW,IAAI,KAAK;AAClB,gBAAU,CAAC,IAAI,QAAW,CAAC,IAAI;AAC/B,gBAAU,IAAI,GAAK,IAAK,QAAW,CAAC,IAAI,KAAO;AAC/C,iBAAW,CAAC,IAAI,CAAC,IAAI;AACrB,iBAAW,IAAI,GAAK,IAAI,CAAC,IAAI;IAG/B,WAAW,KAAK,IAAI;AAClB,gBAAU,CAAC,IAAK,IAAI,MAAO;AAC3B,gBAAU,IAAI,GAAK,IAAM,IAAI,MAAO,KAAM;AAC1C,iBAAW,CAAC,IAAI;AAChB,iBAAW,IAAI,GAAK,IAAI;IAG1B,WAAW,IAAI,KAAK;AAClB,gBAAU,CAAC,IAAI;AACf,gBAAU,IAAI,GAAK,IAAI;AACvB,iBAAW,CAAC,IAAI;AAChB,iBAAW,IAAI,GAAK,IAAI;IAG1B,OAAO;AACL,gBAAU,CAAC,IAAI;AACf,gBAAU,IAAI,GAAK,IAAI;AACvB,iBAAW,CAAC,IAAI;AAChB,iBAAW,IAAI,GAAK,IAAI;IAC1B;EACF;AAIA,QAAM,gBAAgB,IAAI,YAAY,IAAI;AAC1C,QAAM,gBAAgB,IAAI,YAAY,EAAE;AACxC,QAAM,cAAc,IAAI,YAAY,EAAE;AAEtC,WAAS,IAAI,GAAG,IAAI,MAAM,EAAE,GAAG;AAC7B,QAAI,IAAI,KAAK;AACb,QAAI,IAAI;AAGR,YAAQ,IAAI,aAAgB,GAAG;AAC7B,YAAM;AACN,WAAK;IACP;AAEA,SAAK,CAAC;AACN,SAAK;AAEL,kBAAc,CAAC,IAAI,IAAI;EACzB;AAEA,WAAS,IAAI,MAAM,IAAI,MAAM,EAAE,GAAG;AAChC,kBAAc,CAAC,IAAI,aAAe,IAAI,QAAS;EACjD;AAEA,WAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,kBAAc,CAAC,IAAI,KAAK;EAC1B;AAEA,gBAAc,EAAE,IAAI;AACpB,gBAAc,EAAE,IAAI;AAEpB,WAAS,IAAI,IAAI,IAAI,IAAI,EAAE,GAAG;AAC5B,kBAAc,CAAC,IAAI,cAAe,IAAI,MAAO;EAC/C;AAEA,gBAAc,EAAE,IAAI;AAEpB,WAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,QAAI,MAAM,IAAI;AACZ,kBAAY,CAAC,IAAI;IACnB;EACF;AAEA,SAAO,EAAC,WAAW,YAAY,eAAe,eAAe,YAAW;AAC1E;;;AC7IM,SAAU,QAAQ,GAAW,MAAoB,CAAA,GAAI,aAAqB,GAAC;AAC/E,QAAM,SAAS,KAAK,OAAO,CAAC;AAC5B,QAAM,SAAS,IAAI;AACnB,MAAI,UAAU,IAAI;AAClB,MAAI,aAAa,CAAC,IAAI;AACtB,SAAO;AACT;AAOM,SAAU,YAAY,GAAS;AACnC,SAAO,IAAI,KAAK,OAAO,CAAC;AAC1B;AAOM,SAAU,eAAe,QAAoB;AAEjD,QAAM,aAAa,IAAI,aAAa,EAAE;AACtC,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,aAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,YAAM,QAAQ,IAAI,IAAI;AACtB,cAAQ,OAAO,IAAI,IAAI,CAAC,GAAG,YAAY,QAAQ,CAAC;IAClD;EACF;AACA,SAAO;AACT;;;ACvCA,IAAM;;EAAgB;;;;;;AAQf,IAAM,SAAS;EACpB,MAAM;EACN;;;;ACVF,IAAM;;EAAwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4JvB,IAAM,OAAO;EAClB,MAAM;EACN,IAAI;;;;AChKC,IAAM;;EAAkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAxC,IAAM;;EAAgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACgB7C,IAAM,kBAAgC;;EAEpC,KAAK;;AAMA,IAAM,iBAAsF;EACjG,MAAM;EACN,IAAI;EACJ;EACA,cAAc,EAAC,KAAK,MAAK;;EAGzB;EACA;EACA;;AAMK,IAAM,OAAyC;EACpD,MAAM;EACN,IAAI;EACJ,cAAc,CAAC,cAAc;;EAG7B;EACA;EACA;;;;AC3CF,IAAM,0BAAwC,CAAC,GAAG,GAAG,GAAG,CAAC;AA2CzD,IAAM;;EAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0EtB,IAAMC;;EAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkEf,IAAM,UAAU;EACrB,OAAO,CAAA;EACP,UAAU,CAAA;EAEV,MAAM;EAEN,cAAc;IACZ,UAAU;IACV,aAAa;IACb,mBAAmB;IACnB,gBAAgB;IAChB,wBAAwB;IACxB,gBAAgB;;EAElB,iBAAiB;IACf,UAAU;IACV,aAAa;IACb,mBAAmB;IACnB,gBAAgB;IAChB,wBAAwB,CAAC,GAAG,GAAG,CAAC;IAChC,gBAAgB;;EAGlB;EACA,IAAAA;EACA;;AAGF,SAAS,YAAY,OAAqB,CAAA,GAAI,cAA8B;AAC1E,QAAM,WAAW,CAAA;AAEjB,MAAI,KAAK,2BAA2B,QAAW;EAE/C,WAAW,KAAK,2BAA2B,MAAM;AAC/C,aAAS,oBAAoB;EAC/B,OAAO;AACL,aAAS,oBAAoB;AAC7B,UAAM,yBAAyB,KAAK,uBAAuB,MAAM,GAAG,CAAC;AACrE,aAAS,yBAAyB;EACpC;AAEA,MAAI,KAAK,gBAAgB;AACvB,UAAM,QAAQ,MAAM,KAAK,KAAK,gBAAgB,OAAK,IAAI,GAAG;AAC1D,QAAI,CAAC,OAAO,SAAS,MAAM,CAAC,CAAC,GAAG;AAC9B,YAAM,CAAC,IAAI;IACb;AACA,aAAS,iBAAiB;EAC5B;AAEA,MAAI,KAAK,aAAa,QAAW;AAC/B,aAAS,WAAW,QAAQ,KAAK,QAAQ;AACzC,aAAS,cAAc,QAAQ,KAAK,WAAW;EACjD;AAEA,MAAI,KAAK,mBAAmB,QAAW;AACrC,aAAS,iBAAiB,QAAQ,KAAK,cAAc;EACvD;AAEA,SAAO;AACT;;;ACtPA,IAAAC,eAAkB;;;ACAX,IAAM;;EAAkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAxC,IAAM;;EAAkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFO/C,IAAM,aAAa;AAGnB,IAAM,eAAe;AAIrB,IAAY;CAAZ,SAAYC,aAAU;AACpB,EAAAA,YAAAA,YAAA,OAAA,IAAA,CAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,aAAA,IAAA,CAAA,IAAA;AACF,GAHY,eAAA,aAAU,CAAA,EAAA;AA8Df,IAAM,WAAW;EACtB,OAAO,CAAA;EACP,UAAU,CAAA;EAEV,MAAM;EAEN,SAAS;IACP;;EAGF,cAAc;IACZ,SAAS;IACT,WAAW;IAEX,uBAAuB;IACvB,iBAAiB;IAEjB,mBAAmB;;IAGnB,aAAa;IACb,gBAAgB;;IAEhB,iBAAiB;IACjB,mBAAmB;IAEnB,aAAa;IACb,gBAAgB;IAChB,iBAAiB;IACjB,mBAAmB;IACnB,aAAa;IACb,gBAAgB;IAChB,iBAAiB;IACjB,mBAAmB;;EAGrB,iBAAiB;IACf,SAAS;IACT,WAAW,WAAW;IAEtB,uBAAuB;IACvB,iBAAiB;IAEjB,mBAAmB,CAAC,KAAK,KAAK,GAAG;IACjC,aAAa,CAAC,GAAG,GAAG,CAAC;IACrB,gBAAgB,CAAC,GAAG,GAAG,CAAC;;IAExB,iBAAiB,CAAC,GAAG,GAAG,CAAC;IACzB,mBAAmB,CAAC,GAAG,GAAG,CAAC;IAE3B,aAAa,CAAC,GAAG,GAAG,CAAC;IACrB,gBAAgB,CAAC,GAAG,GAAG,CAAC;IACxB,iBAAiB,CAAC,GAAG,GAAG,CAAC;IACzB,mBAAmB,CAAC,GAAG,GAAG,CAAC;IAC3B,aAAa,CAAC,GAAG,GAAG,CAAC;IACrB,gBAAgB,CAAC,GAAG,GAAG,CAAC;IACxB,iBAAiB,CAAC,GAAG,GAAG,CAAC;IACzB,mBAAmB,CAAC,GAAG,GAAG,CAAC;;EAE7B,QAAQ;EACR,IAAI;EACJ,IAAI;EAEJ,aAAAC;;AAGF,SAASA,aACP,OACA,eAA0C,CAAA,GAAE;AAG5C,UAAQ,QAAQ,EAAC,GAAG,MAAK,IAAI;AAG7B,MAAI,CAAC,OAAO;AACV,WAAO,EAAC,GAAG,SAAS,gBAAe;EACrC;AAEA,MAAI,MAAM,QAAQ;AAChB,YAAQ,EAAC,GAAG,OAAO,GAAG,kBAAkB,MAAM,MAAM,GAAG,QAAQ,OAAS;EAC1E;AAGA,QAAM,EAAC,cAAc,aAAa,kBAAiB,IAAI,SAAS,CAAA;AAChE,QAAM,YACJ,gBACC,eAAe,YAAY,SAAS,KACpC,qBAAqB,kBAAkB,SAAS;AAGnD,MAAI,CAAC,WAAW;AACd,WAAO,EAAC,GAAG,SAAS,iBAAiB,SAAS,EAAC;EACjD;AAEA,QAAM,WAAW;IACf,GAAG,SAAS;IACZ,GAAG;IACH,GAAG,uBAAuB,EAAC,cAAc,aAAa,kBAAiB,CAAC;;AAG1E,MAAI,MAAM,YAAY,QAAW;AAC/B,aAAS,UAAU,MAAM,UAAU,IAAI;EACzC;AAEA,SAAO;AACT;AAEA,SAAS,uBAAuB,EAC9B,cACA,cAAc,CAAA,GACd,oBAAoB,CAAA,EAAE,GACR;AACd,QAAM,sBAAiD,CAAA;AAEvD,sBAAoB,oBAAoB,aAAa,YAAY;AAEjE,MAAI,eAA0B;AAE9B,aAAW,cAAc,aAAa;AACpC,wBAAoB,YAAY,WAAW;AAE3C,UAAM,IAAI;AACV,wBAAoB,aAAa,GAAG,IAAI,aAAa,UAAU;AAC/D,wBAAoB,gBAAgB,GAAG,IAAI,WAAW;AACtD,wBAAoB,mBAAmB,GAAG,IAAI,WAAW,eAAe,CAAC,GAAG,GAAG,CAAC;AAChF;EACF;AAEA,aAAW,oBAAoB,mBAAmB;AAChD,wBAAoB,YAAY,WAAW;AAE3C,UAAM,IAAI;AACV,wBAAoB,aAAa,GAAG,IAAI,aAAa,gBAAgB;AACrE,wBAAoB,iBAAiB,GAAG,IAAI,iBAAiB;AAC7D;EACF;AAEA,MAAI,eAAe,YAAY;AAC7B,qBAAI,KAAK,qBAAqB,EAAC;EACjC;AAEA,sBAAoB,wBAAwB,kBAAkB;AAC9D,sBAAoB,kBAAkB,YAAY;AAElD,SAAO;AACT;AAEA,SAAS,kBAAkBC,SAAe;AAnO1C;AAoOE,QAAM,eAA8B,EAAC,aAAa,CAAA,GAAI,mBAAmB,CAAA,EAAE;AAC3E,aAAW,SAASA,WAAU,CAAA,GAAI;AAChC,YAAQ,MAAM,MAAM;MAClB,KAAK;AAGH,qBAAa,eAAe;AAC5B;MACF,KAAK;AACH,2BAAa,sBAAb,mBAAgC,KAAK;AACrC;MACF,KAAK;AACH,2BAAa,gBAAb,mBAA0B,KAAK;AAC/B;MACF;IAGF;EACF;AACA,SAAO;AACT;AAGA,SAAS,aACP,WAAiE,CAAA,GAAE;AAEnE,QAAM,EAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,GAAG,YAAY,EAAG,IAAI;AAC7C,SAAO,MAAM,IAAI,eAAc,YAAY,YAAa,YAAY;AACtE;;;AGlPO,IAAM;;EAAyB;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BtC,IAAM;;EAAqB;;;;;;;AAQ3B,IAAM;;EAAqB;;;;;;;;;;;;;AAiBpB,IAAM,WAAW;EACtB,OAAO,CAAA;EACP,UAAU,CAAA;EAEV,MAAM;EACN,cAAc,CAAA;EACd,QAAQ;EACR,IAAI;EACJ,IAAI;;;;;;;EAQJ,cAAc;IACZ,gBAAgB;;EAElB,iBAAiB;IACf,gBAAgB,CAAC,GAAG,GAAG,CAAC;;EAE1B,aAAAC;;AAGF,SAASA,aAAY,OAAsB,SAAS,iBAAe;AACjE,QAAM,WAAoC,CAAA;AAC1C,MAAI,KAAK,gBAAgB;AAEvB,aAAS,2BAA2B,KAAK;EAC3C;AACA,SAAO;AACT;;;AC/FO,IAAM;;EAAsB;;;;;;;;AAS5B,IAAM;;EAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACT5B,IAAM;;EAAwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACe9B,IAAM,kBAAsD;EACjE,OAAO,CAAA;EAEP,MAAM;;EAEN,IAAI,SAAS,QAAQ,iBAAiB,iBAAiB;EACvD,IAAI,SAAS,QAAQ,iBAAiB,iBAAiB;EACvD,QAAQ,WAAW,WAAW,iBAAiB,iBAAiB;EAChE,SAAS;IACP,iBAAiB;;EAEnB,cAAc,CAAC,QAAQ;EACvB,cAAc;IACZ,SAAS;IACT,SAAS;IACT,WAAW;IACX,eAAe;;EAEjB,iBAAiB;IACf,SAAS;IACT,SAAS;IACT,WAAW;IACX,eAAe,CAAC,MAAM,MAAM,IAAI;;EAGlC,YAAY,OAA2B;AACrC,UAAM,WAAW,EAAC,GAAG,MAAK;AAC1B,QAAI,SAAS,eAAe;AAC1B,eAAS,gBAAgB,SAAS,cAAc,IAAI,OAAK,IAAI,GAAG;IAClE;AACA,WAAO,EAAC,GAAG,gBAAgB,iBAAiB,GAAG,SAAQ;EACzD;;;;AC/BK,IAAM,gBAAkD;EAC7D,MAAM;EACN,cAAc,CAAC,QAAQ;;EAEvB,QAAQ;EACR,IAAI;EACJ,IAAI;EACJ,SAAS;IACP,mBAAmB;;EAErB,cAAc;IACZ,SAAS;IACT,SAAS;IACT,WAAW;IACX,eAAe;;EAEjB,iBAAiB;IACf,SAAS;IACT,SAAS;IACT,WAAW;IACX,eAAe,CAAC,MAAM,MAAM,IAAI;;EAElC,YAAY,OAA0B;AACpC,UAAM,WAAW,EAAC,GAAG,MAAK;AAC1B,QAAI,SAAS,eAAe;AAC1B,eAAS,gBAAgB,SAAS,cAAc,IAAI,OAAK,IAAI,GAAG;IAClE;AACA,WAAO,EAAC,GAAG,cAAc,iBAAiB,GAAG,SAAQ;EACvD;;;;AC3CK,IAAMC;;EAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACQtB,IAAMC;;EAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACF7B,IAAM;;EAA0B;;;;;;;;AAgBzB,IAAM,gBAAkD;EAC7D,MAAM;EACN,IAAI;EACJ,IAAI;;EAEJ,aAAa,WAAS;EACtB,cAAc;IACZ,2BAA2B;IAC3B,aAAa;IACb,cAAc;IACd,QAAQ;;;;;ACwCL,IAAM,cAAc;EACzB,OAAO,CAAA;EACP,UAAU,CAAA;EAEV,MAAM;EACN,cAAc,CAAC,UAAU,aAAa;EACtC,IAAAC;EACA,IAAAC;EAEA,SAAS;IACP,mBAAmB;;;;;;;;;;;EAWrB,aAAa,WAAS;EACtB,cAAc;;IAEZ,OAAO;;IAGP,qBAAqB;IACrB,iBAAiB;IAEjB,kBAAkB;IAClB,aAAa;;IAEb,oBAAoB;IACpB,gBAAgB;;IAEhB,yBAAyB;IACzB,6BAA6B;IAE7B,qBAAqB;IACrB,mBAAmB;;IAEnB,oBAAoB;IACpB,aAAa;;;IAGb,YAAY;IACZ,iBAAiB;;;;IAIjB,iBAAiB;IACjB,cAAc;;;;;AC7HlB,IAAMC;;EAAgB;;;;;;;;;;;;;;;;AAiBtB,IAAMC;;EAAgB;;;;;;;;;;;;AAgBf,IAAM,WAAW;EACtB,MAAM;EACN,IAAAD;EACA,IAAAC;;;;ACnCF,IAAAC,eAA+B;AAW/B,IAAM,kBAAiC,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAEtF,IAAM,yBAA0C;EAC9C,aAAa;EACb,YAAY;EACZ,kBAAkB;EAClB,qBAAqB,CAAC,GAAG,GAAG,CAAC;;AAG/B,SAASC,aAAY,OAAwB,wBAAwB,eAAe,CAAA,GAAE;AAKpF,QAAM,WAAgC,CAAA;AACtC,MAAI,KAAK,gBAAgB,QAAW;AAClC,aAAS,cAAc,KAAK;EAC9B;AACA,MAAI,KAAK,eAAe,QAAW;AACjC,aAAS,aAAa,KAAK;EAC7B;AACA,MAAI,KAAK,qBAAqB,QAAW;AACvC,aAAS,mBAAmB,KAAK;EACnC;AACA,MAAI,KAAK,wBAAwB,QAAW;AAC1C,aAAS,sBAAsB,KAAK;EACtC;AAGA,MAAI,KAAK,qBAAqB,UAAa,KAAK,eAAe,QAAW;AACxE,aAAS,uBAAuB,IAAI,qBAAQ,KAAK,gBAAgB,EAAE,cACjE,KAAK,UAAU;EAEnB;AAEA,SAAO;AACT;AAEA,IAAM;;EAAoB;;;;;;;;;;;;AAa1B,IAAMC,MAAK,GACT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuDF,IAAMC,MAAK;EACT;AAMK,IAAM,UAAU;EACrB,MAAM;EACN,aAAAF;EACA,IAAAC;EACA,IAAAC;;;;ACjIK,IAAM;;EAA4B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4BzC,IAAM,yBAAkD;EACtD,cAAc,CAAA;;AAIhB,SAASC,cACP,WAAgE,CAAA,GAAE;AAElE,QAAM,EAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,GAAG,YAAY,EAAG,IAAI;AAC7C,SAAO,MAAM,IAAI,eAAc,YAAY,YAAa,GAAK;AAC/D;AAEA,SAASC,wBAAuB,EAC9B,cACA,cAAc,CAAA,GACd,oBAAoB,CAAA,EAAE,GACT;AACb,QAAM,sBAA2C,CAAA;AAEjD,MAAI,cAAc;AAChB,wBAAoB,8BAA8B,IAAID,cAAa,YAAY;EACjF,OAAO;AACL,wBAAoB,8BAA8B,IAAI,CAAC,GAAG,GAAG,CAAC;EAChE;AAEA,cAAY,QAAQ,CAAC,YAAY,UAAS;AACxC,wBAAoB,wBAAwB,cAAc,IAAIA,cAAa,UAAU;AACrF,wBAAoB,wBAAwB,iBAAiB,IAAI,WAAW;AAC5E,wBAAoB,wBAAwB,oBAAoB,IAAI,WAAW,eAAe;MAC5F;MAAG;MAAG;;EAEV,CAAC;AACD,sBAAoB,4BAA4B,YAAY;AAE5D,oBAAkB,QAAQ,CAAC,kBAAkB,UAAS;AACpD,wBAAoB,8BAA8B,cAAc,IAC9DA,cAAa,gBAAgB;AAC/B,wBAAoB,8BAA8B,kBAAkB,IAClE,iBAAiB;EACrB,CAAC;AACD,sBAAoB,kCAAkC,kBAAkB;AAExE,SAAO;AACT;AAGA,SAASE,aAAY,OAAsB,wBAAsB;AA9EjE;AAgFE,MAAI,kBAAkB,MAAM;AAC1B,UAAM,EAAC,cAAc,aAAa,kBAAiB,IAAI,KAAK,gBAAgB,CAAA;AAC5E,UAAM,YACJ,gBACC,eAAe,YAAY,SAAS,KACpC,qBAAqB,kBAAkB,SAAS;AAEnD,QAAI,CAAC,WAAW;AACd,aAAO,EAAC,mBAAmB,MAAK;IAClC;AAEA,WAAO,OAAO,OACZ,CAAA,GACAD,wBAAuB,EAAC,cAAc,aAAa,kBAAiB,CAAC,GACrE;MACE,mBAAmB;KACpB;EAEL;AAGA,MAAI,YAAY,MAAM;AACpB,UAAM,eAA6B,EAAC,aAAa,CAAA,GAAI,mBAAmB,CAAA,EAAE;AAE1E,eAAW,SAAS,KAAK,UAAU,CAAA,GAAI;AACrC,cAAQ,MAAM,MAAM;QAClB,KAAK;AAGH,uBAAa,eAAe;AAC5B;QACF,KAAK;AACH,6BAAa,sBAAb,mBAAgC,KAAK;AACrC;QACF,KAAK;AACH,6BAAa,gBAAb,mBAA0B,KAAK;AAC/B;QACF;MAGF;IACF;AAGA,WAAOC,aAAY,EAAC,aAAY,CAAC;EACnC;AAEA,SAAO,CAAA;AACT;AAMO,IAAM,SAAS;EACpB,MAAM;EACN,IAAI;EACJ,IAAI;EACJ,aAAAA;EACA,SAAS;IACP,YAAY;;;;;AC9HhB,IAAMC,0BAAoD;EACxD,gBAAgB,IAAI,aAAa,CAAC,GAAG,GAAG,CAAC,CAAC;;AAG5C,SAASC,aAAY,OAAwBD,yBAAsB;AACjE,QAAM,WAAW,CAAA;AACjB,MAAI,KAAK,gBAAgB;AAEvB,aAAS,2BAA2B,KAAK;EAC3C;AACA,SAAO;AACT;AAEA,IAAME;;EAAgB;;;;;;;;;;;;AAgBf,IAAMC,YAAyB;EACpC,MAAM;;EAEN,IAAAD;EACA,aAAAD;EACA,cAAc,CAAC,OAAO;;;;AC5CjB,IAAMG;;EAA4B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACYzC,IAAMC,0BAA0D,CAAA;AAEhE,SAAS,oBAAoB,UAA4B;AACvD,QAAM,EAAC,UAAU,MAAM,UAAU,KAAK,YAAY,IAAI,gBAAgB,CAAC,IAAI,IAAI,EAAE,EAAC,IAAI;AAEtF,SAAO;IACL,mBAAmB;IACnB,mBAAmB;IACnB,qBAAqB;IACrB,yBAAyB,cAAc,IAAI,OAAK,IAAI,GAAG;;AAE3D;AAEA,SAASC,aACP,OAAwCD,yBAAsB;AAE9D,MAAI,EAAE,cAAc,OAAO;AACzB,WAAO,CAAA;EACT;AAEA,QAAM,EAAC,SAAQ,IAAI;AAEnB,MAAI,CAAC,UAAU;AACb,WAAO,EAAC,mBAAmB,MAAK;EAClC;AAEA,SAAO,oBAAoB,QAAQ;AACrC;AAEO,IAAM,kBAAkB;EAC7B,MAAM;EACN,cAAc,CAAC,MAAM;EACrB,IAAIE;EACJ,SAAS;IACP,iBAAiB;;EAEnB,aAAAD;;AAGK,IAAM,gBAAgB;EAC3B,MAAM;EACN,cAAc,CAAC,MAAM;EACrB,IAAIC;EACJ,SAAS;IACP,mBAAmB;;EAErB,aAAAD;;;;AC1DK,IAAME;;EAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACStB,IAAMC;;EAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAtB,IAAM,MAAM;EACjB,MAAM;EACN,IAAAC;EACA,IAAAC;EACA,SAAS;IACP,mBAAmB;;EAErB,cAAc,CAAC,MAAM;EACrB,aAAa,CAAC,UAAe;;",
  "names": ["dirlight", "module", "log", "_a", "module", "vs", "fs", "log", "module", "getUniforms", "module", "getUniforms", "module", "module", "module", "import_core", "fs", "import_core", "LIGHT_TYPE", "getUniforms", "lights", "getUniforms", "vs", "fs", "vs", "fs", "vs", "fs", "import_core", "getUniforms", "vs", "fs", "convertColor", "getLightSourceUniforms", "getUniforms", "DEFAULT_MODULE_OPTIONS", "getUniforms", "fs", "dirlight", "lightingShader", "INITIAL_MODULE_OPTIONS", "getUniforms", "lightingShader", "vs", "fs", "vs", "fs"]
}
