{
  "version": 3,
  "sources": ["../src/index.ts", "../src/animation/timeline.ts", "../src/animation/key-frames.ts", "../src/animation-loop/animation-loop-template.ts", "../src/animation-loop/animation-loop.ts", "../src/animation-loop/request-animation-frame.ts", "../src/animation-loop/make-animation-loop.ts", "../src/model/model.ts", "../src/geometry/gpu-geometry.ts", "../src/utils/uid.ts", "../src/factories/pipeline-factory.ts", "../src/factories/shader-factory.ts", "../src/debug/debug-shader-layout.ts", "../src/debug/debug-framebuffer.ts", "../src/utils/deep-equal.ts", "../src/shader-inputs.ts", "../src/model/split-uniforms-and-bindings.ts", "../src/application-utils/load-file.ts", "../src/async-texture/async-texture.ts", "../src/compute/buffer-transform.ts", "../src/compute/texture-transform.ts", "../src/geometry/geometry.ts", "../src/models/clip-space.ts", "../src/models/billboard-texture-model.ts", "../src/scenegraph/scenegraph-node.ts", "../src/scenegraph/group-node.ts", "../src/scenegraph/model-node.ts", "../src/geometries/truncated-cone-geometry.ts", "../src/geometries/cone-geometry.ts", "../src/geometries/cube-geometry.ts", "../src/geometries/cylinder-geometry.ts", "../src/geometries/ico-sphere-geometry.ts", "../src/geometry/geometry-utils.ts", "../src/geometries/plane-geometry.ts", "../src/geometries/sphere-geometry.ts", "../src/application-utils/random.ts", "../src/passes/shader-pass-renderer.ts", "../src/compute/swap.ts", "../src/passes/get-fragment-shader.ts", "../src/compute/computation.ts", "../src/modules/picking/picking-uniforms.ts", "../src/modules/picking/picking-manager.ts", "../src/modules/picking/index-picking.ts", "../src/modules/picking/color-picking.ts", "../src/modules/picking/legacy-picking-manager.ts"],
  "sourcesContent": ["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// luma.gl Engine API\n\n// Animation\nexport {Timeline} from './animation/timeline';\nexport {KeyFrames} from './animation/key-frames';\nexport type {AnimationProps} from './animation-loop/animation-props';\n\nexport {AnimationLoopTemplate} from './animation-loop/animation-loop-template';\n\nexport type {AnimationLoopProps} from './animation-loop/animation-loop';\nexport {AnimationLoop} from './animation-loop/animation-loop';\n\nexport type {MakeAnimationLoopProps} from './animation-loop/make-animation-loop';\nexport {makeAnimationLoop} from './animation-loop/make-animation-loop';\n\nexport type {ModelProps} from './model/model';\nexport {Model} from './model/model';\n\n// Transforms\nexport type {BufferTransformProps} from './compute/buffer-transform';\nexport {BufferTransform} from './compute/buffer-transform';\nexport type {TextureTransformProps} from './compute/texture-transform';\nexport {TextureTransform} from './compute/texture-transform';\n\nexport {PipelineFactory} from './factories/pipeline-factory';\nexport {ShaderFactory} from './factories/shader-factory';\n\n// Models\nexport type {ClipSpaceProps} from './models/clip-space';\nexport {ClipSpace} from './models/clip-space';\nexport type {BackgroundTextureModelProps} from './models/billboard-texture-model';\nexport {BackgroundTextureModel} from './models/billboard-texture-model';\n\n// Scenegraph Core nodes\nexport {ScenegraphNode} from './scenegraph/scenegraph-node';\nexport {GroupNode} from './scenegraph/group-node';\nexport type {ModelNodeProps} from './scenegraph/model-node';\nexport {ModelNode} from './scenegraph/model-node';\n\n// Geometries\nexport type {GeometryProps, GeometryAttribute} from './geometry/geometry';\nexport {Geometry} from './geometry/geometry';\nexport type {GPUGeometryProps} from './geometry/gpu-geometry';\nexport {GPUGeometry} from './geometry/gpu-geometry';\n\n// Primitives\nexport type {ConeGeometryProps} from './geometries/cone-geometry';\nexport {ConeGeometry} from './geometries/cone-geometry';\nexport type {CubeGeometryProps} from './geometries/cube-geometry';\nexport {CubeGeometry} from './geometries/cube-geometry';\nexport type {CylinderGeometryProps} from './geometries/cylinder-geometry';\nexport {CylinderGeometry} from './geometries/cylinder-geometry';\nexport type {IcoSphereGeometryProps} from './geometries/ico-sphere-geometry';\nexport {IcoSphereGeometry} from './geometries/ico-sphere-geometry';\nexport type {PlaneGeometryProps} from './geometries/plane-geometry';\nexport {PlaneGeometry} from './geometries/plane-geometry';\nexport type {SphereGeometryProps} from './geometries/sphere-geometry';\nexport {SphereGeometry} from './geometries/sphere-geometry';\nexport type {TruncatedConeGeometryProps} from './geometries/truncated-cone-geometry';\nexport {TruncatedConeGeometry} from './geometries/truncated-cone-geometry';\n\nexport {ShaderInputs} from './shader-inputs';\n\n// Application Utilities\nexport {makeRandomGenerator} from './application-utils/random';\nexport {setPathPrefix, loadImage, loadImageBitmap} from './application-utils/load-file';\n\n// EXPERIMENTAL\nexport type {ShaderPassRendererProps} from './passes/shader-pass-renderer';\nexport {ShaderPassRenderer} from './passes/shader-pass-renderer';\n\nexport {Swap} from './compute/swap';\nexport {SwapBuffers} from './compute/swap';\nexport {SwapFramebuffers} from './compute/swap';\n\nexport type {ComputationProps} from './compute/computation';\nexport {Computation} from './compute/computation';\n\nexport type {AsyncTextureProps} from './async-texture/async-texture';\nexport {AsyncTexture} from './async-texture/async-texture';\n\nexport {PickingManager} from './modules/picking/picking-manager';\nexport {picking as indexPicking} from './modules/picking/index-picking';\nexport {picking as colorPicking} from './modules/picking/color-picking';\n\nexport {\n  requestAnimationFramePolyfill,\n  cancelAnimationFramePolyfill\n} from './animation-loop/request-animation-frame';\n\n// DEPRECATED\n\nexport {LegacyPickingManager} from './modules/picking/legacy-picking-manager';\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/**\n * Timeline channel properties\n * @param delay = 0;\n * @param duration = Number.POSITIVE_INFINITY;\n * @param rate = 1\n * @param repeat = 1\n */\nexport type ChannelOptions = {\n  delay?: number;\n  duration?: number;\n  rate?: number;\n  repeat?: number;\n};\n\nexport type AnimationOptions = {\n  setTime: (time: number) => void;\n};\n\ntype Channel = {\n  time: number;\n  delay: number;\n  duration: number;\n  rate: number;\n  repeat: number;\n};\n\ntype Animation = {\n  channel?: number;\n  animation: {\n    setTime: (time: number) => void;\n  };\n};\n\nlet channelHandles = 1;\nlet animationHandles = 1;\n\nexport class Timeline {\n  time: number = 0;\n  channels = new Map<number, Channel>();\n  animations = new Map<number, Animation>();\n  playing: boolean = false;\n  lastEngineTime: number = -1;\n\n  constructor() {}\n\n  addChannel(props: ChannelOptions): number {\n    const {delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1} = props;\n\n    const channelId = channelHandles++;\n    const channel: Channel = {\n      time: 0,\n      delay,\n      duration,\n      rate,\n      repeat\n    };\n    this._setChannelTime(channel, this.time);\n    this.channels.set(channelId, channel);\n\n    return channelId;\n  }\n\n  removeChannel(channelId: number): void {\n    this.channels.delete(channelId);\n\n    for (const [animationHandle, animation] of this.animations) {\n      if (animation.channel === channelId) {\n        this.detachAnimation(animationHandle);\n      }\n    }\n  }\n\n  isFinished(channelId: number): boolean {\n    const channel = this.channels.get(channelId);\n    if (channel === undefined) {\n      return false;\n    }\n\n    return this.time >= channel.delay + channel.duration * channel.repeat;\n  }\n\n  getTime(channelId?: number): number {\n    if (channelId === undefined) {\n      return this.time;\n    }\n\n    const channel = this.channels.get(channelId);\n\n    if (channel === undefined) {\n      return -1;\n    }\n\n    return channel.time;\n  }\n\n  setTime(time: number): void {\n    this.time = Math.max(0, time);\n\n    const channels = this.channels.values();\n    for (const channel of channels) {\n      this._setChannelTime(channel, this.time);\n    }\n\n    const animations = this.animations.values();\n    for (const animationData of animations) {\n      const {animation, channel} = animationData;\n      animation.setTime(this.getTime(channel));\n    }\n  }\n\n  play(): void {\n    this.playing = true;\n  }\n\n  pause(): void {\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  reset(): void {\n    this.setTime(0);\n  }\n\n  attachAnimation(animation: AnimationOptions, channelHandle?: number): number {\n    const animationHandle = animationHandles++;\n\n    this.animations.set(animationHandle, {\n      animation,\n      channel: channelHandle\n    });\n\n    animation.setTime(this.getTime(channelHandle));\n\n    return animationHandle;\n  }\n\n  detachAnimation(channelId: number): void {\n    this.animations.delete(channelId);\n  }\n\n  update(engineTime: number): void {\n    if (this.playing) {\n      if (this.lastEngineTime === -1) {\n        this.lastEngineTime = engineTime;\n      }\n      this.setTime(this.time + (engineTime - this.lastEngineTime));\n      this.lastEngineTime = engineTime;\n    }\n  }\n\n  _setChannelTime(channel: Channel, time: number): void {\n    const offsetTime = time - channel.delay;\n    const totalDuration = channel.duration * channel.repeat;\n    // Note(Tarek): Don't loop on final repeat.\n    if (offsetTime >= totalDuration) {\n      channel.time = channel.duration * channel.rate;\n    } else {\n      channel.time = Math.max(0, offsetTime) % channel.duration;\n      channel.time *= channel.rate;\n    }\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// keyframes\nexport type KeyFrame<T> = [number, T];\n\n/** Holds a list of key frames (timestamped values) */\nexport class KeyFrames<T = number> {\n  startIndex: number = -1;\n  endIndex: number = -1;\n  factor: number = 0;\n  times: number[] = [];\n  values: T[] = [];\n  private _lastTime = -1;\n\n  constructor(keyFrames: KeyFrame<T>[]) {\n    this.setKeyFrames(keyFrames);\n    this.setTime(0);\n  }\n\n  setKeyFrames(keyFrames: KeyFrame<T>[]): void {\n    const numKeys = keyFrames.length;\n    this.times.length = numKeys;\n    this.values.length = numKeys;\n\n    for (let i = 0; i < numKeys; ++i) {\n      this.times[i] = keyFrames[i][0];\n      this.values[i] = keyFrames[i][1];\n    }\n\n    this._calculateKeys(this._lastTime);\n  }\n\n  setTime(time: number): void {\n    time = Math.max(0, time);\n\n    if (time !== this._lastTime) {\n      this._calculateKeys(time);\n      this._lastTime = time;\n    }\n  }\n\n  getStartTime(): number {\n    return this.times[this.startIndex];\n  }\n\n  getEndTime(): number {\n    return this.times[this.endIndex];\n  }\n\n  getStartData(): T {\n    return this.values[this.startIndex];\n  }\n\n  getEndData(): T {\n    return this.values[this.endIndex];\n  }\n\n  _calculateKeys(time: number): void {\n    let index = 0;\n    const numKeys = this.times.length;\n\n    for (index = 0; index < numKeys - 2; ++index) {\n      if (this.times[index + 1] > time) {\n        break;\n      }\n    }\n\n    this.startIndex = index;\n    this.endIndex = index + 1;\n\n    const startTime = this.times[this.startIndex];\n    const endTime = this.times[this.endIndex];\n    this.factor = Math.min(Math.max(0, (time - startTime) / (endTime - startTime)), 1);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {AnimationProps} from './animation-props';\n\n/**\n * Minimal class that represents a \"componentized\" rendering life cycle\n * (resource construction, repeated rendering, resource destruction)\n *\n * @note A motivation for this class compared to the raw animation loop is\n * that it simplifies TypeScript code by allowing resources to be typed unconditionally\n * since they are allocated in the constructor rather than in onInitialized\n *\n * @note Introduced in luma.gl v9\n *\n * @example AnimationLoopTemplate is intended to be subclassed,\n * but the subclass should not be instantiated directly. Instead the subclass\n * (i.e. the constructor of the subclass) should be used\n * as an argument to create an AnimationLoop.\n */\nexport abstract class AnimationLoopTemplate {\n  constructor(animationProps?: AnimationProps) {}\n  async onInitialize(animationProps: AnimationProps): Promise<unknown> {\n    return null;\n  }\n  abstract onRender(animationProps: AnimationProps): unknown;\n  abstract onFinalize(animationProps: AnimationProps): void;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {luma, Device} from '@luma.gl/core';\nimport {\n  requestAnimationFramePolyfill,\n  cancelAnimationFramePolyfill\n} from './request-animation-frame';\nimport {Timeline} from '../animation/timeline';\nimport {AnimationProps} from './animation-props';\nimport {Stats, Stat} from '@probe.gl/stats';\n\nlet statIdCounter = 0;\n\n/** AnimationLoop properties */\nexport type AnimationLoopProps = {\n  device: Device | Promise<Device>;\n\n  onAddHTML?: (div: HTMLDivElement) => string; // innerHTML\n  onInitialize?: (animationProps: AnimationProps) => Promise<unknown>;\n  onRender?: (animationProps: AnimationProps) => unknown;\n  onFinalize?: (animationProps: AnimationProps) => void;\n  onError?: (reason: Error) => void;\n\n  stats?: Stats;\n\n  // view parameters - TODO move to CanvasContext?\n  autoResizeViewport?: boolean;\n  autoResizeDrawingBuffer?: boolean;\n  useDevicePixels?: number | boolean;\n};\n\nexport type MutableAnimationLoopProps = {\n  // view parameters\n  autoResizeViewport?: boolean;\n  autoResizeDrawingBuffer?: boolean;\n  useDevicePixels?: number | boolean;\n};\n\nconst DEFAULT_ANIMATION_LOOP_PROPS: Required<AnimationLoopProps> = {\n  device: null!,\n\n  onAddHTML: () => '',\n  onInitialize: async () => {\n    return null;\n  },\n  onRender: () => {},\n  onFinalize: () => {},\n  onError: error => console.error(error), // eslint-disable-line no-console\n\n  stats: luma.stats.get(`animation-loop-${statIdCounter++}`),\n\n  // view parameters\n  useDevicePixels: true,\n  autoResizeViewport: false,\n  autoResizeDrawingBuffer: false\n};\n\n/** Convenient animation loop */\nexport class AnimationLoop {\n  device: Device | null = null;\n  canvas: HTMLCanvasElement | OffscreenCanvas | null = null;\n\n  props: Required<AnimationLoopProps>;\n  animationProps: AnimationProps | null = null;\n  timeline: Timeline | null = null;\n  stats: Stats;\n  cpuTime: Stat;\n  gpuTime: Stat;\n  frameRate: Stat;\n\n  display: any;\n\n  needsRedraw: string | false = 'initialized';\n\n  _initialized: boolean = false;\n  _running: boolean = false;\n  _animationFrameId: any = null;\n  _nextFramePromise: Promise<AnimationLoop> | null = null;\n  _resolveNextFrame: ((animationLoop: AnimationLoop) => void) | null = null;\n  _cpuStartTime: number = 0;\n  _error: Error | null = null;\n\n  // _gpuTimeQuery: Query | null = null;\n\n  /*\n   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context\n   */\n  constructor(props: AnimationLoopProps) {\n    this.props = {...DEFAULT_ANIMATION_LOOP_PROPS, ...props};\n    props = this.props;\n\n    if (!props.device) {\n      throw new Error('No device provided');\n    }\n\n    const {useDevicePixels = true} = this.props;\n\n    // state\n    this.stats = props.stats || new Stats({id: 'animation-loop-stats'});\n    this.cpuTime = this.stats.get('CPU Time');\n    this.gpuTime = this.stats.get('GPU Time');\n    this.frameRate = this.stats.get('Frame Rate');\n\n    this.setProps({\n      autoResizeViewport: props.autoResizeViewport,\n      autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,\n      useDevicePixels\n    });\n\n    // Bind methods\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n\n    this._onMousemove = this._onMousemove.bind(this);\n    this._onMouseleave = this._onMouseleave.bind(this);\n  }\n\n  destroy(): void {\n    this.stop();\n    this._setDisplay(null);\n  }\n\n  /** @deprecated Use .destroy() */\n  delete(): void {\n    this.destroy();\n  }\n\n  setError(error: Error): void {\n    this.props.onError(error);\n    this._error = Error();\n    const canvas = this.device?.canvasContext?.canvas;\n    if (canvas instanceof HTMLCanvasElement) {\n      const errorDiv = document.createElement('h1');\n      errorDiv.innerHTML = error.message;\n      errorDiv.style.position = 'absolute';\n      errorDiv.style.top = '20%'; // left: 50%; transform: translate(-50%, -50%);';\n      errorDiv.style.left = '10px';\n      errorDiv.style.color = 'black';\n      errorDiv.style.backgroundColor = 'red';\n      document.body.appendChild(errorDiv);\n      // canvas.style.position = 'absolute';\n    }\n  }\n\n  /** Flags this animation loop as needing redraw */\n  setNeedsRedraw(reason: string): this {\n    this.needsRedraw = this.needsRedraw || reason;\n    return this;\n  }\n\n  /** TODO - move these props to CanvasContext? */\n  setProps(props: MutableAnimationLoopProps): this {\n    if ('autoResizeViewport' in props) {\n      this.props.autoResizeViewport = props.autoResizeViewport || false;\n    }\n    if ('autoResizeDrawingBuffer' in props) {\n      this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;\n    }\n    if ('useDevicePixels' in props) {\n      this.props.useDevicePixels = props.useDevicePixels || false;\n    }\n    return this;\n  }\n\n  /** Starts a render loop if not already running */\n  async start() {\n    if (this._running) {\n      return this;\n    }\n    this._running = true;\n\n    try {\n      let appContext;\n      if (!this._initialized) {\n        this._initialized = true;\n        // Create the WebGL context\n        await this._initDevice();\n        this._initialize();\n\n        // Note: onIntialize can return a promise (e.g. in case app needs to load resources)\n        await this.props.onInitialize(this._getAnimationProps());\n      }\n\n      // check that we haven't been stopped\n      if (!this._running) {\n        return null;\n      }\n\n      // Start the loop\n      if (appContext !== false) {\n        // cancel any pending renders to ensure only one loop can ever run\n        this._cancelAnimationFrame();\n        this._requestAnimationFrame();\n      }\n\n      return this;\n    } catch (err: unknown) {\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.props.onError(error);\n      // this._running = false; // TODO\n      throw error;\n    }\n  }\n\n  /** Stops a render loop if already running, finalizing */\n  stop() {\n    // console.debug(`Stopping ${this.constructor.name}`);\n    if (this._running) {\n      // call callback\n      // If stop is called immediately, we can end up in a state where props haven't been initialized...\n      if (this.animationProps && !this._error) {\n        this.props.onFinalize(this.animationProps);\n      }\n\n      this._cancelAnimationFrame();\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n      this._running = false;\n    }\n    return this;\n  }\n\n  /** Explicitly draw a frame */\n  redraw(): this {\n    if (this.device?.isLost || this._error) {\n      return this;\n    }\n\n    this._beginFrameTimers();\n\n    this._setupFrame();\n    this._updateAnimationProps();\n\n    this._renderFrame(this._getAnimationProps());\n\n    // clear needsRedraw flag\n    this._clearNeedsRedraw();\n\n    if (this._resolveNextFrame) {\n      this._resolveNextFrame(this);\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n    }\n\n    this._endFrameTimers();\n\n    return this;\n  }\n\n  /** Add a timeline, it will be automatically updated by the animation loop. */\n  attachTimeline(timeline: Timeline): Timeline {\n    this.timeline = timeline;\n    return this.timeline;\n  }\n\n  /** Remove a timeline */\n  detachTimeline(): void {\n    this.timeline = null;\n  }\n\n  /** Wait until a render completes */\n  waitForRender(): Promise<AnimationLoop> {\n    this.setNeedsRedraw('waitForRender');\n\n    if (!this._nextFramePromise) {\n      this._nextFramePromise = new Promise(resolve => {\n        this._resolveNextFrame = resolve;\n      });\n    }\n    return this._nextFramePromise;\n  }\n\n  /** TODO - should use device.deviceContext */\n  async toDataURL(): Promise<string> {\n    this.setNeedsRedraw('toDataURL');\n    await this.waitForRender();\n    if (this.canvas instanceof HTMLCanvasElement) {\n      return this.canvas.toDataURL();\n    }\n    throw new Error('OffscreenCanvas');\n  }\n\n  // PRIVATE METHODS\n\n  _initialize(): void {\n    this._startEventHandling();\n\n    // Initialize the callback data\n    this._initializeAnimationProps();\n    this._updateAnimationProps();\n\n    // Default viewport setup, in case onInitialize wants to render\n    this._resizeCanvasDrawingBuffer();\n    this._resizeViewport();\n\n    // this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;\n  }\n\n  _setDisplay(display: any): void {\n    if (this.display) {\n      this.display.destroy();\n      this.display.animationLoop = null;\n    }\n\n    // store animation loop on the display\n    if (display) {\n      display.animationLoop = this;\n    }\n\n    this.display = display;\n  }\n\n  _requestAnimationFrame(): void {\n    if (!this._running) {\n      return;\n    }\n\n    // VR display has a separate animation frame to sync with headset\n    // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/\n    // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame\n    // if (this.display && this.display.requestAnimationFrame) {\n    //   this._animationFrameId = this.display.requestAnimationFrame(this._animationFrame.bind(this));\n    // }\n    this._animationFrameId = requestAnimationFramePolyfill(this._animationFrame.bind(this));\n  }\n\n  _cancelAnimationFrame(): void {\n    if (this._animationFrameId === null) {\n      return;\n    }\n\n    // VR display has a separate animation frame to sync with headset\n    // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/\n    // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame\n    // if (this.display && this.display.cancelAnimationFramePolyfill) {\n    //   this.display.cancelAnimationFrame(this._animationFrameId);\n    // }\n    cancelAnimationFramePolyfill(this._animationFrameId);\n    this._animationFrameId = null;\n  }\n\n  _animationFrame(): void {\n    if (!this._running) {\n      return;\n    }\n    this.redraw();\n    this._requestAnimationFrame();\n  }\n\n  // Called on each frame, can be overridden to call onRender multiple times\n  // to support e.g. stereoscopic rendering\n  _renderFrame(animationProps: AnimationProps): void {\n    // Allow e.g. VR display to render multiple frames.\n    if (this.display) {\n      this.display._renderFrame(animationProps);\n      return;\n    }\n\n    // call callback\n    this.props.onRender(this._getAnimationProps());\n    // end callback\n\n    // Submit commands (necessary on WebGPU)\n    this.device?.submit();\n  }\n\n  _clearNeedsRedraw(): void {\n    this.needsRedraw = false;\n  }\n\n  _setupFrame(): void {\n    this._resizeCanvasDrawingBuffer();\n    this._resizeViewport();\n  }\n\n  // Initialize the  object that will be passed to app callbacks\n  _initializeAnimationProps(): void {\n    const canvas = this.device?.canvasContext?.canvas;\n\n    if (!this.device || !canvas) {\n      throw new Error('loop');\n    }\n    this.animationProps = {\n      animationLoop: this,\n\n      device: this.device,\n      canvas,\n      timeline: this.timeline,\n\n      // Initial values\n      useDevicePixels: this.props.useDevicePixels,\n      needsRedraw: false,\n\n      // Placeholders\n      width: 1,\n      height: 1,\n      aspect: 1,\n\n      // Animation props\n      time: 0,\n      startTime: Date.now(),\n      engineTime: 0,\n      tick: 0,\n      tock: 0,\n\n      // Experimental\n      _mousePosition: null // Event props\n    };\n  }\n\n  _getAnimationProps(): AnimationProps {\n    if (!this.animationProps) {\n      throw new Error('animationProps');\n    }\n    return this.animationProps;\n  }\n\n  // Update the context object that will be passed to app callbacks\n  _updateAnimationProps(): void {\n    if (!this.animationProps) {\n      return;\n    }\n\n    // Can this be replaced with canvas context?\n    const {width, height, aspect} = this._getSizeAndAspect();\n    if (width !== this.animationProps.width || height !== this.animationProps.height) {\n      this.setNeedsRedraw('drawing buffer resized');\n    }\n    if (aspect !== this.animationProps.aspect) {\n      this.setNeedsRedraw('drawing buffer aspect changed');\n    }\n\n    this.animationProps.width = width;\n    this.animationProps.height = height;\n    this.animationProps.aspect = aspect;\n\n    this.animationProps.needsRedraw = this.needsRedraw;\n\n    // Update time properties\n    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n\n    if (this.timeline) {\n      this.timeline.update(this.animationProps.engineTime);\n    }\n\n    this.animationProps.tick = Math.floor((this.animationProps.time / 1000) * 60);\n    this.animationProps.tock++;\n\n    // For back compatibility\n    this.animationProps.time = this.timeline\n      ? this.timeline.getTime()\n      : this.animationProps.engineTime;\n  }\n\n  /** Wait for supplied device */\n  async _initDevice() {\n    this.device = await this.props.device;\n    if (!this.device) {\n      throw new Error('No device provided');\n    }\n    this.canvas = this.device.canvasContext?.canvas || null;\n    // this._createInfoDiv();\n  }\n\n  _createInfoDiv(): void {\n    if (this.canvas && this.props.onAddHTML) {\n      const wrapperDiv = document.createElement('div');\n      document.body.appendChild(wrapperDiv);\n      wrapperDiv.style.position = 'relative';\n      const div = document.createElement('div');\n      div.style.position = 'absolute';\n      div.style.left = '10px';\n      div.style.bottom = '10px';\n      div.style.width = '300px';\n      div.style.background = 'white';\n      if (this.canvas instanceof HTMLCanvasElement) {\n        wrapperDiv.appendChild(this.canvas);\n      }\n      wrapperDiv.appendChild(div);\n      const html = this.props.onAddHTML(div);\n      if (html) {\n        div.innerHTML = html;\n      }\n    }\n  }\n\n  _getSizeAndAspect(): {width: number; height: number; aspect: number} {\n    if (!this.device) {\n      return {width: 1, height: 1, aspect: 1};\n    }\n    // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n    const [width, height] = this.device?.canvasContext?.getPixelSize() || [1, 1];\n\n    // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html\n    let aspect = 1;\n    const canvas = this.device?.canvasContext?.canvas;\n\n    // @ts-expect-error\n    if (canvas && canvas.clientHeight) {\n      // @ts-expect-error\n      aspect = canvas.clientWidth / canvas.clientHeight;\n    } else if (width > 0 && height > 0) {\n      aspect = width / height;\n    }\n\n    return {width, height, aspect};\n  }\n\n  /** Default viewport setup */\n  _resizeViewport(): void {\n    // TODO can we use canvas context to code this in a portable way?\n    // @ts-expect-error Expose on canvasContext\n    if (this.props.autoResizeViewport && this.device.gl) {\n      // @ts-expect-error Expose canvasContext\n      this.device.gl.viewport(\n        0,\n        0,\n        // @ts-expect-error Expose canvasContext\n        this.device.gl.drawingBufferWidth,\n        // @ts-expect-error Expose canvasContext\n        this.device.gl.drawingBufferHeight\n      );\n    }\n  }\n\n  /**\n   * Resize the render buffer of the canvas to match canvas client size\n   * Optionally multiplying with devicePixel ratio\n   */\n  _resizeCanvasDrawingBuffer(): void {\n    if (this.props.autoResizeDrawingBuffer) {\n      this.device?.canvasContext?.resize({useDevicePixels: this.props.useDevicePixels});\n    }\n  }\n\n  _beginFrameTimers() {\n    this.frameRate.timeEnd();\n    this.frameRate.timeStart();\n\n    // Check if timer for last frame has completed.\n    // GPU timer results are never available in the same\n    // frame they are captured.\n    // if (\n    //   this._gpuTimeQuery &&\n    //   this._gpuTimeQuery.isResultAvailable() &&\n    //   !this._gpuTimeQuery.isTimerDisjoint()\n    // ) {\n    //   this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n    // }\n\n    // if (this._gpuTimeQuery) {\n    //   // GPU time query start\n    //   this._gpuTimeQuery.beginTimeElapsedQuery();\n    // }\n\n    this.cpuTime.timeStart();\n  }\n\n  _endFrameTimers() {\n    this.cpuTime.timeEnd();\n\n    // if (this._gpuTimeQuery) {\n    //   // GPU time query end. Results will be available on next frame.\n    //   this._gpuTimeQuery.end();\n    // }\n  }\n\n  // Event handling\n\n  _startEventHandling() {\n    if (this.canvas) {\n      this.canvas.addEventListener('mousemove', this._onMousemove.bind(this));\n      this.canvas.addEventListener('mouseleave', this._onMouseleave.bind(this));\n    }\n  }\n\n  _onMousemove(event: Event) {\n    if (event instanceof MouseEvent) {\n      this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];\n    }\n  }\n\n  _onMouseleave(event: Event) {\n    this._getAnimationProps()._mousePosition = null;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* global window, setTimeout, clearTimeout */\n\n/** Node.js polyfill for requestAnimationFrame */\n// / <reference types=\"@types/node\" />\nexport function requestAnimationFramePolyfill(callback: (time?: any) => void): any {\n  return typeof window !== 'undefined' && window.requestAnimationFrame\n    ? window.requestAnimationFrame(callback)\n    : setTimeout(callback, 1000 / 60);\n}\n\n/** Node.js polyfill for cancelAnimationFrame */\nexport function cancelAnimationFramePolyfill(timerId: any): void {\n  return typeof window !== 'undefined' && window.cancelAnimationFrame\n    ? window.cancelAnimationFrame(timerId)\n    : clearTimeout(timerId);\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {luma, Adapter} from '@luma.gl/core';\nimport {AnimationLoopTemplate} from './animation-loop-template';\nimport {AnimationLoop, AnimationLoopProps} from './animation-loop';\nimport type {AnimationProps} from './animation-props';\n\nexport type MakeAnimationLoopProps = Omit<\n  AnimationLoopProps,\n  'onCreateDevice' | 'onInitialize' | 'onRedraw' | 'onFinalize'\n> & {\n  /** List of adapters to use when creating the device */\n  adapters?: Adapter[];\n};\n\n/** Instantiates and runs the render loop */\nexport function makeAnimationLoop(\n  AnimationLoopTemplateCtor: typeof AnimationLoopTemplate,\n  props?: MakeAnimationLoopProps\n): AnimationLoop {\n  let renderLoop: AnimationLoopTemplate | null = null;\n\n  const device =\n    props?.device ||\n    luma.createDevice({id: 'animation-loop', adapters: props?.adapters, createCanvasContext: true});\n\n  // Create an animation loop;\n  const animationLoop = new AnimationLoop({\n    ...props,\n\n    device,\n\n    async onInitialize(animationProps: AnimationProps): Promise<unknown> {\n      // @ts-expect-error abstract to prevent instantiation\n      renderLoop = new AnimationLoopTemplateCtor(animationProps);\n      // Any async loading can be handled here\n      return await renderLoop?.onInitialize(animationProps);\n    },\n\n    onRender: (animationProps: AnimationProps) => renderLoop?.onRender(animationProps),\n\n    onFinalize: (animationProps: AnimationProps) => renderLoop?.onFinalize(animationProps)\n  });\n\n  // @ts-expect-error Hack: adds info for the website to find\n  animationLoop.getInfo = () => {\n    // @ts-ignore\n    // eslint-disable-next-line no-invalid-this\n    return this.AnimationLoopTemplateCtor.info;\n  };\n\n  // Start the loop automatically\n  // animationLoop.start();\n\n  return animationLoop;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// A lot of imports, but then Model is where it all comes together...\nimport type {TypedArray} from '@math.gl/types';\nimport type {\n  RenderPipelineProps,\n  RenderPipelineParameters,\n  BufferLayout,\n  Shader,\n  VertexArray,\n  TransformFeedback,\n  AttributeInfo,\n  Binding,\n  UniformValue,\n  PrimitiveTopology\n} from '@luma.gl/core';\nimport {\n  Device,\n  DeviceFeature,\n  Buffer,\n  Texture,\n  TextureView,\n  Sampler,\n  RenderPipeline,\n  RenderPass,\n  UniformStore,\n  log,\n  getTypedArrayFromDataType,\n  getAttributeInfosFromLayouts,\n  _BufferLayoutHelper,\n  sortedBufferLayoutByShaderSourceLocations\n} from '@luma.gl/core';\n\nimport type {ShaderModule, PlatformInfo} from '@luma.gl/shadertools';\nimport {ShaderAssembler, getShaderLayoutFromWGSL} from '@luma.gl/shadertools';\n\nimport type {Geometry} from '../geometry/geometry';\nimport {GPUGeometry, makeGPUGeometry} from '../geometry/gpu-geometry';\nimport {PipelineFactory} from '../factories/pipeline-factory';\nimport {ShaderFactory} from '../factories/shader-factory';\nimport {getDebugTableForShaderLayout} from '../debug/debug-shader-layout';\nimport {debugFramebuffer} from '../debug/debug-framebuffer';\nimport {deepEqual} from '../utils/deep-equal';\nimport {uid} from '../utils/uid';\nimport {ShaderInputs} from '../shader-inputs';\n// import type {AsyncTextureProps} from '../async-texture/async-texture';\nimport {AsyncTexture} from '../async-texture/async-texture';\n\nimport {splitUniformsAndBindings} from './split-uniforms-and-bindings';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\nexport type ModelProps = Omit<RenderPipelineProps, 'vs' | 'fs' | 'bindings'> & {\n  source?: string;\n  vs: string | null;\n  fs: string | null;\n\n  /** shadertool shader modules (added to shader code) */\n  modules?: ShaderModule[];\n  /** Shadertool module defines (configures shader code)*/\n  defines?: Record<string, string | number | boolean>;\n  // TODO - injections, hooks etc?\n\n  /** Shader inputs, used to generated uniform buffers and bindings */\n  shaderInputs?: ShaderInputs;\n  /** Bindings */\n  bindings?: Record<string, Binding | AsyncTexture>;\n  /** Parameters that are built into the pipeline */\n  parameters?: RenderPipelineParameters;\n\n  /** Geometry */\n  geometry?: GPUGeometry | Geometry | null;\n\n  /** @deprecated Use instanced rendering? Will be auto-detected in 9.1 */\n  isInstanced?: boolean;\n  /** instance count */\n  instanceCount?: number;\n  /** Vertex count */\n  vertexCount?: number;\n\n  indexBuffer?: Buffer | null;\n  /** @note this is really a map of buffers, not a map of attributes */\n  attributes?: Record<string, Buffer>;\n  /**   */\n  constantAttributes?: Record<string, TypedArray>;\n\n  /** Some applications intentionally supply unused attributes and bindings, and want to disable warnings */\n  disableWarnings?: boolean;\n\n  /** @internal For use with {@link TransformFeedback}, WebGL only. */\n  varyings?: string[];\n\n  transformFeedback?: TransformFeedback;\n\n  /** Mapped uniforms for shadertool modules */\n  moduleSettings?: Record<string, Record<string, any>>;\n\n  /** Show shader source in browser? */\n  debugShaders?: 'never' | 'errors' | 'warnings' | 'always';\n\n  /** Factory used to create a {@link RenderPipeline}. Defaults to {@link Device} default factory. */\n  pipelineFactory?: PipelineFactory;\n  /** Factory used to create a {@link Shader}. Defaults to {@link Device} default factory. */\n  shaderFactory?: ShaderFactory;\n  /** Shader assembler. Defaults to the ShaderAssembler.getShaderAssembler() */\n  shaderAssembler?: ShaderAssembler;\n};\n\n/**\n * v9 Model API\n * A model\n * - automatically reuses pipelines (programs) when possible\n * - automatically rebuilds pipelines if necessary to accommodate changed settings\n * shadertools integration\n * - accepts modules and performs shader transpilation\n */\nexport class Model {\n  static defaultProps: Required<ModelProps> = {\n    ...RenderPipeline.defaultProps,\n    source: undefined!,\n    vs: null,\n    fs: null,\n    id: 'unnamed',\n    handle: undefined,\n    userData: {},\n    defines: {},\n    modules: [],\n    moduleSettings: undefined!,\n    geometry: null,\n    indexBuffer: null,\n    attributes: {},\n    constantAttributes: {},\n    varyings: [],\n\n    isInstanced: undefined!,\n    instanceCount: 0,\n    vertexCount: 0,\n\n    shaderInputs: undefined!,\n    pipelineFactory: undefined!,\n    shaderFactory: undefined!,\n    transformFeedback: undefined!,\n    shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),\n\n    debugShaders: undefined!,\n    disableWarnings: undefined!\n  };\n\n  readonly device: Device;\n  readonly id: string;\n  // @ts-expect-error assigned in function called from constructor\n  readonly source: string;\n  // @ts-expect-error assigned in function called from constructor\n  readonly vs: string;\n  // @ts-expect-error assigned in function called from constructor\n  readonly fs: string;\n  readonly pipelineFactory: PipelineFactory;\n  readonly shaderFactory: ShaderFactory;\n  userData: {[key: string]: any} = {};\n\n  // Fixed properties (change can trigger pipeline rebuild)\n\n  /** The render pipeline GPU parameters, depth testing etc */\n  parameters: RenderPipelineParameters;\n\n  /** The primitive topology */\n  topology: PrimitiveTopology;\n  /** Buffer layout */\n  bufferLayout: BufferLayout[];\n\n  // Dynamic properties\n\n  /** Use instanced rendering */\n  isInstanced: boolean | undefined = undefined;\n  /** instance count. `undefined` means not instanced */\n  instanceCount: number = 0;\n  /** Vertex count */\n  vertexCount: number;\n\n  /** Index buffer */\n  indexBuffer: Buffer | null = null;\n  /** Buffer-valued attributes */\n  bufferAttributes: Record<string, Buffer> = {};\n  /** Constant-valued attributes */\n  constantAttributes: Record<string, TypedArray> = {};\n  /** Bindings (textures, samplers, uniform buffers) */\n  bindings: Record<string, Binding | AsyncTexture> = {};\n  /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/\n  uniforms: Record<string, UniformValue> = {};\n\n  /**\n   * VertexArray\n   * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!\n   * @todo - allow application to define multiple vertex arrays?\n   * */\n  vertexArray: VertexArray;\n\n  /** TransformFeedback, WebGL 2 only. */\n  transformFeedback: TransformFeedback | null = null;\n\n  /** The underlying GPU \"program\". @note May be recreated if parameters change */\n  pipeline: RenderPipeline;\n\n  /** ShaderInputs instance */\n  // @ts-expect-error Assigned in function called by constructor\n  shaderInputs: ShaderInputs;\n  // @ts-expect-error Assigned in function called by constructor\n  _uniformStore: UniformStore;\n\n  _attributeInfos: Record<string, AttributeInfo> = {};\n  _gpuGeometry: GPUGeometry | null = null;\n  private _getModuleUniforms: (props?: Record<string, Record<string, any>>) => Record<string, any>;\n  private props: Required<ModelProps>;\n\n  _pipelineNeedsUpdate: string | false = 'newly created';\n  private _needsRedraw: string | false = 'initializing';\n  private _destroyed = false;\n\n  /** \"Time\" of last draw. Monotonically increasing timestamp */\n  _lastDrawTimestamp: number = -1;\n\n  get [Symbol.toStringTag](): string {\n    return 'Model';\n  }\n\n  toString(): string {\n    return `Model(${this.id})`;\n  }\n\n  constructor(device: Device, props: ModelProps) {\n    this.props = {...Model.defaultProps, ...props};\n    props = this.props;\n    this.id = props.id || uid('model');\n    this.device = device;\n\n    Object.assign(this.userData, props.userData);\n\n    // Setup shader module inputs\n    const moduleMap = Object.fromEntries(\n      this.props.modules?.map(module => [module.name, module]) || []\n    );\n\n    const shaderInputs =\n      props.shaderInputs ||\n      new ShaderInputs(moduleMap, {disableWarnings: this.props.disableWarnings});\n    // @ts-ignore\n    this.setShaderInputs(shaderInputs);\n\n    // Setup shader assembler\n    const platformInfo = getPlatformInfo(device);\n\n    // Extract modules from shader inputs if not supplied\n    const modules =\n      // @ts-ignore shaderInputs is assigned in setShaderInputs above.\n      (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];\n\n    const isWebGPU = this.device.type === 'webgpu';\n\n    // WebGPU\n    // TODO - hack to support unified WGSL shader\n    // TODO - this is wrong, compile a single shader\n    if (isWebGPU && this.props.source) {\n      // WGSL\n      const {source, getUniforms} = this.props.shaderAssembler.assembleWGSLShader({\n        platformInfo,\n        ...this.props,\n        modules\n      });\n      this.source = source;\n      // @ts-expect-error\n      this._getModuleUniforms = getUniforms;\n      // Extract shader layout after modules have been added to WGSL source, to include any bindings added by modules\n      this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.source);\n    } else {\n      // GLSL\n      const {vs, fs, getUniforms} = this.props.shaderAssembler.assembleGLSLShaderPair({\n        platformInfo,\n        ...this.props,\n        modules\n      });\n\n      this.vs = vs;\n      this.fs = fs;\n      // @ts-expect-error\n      this._getModuleUniforms = getUniforms;\n    }\n\n    this.vertexCount = this.props.vertexCount;\n    this.instanceCount = this.props.instanceCount;\n\n    this.topology = this.props.topology;\n    this.bufferLayout = this.props.bufferLayout;\n    this.parameters = this.props.parameters;\n\n    // Geometry, if provided, sets topology and vertex cound\n    if (props.geometry) {\n      this.setGeometry(props.geometry);\n    }\n\n    this.pipelineFactory =\n      props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);\n    this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);\n\n    // Create the pipeline\n    // @note order is important\n    this.pipeline = this._updatePipeline();\n\n    this.vertexArray = device.createVertexArray({\n      renderPipeline: this.pipeline\n    });\n\n    // Now we can apply geometry attributes\n    if (this._gpuGeometry) {\n      this._setGeometryAttributes(this._gpuGeometry);\n    }\n\n    // Apply any dynamic settings that will not trigger pipeline change\n    if ('isInstanced' in props) {\n      this.isInstanced = props.isInstanced;\n    }\n\n    if (props.instanceCount) {\n      this.setInstanceCount(props.instanceCount);\n    }\n    if (props.vertexCount) {\n      this.setVertexCount(props.vertexCount);\n    }\n    if (props.indexBuffer) {\n      this.setIndexBuffer(props.indexBuffer);\n    }\n    if (props.attributes) {\n      this.setAttributes(props.attributes);\n    }\n    if (props.constantAttributes) {\n      this.setConstantAttributes(props.constantAttributes);\n    }\n    if (props.bindings) {\n      this.setBindings(props.bindings);\n    }\n    if (props.uniforms) {\n      this.setUniformsWebGL(props.uniforms);\n    }\n    if (props.moduleSettings) {\n      // log.warn('Model.props.moduleSettings is deprecated. Use Model.shaderInputs.setProps()')();\n      this.updateModuleSettingsWebGL(props.moduleSettings);\n    }\n    if (props.transformFeedback) {\n      this.transformFeedback = props.transformFeedback;\n    }\n\n    // Catch any access to non-standard props\n    Object.seal(this);\n  }\n\n  destroy(): void {\n    if (this._destroyed) return;\n    this.pipelineFactory.release(this.pipeline);\n    this.shaderFactory.release(this.pipeline.vs);\n    if (this.pipeline.fs) {\n      this.shaderFactory.release(this.pipeline.fs);\n    }\n    this._uniformStore.destroy();\n    // TODO - mark resource as managed and destroyIfManaged() ?\n    this._gpuGeometry?.destroy();\n    this._destroyed = true;\n  }\n\n  // Draw call\n\n  /** Query redraw status. Clears the status. */\n  needsRedraw(): false | string {\n    // Catch any writes to already bound resources\n    if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {\n      this.setNeedsRedraw('contents of bound textures or buffers updated');\n    }\n    const needsRedraw = this._needsRedraw;\n    this._needsRedraw = false;\n    return needsRedraw;\n  }\n\n  /** Mark the model as needing a redraw */\n  setNeedsRedraw(reason: string): void {\n    this._needsRedraw ||= reason;\n  }\n\n  predraw(): void {\n    // Update uniform buffers if needed\n    this.updateShaderInputs();\n    // Check if the pipeline is invalidated\n    this.pipeline = this._updatePipeline();\n  }\n\n  draw(renderPass: RenderPass): boolean {\n    const loadingBinding = this._areBindingsLoading();\n    if (loadingBinding) {\n      log.info(LOG_DRAW_PRIORITY, `>>> DRAWING ABORTED ${this.id}: ${loadingBinding} not loaded`)();\n      return false;\n    }\n\n    try {\n      renderPass.pushDebugGroup(`${this}.predraw(${renderPass})`);\n      this.predraw();\n    } finally {\n      renderPass.popDebugGroup();\n    }\n\n    let drawSuccess: boolean;\n    try {\n      renderPass.pushDebugGroup(`${this}.draw(${renderPass})`);\n      this._logDrawCallStart();\n\n      // Update the pipeline if invalidated\n      // TODO - inside RenderPass is likely the worst place to do this from performance perspective.\n      // Application can call Model.predraw() to avoid this.\n      this.pipeline = this._updatePipeline();\n\n      // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw\n      // Any caching needs to be done inside the pipeline functions\n      // TODO this is a busy initialized check for all bindings every frame\n\n      const syncBindings = this._getBindings();\n      this.pipeline.setBindings(syncBindings, {\n        disableWarnings: this.props.disableWarnings\n      });\n      if (!isObjectEmpty(this.uniforms)) {\n        this.pipeline.setUniformsWebGL(this.uniforms);\n      }\n\n      const {indexBuffer} = this.vertexArray;\n      const indexCount = indexBuffer\n        ? indexBuffer.byteLength / (indexBuffer.indexType === 'uint32' ? 4 : 2)\n        : undefined;\n\n      drawSuccess = this.pipeline.draw({\n        renderPass,\n        vertexArray: this.vertexArray,\n        isInstanced: this.isInstanced,\n        vertexCount: this.vertexCount,\n        instanceCount: this.instanceCount,\n        indexCount,\n        transformFeedback: this.transformFeedback || undefined,\n        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,\n        // so we must provide our unique parameters to each draw\n        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)\n        parameters: this.parameters,\n        topology: this.topology\n      });\n    } finally {\n      renderPass.popDebugGroup();\n      this._logDrawCallEnd();\n    }\n    this._logFramebuffer(renderPass);\n\n    // Update needsRedraw flag\n    if (drawSuccess) {\n      this._lastDrawTimestamp = this.device.timestamp;\n      this._needsRedraw = false;\n    } else {\n      this._needsRedraw = 'waiting for resource initialization';\n    }\n    return drawSuccess;\n  }\n\n  // Update fixed fields (can trigger pipeline rebuild)\n\n  /**\n   * Updates the optional geometry\n   * Geometry, set topology and bufferLayout\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  setGeometry(geometry: GPUGeometry | Geometry | null): void {\n    this._gpuGeometry?.destroy();\n    const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);\n    if (gpuGeometry) {\n      this.setTopology(gpuGeometry.topology || 'triangle-list');\n      const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n      this.bufferLayout = bufferLayoutHelper.mergeBufferLayouts(\n        gpuGeometry.bufferLayout,\n        this.bufferLayout\n      );\n      if (this.vertexArray) {\n        this._setGeometryAttributes(gpuGeometry);\n      }\n    }\n    this._gpuGeometry = gpuGeometry;\n  }\n\n  /**\n   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).\n   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  setTopology(topology: PrimitiveTopology): void {\n    if (topology !== this.topology) {\n      this.topology = topology;\n      this._setPipelineNeedsUpdate('topology');\n    }\n  }\n\n  /**\n   * Updates the buffer layout.\n   * @note Triggers a pipeline rebuild / pipeline cache fetch\n   */\n  setBufferLayout(bufferLayout: BufferLayout[]): void {\n    const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n    this.bufferLayout = this._gpuGeometry\n      ? bufferLayoutHelper.mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout)\n      : bufferLayout;\n    this._setPipelineNeedsUpdate('bufferLayout');\n\n    // Recreate the pipeline\n    this.pipeline = this._updatePipeline();\n\n    // vertex array needs to be updated if we update buffer layout,\n    // but not if we update parameters\n    this.vertexArray = this.device.createVertexArray({\n      renderPipeline: this.pipeline\n    });\n\n    // Reapply geometry attributes to the new vertex array\n    if (this._gpuGeometry) {\n      this._setGeometryAttributes(this._gpuGeometry);\n    }\n  }\n\n  /**\n   * Set GPU parameters.\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch.\n   * @param parameters\n   */\n  setParameters(parameters: RenderPipelineParameters) {\n    if (!deepEqual(parameters, this.parameters, 2)) {\n      this.parameters = parameters;\n      this._setPipelineNeedsUpdate('parameters');\n    }\n  }\n\n  // Update dynamic fields\n\n  /**\n   * Updates the instance count (used in draw calls)\n   * @note Any attributes with stepMode=instance need to be at least this big\n   */\n  setInstanceCount(instanceCount: number): void {\n    this.instanceCount = instanceCount;\n    // luma.gl examples don't set props.isInstanced and rely on auto-detection\n    // but deck.gl sets instanceCount even for models that are not instanced.\n    if (this.isInstanced === undefined && instanceCount > 0) {\n      this.isInstanced = true;\n    }\n    this.setNeedsRedraw('instanceCount');\n  }\n\n  /**\n   * Updates the vertex count (used in draw calls)\n   * @note Any attributes with stepMode=vertex need to be at least this big\n   */\n  setVertexCount(vertexCount: number): void {\n    this.vertexCount = vertexCount;\n    this.setNeedsRedraw('vertexCount');\n  }\n\n  /** Set the shader inputs */\n  setShaderInputs(shaderInputs: ShaderInputs): void {\n    this.shaderInputs = shaderInputs;\n    this._uniformStore = new UniformStore(this.shaderInputs.modules);\n    // Create uniform buffer bindings for all modules that actually have uniforms\n    for (const [moduleName, module] of Object.entries(this.shaderInputs.modules)) {\n      if (shaderModuleHasUniforms(module)) {\n        const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);\n        this.bindings[`${moduleName}Uniforms`] = uniformBuffer;\n      }\n    }\n    this.setNeedsRedraw('shaderInputs');\n  }\n\n  /** Update uniform buffers from the model's shader inputs */\n  updateShaderInputs(): void {\n    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());\n    this.setBindings(this.shaderInputs.getBindingValues());\n    // TODO - this is already tracked through buffer/texture update times?\n    this.setNeedsRedraw('shaderInputs');\n  }\n\n  /**\n   * Sets bindings (textures, samplers, uniform buffers)\n   */\n  setBindings(bindings: Record<string, Binding | AsyncTexture>): void {\n    Object.assign(this.bindings, bindings);\n    this.setNeedsRedraw('bindings');\n  }\n\n  /**\n   * Updates optional transform feedback. WebGL only.\n   */\n  setTransformFeedback(transformFeedback: TransformFeedback | null): void {\n    this.transformFeedback = transformFeedback;\n    this.setNeedsRedraw('transformFeedback');\n  }\n\n  /**\n   * Sets the index buffer\n   * @todo - how to unset it if we change geometry?\n   */\n  setIndexBuffer(indexBuffer: Buffer | null): void {\n    this.vertexArray.setIndexBuffer(indexBuffer);\n    this.setNeedsRedraw('indexBuffer');\n  }\n\n  /**\n   * Sets attributes (buffers)\n   * @note Overrides any attributes previously set with the same name\n   */\n  setAttributes(buffers: Record<string, Buffer>, options?: {disableWarnings?: boolean}): void {\n    const disableWarnings = options?.disableWarnings ?? this.props.disableWarnings;\n    if (buffers.indices) {\n      log.warn(\n        `Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`\n      )();\n    }\n\n    // ensure bufferLayout order matches source layout so we bind\n    // the correct buffers to the correct indices in webgpu.\n    this.bufferLayout = sortedBufferLayoutByShaderSourceLocations(\n      this.pipeline.shaderLayout,\n      this.bufferLayout\n    );\n    const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n\n    // Check if all buffers have a layout\n    for (const [bufferName, buffer] of Object.entries(buffers)) {\n      const bufferLayout = bufferLayoutHelper.getBufferLayout(bufferName);\n      if (!bufferLayout) {\n        if (!disableWarnings) {\n          log.warn(`Model(${this.id}): Missing layout for buffer \"${bufferName}\".`)();\n        }\n        continue; // eslint-disable-line no-continue\n      }\n\n      // In WebGL, for an interleaved attribute we may need to set multiple attributes\n      // but in WebGPU, we set it according to the buffer's position in the vertexArray\n      const attributeNames = bufferLayoutHelper.getAttributeNamesForBuffer(bufferLayout);\n      let set = false;\n      for (const attributeName of attributeNames) {\n        const attributeInfo = this._attributeInfos[attributeName];\n        if (attributeInfo) {\n          const location =\n            this.device.type === 'webgpu'\n              ? bufferLayoutHelper.getBufferIndex(attributeInfo.bufferName)\n              : attributeInfo.location;\n\n          this.vertexArray.setBuffer(location, buffer);\n          set = true;\n        }\n      }\n      if (!set && !disableWarnings) {\n        log.warn(\n          `Model(${this.id}): Ignoring buffer \"${buffer.id}\" for unknown attribute \"${bufferName}\"`\n        )();\n      }\n    }\n    this.setNeedsRedraw('attributes');\n  }\n\n  /**\n   * Sets constant attributes\n   * @note Overrides any attributes previously set with the same name\n   * Constant attributes are only supported in WebGL, not in WebGPU\n   * Any attribute that is disabled in the current vertex array object\n   * is read from the context's global constant value for that attribute location.\n   * @param constantAttributes\n   */\n  setConstantAttributes(\n    attributes: Record<string, TypedArray>,\n    options?: {disableWarnings?: boolean}\n  ): void {\n    for (const [attributeName, value] of Object.entries(attributes)) {\n      const attributeInfo = this._attributeInfos[attributeName];\n      if (attributeInfo) {\n        this.vertexArray.setConstantWebGL(attributeInfo.location, value);\n      } else if (!(options?.disableWarnings ?? this.props.disableWarnings)) {\n        log.warn(\n          `Model \"${this.id}: Ignoring constant supplied for unknown attribute \"${attributeName}\"`\n        )();\n      }\n    }\n    this.setNeedsRedraw('constants');\n  }\n\n  // DEPRECATED METHODS\n\n  /**\n   * Sets individual uniforms\n   * @deprecated WebGL only, use uniform buffers for portability\n   * @param uniforms\n   */\n  setUniforms(uniforms: Record<string, UniformValue>): void {\n    this.setUniformsWebGL(uniforms);\n  }\n\n  /**\n   * Sets individual uniforms\n   * @deprecated WebGL only, use uniform buffers for portability\n   * @param uniforms\n   */\n  setUniformsWebGL(uniforms: Record<string, UniformValue>): void {\n    if (!isObjectEmpty(uniforms)) {\n      this.pipeline.setUniformsWebGL(uniforms);\n      Object.assign(this.uniforms, uniforms);\n    }\n    this.setNeedsRedraw('uniforms');\n  }\n\n  /**\n   * @deprecated Updates shader module settings (which results in uniforms being set)\n   */\n  updateModuleSettingsWebGL(props: Record<string, any>): void {\n    // log.warn('Model.updateModuleSettings is deprecated. Use Model.shaderInputs.setProps()')();\n    const {bindings, uniforms} = splitUniformsAndBindings(this._getModuleUniforms(props));\n    Object.assign(this.bindings, bindings);\n    Object.assign(this.uniforms, uniforms);\n    this.setNeedsRedraw('moduleSettings');\n  }\n\n  // Internal methods\n\n  /** Check that bindings are loaded. Returns id of first binding that is still loading. */\n  _areBindingsLoading(): string | false {\n    for (const binding of Object.values(this.bindings)) {\n      if (binding instanceof AsyncTexture && !binding.isReady) {\n        return binding.id;\n      }\n    }\n    return false;\n  }\n\n  /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */\n  _getBindings(): Record<string, Binding> {\n    const validBindings: Record<string, Binding> = {};\n\n    for (const [name, binding] of Object.entries(this.bindings)) {\n      if (binding instanceof AsyncTexture) {\n        // Check that async textures are loaded\n        if (binding.isReady) {\n          validBindings[name] = binding.texture;\n        }\n      } else {\n        validBindings[name] = binding;\n      }\n    }\n\n    return validBindings;\n  }\n\n  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */\n  _getBindingsUpdateTimestamp(): number {\n    let timestamp = 0;\n    for (const binding of Object.values(this.bindings)) {\n      if (binding instanceof TextureView) {\n        timestamp = Math.max(timestamp, binding.texture.updateTimestamp);\n      } else if (binding instanceof Buffer || binding instanceof Texture) {\n        timestamp = Math.max(timestamp, binding.updateTimestamp);\n      } else if (binding instanceof AsyncTexture) {\n        timestamp = binding.texture\n          ? Math.max(timestamp, binding.texture.updateTimestamp)\n          : // The texture will become available in the future\n            Infinity;\n      } else if (!(binding instanceof Sampler)) {\n        timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);\n      }\n    }\n    return timestamp;\n  }\n\n  /**\n   * Updates the optional geometry attributes\n   * Geometry, sets several attributes, indexBuffer, and also vertex count\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  _setGeometryAttributes(gpuGeometry: GPUGeometry): void {\n    // Filter geometry attribute so that we don't issue warnings for unused attributes\n    const attributes = {...gpuGeometry.attributes};\n    for (const [attributeName] of Object.entries(attributes)) {\n      if (\n        !this.pipeline.shaderLayout.attributes.find(layout => layout.name === attributeName) &&\n        attributeName !== 'positions'\n      ) {\n        delete attributes[attributeName];\n      }\n    }\n\n    // TODO - delete previous geometry?\n    this.vertexCount = gpuGeometry.vertexCount;\n    this.setIndexBuffer(gpuGeometry.indices || null);\n    this.setAttributes(gpuGeometry.attributes, {disableWarnings: true});\n    this.setAttributes(attributes, {disableWarnings: this.props.disableWarnings});\n\n    this.setNeedsRedraw('geometry attributes');\n  }\n\n  /** Mark pipeline as needing update */\n  _setPipelineNeedsUpdate(reason: string): void {\n    this._pipelineNeedsUpdate ||= reason;\n    this.setNeedsRedraw(reason);\n  }\n\n  /** Update pipeline if needed */\n  _updatePipeline(): RenderPipeline {\n    if (this._pipelineNeedsUpdate) {\n      let prevShaderVs: Shader | null = null;\n      let prevShaderFs: Shader | null = null;\n      if (this.pipeline) {\n        log.log(\n          1,\n          `Model ${this.id}: Recreating pipeline because \"${this._pipelineNeedsUpdate}\".`\n        )();\n        prevShaderVs = this.pipeline.vs;\n        prevShaderFs = this.pipeline.fs;\n      }\n\n      this._pipelineNeedsUpdate = false;\n\n      const vs = this.shaderFactory.createShader({\n        id: `${this.id}-vertex`,\n        stage: 'vertex',\n        source: this.source || this.vs,\n        debugShaders: this.props.debugShaders\n      });\n\n      let fs: Shader | null = null;\n      if (this.source) {\n        fs = vs;\n      } else if (this.fs) {\n        fs = this.shaderFactory.createShader({\n          id: `${this.id}-fragment`,\n          stage: 'fragment',\n          source: this.source || this.fs,\n          debugShaders: this.props.debugShaders\n        });\n      }\n\n      this.pipeline = this.pipelineFactory.createRenderPipeline({\n        ...this.props,\n        bufferLayout: this.bufferLayout,\n        topology: this.topology,\n        parameters: this.parameters,\n        // TODO - why set bindings here when we reset them every frame?\n        // Should we expose a BindGroup abstraction?\n        bindings: this._getBindings(),\n        vs,\n        fs\n      });\n\n      this._attributeInfos = getAttributeInfosFromLayouts(\n        this.pipeline.shaderLayout,\n        this.bufferLayout\n      );\n\n      if (prevShaderVs) this.shaderFactory.release(prevShaderVs);\n      if (prevShaderFs) this.shaderFactory.release(prevShaderFs);\n    }\n    return this.pipeline;\n  }\n\n  /** Throttle draw call logging */\n  _lastLogTime = 0;\n  _logOpen = false;\n\n  _logDrawCallStart(): void {\n    // IF level is 4 or higher, log every frame.\n    const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {\n      return;\n    }\n\n    this._lastLogTime = Date.now();\n    this._logOpen = true;\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.level <= 2})();\n  }\n\n  _logDrawCallEnd(): void {\n    if (this._logOpen) {\n      const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);\n\n      // log.table(logLevel, attributeTable)();\n      // log.table(logLevel, uniformTable)();\n      log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();\n\n      const uniformTable = this.shaderInputs.getDebugTable();\n      // Add any global uniforms\n      for (const [name, value] of Object.entries(this.uniforms)) {\n        uniformTable[name] = {value};\n      }\n      log.table(LOG_DRAW_PRIORITY, uniformTable)();\n\n      const attributeTable = this._getAttributeDebugTable();\n      log.table(LOG_DRAW_PRIORITY, this._attributeInfos)();\n      log.table(LOG_DRAW_PRIORITY, attributeTable)();\n\n      log.groupEnd(LOG_DRAW_PRIORITY)();\n      this._logOpen = false;\n    }\n  }\n\n  protected _drawCount = 0;\n  _logFramebuffer(renderPass: RenderPass): void {\n    const debugFramebuffers = this.device.props.debugFramebuffers;\n    this._drawCount++;\n    // Update first 3 frames and then every 60 frames\n    if (!debugFramebuffers) {\n      // } || (this._drawCount++ > 3 && this._drawCount % 60)) {\n      return;\n    }\n    // TODO - display framebuffer output in debug window\n    const framebuffer = renderPass.props.framebuffer;\n    if (framebuffer) {\n      debugFramebuffer(framebuffer, {id: framebuffer.id, minimap: true});\n      // log.image({logLevel: LOG_DRAW_PRIORITY, message: `${framebuffer.id} %c sup?`, image})();\n    }\n  }\n\n  _getAttributeDebugTable(): Record<string, Record<string, unknown>> {\n    const table: Record<string, Record<string, unknown>> = {};\n    for (const [name, attributeInfo] of Object.entries(this._attributeInfos)) {\n      const values = this.vertexArray.attributes[attributeInfo.location];\n      table[attributeInfo.location] = {\n        name,\n        type: attributeInfo.shaderType,\n        values: values\n          ? this._getBufferOrConstantValues(values, attributeInfo.bufferDataType)\n          : 'null'\n      };\n    }\n    if (this.vertexArray.indexBuffer) {\n      const {indexBuffer} = this.vertexArray;\n      const values =\n        indexBuffer.indexType === 'uint32'\n          ? new Uint32Array(indexBuffer.debugData)\n          : new Uint16Array(indexBuffer.debugData);\n      table.indices = {\n        name: 'indices',\n        type: indexBuffer.indexType,\n        values: values.toString()\n      };\n    }\n    return table;\n  }\n\n  // TODO - fix typing of luma data types\n  _getBufferOrConstantValues(attribute: Buffer | TypedArray, dataType: any): string {\n    const TypedArrayConstructor = getTypedArrayFromDataType(dataType);\n    const typedArray =\n      attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;\n    return typedArray.toString();\n  }\n}\n\nfunction shaderModuleHasUniforms(module: ShaderModule): boolean {\n  return Boolean(module.uniformTypes && !isObjectEmpty(module.uniformTypes));\n}\n\n// HELPERS\n\n/** Create a shadertools platform info from the Device */\nexport function getPlatformInfo(device: Device): PlatformInfo {\n  return {\n    type: device.type,\n    shaderLanguage: device.info.shadingLanguage,\n    shaderLanguageVersion: device.info.shadingLanguageVersion as 100 | 300,\n    gpu: device.info.gpu,\n    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API\n    features: device.features as unknown as Set<DeviceFeature>\n  };\n}\n\n/** Returns true if given object is empty, false otherwise. */\nfunction isObjectEmpty(obj: object): boolean {\n  // @ts-ignore key is unused\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const key in obj) {\n    return false;\n  }\n  return true;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {PrimitiveTopology, BufferLayout} from '@luma.gl/core';\nimport {Device, Buffer, getVertexFormatFromAttribute} from '@luma.gl/core';\nimport type {Geometry} from '../geometry/geometry';\nimport {uid} from '../utils/uid';\n\nexport type GPUGeometryProps = {\n  id?: string;\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology: 'point-list' | 'line-list' | 'line-strip' | 'triangle-list' | 'triangle-strip';\n  /** Auto calculated from attributes if not provided */\n  vertexCount: number;\n  bufferLayout: BufferLayout[];\n  indices?: Buffer | null;\n  attributes: Record<string, Buffer>;\n};\n\nexport class GPUGeometry {\n  readonly id: string;\n  userData: Record<string, unknown> = {};\n\n  /** Determines how vertices are read from the 'vertex' attributes */\n  readonly topology?: PrimitiveTopology;\n  readonly bufferLayout: BufferLayout[] = [];\n\n  readonly vertexCount: number;\n  readonly indices?: Buffer | null;\n  readonly attributes: Record<string, Buffer>;\n\n  constructor(props: GPUGeometryProps) {\n    this.id = props.id || uid('geometry');\n    this.topology = props.topology;\n    this.indices = props.indices || null;\n    this.attributes = props.attributes;\n\n    this.vertexCount = props.vertexCount;\n\n    this.bufferLayout = props.bufferLayout || [];\n\n    if (this.indices) {\n      if (!(this.indices.usage & Buffer.INDEX)) {\n        throw new Error('Index buffer must have INDEX usage');\n      }\n    }\n  }\n\n  destroy(): void {\n    this.indices?.destroy();\n    for (const attribute of Object.values(this.attributes)) {\n      attribute.destroy();\n    }\n  }\n\n  getVertexCount(): number {\n    return this.vertexCount;\n  }\n\n  getAttributes(): Record<string, Buffer> {\n    return this.attributes;\n  }\n\n  getIndexes(): Buffer | null {\n    return this.indices || null;\n  }\n\n  _calculateVertexCount(positions: Buffer): number {\n    // Assume that positions is a fully packed float32x3 buffer\n    const vertexCount = positions.byteLength / 12;\n    return vertexCount;\n  }\n}\n\nexport function makeGPUGeometry(device: Device, geometry: Geometry | GPUGeometry): GPUGeometry {\n  if (geometry instanceof GPUGeometry) {\n    return geometry;\n  }\n\n  const indices = getIndexBufferFromGeometry(device, geometry);\n  const {attributes, bufferLayout} = getAttributeBuffersFromGeometry(device, geometry);\n  return new GPUGeometry({\n    topology: geometry.topology || 'triangle-list',\n    bufferLayout,\n    vertexCount: geometry.vertexCount,\n    indices,\n    attributes\n  });\n}\n\nexport function getIndexBufferFromGeometry(device: Device, geometry: Geometry): Buffer | undefined {\n  if (!geometry.indices) {\n    return undefined;\n  }\n  const data = geometry.indices.value;\n  return device.createBuffer({usage: Buffer.INDEX, data});\n}\n\nexport function getAttributeBuffersFromGeometry(\n  device: Device,\n  geometry: Geometry\n): {attributes: Record<string, Buffer>; bufferLayout: BufferLayout[]; vertexCount: number} {\n  const bufferLayout: BufferLayout[] = [];\n\n  const attributes: Record<string, Buffer> = {};\n  for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {\n    let name: string = attributeName;\n    // TODO Map some GLTF attribute names (is this still needed?)\n    switch (attributeName) {\n      case 'POSITION':\n        name = 'positions';\n        break;\n      case 'NORMAL':\n        name = 'normals';\n        break;\n      case 'TEXCOORD_0':\n        name = 'texCoords';\n        break;\n      case 'COLOR_0':\n        name = 'colors';\n        break;\n    }\n    if (attribute) {\n      attributes[name] = device.createBuffer({\n        data: attribute.value,\n        id: `${attributeName}-buffer`\n      });\n      const {value, size, normalized} = attribute;\n      // @ts-expect-error\n      bufferLayout.push({name, format: getVertexFormatFromAttribute(value, size, normalized)});\n    }\n  }\n\n  const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);\n\n  return {attributes, bufferLayout, vertexCount};\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nconst uidCounters: Record<string, number> = {};\n\n/**\n * Returns a UID.\n * @param id= - Identifier base name\n * @return uid\n **/\nexport function uid(id: string = 'id'): string {\n  uidCounters[id] = uidCounters[id] || 1;\n  const count = uidCounters[id]++;\n  return `${id}-${count}`;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {RenderPipelineProps, ComputePipelineProps} from '@luma.gl/core';\nimport {Device, RenderPipeline, ComputePipeline} from '@luma.gl/core';\n\nexport type PipelineFactoryProps = RenderPipelineProps;\n\ntype RenderPipelineCacheItem = {pipeline: RenderPipeline; useCount: number};\ntype ComputePipelineCacheItem = {pipeline: ComputePipeline; useCount: number};\n\n/**\n * Efficiently creates / caches pipelines\n */\nexport class PipelineFactory {\n  static defaultProps: Required<PipelineFactoryProps> = {...RenderPipeline.defaultProps};\n\n  /** Get the singleton default pipeline factory for the specified device */\n  static getDefaultPipelineFactory(device: Device): PipelineFactory {\n    device._lumaData.defaultPipelineFactory =\n      device._lumaData.defaultPipelineFactory || new PipelineFactory(device);\n    return device._lumaData.defaultPipelineFactory as PipelineFactory;\n  }\n\n  readonly device: Device;\n  readonly destroyPolicy: 'unused' | 'never';\n\n  private _hashCounter: number = 0;\n  private readonly _hashes: Record<string, number> = {};\n  private readonly _renderPipelineCache: Record<string, RenderPipelineCacheItem> = {};\n  private readonly _computePipelineCache: Record<string, ComputePipelineCacheItem> = {};\n\n  constructor(device: Device) {\n    this.device = device;\n    this.destroyPolicy = device.props._factoryDestroyPolicy;\n  }\n\n  /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */\n  createRenderPipeline(props: RenderPipelineProps): RenderPipeline {\n    const allProps: Required<RenderPipelineProps> = {...RenderPipeline.defaultProps, ...props};\n\n    const hash = this._hashRenderPipeline(allProps);\n\n    if (!this._renderPipelineCache[hash]) {\n      const pipeline = this.device.createRenderPipeline({\n        ...allProps,\n        id: allProps.id ? `${allProps.id}-cached` : undefined\n      });\n      pipeline.hash = hash;\n      this._renderPipelineCache[hash] = {pipeline, useCount: 0};\n    }\n\n    this._renderPipelineCache[hash].useCount++;\n    return this._renderPipelineCache[hash].pipeline;\n  }\n\n  createComputePipeline(props: ComputePipelineProps): ComputePipeline {\n    const allProps: Required<ComputePipelineProps> = {...ComputePipeline.defaultProps, ...props};\n\n    const hash = this._hashComputePipeline(allProps);\n\n    if (!this._computePipelineCache[hash]) {\n      const pipeline = this.device.createComputePipeline({\n        ...allProps,\n        id: allProps.id ? `${allProps.id}-cached` : undefined\n      });\n      pipeline.hash = hash;\n      this._computePipelineCache[hash] = {pipeline, useCount: 0};\n    }\n\n    this._computePipelineCache[hash].useCount++;\n    return this._computePipelineCache[hash].pipeline;\n  }\n\n  release(pipeline: RenderPipeline | ComputePipeline): void {\n    const hash = pipeline.hash;\n    const cache =\n      pipeline instanceof ComputePipeline ? this._computePipelineCache : this._renderPipelineCache;\n    cache[hash].useCount--;\n    if (cache[hash].useCount === 0) {\n      if (this.destroyPolicy === 'unused') {\n        cache[hash].pipeline.destroy();\n        delete cache[hash];\n      }\n    }\n  }\n\n  // PRIVATE\n  private _hashComputePipeline(props: ComputePipelineProps): string {\n    const shaderHash = this._getHash(props.shader.source);\n    return `${shaderHash}`;\n  }\n\n  /** Calculate a hash based on all the inputs for a render pipeline */\n  private _hashRenderPipeline(props: RenderPipelineProps): string {\n    const vsHash = props.vs ? this._getHash(props.vs.source) : 0;\n    const fsHash = props.fs ? this._getHash(props.fs.source) : 0;\n\n    // WebGL specific\n    // const {varyings = [], bufferMode = {}} = props;\n    // const varyingHashes = varyings.map((v) => this._getHash(v));\n    const varyingHash = '-'; // `${varyingHashes.join('/')}B${bufferMode}`\n    const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));\n\n    switch (this.device.type) {\n      case 'webgl':\n        // WebGL is more dynamic\n        return `${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;\n\n      default:\n        // On WebGPU we need to rebuild the pipeline if topology, parameters or bufferLayout change\n        const parameterHash = this._getHash(JSON.stringify(props.parameters));\n        // TODO - Can json.stringify() generate different strings for equivalent objects if order of params is different?\n        // create a deepHash() to deduplicate?\n        return `${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;\n    }\n  }\n\n  private _getHash(key: string): number {\n    if (this._hashes[key] === undefined) {\n      this._hashes[key] = this._hashCounter++;\n    }\n    return this._hashes[key];\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Shader, ShaderProps} from '@luma.gl/core';\n\n/** Manages a cached pool of Shaders for reuse. */\nexport class ShaderFactory {\n  static readonly defaultProps: Required<ShaderProps> = {...Shader.defaultProps};\n\n  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */\n  static getDefaultShaderFactory(device: Device): ShaderFactory {\n    device._lumaData.defaultShaderFactory ||= new ShaderFactory(device);\n    return device._lumaData.defaultShaderFactory as ShaderFactory;\n  }\n\n  public readonly device: Device;\n  readonly destroyPolicy: 'unused' | 'never';\n  private readonly _cache: Record<string, {shader: Shader; useCount: number}> = {};\n\n  /** @internal */\n  constructor(device: Device) {\n    this.device = device;\n    this.destroyPolicy = device.props._factoryDestroyPolicy;\n  }\n\n  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */\n  createShader(props: ShaderProps): Shader {\n    const key = this._hashShader(props);\n\n    let cacheEntry = this._cache[key];\n    if (!cacheEntry) {\n      const shader = this.device.createShader({\n        ...props,\n        id: props.id ? `${props.id}-cached` : undefined\n      });\n      this._cache[key] = cacheEntry = {shader, useCount: 0};\n    }\n\n    cacheEntry.useCount++;\n    return cacheEntry.shader;\n  }\n\n  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */\n  release(shader: Shader): void {\n    const key = this._hashShader(shader);\n    const cacheEntry = this._cache[key];\n    if (cacheEntry) {\n      cacheEntry.useCount--;\n      if (cacheEntry.useCount === 0) {\n        if (this.destroyPolicy === 'unused') {\n          delete this._cache[key];\n          cacheEntry.shader.destroy();\n        }\n      }\n    }\n  }\n\n  // PRIVATE\n\n  private _hashShader(value: Shader | ShaderProps): string {\n    return `${value.stage}:${value.source}`;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderLayout} from '@luma.gl/core';\n\n/**\n * Extracts a table suitable for `console.table()` from a shader layout to assist in debugging.\n * @param layout shader layout\n * @param name app should provide the most meaningful name, usually the model or pipeline name / id.\n * @returns\n */\nexport function getDebugTableForShaderLayout(\n  layout: ShaderLayout,\n  name: string\n): Record<string, Record<string, string>> {\n  const table: Record<string, Record<string, string>> = {};\n\n  const header = 'Values'; // '`Shader Layout for ${name}`;\n\n  if (layout.attributes.length === 0 && !layout.varyings?.length) {\n    return {'No attributes or varyings': {[header]: 'N/A'}};\n  }\n\n  for (const attributeDeclaration of layout.attributes) {\n    if (attributeDeclaration) {\n      const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;\n      table[`in ${glslDeclaration}`] = {[header]: attributeDeclaration.stepMode || 'vertex'};\n    }\n  }\n\n  for (const varyingDeclaration of layout.varyings || []) {\n    const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;\n    table[`out ${glslDeclaration}`] = {[header]: JSON.stringify(varyingDeclaration)};\n  }\n\n  return table;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Framebuffer, Texture} from '@luma.gl/core';\n// import {copyTextureToImage} from '../debug/copy-texture-to-image';\n\n/** Only works with 1st device? */\nlet canvas: HTMLCanvasElement | null = null;\nlet ctx: CanvasRenderingContext2D | null = null;\n// let targetImage: HTMLImageElement | null = null;\n\n/** Debug utility to draw FBO contents onto screen */\n// eslint-disable-next-line\nexport function debugFramebuffer(\n  fbo: Framebuffer | Texture,\n  {\n    id,\n    minimap,\n    opaque,\n    top = '0',\n    left = '0',\n    rgbaScale = 1\n  }: {\n    id: string;\n    minimap?: boolean;\n    opaque?: boolean;\n    top?: string;\n    left?: string;\n    rgbaScale?: number;\n  }\n) {\n  if (!canvas) {\n    canvas = document.createElement('canvas');\n    canvas.id = id;\n    canvas.title = id;\n    canvas.style.zIndex = '100';\n    canvas.style.position = 'absolute';\n    canvas.style.top = top; // \u26A0\uFE0F\n    canvas.style.left = left; // \u26A0\uFE0F\n    canvas.style.border = 'blue 5px solid';\n    canvas.style.transform = 'scaleY(-1)';\n    document.body.appendChild(canvas);\n\n    ctx = canvas.getContext('2d');\n    // targetImage = new Image();\n  }\n\n  // const canvasHeight = (minimap ? 2 : 1) * fbo.height;\n  if (canvas.width !== fbo.width || canvas.height !== fbo.height) {\n    canvas.width = fbo.width / 2;\n    canvas.height = fbo.height / 2;\n    canvas.style.width = '400px';\n    canvas.style.height = '400px';\n  }\n\n  // const image = copyTextureToImage(fbo, {targetMaxHeight: 100, targetImage});\n  // ctx.drawImage(image, 0, 0);\n\n  const color = fbo.device.readPixelsToArrayWebGL(fbo);\n  const imageData = ctx?.createImageData(fbo.width, fbo.height);\n  if (imageData) {\n    // Full map\n    const offset = 0;\n    // if (color.some((v) => v > 0)) {\n    //   console.error('THERE IS NON-ZERO DATA IN THE FBO!');\n    // }\n    for (let i = 0; i < color.length; i += 4) {\n      imageData.data[offset + i + 0] = color[i + 0] * rgbaScale;\n      imageData.data[offset + i + 1] = color[i + 1] * rgbaScale;\n      imageData.data[offset + i + 2] = color[i + 2] * rgbaScale;\n      imageData.data[offset + i + 3] = opaque ? 255 : color[i + 3] * rgbaScale;\n    }\n    ctx?.putImageData(imageData, 0, 0);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/**\n * Fast partial deep equal for prop.\n *\n * @param a Prop\n * @param b Prop to compare against `a`\n * @param depth Depth to which to recurse in nested Objects/Arrays. Use 0 (default) for shallow comparison, -1 for infinite depth\n */\n/* eslint-disable complexity */\nexport function deepEqual(a: any, b: any, depth: number): boolean {\n  if (a === b) {\n    return true;\n  }\n  if (!depth || !a || !b) {\n    return false;\n  }\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b) || a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i], depth - 1)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (Array.isArray(b)) {\n    return false;\n  }\n  if (typeof a === 'object' && typeof b === 'object') {\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n    for (const key of aKeys) {\n      if (!b.hasOwnProperty(key)) {\n        return false;\n      }\n      if (!deepEqual(a[key], b[key], depth - 1)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Binding, UniformValue} from '@luma.gl/core';\nimport {log} from '@luma.gl/core';\n// import type {ShaderUniformType, UniformValue, UniformFormat, UniformInfoDevice, Texture, Sampler} from '@luma.gl/core';\nimport {getShaderModuleDependencies, ShaderModule} from '@luma.gl/shadertools';\nimport {splitUniformsAndBindings} from './model/split-uniforms-and-bindings';\n\nexport type ShaderInputsOptions = {\n  disableWarnings?: boolean;\n};\n\n/**\n * ShaderInputs holds uniform and binding values for one or more shader modules,\n * - It can generate binary data for any uniform buffer\n * - It can manage a uniform buffer for each block\n * - It can update managed uniform buffers with a single call\n * - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.\n */\nexport class ShaderInputs<\n  ShaderPropsT extends Partial<Record<string, Record<string, unknown>>> = Partial<\n    Record<string, Record<string, unknown>>\n  >\n> {\n  options: Required<ShaderInputsOptions> = {\n    disableWarnings: false\n  };\n\n  /**\n   * The map of modules\n   * @todo should should this include the resolved dependencies?\n   */\n  // @ts-ignore Fix typings\n  modules: Readonly<{[P in keyof ShaderPropsT]: ShaderModule<ShaderPropsT[P]>}>;\n\n  /** Stores the uniform values for each module */\n  moduleUniforms: Record<keyof ShaderPropsT, Record<string, UniformValue>>;\n  /** Stores the uniform bindings for each module  */\n  moduleBindings: Record<keyof ShaderPropsT, Record<string, Binding>>;\n  /** Tracks if uniforms have changed */\n  // moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;\n\n  /**\n   * Create a new UniformStore instance\n   * @param modules\n   */\n  constructor(\n    // @ts-ignore Fix typings\n    modules: {[P in keyof ShaderPropsT]?: ShaderModule<ShaderPropsT[P], any>},\n    options?: ShaderInputsOptions\n  ) {\n    Object.assign(this.options, options);\n\n    // Extract modules with dependencies\n    const resolvedModules = getShaderModuleDependencies(\n      Object.values(modules).filter(module => module.dependencies)\n    );\n    for (const resolvedModule of resolvedModules) {\n      // @ts-ignore\n      modules[resolvedModule.name] = resolvedModule;\n    }\n\n    log.log(1, 'Creating ShaderInputs with modules', Object.keys(modules))();\n\n    // Store the module definitions and create storage for uniform values and binding values, per module\n    // @ts-ignore Fix typings\n    this.modules = modules as {[P in keyof ShaderPropsT]: ShaderModule<ShaderPropsT[P]>};\n    this.moduleUniforms = {} as Record<keyof ShaderPropsT, Record<string, UniformValue>>;\n    this.moduleBindings = {} as Record<keyof ShaderPropsT, Record<string, Binding>>;\n\n    // Initialize the modules\n    for (const [name, module] of Object.entries(modules)) {\n      this._addModule(module);\n      if (module.name && name !== module.name && !this.options.disableWarnings) {\n        log.warn(`Module name: ${name} vs ${module.name}`)();\n      }\n    }\n  }\n\n  /** Destroy */\n  destroy(): void {}\n\n  /**\n   * Set module props\n   */\n  setProps(props: Partial<{[P in keyof ShaderPropsT]?: Partial<ShaderPropsT[P]>}>): void {\n    for (const name of Object.keys(props)) {\n      const moduleName = name as keyof ShaderPropsT;\n      const moduleProps = props[moduleName] || {};\n      const module = this.modules[moduleName];\n      if (!module) {\n        // Ignore props for unregistered modules\n        if (!this.options.disableWarnings) {\n          log.warn(`Module ${name} not found`)();\n        }\n        continue; // eslint-disable-line no-continue\n      }\n\n      const oldUniforms = this.moduleUniforms[moduleName] as (typeof module)['uniforms'];\n      const oldBindings = this.moduleBindings[moduleName];\n      const uniformsAndBindings =\n        module.getUniforms?.(moduleProps, oldUniforms) || (moduleProps as any);\n\n      const {uniforms, bindings} = splitUniformsAndBindings(uniformsAndBindings);\n      this.moduleUniforms[moduleName] = {...oldUniforms, ...uniforms};\n      this.moduleBindings[moduleName] = {...oldBindings, ...bindings};\n      // this.moduleUniformsChanged ||= moduleName;\n\n      // console.log(`setProps(${String(moduleName)}`, moduleName, this.moduleUniforms[moduleName])\n    }\n  }\n\n  /**\n   * Return the map of modules\n   * @todo should should this include the resolved dependencies?\n   */\n  getModules(): ShaderModule[] {\n    return Object.values(this.modules);\n  }\n\n  /** Get all uniform values for all modules */\n  getUniformValues(): Partial<Record<keyof ShaderPropsT, Record<string, UniformValue>>> {\n    return this.moduleUniforms;\n  }\n\n  /** Merges all bindings for the shader (from the various modules) */\n  getBindingValues(): Record<string, Binding> {\n    const bindings = {} as Record<string, Binding>;\n    for (const moduleBindings of Object.values(this.moduleBindings)) {\n      Object.assign(bindings, moduleBindings);\n    }\n    return bindings;\n  }\n\n  // INTERNAL\n\n  /** Return a debug table that can be used for console.table() or log.table() */\n  getDebugTable(): Record<string, Record<string, unknown>> {\n    const table: Record<string, Record<string, unknown>> = {};\n    for (const [moduleName, module] of Object.entries(this.moduleUniforms)) {\n      for (const [key, value] of Object.entries(module)) {\n        table[`${moduleName}.${key}`] = {\n          type: this.modules[moduleName].uniformTypes?.[key as keyof ShaderPropsT],\n          value: String(value)\n        };\n      }\n    }\n    return table;\n  }\n\n  _addModule(module: ShaderModule): void {\n    const moduleName = module.name as keyof ShaderPropsT;\n    // Get default uniforms from module\n    this.moduleUniforms[moduleName] = module.defaultUniforms || {};\n    this.moduleBindings[moduleName] = {};\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {UniformValue, Binding} from '@luma.gl/core';\nimport {isNumericArray} from '@math.gl/types';\n\nexport function isUniformValue(value: unknown): value is UniformValue {\n  return isNumericArray(value) || typeof value === 'number' || typeof value === 'boolean';\n}\n\ntype UniformsAndBindings = {\n  bindings: Record<string, Binding>;\n  uniforms: Record<string, UniformValue>;\n};\n\nexport function splitUniformsAndBindings(\n  uniforms: Record<string, Binding | UniformValue>\n): UniformsAndBindings {\n  const result: UniformsAndBindings = {bindings: {}, uniforms: {}};\n  Object.keys(uniforms).forEach(name => {\n    const uniform = uniforms[name];\n    if (isUniformValue(uniform)) {\n      result.uniforms[name] = uniform;\n    } else {\n      result.bindings[name] = uniform;\n    }\n  });\n\n  return result;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nlet pathPrefix = '';\n\n/**\n * Set a relative path prefix\n */\nexport function setPathPrefix(prefix: string) {\n  pathPrefix = prefix;\n}\n\n/**\n * Loads ImageBitmap asynchronously. Respects setPathPrefix.\n * image.crossOrigin can be set via opts.crossOrigin, default to 'anonymous'\n * @returns a promise tracking the load\n */\nexport async function loadImageBitmap(\n  url: string,\n  opts?: {crossOrigin?: string} & ImageBitmapOptions\n): Promise<ImageBitmap> {\n  const image = new Image();\n  image.crossOrigin = opts?.crossOrigin || 'anonymous';\n  image.src = url.startsWith('http') ? url : pathPrefix + url;\n  await image.decode();\n  return opts ? await createImageBitmap(image, opts) : await createImageBitmap(image);\n}\n\n/**\n * Loads image asynchronously. Respects setPathPrefix.\n * image.crossOrigin can be set via opts.crossOrigin, default to 'anonymous'\n * @returns a promise tracking the load\n * @deprecated Use `loadImageBitmap()` unless you are supporting old versions of Safari.\n */\nexport async function loadImage(\n  url: string,\n  opts?: {crossOrigin?: string}\n): Promise<HTMLImageElement> {\n  return await new Promise((resolve, reject) => {\n    try {\n      const image = new Image();\n      image.onload = () => resolve(image);\n      image.onerror = () => reject(new Error(`Could not load image ${url}.`));\n      image.crossOrigin = opts?.crossOrigin || 'anonymous';\n      image.src = url.startsWith('http') ? url : pathPrefix + url;\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n", "// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\n\nimport type {\n  Texture,\n  TextureProps,\n  Sampler,\n  TextureView,\n  Device,\n  Texture1DData,\n  Texture2DData,\n  Texture3DData,\n  TextureArrayData,\n  TextureCubeData,\n  TextureCubeArrayData\n} from '@luma.gl/core';\n\nimport {loadImageBitmap} from '../application-utils/load-file';\nimport {uid} from '../utils/uid';\n\nexport type AsyncTextureProps = Omit<TextureProps, 'data'> & AsyncTextureDataProps;\n\ntype AsyncTextureDataProps =\n  | AsyncTexture1DProps\n  | AsyncTexture2DProps\n  | AsyncTexture3DProps\n  | AsyncTextureArrayProps\n  | AsyncTextureCubeProps\n  | AsyncTextureCubeArrayProps;\n\ntype AsyncTexture1DProps = {dimension: '1d'; data: Promise<Texture1DData> | Texture1DData | null};\ntype AsyncTexture2DProps = {dimension?: '2d'; data: Promise<Texture2DData> | Texture2DData | null};\ntype AsyncTexture3DProps = {dimension: '3d'; data: Promise<Texture3DData> | Texture3DData | null};\ntype AsyncTextureArrayProps = {\n  dimension: '2d-array';\n  data: Promise<TextureArrayData> | TextureArrayData | null;\n};\ntype AsyncTextureCubeProps = {\n  dimension: 'cube';\n  data: Promise<TextureCubeData> | TextureCubeData | null;\n};\ntype AsyncTextureCubeArrayProps = {\n  dimension: 'cube-array';\n  data: Promise<TextureCubeArrayData> | TextureCubeArrayData | null;\n};\n\ntype TextureData = TextureProps['data'];\ntype AsyncTextureData = AsyncTextureProps['data'];\n\n/**\n * It is very convenient to be able to initialize textures with promises\n * This can add considerable complexity to the Texture class, and doesn't\n * fit with the immutable nature of WebGPU resources.\n * Instead, luma.gl offers async textures as a separate class.\n */\nexport class AsyncTexture {\n  readonly device: Device;\n  readonly id: string;\n\n  // TODO - should we type these as possibly `null`? It will make usage harder?\n  // @ts-expect-error\n  texture: Texture;\n  // @ts-expect-error\n  sampler: Sampler;\n  // @ts-expect-error\n  view: TextureView;\n\n  readonly ready: Promise<void>;\n  isReady: boolean = false;\n  destroyed: boolean = false;\n\n  protected resolveReady: () => void = () => {};\n  protected rejectReady: (error: Error) => void = () => {};\n\n  get [Symbol.toStringTag]() {\n    return 'AsyncTexture';\n  }\n\n  toString(): string {\n    return `AsyncTexture:\"${this.id}\"(${this.isReady ? 'ready' : 'loading'})`;\n  }\n\n  constructor(device: Device, props: AsyncTextureProps) {\n    this.device = device;\n    this.id = props.id || uid('async-texture');\n    // this.id = typeof props?.data === 'string' ? props.data.slice(-20) : uid('async-texture');\n\n    // Signature: new AsyncTexture(device, {data: url})\n    if (typeof props?.data === 'string' && props.dimension === '2d') {\n      props = {...props, data: loadImageBitmap(props.data)};\n    }\n\n    this.ready = new Promise<void>((resolve, reject) => {\n      this.resolveReady = () => {\n        this.isReady = true;\n        resolve();\n      };\n      this.rejectReady = reject;\n    });\n\n    this.initAsync(props);\n  }\n\n  async initAsync(props: AsyncTextureProps): Promise<void> {\n    const asyncData: AsyncTextureData = props.data;\n    let data: TextureData;\n    try {\n      data = await awaitAllPromises(asyncData);\n    } catch (error) {\n      this.rejectReady(error as Error);\n    }\n\n    // Check that we haven't been destroyed while waiting for texture data to load\n    if (this.destroyed) {\n      return;\n    }\n\n    // Now we can actually create the texture\n    // @ts-expect-error Discriminated union\n    const syncProps: TextureProps = {...props, data};\n\n    this.texture = this.device.createTexture(syncProps);\n    this.sampler = this.texture.sampler;\n    this.view = this.texture.view;\n    this.isReady = true;\n    this.resolveReady();\n  }\n\n  destroy(): void {\n    if (this.texture) {\n      this.texture.destroy();\n      // @ts-expect-error\n      this.texture = null;\n    }\n    this.destroyed = true;\n  }\n\n  /**\n   * Textures are immutable and cannot be resized after creation,\n   * but we can create a similar texture with the same parameters but a new size.\n   * @note Does not copy contents of the texture\n   * @todo Abort pending promise and create a texture with the new size?\n   */\n  resize(size: {width: number; height: number}): boolean {\n    if (!this.isReady) {\n      throw new Error('Cannot resize texture before it is ready');\n    }\n\n    if (size.width === this.texture.width && size.height === this.texture.height) {\n      return false;\n    }\n\n    if (this.texture) {\n      const texture = this.texture;\n      this.texture = texture.clone(size);\n      texture.destroy();\n    }\n    return true;\n  }\n}\n\n// HELPERS\n\n/** Resolve all promises in a nested data structure */\nasync function awaitAllPromises(x: any): Promise<any> {\n  x = await x;\n  if (Array.isArray(x)) {\n    return await Promise.all(x.map(awaitAllPromises));\n  }\n  if (x && typeof x === 'object' && x.constructor === Object) {\n    const object: Record<string, any> = x;\n    const values = await Promise.all(Object.values(object));\n    const keys = Object.keys(object);\n    const resolvedObject: Record<string, any> = {};\n    for (let i = 0; i < keys.length; i++) {\n      resolvedObject[keys[i]] = values[i];\n    }\n    return resolvedObject;\n  }\n  return x;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Buffer, BufferRange, TransformFeedback, RenderPassProps} from '@luma.gl/core';\nimport {getPassthroughFS} from '@luma.gl/shadertools';\nimport {Model} from '../model/model';\nimport type {ModelProps} from '../model/model';\n\n/**\n * Properties for creating a {@link BufferTransform}\n * @note Only works under WebGL2.\n */\nexport type BufferTransformProps = Omit<ModelProps, 'fs'> & {\n  /** Optional fragment shader - normally not used in transforms */\n  fs?: ModelProps['fs']; // override as optional\n  /** A list of named outputs corresponding to shader declarations (varyings in WebGL) */\n  outputs?: string[];\n  /** @deprecated Use run({outputBuffers}) instead - Map of output buffers that the shaders will write results of computations to */\n  feedbackBuffers?: Record<string, Buffer | BufferRange>;\n};\n\n/**\n * Manages a WebGL program (pipeline) for buffer\u2192buffer transforms.\n * @note Only works under WebGL2.\n */\nexport class BufferTransform {\n  readonly device: Device;\n  readonly model: Model;\n  readonly transformFeedback: TransformFeedback;\n\n  static defaultProps: Required<BufferTransformProps> = {\n    ...Model.defaultProps,\n    outputs: undefined!,\n    feedbackBuffers: undefined!\n  };\n\n  static isSupported(device: Device): boolean {\n    return device?.info?.type === 'webgl';\n  }\n\n  constructor(device: Device, props: BufferTransformProps = BufferTransform.defaultProps) {\n    if (!BufferTransform.isSupported(device)) {\n      throw new Error('BufferTransform not yet implemented on WebGPU');\n    }\n\n    this.device = device;\n\n    this.model = new Model(this.device, {\n      id: props.id || 'buffer-transform-model',\n      fs: props.fs || getPassthroughFS(),\n      topology: props.topology || 'point-list',\n      varyings: props.outputs || props.varyings,\n      ...props\n    });\n\n    this.transformFeedback = this.device.createTransformFeedback({\n      layout: this.model.pipeline.shaderLayout,\n      // @ts-expect-error TODO\n      buffers: props.feedbackBuffers\n    });\n\n    this.model.setTransformFeedback(this.transformFeedback);\n\n    Object.seal(this);\n  }\n\n  /** Destroy owned resources. */\n  destroy(): void {\n    if (this.model) {\n      this.model.destroy();\n    }\n  }\n\n  /** @deprecated Use {@link destroy}. */\n  delete(): void {\n    this.destroy();\n  }\n\n  /** Run one transform loop. */\n  run(\n    options?: RenderPassProps & {\n      inputBuffers?: Record<string, Buffer>;\n      outputBuffers?: Record<string, Buffer>;\n    }\n  ): void {\n    if (options?.inputBuffers) {\n      this.model.setAttributes(options.inputBuffers);\n    }\n    if (options?.outputBuffers) {\n      this.transformFeedback.setBuffers(options.outputBuffers);\n    }\n    const renderPass = this.device.beginRenderPass(options);\n    this.model.draw(renderPass);\n    renderPass.end();\n  }\n\n  // DEPRECATED METHODS\n\n  /** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */\n  getBuffer(varyingName: string): Buffer | BufferRange | null {\n    return this.transformFeedback.getBuffer(varyingName);\n  }\n\n  /** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */\n  readAsync(varyingName: string): Promise<Uint8Array> {\n    const result = this.getBuffer(varyingName);\n    if (!result) {\n      throw new Error('BufferTransform#getBuffer');\n    }\n    if (result instanceof Buffer) {\n      return result.readAsync();\n    }\n    const {buffer, byteOffset = 0, byteLength = buffer.byteLength} = result;\n    return buffer.readAsync(byteOffset, byteLength);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Buffer, Device, Framebuffer, RenderPassProps, Sampler, Texture} from '@luma.gl/core';\nimport {Model, ModelProps} from '../model/model';\nimport {getPassthroughFS} from '@luma.gl/shadertools';\n\n/**\n * Properties for creating a {@link TextureTransform}\n */\nexport type TextureTransformProps = Omit<ModelProps, 'fs'> & {\n  fs?: ModelProps['fs']; // override as optional\n  /** @deprecated TODO(donmccurdy): Needed? */\n  inject?: Record<string, string>;\n  /** @deprecated TODO(donmccurdy): Needed? */\n  framebuffer?: Framebuffer;\n  /** @deprecated TODO(donmccurdy): Model already handles this? */\n  sourceBuffers?: Record<string, Buffer>;\n  /** @deprecated TODO(donmccurdy): Model already handles this? */\n  sourceTextures?: Record<string, Texture>;\n  targetTexture: Texture;\n  targetTextureChannels: 1 | 2 | 3 | 4;\n  targetTextureVarying: string;\n};\n\ntype TextureBinding = {\n  sourceBuffers: Record<string, Buffer>;\n  sourceTextures: Record<string, Texture>;\n  targetTexture: Texture;\n  framebuffer?: Framebuffer;\n};\n\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\n/**\n * Creates a pipeline for texture\u2192texture transforms.\n * @deprecated\n */\nexport class TextureTransform {\n  readonly device: Device;\n  readonly model: Model;\n  readonly sampler: Sampler;\n\n  currentIndex = 0;\n  samplerTextureMap: Record<string, any> | null = null;\n  bindings: TextureBinding[] = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n  resources: Record<string, any> = {}; // resources to be deleted\n\n  constructor(device: Device, props: TextureTransformProps) {\n    this.device = device;\n\n    // For precise picking of element IDs.\n    this.sampler = device.createSampler({\n      addressModeU: 'clamp-to-edge',\n      addressModeV: 'clamp-to-edge',\n      minFilter: 'nearest',\n      magFilter: 'nearest',\n      mipmapFilter: 'nearest'\n    });\n\n    this.model = new Model(this.device, {\n      id: props.id || 'texture-transform-model',\n      fs:\n        props.fs ||\n        getPassthroughFS({\n          input: props.targetTextureVarying,\n          inputChannels: props.targetTextureChannels,\n          output: FS_OUTPUT_VARIABLE\n        }),\n      vertexCount: props.vertexCount, // TODO(donmccurdy): Naming?\n      ...props\n    });\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  destroy(): void {\n    this.model.destroy();\n    for (const binding of this.bindings) {\n      binding.framebuffer?.destroy();\n    }\n  }\n\n  /** @deprecated Use {@link destroy}. */\n  delete(): void {\n    this.destroy();\n  }\n\n  run(options?: RenderPassProps): void {\n    const {framebuffer} = this.bindings[this.currentIndex];\n    const renderPass = this.device.beginRenderPass({framebuffer, ...options});\n    this.model.draw(renderPass);\n    renderPass.end();\n  }\n\n  getTargetTexture(): Texture {\n    const {targetTexture} = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getFramebuffer(): Framebuffer | undefined {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  // Private\n\n  _initialize(props: TextureTransformProps): void {\n    this._updateBindings(props);\n  }\n\n  _updateBindings(props: TextureTransformProps) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], props);\n  }\n\n  _updateBinding(\n    binding: TextureBinding,\n    {sourceBuffers, sourceTextures, targetTexture}: TextureTransformProps\n  ): TextureBinding {\n    if (!binding) {\n      binding = {\n        sourceBuffers: {},\n        sourceTextures: {},\n        // @ts-expect-error\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    Object.assign(binding.sourceBuffers, sourceBuffers);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n      const {width, height} = targetTexture;\n      // TODO(donmccurdy): When is this called, and is this expected?\n      if (binding.framebuffer) {\n        binding.framebuffer.destroy();\n      }\n      binding.framebuffer = this.device.createFramebuffer({\n        id: 'transform-framebuffer',\n        width,\n        height,\n        colorAttachments: [targetTexture]\n      });\n      binding.framebuffer.resize({width, height});\n    }\n    return binding;\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters(): void {\n    const index = this.currentIndex;\n    const {sourceTextures} = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].sampler = this.sampler;\n    }\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TypedArray} from '@math.gl/core';\nimport type {PrimitiveTopology} from '@luma.gl/core';\nimport {uid} from '../utils/uid';\n\nexport type GeometryProps = {\n  id?: string;\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology: 'point-list' | 'line-list' | 'line-strip' | 'triangle-list' | 'triangle-strip';\n  /** Auto calculated from attributes if not provided */\n  vertexCount?: number;\n  attributes: Record<string, GeometryAttribute | TypedArray>;\n  indices?: GeometryAttribute | TypedArray;\n};\n\nexport type GeometryAttributes = {\n  POSITION: GeometryAttribute;\n  NORMAL: GeometryAttribute;\n  TEXCOORD_0: GeometryAttribute;\n  COLOR_0?: GeometryAttribute;\n  indices?: GeometryAttribute & {size: 1; value: Uint32Array | Uint16Array};\n};\n\nexport type GeometryAttribute = {\n  size?: number;\n  value: TypedArray;\n  [key: string]: any;\n};\n\nexport class Geometry {\n  readonly id: string;\n  /** Determines how vertices are read from the 'vertex' attributes */\n  readonly topology?: PrimitiveTopology;\n  readonly vertexCount: number;\n  readonly indices?: GeometryAttribute;\n  readonly attributes: {\n    POSITION: GeometryAttribute;\n    NORMAL: GeometryAttribute;\n    TEXCOORD_0: GeometryAttribute;\n    COLOR_0?: GeometryAttribute;\n    [key: string]: GeometryAttribute | undefined;\n  };\n\n  userData: Record<string, unknown> = {};\n\n  constructor(props: GeometryProps) {\n    const {attributes = {}, indices = null, vertexCount = null} = props;\n\n    this.id = props.id || uid('geometry');\n    this.topology = props.topology;\n\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {value: indices, size: 1} : indices;\n    }\n\n    // @ts-expect-error\n    this.attributes = {};\n\n    for (const [attributeName, attributeValue] of Object.entries(attributes)) {\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      const attribute: GeometryAttribute = ArrayBuffer.isView(attributeValue)\n        ? {value: attributeValue}\n        : attributeValue;\n\n      if (!ArrayBuffer.isView(attribute.value)) {\n        throw new Error(\n          `${this._print(attributeName)}: must be typed array or object with value as typed array`\n        );\n      }\n\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        if (this.indices) {\n          throw new Error('Multiple indices detected');\n        }\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n  }\n\n  getVertexCount(): number {\n    return this.vertexCount;\n  }\n\n  /**\n   * Return an object with all attributes plus indices added as a field.\n   * TODO Geometry types are a mess\n   */\n  getAttributes(): GeometryAttributes {\n    return this.indices ? {indices: this.indices, ...this.attributes} : this.attributes;\n  }\n\n  // PRIVATE\n\n  _print(attributeName: string): string {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n\n  /**\n   * GeometryAttribute\n   * value: typed array\n   * type: indices, vertices, uvs\n   * size: elements per vertex\n   * target: WebGL buffer type (string or constant)\n   *\n   * @param attributes\n   * @param indices\n   * @returns\n   */\n  _setAttributes(attributes: Record<string, GeometryAttribute>, indices: any): this {\n    return this;\n  }\n\n  _calculateVertexCount(attributes: GeometryAttributes, indices?: GeometryAttribute): number {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attribute of Object.values(attributes)) {\n      const {value, size, constant} = attribute;\n      if (!constant && value && size !== undefined && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n\n    // assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// ClipSpace\nimport {Device} from '@luma.gl/core';\nimport {Model, ModelProps} from '../model/model';\nimport {Geometry} from '../geometry/geometry';\nimport {uid} from '../utils/uid';\n\nconst CLIPSPACE_VERTEX_SHADER_WGSL = /* wgsl */ `\\\nstruct VertexInputs {\n  @location(0) clipSpacePosition: vec2<f32>,\n  @location(1) texCoord: vec2<f32>,\n  @location(2) coordinate: vec2<f32>  \n}\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) position : vec2<f32>,\n  @location(1) coordinate : vec2<f32>,\n  @location(2) uv : vec2<f32>\n};\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs: FragmentInputs;\n  outputs.Position = vec4(inputs.clipSpacePosition, 0., 1.);\n  outputs.position = inputs.clipSpacePosition;\n  outputs.coordinate = inputs.coordinate;\n  outputs.uv = inputs.texCoord;\n  return outputs;\n}\n`;\n\nconst CLIPSPACE_VERTEX_SHADER = /* glsl */ `\\\n#version 300 es\nin vec2 clipSpacePositions;\nin vec2 texCoords;\nin vec2 coordinates;\n\nout vec2 position;\nout vec2 coordinate;\nout vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(clipSpacePositions, 0., 1.);\n  position = clipSpacePositions;\n  coordinate = coordinates;\n  uv = texCoords;\n}\n`;\n\n/* eslint-disable indent, no-multi-spaces */\nconst POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];\n\n/** Props for ClipSpace */\nexport type ClipSpaceProps = Omit<ModelProps, 'vs' | 'vertexCount' | 'geometry'>;\n\n/**\n * A flat geometry that covers the \"visible area\" that the GPU renders.\n */\nexport class ClipSpace extends Model {\n  constructor(device: Device, props: ClipSpaceProps) {\n    const TEX_COORDS = POSITIONS.map(coord => (coord === -1 ? 0 : coord));\n\n    // For WGSL we need to append the supplied fragment shader to the default vertex shader source\n    if (props.source) {\n      props = {...props, source: `${CLIPSPACE_VERTEX_SHADER_WGSL}\\n${props.source}`};\n    }\n\n    super(device, {\n      id: props.id || uid('clip-space'),\n      ...props,\n      vs: CLIPSPACE_VERTEX_SHADER,\n      vertexCount: 4,\n      geometry: new Geometry({\n        topology: 'triangle-strip',\n        vertexCount: 4,\n        attributes: {\n          clipSpacePositions: {size: 2, value: new Float32Array(POSITIONS)},\n          texCoords: {size: 2, value: new Float32Array(TEX_COORDS)},\n          coordinates: {size: 2, value: new Float32Array(TEX_COORDS)}\n        }\n      })\n    });\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Texture} from '@luma.gl/core';\nimport {AsyncTexture} from '../async-texture/async-texture';\nimport {ClipSpace} from './clip-space';\n\nconst BACKGROUND_FS_WGSL = /* wgsl */ `\\\n@group(0) @binding(0) var backgroundTexture: texture_2d<f32>;\n@group(0) @binding(1) var backgroundTextureSampler: sampler;\n\nfn billboardTexture_getTextureUV(coordinates: vec2<f32>) -> vec2<f32> {\n\tlet iTexSize: vec2<u32> = textureDimensions(backgroundTexture, 0) * 2;\n\tlet texSize: vec2<f32> = vec2<f32>(f32(iTexSize.x), f32(iTexSize.y));\n\tvar position: vec2<f32> = coordinates.xy / texSize;\n\treturn position;\n} \n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n\tlet position: vec2<f32> = billboardTexture_getTextureUV(inputs.coordinate);\n\treturn textureSample(backgroundTexture, backgroundTextureSampler, position);\n}\n`;\n\nconst BACKGROUND_FS = /* glsl */ `\\\n#version 300 es\nprecision highp float;\n\nuniform sampler2D backgroundTexture;\nout vec4 fragColor;\n\nvec2 billboardTexture_getTextureUV() {\n  ivec2 iTexSize = textureDimensions(backgroundTexture, 0) * 2;\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n  vec2 position = gl_FragCoord.xy / texSize;\n  return position;\n}\n\nvoid main(void) {\n  vec2 position = billboardTexture_getTextureUV();\n  fragColor = texture(backgroundTexture, position);\n}\n`;\n\n/**\n * Props for a Model that renders a bitmap into the \"background\", i.e covering the screen\n */\nexport type BackgroundTextureModelProps = {\n  /** id of this model */\n  id?: string;\n  /** The texture to render */\n  backgroundTexture: Texture | AsyncTexture;\n  /** If true, the texture is rendered into transparent areas of the screen only, i.e blended in where background alpha is small */\n  blend?: boolean;\n};\n\n/**\n * Model that renders a bitmap into the \"background\", i.e covering the screen\n */\nexport class BackgroundTextureModel extends ClipSpace {\n  constructor(device: Device, props: BackgroundTextureModelProps) {\n    super(device, {\n      id: props.id || 'background-texture-model',\n      source: BACKGROUND_FS_WGSL,\n      fs: BACKGROUND_FS,\n      parameters: {\n        depthWriteEnabled: false,\n        depthCompare: 'always',\n        ...(props.blend\n          ? {\n              blend: true,\n              blendColorOperation: 'add',\n              blendAlphaOperation: 'add',\n              blendColorSrcFactor: 'one',\n              blendColorDstFactor: 'one-minus-src-color',\n              blendAlphaSrcFactor: 'one',\n              blendAlphaDstFactor: 'one-minus-src-alpha'\n            }\n          : {})\n      }\n    });\n\n    this.setTexture(props.backgroundTexture);\n  }\n\n  setTexture(backgroundTexture: Texture | AsyncTexture): void {\n    this.setBindings({\n      backgroundTexture\n    });\n  }\n\n  override predraw(): void {\n    this.shaderInputs.setProps({});\n    super.predraw();\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Vector3, Matrix4, NumericArray} from '@math.gl/core';\nimport {uid} from '../utils/uid';\n\n/** Properties for creating a new Scenegraph */\nexport type ScenegraphNodeProps = {\n  id?: string;\n  /** whether to display the object at all */\n  display?: boolean;\n  matrix?: NumericArray;\n  position?: NumericArray;\n  rotation?: NumericArray;\n  scale?: NumericArray;\n  update?: boolean;\n};\n\nexport class ScenegraphNode {\n  readonly id: string;\n  matrix: Matrix4 = new Matrix4();\n\n  display = true;\n  position = new Vector3();\n  rotation = new Vector3();\n  scale = new Vector3(1, 1, 1);\n  userData: Record<string, unknown> = {};\n\n  props: ScenegraphNodeProps = {};\n\n  constructor(props: ScenegraphNodeProps = {}) {\n    const {id} = props;\n\n    this.id = id || uid(this.constructor.name);\n\n    this._setScenegraphNodeProps(props);\n  }\n\n  getBounds(): [number[], number[]] | null {\n    return null;\n  }\n\n  destroy(): void {}\n\n  /** @deprecated use .destroy() */\n  delete(): void {\n    this.destroy();\n  }\n  setProps(props: ScenegraphNodeProps): this {\n    this._setScenegraphNodeProps(props);\n    return this;\n  }\n\n  toString(): string {\n    return `{type: ScenegraphNode, id: ${this.id})}`;\n  }\n\n  setPosition(position: any): this {\n    // assert(position.length === 3, 'setPosition requires vector argument');\n    this.position = position;\n    return this;\n  }\n\n  setRotation(rotation: any): this {\n    // assert(rotation.length === 3, 'setRotation requires vector argument');\n    this.rotation = rotation;\n    return this;\n  }\n\n  setScale(scale: any): this {\n    // assert(scale.length === 3, 'setScale requires vector argument');\n    this.scale = scale;\n    return this;\n  }\n\n  setMatrix(matrix: any, copyMatrix: boolean = true): void {\n    if (copyMatrix) {\n      this.matrix.copy(matrix);\n    } else {\n      this.matrix = matrix;\n    }\n  }\n\n  setMatrixComponents(components: {\n    position?: any;\n    rotation?: any;\n    scale?: any;\n    update?: boolean;\n  }): this {\n    const {position, rotation, scale, update = true} = components;\n    if (position) {\n      this.setPosition(position);\n    }\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n    if (scale) {\n      this.setScale(scale);\n    }\n    if (update) {\n      this.updateMatrix();\n    }\n    return this;\n  }\n\n  updateMatrix(): this {\n    const pos = this.position;\n    const rot = this.rotation;\n    const scale = this.scale;\n\n    this.matrix.identity();\n    this.matrix.translate(pos);\n    this.matrix.rotateXYZ(rot);\n    this.matrix.scale(scale);\n    return this;\n  }\n\n  update(options: {position?: any; rotation?: any; scale?: any} = {}): this {\n    const {position, rotation, scale} = options;\n    if (position) {\n      this.setPosition(position);\n    }\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n    if (scale) {\n      this.setScale(scale);\n    }\n    this.updateMatrix();\n    return this;\n  }\n\n  getCoordinateUniforms(\n    viewMatrix: any,\n    modelMatrix?: any\n  ): {\n    viewMatrix: any;\n    modelMatrix: any;\n    objectMatrix: any;\n    worldMatrix: any;\n    worldInverseMatrix: any;\n    worldInverseTransposeMatrix: any;\n  } {\n    // TODO - solve multiple class problem\n    // assert(viewMatrix instanceof Matrix4);\n    // assert(viewMatrix);\n    modelMatrix = modelMatrix || this.matrix;\n    const worldMatrix = new Matrix4(viewMatrix).multiplyRight(modelMatrix);\n    const worldInverse = worldMatrix.invert();\n    const worldInverseTranspose = worldInverse.transpose();\n\n    return {\n      viewMatrix,\n      modelMatrix,\n      objectMatrix: modelMatrix,\n      worldMatrix,\n      worldInverseMatrix: worldInverse,\n      worldInverseTransposeMatrix: worldInverseTranspose\n    };\n  }\n\n  // TODO - copied code, not yet vetted\n  /*\n  transform() {\n    if (!this.parent) {\n      this.endPosition.set(this.position);\n      this.endRotation.set(this.rotation);\n      this.endScale.set(this.scale);\n    } else {\n      const parent = this.parent;\n      this.endPosition.set(this.position.add(parent.endPosition));\n      this.endRotation.set(this.rotation.add(parent.endRotation));\n      this.endScale.set(this.scale.add(parent.endScale));\n    }\n\n    const ch = this.children;\n    for (let i = 0; i < ch.length; ++i) {\n      ch[i].transform();\n    }\n\n    return this;\n  }\n  */\n\n  _setScenegraphNodeProps(props: ScenegraphNodeProps): void {\n    // if ('display' in props) {\n    //   this.display = props.display;\n    // }\n\n    if ('position' in props) {\n      this.setPosition(props.position);\n    }\n    if ('rotation' in props) {\n      this.setRotation(props.rotation);\n    }\n    if ('scale' in props) {\n      this.setScale(props.scale);\n    }\n\n    // Matrix overwrites other props\n    if ('matrix' in props) {\n      this.setMatrix(props.matrix);\n    }\n\n    Object.assign(this.props, props);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Matrix4, Vector3} from '@math.gl/core';\nimport {log} from '@luma.gl/core';\nimport {ScenegraphNode, ScenegraphNodeProps} from './scenegraph-node';\n\nexport type GroupNodeProps = ScenegraphNodeProps & {\n  children?: ScenegraphNode[];\n};\n\nexport class GroupNode extends ScenegraphNode {\n  children: ScenegraphNode[];\n\n  constructor(children: ScenegraphNode[]);\n  constructor(props?: GroupNodeProps);\n\n  constructor(props: ScenegraphNode[] | GroupNodeProps = {}) {\n    props = Array.isArray(props) ? {children: props} : props;\n    const {children = []} = props;\n    log.assert(\n      children.every(child => child instanceof ScenegraphNode),\n      'every child must an instance of ScenegraphNode'\n    );\n    super(props);\n    this.children = children;\n  }\n\n  override getBounds(): [number[], number[]] | null {\n    const result: [number[], number[]] = [\n      [Infinity, Infinity, Infinity],\n      [-Infinity, -Infinity, -Infinity]\n    ];\n\n    this.traverse((node, {worldMatrix}) => {\n      const bounds = node.getBounds();\n      if (!bounds) {\n        return;\n      }\n      const [min, max] = bounds;\n      const center = new Vector3(min).add(max).divide([2, 2, 2]);\n      worldMatrix.transformAsPoint(center, center);\n      const halfSize = new Vector3(max).subtract(min).divide([2, 2, 2]);\n      worldMatrix.transformAsVector(halfSize, halfSize);\n\n      for (let v = 0; v < 8; v++) {\n        // Test all 8 corners of the box\n        const position = new Vector3(v & 0b001 ? -1 : 1, v & 0b010 ? -1 : 1, v & 0b100 ? -1 : 1)\n          .multiply(halfSize)\n          .add(center);\n\n        for (let i = 0; i < 3; i++) {\n          result[0][i] = Math.min(result[0][i], position[i]);\n          result[1][i] = Math.max(result[1][i], position[i]);\n        }\n      }\n    });\n    if (!Number.isFinite(result[0][0])) {\n      return null;\n    }\n    return result;\n  }\n\n  override destroy(): void {\n    this.children.forEach(child => child.destroy());\n    this.removeAll();\n    super.destroy();\n  }\n\n  // Unpacks arrays and nested arrays of children\n  add(...children: (ScenegraphNode | ScenegraphNode[])[]): this {\n    for (const child of children) {\n      if (Array.isArray(child)) {\n        this.add(...child);\n      } else {\n        this.children.push(child);\n      }\n    }\n    return this;\n  }\n\n  remove(child: ScenegraphNode): this {\n    const children = this.children;\n    const indexOf = children.indexOf(child);\n    if (indexOf > -1) {\n      children.splice(indexOf, 1);\n    }\n    return this;\n  }\n\n  removeAll(): this {\n    this.children = [];\n    return this;\n  }\n\n  traverse(\n    visitor: (node: ScenegraphNode, context: {worldMatrix: Matrix4}) => void,\n    {worldMatrix = new Matrix4()} = {}\n  ) {\n    const modelMatrix = new Matrix4(worldMatrix).multiplyRight(this.matrix);\n\n    for (const child of this.children) {\n      if (child instanceof GroupNode) {\n        child.traverse(visitor, {worldMatrix: modelMatrix});\n      } else {\n        visitor(child, {worldMatrix: modelMatrix});\n      }\n    }\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {RenderPass} from '@luma.gl/core';\nimport {ScenegraphNode, ScenegraphNodeProps} from './scenegraph-node';\nimport {Model} from '../model/model';\n\nexport type ModelNodeProps = ScenegraphNodeProps & {\n  model: Model;\n  managedResources?: any[];\n  bounds?: [number[], number[]];\n};\n\nexport class ModelNode extends ScenegraphNode {\n  readonly model: Model;\n  bounds: [number[], number[]] | null = null;\n  managedResources: any[];\n\n  // TODO - is this used? override callbacks to make sure we call them with this\n  // onBeforeRender = null;\n  // onAfterRender = null;\n  // AfterRender = null;\n\n  constructor(props: ModelNodeProps) {\n    super(props);\n\n    // Create new Model or used supplied Model\n    this.model = props.model;\n    this.managedResources = props.managedResources || [];\n    this.bounds = props.bounds || null;\n    this.setProps(props);\n  }\n\n  override destroy(): void {\n    if (this.model) {\n      this.model.destroy();\n      // @ts-expect-error\n      this.model = null;\n    }\n    this.managedResources.forEach(resource => resource.destroy());\n    this.managedResources = [];\n  }\n\n  override getBounds(): [number[], number[]] | null {\n    return this.bounds;\n  }\n\n  // Expose model methods\n  draw(renderPass: RenderPass) {\n    // Return value indicates if something was actually drawn\n    return this.model.draw(renderPass);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Geometry} from '../geometry/geometry';\nimport {uid} from '../utils/uid';\n\nconst INDEX_OFFSETS = {\n  x: [2, 0, 1],\n  y: [0, 1, 2],\n  z: [1, 2, 0]\n};\n\nexport type TruncatedConeGeometryProps = {\n  topRadius?: number;\n  bottomRadius?: number;\n  topCap?: boolean;\n  bottomCap?: boolean;\n  height?: number;\n  nradial?: number;\n  nvertical?: number;\n  verticalAxis?: 'x' | 'y' | 'z';\n};\n\n/**\n * Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n * copyright 2011 Google Inc. new BSD License\n * (http://www.opensource.org/licenses/bsd-license.php).\n */\nexport class TruncatedConeGeometry extends Geometry {\n  constructor(props: TruncatedConeGeometryProps & {id?: string; attributes?: any} = {}) {\n    const {id = uid('truncated-code-geometry')} = props;\n    const {indices, attributes} = tesselateTruncatedCone(props);\n    super({\n      ...props,\n      id,\n      topology: 'triangle-list',\n      indices,\n      attributes: {\n        POSITION: {size: 3, value: attributes.POSITION},\n        NORMAL: {size: 3, value: attributes.NORMAL},\n        TEXCOORD_0: {size: 2, value: attributes.TEXCOORD_0},\n        ...props.attributes\n      }\n    });\n  }\n}\n\n/* eslint-disable max-statements, complexity */\nfunction tesselateTruncatedCone(props: TruncatedConeGeometryProps = {}) {\n  const {\n    bottomRadius = 0,\n    topRadius = 0,\n    height = 1,\n    nradial = 10,\n    nvertical = 10,\n    verticalAxis = 'y',\n    topCap = false,\n    bottomCap = false\n  } = props;\n\n  const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);\n  const numVertices = (nradial + 1) * (nvertical + 1 + extra);\n\n  const slant = Math.atan2(bottomRadius - topRadius, height);\n  const msin = Math.sin;\n  const mcos = Math.cos;\n  const mpi = Math.PI;\n  const cosSlant = mcos(slant);\n  const sinSlant = msin(slant);\n  const start = topCap ? -2 : 0;\n  const end = nvertical + (bottomCap ? 2 : 0);\n  const vertsAroundEdge = nradial + 1;\n\n  const indices = new Uint16Array(nradial * (nvertical + extra) * 6);\n  const indexOffset = INDEX_OFFSETS[verticalAxis];\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  const texCoords = new Float32Array(numVertices * 2);\n\n  let i3 = 0;\n  let i2 = 0;\n  for (let i = start; i <= end; i++) {\n    let v = i / nvertical;\n    let y = height * v;\n    let ringRadius;\n\n    if (i < 0) {\n      y = 0;\n      v = 1;\n      ringRadius = bottomRadius;\n    } else if (i > nvertical) {\n      y = height;\n      v = 1;\n      ringRadius = topRadius;\n    } else {\n      ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);\n    }\n    if (i === -2 || i === nvertical + 2) {\n      ringRadius = 0;\n      v = 0;\n    }\n    y -= height / 2;\n    for (let j = 0; j < vertsAroundEdge; j++) {\n      const sin = msin((j * mpi * 2) / nradial);\n      const cos = mcos((j * mpi * 2) / nradial);\n\n      positions[i3 + indexOffset[0]] = sin * ringRadius;\n      positions[i3 + indexOffset[1]] = y;\n      positions[i3 + indexOffset[2]] = cos * ringRadius;\n\n      normals[i3 + indexOffset[0]] = i < 0 || i > nvertical ? 0 : sin * cosSlant;\n      normals[i3 + indexOffset[1]] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;\n      normals[i3 + indexOffset[2]] = i < 0 || i > nvertical ? 0 : cos * cosSlant;\n\n      texCoords[i2 + 0] = j / nradial;\n      texCoords[i2 + 1] = v;\n\n      i2 += 2;\n      i3 += 3;\n    }\n  }\n\n  for (let i = 0; i < nvertical + extra; i++) {\n    for (let j = 0; j < nradial; j++) {\n      const index = (i * nradial + j) * 6;\n      indices[index + 0] = vertsAroundEdge * (i + 0) + 0 + j;\n      indices[index + 1] = vertsAroundEdge * (i + 0) + 1 + j;\n      indices[index + 2] = vertsAroundEdge * (i + 1) + 1 + j;\n      indices[index + 3] = vertsAroundEdge * (i + 0) + 0 + j;\n      indices[index + 4] = vertsAroundEdge * (i + 1) + 1 + j;\n      indices[index + 5] = vertsAroundEdge * (i + 1) + 0 + j;\n    }\n  }\n\n  return {\n    indices,\n    attributes: {\n      POSITION: positions,\n      NORMAL: normals,\n      TEXCOORD_0: texCoords\n    }\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TruncatedConeGeometry} from './truncated-cone-geometry';\nimport {uid} from '../utils/uid';\n\nexport type ConeGeometryProps = {\n  id?: string;\n  radius?: number;\n  cap?: boolean;\n};\n\nexport class ConeGeometry extends TruncatedConeGeometry {\n  constructor(props: ConeGeometryProps = {}) {\n    const {id = uid('cone-geometry'), radius = 1, cap = true} = props;\n    super({\n      ...props,\n      id,\n      topRadius: 0,\n      topCap: Boolean(cap),\n      bottomCap: Boolean(cap),\n      bottomRadius: radius\n    });\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Geometry} from '../geometry/geometry';\nimport {uid} from '../utils/uid';\n// import type {GeometryType} from '../geometry/geometry-type';\n\nexport type CubeGeometryProps = {\n  id?: string;\n  indices?: boolean;\n  attributes?: any;\n};\n\nexport class CubeGeometry extends Geometry {\n  constructor(props: CubeGeometryProps = {}) {\n    const {id = uid('cube-geometry'), indices = true} = props;\n    super(\n      indices\n        ? {\n            ...props,\n            id,\n            topology: 'triangle-list',\n            indices: {size: 1, value: CUBE_INDICES},\n            attributes: {...ATTRIBUTES, ...props.attributes}\n          }\n        : {\n            ...props,\n            id,\n            topology: 'triangle-list',\n            indices: undefined,\n            attributes: {...NON_INDEXED_ATTRIBUTES, ...props.attributes}\n          }\n    );\n  }\n}\n\n// prettier-ignore\nconst CUBE_INDICES = new Uint16Array([\n  0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13,\n  14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23\n]);\n\n// prettier-ignore\nconst CUBE_POSITIONS = new Float32Array([\n  -1,  -1,  1, 1,  -1,  1,  1,  1,  1,  -1,  1,  1,\n  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1,  -1,\n  -1,  1,  -1,  -1,  1,  1,  1,  1,  1,  1,  1,  -1,\n  -1,  -1,  -1,  1,  -1,  -1,  1,  -1,  1,  -1,  -1,  1,\n  1,  -1,  -1,  1,  1,  -1,  1,  1,  1,  1,  -1,  1,\n  -1,  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1\n]);\n\n// TODO - could be Uint8\n// prettier-ignore\nconst CUBE_NORMALS = new Float32Array([\n  // Front face\n  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,\n  // Back face\n  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,\n  // Top face\n  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,\n  // Bottom face\n  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,\n  // Right face\n  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,\n  // Left face\n  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0\n]);\n\n// prettier-ignore\nconst CUBE_TEX_COORDS = new Float32Array([\n  // Front face\n  0,  0,  1,  0,  1,  1,  0,  1,\n  // Back face\n  1,  0,  1,  1,  0,  1,  0,  0,\n  // Top face\n  0,  1,  0,  0,  1,  0,  1,  1,\n  // Bottom face\n  1,  1,  0,  1,  0,  0,  1,  0,\n  // Right face\n  1,  0,  1,  1,  0,  1,  0,  0,\n  // Left face\n  0,  0,  1,  0,  1,  1,  0,  1\n]);\n\n// float4 position\n// prettier-ignore\nexport const CUBE_NON_INDEXED_POSITIONS = new Float32Array([\n  1, -1, 1,\n  -1, -1, 1,\n  -1, -1, -1,\n  1, -1, -1,\n  1, -1, 1,\n  -1, -1, -1,\n\n  1, 1, 1,\n  1, -1, 1,\n  1, -1, -1,\n  1, 1, -1,\n  1, 1, 1,\n  1, -1, -1,\n\n  -1, 1, 1,\n  1, 1, 1,\n  1, 1, -1,\n  -1, 1, -1,\n  -1, 1, 1,\n  1, 1, -1,\n\n  -1, -1, 1,\n  -1, 1, 1,\n  -1, 1, -1,\n  -1, -1, -1,\n  -1, -1, 1,\n  -1, 1, -1,\n\n  1, 1, 1,\n  -1, 1, 1,\n  -1, -1, 1,\n  -1, -1, 1,\n  1, -1, 1,\n  1, 1, 1,\n\n  1, -1, -1,\n  -1, -1, -1,\n  -1, 1, -1,\n  1, 1, -1,\n  1, -1, -1,\n  -1, 1, -1,\n]);\n\n// float2 uv,\n// prettier-ignore\nexport const CUBE_NON_INDEXED_TEX_COORDS = new Float32Array([\n  1, 1,\n  0, 1,\n  0, 0,\n  1, 0,\n  1, 1,\n  0, 0,\n\n  1, 1,\n  0, 1,\n  0, 0,\n  1, 0,\n  1, 1,\n  0, 0,\n\n  1, 1,\n  0, 1,\n  0, 0,\n  1, 0,\n  1, 1,\n  0, 0,\n\n  1, 1,\n  0, 1,\n  0, 0,\n  1, 0,\n  1, 1,\n  0, 0,\n\n  1, 1,\n  0, 1,\n  0, 0,\n  0, 0,\n  1, 0,\n  1, 1,\n\n  1, 1,\n  0, 1,\n  0, 0,\n  1, 0,\n  1, 1,\n  0, 0,\n]);\n\n// float4 color\n// prettier-ignore\nexport const CUBE_NON_INDEXED_COLORS = new Float32Array([\n  1, 0, 1, 1,\n  0, 0, 1, 1,\n  0, 0, 0, 1,\n  1, 0, 0, 1,\n  1, 0, 1, 1,\n  0, 0, 0, 1,\n\n  1, 1, 1, 1,\n  1, 0, 1, 1,\n  1, 0, 0, 1,\n  1, 1, 0, 1,\n  1, 1, 1, 1,\n  1, 0, 0, 1,\n\n  0, 1, 1, 1,\n  1, 1, 1, 1,\n  1, 1, 0, 1,\n  0, 1, 0, 1,\n  0, 1, 1, 1,\n  1, 1, 0, 1,\n\n  0, 0, 1, 1,\n  0, 1, 1, 1,\n  0, 1, 0, 1,\n  0, 0, 0, 1,\n  0, 0, 1, 1,\n  0, 1, 0, 1,\n\n  1, 1, 1, 1,\n  0, 1, 1, 1,\n  0, 0, 1, 1,\n  0, 0, 1, 1,\n  1, 0, 1, 1,\n  1, 1, 1, 1,\n\n  1, 0, 0, 1,\n  0, 0, 0, 1,\n  0, 1, 0, 1,\n  1, 1, 0, 1,\n  1, 0, 0, 1,\n  0, 1, 0, 1,\n]);\n\nconst ATTRIBUTES = {\n  POSITION: {size: 3, value: CUBE_POSITIONS},\n  NORMAL: {size: 3, value: CUBE_NORMALS},\n  TEXCOORD_0: {size: 2, value: CUBE_TEX_COORDS}\n};\n\nconst NON_INDEXED_ATTRIBUTES = {\n  POSITION: {size: 3, value: CUBE_NON_INDEXED_POSITIONS},\n  // NORMAL: {size: 3, value: CUBE_NON_INDEXED_NORMALS},\n  TEXCOORD_0: {size: 2, value: CUBE_NON_INDEXED_TEX_COORDS},\n  COLOR_0: {size: 3, value: CUBE_NON_INDEXED_COLORS}\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TruncatedConeGeometry} from './truncated-cone-geometry';\nimport {uid} from '../utils/uid';\n\nexport type CylinderGeometryProps = {\n  id?: string;\n  radius?: number;\n  attributes?: any;\n};\n\nexport class CylinderGeometry extends TruncatedConeGeometry {\n  constructor(props: CylinderGeometryProps = {}) {\n    const {id = uid('cylinder-geometry'), radius = 1} = props;\n    super({\n      ...props,\n      id,\n      bottomRadius: radius,\n      topRadius: radius\n    });\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Vector3} from '@math.gl/core';\nimport {Geometry} from '../geometry/geometry';\nimport {uid} from '../utils/uid';\n\n/* eslint-disable comma-spacing, max-statements, complexity */\n\nconst ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];\nconst ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];\n\nexport type IcoSphereGeometryProps = {\n  id?: string;\n  radius?: number;\n  iterations?: number;\n  attributes?: any;\n};\n\nexport class IcoSphereGeometry extends Geometry {\n  constructor(props: IcoSphereGeometryProps = {}) {\n    const {id = uid('ico-sphere-geometry')} = props;\n    const {indices, attributes} = tesselateIcosaHedron(props);\n    super({\n      ...props,\n      id,\n      topology: 'triangle-list',\n      indices,\n      attributes: {...attributes, ...props.attributes}\n    });\n  }\n}\n\nfunction tesselateIcosaHedron(props: IcoSphereGeometryProps) {\n  const {iterations = 0} = props;\n\n  const PI = Math.PI;\n  const PI2 = PI * 2;\n\n  const positions = [...ICO_POSITIONS];\n  let indices = [...ICO_INDICES];\n\n  positions.push();\n  indices.push();\n\n  const getMiddlePoint = (() => {\n    const pointMemo: Record<string, number> = {};\n\n    return (i1: number, i2: number) => {\n      i1 *= 3;\n      i2 *= 3;\n      const mini = i1 < i2 ? i1 : i2;\n      const maxi = i1 > i2 ? i1 : i2;\n      const key = `${mini}|${maxi}`;\n\n      if (key in pointMemo) {\n        return pointMemo[key];\n      }\n\n      const x1 = positions[i1];\n      const y1 = positions[i1 + 1];\n      const z1 = positions[i1 + 2];\n      const x2 = positions[i2];\n      const y2 = positions[i2 + 1];\n      const z2 = positions[i2 + 2];\n      let xm = (x1 + x2) / 2;\n      let ym = (y1 + y2) / 2;\n      let zm = (z1 + z2) / 2;\n      const len = Math.sqrt(xm * xm + ym * ym + zm * zm);\n\n      xm /= len;\n      ym /= len;\n      zm /= len;\n\n      positions.push(xm, ym, zm);\n\n      return (pointMemo[key] = positions.length / 3 - 1);\n    };\n  })();\n\n  for (let i = 0; i < iterations; i++) {\n    const indices2: number[] = [];\n    for (let j = 0; j < indices.length; j += 3) {\n      const a = getMiddlePoint(indices[j + 0], indices[j + 1]);\n      const b = getMiddlePoint(indices[j + 1], indices[j + 2]);\n      const c = getMiddlePoint(indices[j + 2], indices[j + 0]);\n\n      indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);\n    }\n    indices = indices2;\n  }\n\n  // Calculate texCoords and normals\n  const normals = new Array(positions.length);\n  const texCoords = new Array((positions.length / 3) * 2);\n\n  const l = indices.length;\n  for (let i = l - 3; i >= 0; i -= 3) {\n    const i1 = indices[i + 0];\n    const i2 = indices[i + 1];\n    const i3 = indices[i + 2];\n    const in1 = i1 * 3;\n    const in2 = i2 * 3;\n    const in3 = i3 * 3;\n    const iu1 = i1 * 2;\n    const iu2 = i2 * 2;\n    const iu3 = i3 * 2;\n    const x1 = positions[in1 + 0];\n    const y1 = positions[in1 + 1];\n    const z1 = positions[in1 + 2];\n    const theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));\n    const phi1 = Math.atan2(y1, x1) + PI;\n    const v1 = theta1 / PI;\n    const u1 = 1 - phi1 / PI2;\n    const x2 = positions[in2 + 0];\n    const y2 = positions[in2 + 1];\n    const z2 = positions[in2 + 2];\n    const theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));\n    const phi2 = Math.atan2(y2, x2) + PI;\n    const v2 = theta2 / PI;\n    const u2 = 1 - phi2 / PI2;\n    const x3 = positions[in3 + 0];\n    const y3 = positions[in3 + 1];\n    const z3 = positions[in3 + 2];\n    const theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));\n    const phi3 = Math.atan2(y3, x3) + PI;\n    const v3 = theta3 / PI;\n    const u3 = 1 - phi3 / PI2;\n    const vec1 = [x3 - x2, y3 - y2, z3 - z2];\n    const vec2 = [x1 - x2, y1 - y2, z1 - z2];\n    const normal = new Vector3(vec1).cross(vec2).normalize();\n    let newIndex;\n\n    if (\n      (u1 === 0 || u2 === 0 || u3 === 0) &&\n      (u1 === 0 || u1 > 0.5) &&\n      (u2 === 0 || u2 > 0.5) &&\n      (u3 === 0 || u3 > 0.5)\n    ) {\n      positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);\n      newIndex = positions.length / 3 - 1;\n      indices.push(newIndex);\n      texCoords[newIndex * 2 + 0] = 1;\n      texCoords[newIndex * 2 + 1] = v1;\n      normals[newIndex * 3 + 0] = normal.x;\n      normals[newIndex * 3 + 1] = normal.y;\n      normals[newIndex * 3 + 2] = normal.z;\n\n      positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);\n      newIndex = positions.length / 3 - 1;\n      indices.push(newIndex);\n      texCoords[newIndex * 2 + 0] = 1;\n      texCoords[newIndex * 2 + 1] = v2;\n      normals[newIndex * 3 + 0] = normal.x;\n      normals[newIndex * 3 + 1] = normal.y;\n      normals[newIndex * 3 + 2] = normal.z;\n\n      positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);\n      newIndex = positions.length / 3 - 1;\n      indices.push(newIndex);\n      texCoords[newIndex * 2 + 0] = 1;\n      texCoords[newIndex * 2 + 1] = v3;\n      normals[newIndex * 3 + 0] = normal.x;\n      normals[newIndex * 3 + 1] = normal.y;\n      normals[newIndex * 3 + 2] = normal.z;\n    }\n\n    normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;\n    normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;\n    normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;\n\n    texCoords[iu1 + 0] = u1;\n    texCoords[iu1 + 1] = v1;\n\n    texCoords[iu2 + 0] = u2;\n    texCoords[iu2 + 1] = v2;\n\n    texCoords[iu3 + 0] = u3;\n    texCoords[iu3 + 1] = v3;\n  }\n\n  return {\n    indices: {size: 1, value: new Uint16Array(indices)},\n    attributes: {\n      POSITION: {size: 3, value: new Float32Array(positions)},\n      NORMAL: {size: 3, value: new Float32Array(normals)},\n      TEXCOORD_0: {size: 2, value: new Float32Array(texCoords)}\n    }\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport function unpackIndexedGeometry(geometry: any) {\n  const {indices, attributes} = geometry;\n  if (!indices) {\n    return geometry;\n  }\n\n  const vertexCount = indices.value.length;\n  const unpackedAttributes: Record<string, any> = {};\n\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const {constant, value, size} = attribute;\n    if (constant || !size) {\n      continue; // eslint-disable-line\n    }\n    const unpackedValue = new value.constructor(vertexCount * size);\n    for (let x = 0; x < vertexCount; ++x) {\n      const index = indices.value[x];\n      for (let i = 0; i < size; i++) {\n        unpackedValue[x * size + i] = value[index * size + i];\n      }\n    }\n    unpackedAttributes[attributeName] = {size, value: unpackedValue};\n  }\n\n  return {\n    attributes: Object.assign({}, attributes, unpackedAttributes)\n  };\n}\n\n// export function calculateVertexNormals(positions: Float32Array): Uint8Array {\n//   let normals = new Uint8Array(positions.length / 3);\n\n//   for (let i = 0; i < positions.length; i++) {\n//     const vec1 = new Vector3(positions.subarray(i * 3, i + 0, i + 3));\n//     const vec2 = new Vector3(positions.subarray(i + 3, i + 6));\n//     const vec3 = new Vector3(positions.subarray(i + 6, i + 9));\n\n//     const normal = new Vector3(vec1).cross(vec2).normalize();\n//     normals.set(normal[0], i + 4);\n//     normals.set(normal[1], i + 4 + 1);\n//     normals.set(normal[2], i + 2);\n//   }\n//   const normal = new Vector3(vec1).cross(vec2).normalize();\n// }\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Geometry} from '../geometry/geometry';\nimport {unpackIndexedGeometry} from '../geometry/geometry-utils';\nimport {uid} from '../utils/uid';\n\nexport type PlaneGeometryProps = {\n  id?: string;\n  radius?: number;\n  attributes?: any;\n};\n\n// Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n// copyright 2011 Google Inc. new BSD License\n// (http://www.opensource.org/licenses/bsd-license.php).\nexport class PlaneGeometry extends Geometry {\n  constructor(props: PlaneGeometryProps = {}) {\n    const {id = uid('plane-geometry')} = props;\n\n    const {indices, attributes} = tesselatePlane(props);\n    super({\n      ...props,\n      id,\n      topology: 'triangle-list',\n      indices,\n      attributes: {...attributes, ...props.attributes}\n    });\n  }\n}\n\n/* eslint-disable complexity, max-statements */\nfunction tesselatePlane(props: any) {\n  const {type = 'x,y', offset = 0, flipCull = false, unpack = false} = props;\n\n  const coords = type.split(',');\n  // width, height\n  let c1len = props[`${coords[0]}len`] || 1;\n  const c2len = props[`${coords[1]}len`] || 1;\n  // subdivisionsWidth, subdivisionsDepth\n  const subdivisions1 = props[`n${coords[0]}`] || 1;\n  const subdivisions2 = props[`n${coords[1]}`] || 1;\n  const numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  const texCoords = new Float32Array(numVertices * 2);\n\n  if (flipCull) {\n    c1len = -c1len;\n  }\n\n  let i2 = 0;\n  let i3 = 0;\n  for (let z = 0; z <= subdivisions2; z++) {\n    for (let x = 0; x <= subdivisions1; x++) {\n      const u = x / subdivisions1;\n      const v = z / subdivisions2;\n      texCoords[i2 + 0] = flipCull ? 1 - u : u;\n      texCoords[i2 + 1] = v;\n\n      switch (type) {\n        case 'x,y':\n          positions[i3 + 0] = c1len * u - c1len * 0.5;\n          positions[i3 + 1] = c2len * v - c2len * 0.5;\n          positions[i3 + 2] = offset;\n\n          normals[i3 + 0] = 0;\n          normals[i3 + 1] = 0;\n          normals[i3 + 2] = flipCull ? 1 : -1;\n          break;\n\n        case 'x,z':\n          positions[i3 + 0] = c1len * u - c1len * 0.5;\n          positions[i3 + 1] = offset;\n          positions[i3 + 2] = c2len * v - c2len * 0.5;\n\n          normals[i3 + 0] = 0;\n          normals[i3 + 1] = flipCull ? 1 : -1;\n          normals[i3 + 2] = 0;\n          break;\n\n        case 'y,z':\n          positions[i3 + 0] = offset;\n          positions[i3 + 1] = c1len * u - c1len * 0.5;\n          positions[i3 + 2] = c2len * v - c2len * 0.5;\n\n          normals[i3 + 0] = flipCull ? 1 : -1;\n          normals[i3 + 1] = 0;\n          normals[i3 + 2] = 0;\n          break;\n\n        default:\n          throw new Error('PlaneGeometry: unknown type');\n      }\n\n      i2 += 2;\n      i3 += 3;\n    }\n  }\n\n  const numVertsAcross = subdivisions1 + 1;\n  const indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);\n\n  for (let z = 0; z < subdivisions2; z++) {\n    for (let x = 0; x < subdivisions1; x++) {\n      const index = (z * subdivisions1 + x) * 6;\n      // Make triangle 1 of quad.\n      indices[index + 0] = (z + 0) * numVertsAcross + x;\n      indices[index + 1] = (z + 1) * numVertsAcross + x;\n      indices[index + 2] = (z + 0) * numVertsAcross + x + 1;\n\n      // Make triangle 2 of quad.\n      indices[index + 3] = (z + 1) * numVertsAcross + x;\n      indices[index + 4] = (z + 1) * numVertsAcross + x + 1;\n      indices[index + 5] = (z + 0) * numVertsAcross + x + 1;\n    }\n  }\n\n  const geometry = {\n    indices: {size: 1, value: indices},\n    attributes: {\n      POSITION: {size: 3, value: positions},\n      NORMAL: {size: 3, value: normals},\n      TEXCOORD_0: {size: 2, value: texCoords}\n    }\n  };\n\n  // Optionally, unpack indexed geometry\n  return unpack ? unpackIndexedGeometry(geometry) : geometry;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Geometry} from '../geometry/geometry';\nimport {uid} from '../utils/uid';\n\nexport type SphereGeometryProps = {\n  id?: string;\n  radius?: number;\n  nlat?: number;\n  nlong?: number;\n  attributes?: any;\n};\n\n// Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n// copyright 2011 Google Inc. new BSD License\n// (http://www.opensource.org/licenses/bsd-license.php).\nexport class SphereGeometry extends Geometry {\n  constructor(props: SphereGeometryProps = {}) {\n    const {id = uid('sphere-geometry')} = props;\n    const {indices, attributes} = tesselateSphere(props);\n    super({\n      ...props,\n      id,\n      topology: 'triangle-list',\n      indices,\n      attributes: {...attributes, ...props.attributes}\n    });\n  }\n}\n\n/* eslint-disable max-statements, complexity */\nfunction tesselateSphere(props: SphereGeometryProps) {\n  const {nlat = 10, nlong = 10} = props;\n\n  const startLat = 0;\n  const endLat = Math.PI;\n  const latRange = endLat - startLat;\n  const startLong = 0;\n  const endLong = 2 * Math.PI;\n  const longRange = endLong - startLong;\n  const numVertices = (nlat + 1) * (nlong + 1);\n\n  const radius = (n1: number, n2: number, n3: number, u: number, v: number) => props.radius || 1;\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  const texCoords = new Float32Array(numVertices * 2);\n\n  const IndexType = numVertices > 0xffff ? Uint32Array : Uint16Array;\n  const indices = new IndexType(nlat * nlong * 6);\n\n  // Create positions, normals and texCoords\n  for (let y = 0; y <= nlat; y++) {\n    for (let x = 0; x <= nlong; x++) {\n      const u = x / nlong;\n      const v = y / nlat;\n\n      const index = x + y * (nlong + 1);\n      const i2 = index * 2;\n      const i3 = index * 3;\n\n      const theta = longRange * u;\n      const phi = latRange * v;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      const sinPhi = Math.sin(phi);\n      const cosPhi = Math.cos(phi);\n      const ux = cosTheta * sinPhi;\n      const uy = cosPhi;\n      const uz = sinTheta * sinPhi;\n\n      const r = radius(ux, uy, uz, u, v);\n\n      positions[i3 + 0] = r * ux;\n      positions[i3 + 1] = r * uy;\n      positions[i3 + 2] = r * uz;\n\n      normals[i3 + 0] = ux;\n      normals[i3 + 1] = uy;\n      normals[i3 + 2] = uz;\n\n      texCoords[i2 + 0] = u;\n      texCoords[i2 + 1] = 1 - v;\n    }\n  }\n\n  // Create indices\n  const numVertsAround = nlong + 1;\n  for (let x = 0; x < nlong; x++) {\n    for (let y = 0; y < nlat; y++) {\n      const index = (x * nlat + y) * 6;\n\n      indices[index + 0] = y * numVertsAround + x;\n      indices[index + 1] = y * numVertsAround + x + 1;\n      indices[index + 2] = (y + 1) * numVertsAround + x;\n\n      indices[index + 3] = (y + 1) * numVertsAround + x;\n      indices[index + 4] = y * numVertsAround + x + 1;\n      indices[index + 5] = (y + 1) * numVertsAround + x + 1;\n    }\n  }\n\n  return {\n    indices: {size: 1, value: indices},\n    attributes: {\n      POSITION: {size: 3, value: positions},\n      NORMAL: {size: 3, value: normals},\n      TEXCOORD_0: {size: 2, value: texCoords}\n    }\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/** Creates a deterministic pseudorandom number generator */\nexport function makeRandomGenerator(): () => number {\n  let s = 1;\n  let c = 1;\n  return () => {\n    s = Math.sin(c * 17.23);\n    c = Math.cos(s * 27.92);\n    return fract(Math.abs(s * c) * 1432.71);\n  };\n}\n\nfunction fract(n: number): number {\n  return n - Math.floor(n);\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, RenderPass, Texture} from '@luma.gl/core';\nimport type {ShaderPass} from '@luma.gl/shadertools';\nimport {initializeShaderModule} from '@luma.gl/shadertools';\nimport {ShaderInputs} from '../shader-inputs';\nimport {AsyncTexture} from '../async-texture/async-texture';\nimport {ClipSpace} from '../models/clip-space';\nimport {SwapFramebuffers} from '../compute/swap';\nimport {BackgroundTextureModel} from '../models/billboard-texture-model';\n\nimport {getFragmentShaderForRenderPass} from './get-fragment-shader';\n\ntype ShaderSubPass = NonNullable<ShaderPass['passes']>[0];\n\n/** Props for ShaderPassRenderer */\nexport type ShaderPassRendererProps = {\n  /** List of ShaderPasses to apply to the sourceTexture */\n  shaderPasses: ShaderPass[];\n  /** Optional typed ShaderInputs object for setting uniforms */\n  shaderInputs: ShaderInputs;\n};\n\n/** A pass that renders a given texture into screen space */\nexport class ShaderPassRenderer {\n  device: Device;\n  shaderInputs: ShaderInputs;\n  passRenderers: PassRenderer[];\n  swapFramebuffers: SwapFramebuffers;\n  /** For rendering to the screen */\n  clipSpace: ClipSpace;\n  textureModel: BackgroundTextureModel;\n\n  constructor(device: Device, props: ShaderPassRendererProps) {\n    this.device = device;\n\n    props.shaderPasses.map(shaderPass => initializeShaderModule(shaderPass));\n\n    const modules = props.shaderPasses.reduce(\n      (object, shaderPass) => ({...object, [shaderPass.name]: shaderPass}),\n      {}\n    );\n    this.shaderInputs = props.shaderInputs || new ShaderInputs(modules);\n\n    const size = device.getCanvasContext().getPixelSize();\n    this.swapFramebuffers = new SwapFramebuffers(device, {\n      colorAttachments: ['rgba8unorm'],\n      width: size[0],\n      height: size[1]\n    });\n\n    this.textureModel = new BackgroundTextureModel(device, {\n      backgroundTexture: this.swapFramebuffers.current.colorAttachments[0].texture\n    });\n\n    this.clipSpace = new ClipSpace(device, {\n      source: /* wgsl */ `\\\n  @group(0) @binding(0) var sourceTexture: texture_2d<f32>;\n  @group(0) @binding(1) var sourceTextureSampler: sampler;\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n\tlet texCoord: vec2<f32> = inputs.coordinate;\n\treturn textureSample(sourceTexture, sourceTextureSampler, texCoord);\n}\n`,\n\n      fs: /* glsl */ `\\\n#version 300 es\n\nuniform sampler2D sourceTexture;\nin vec2 uv;\nin vec2 coordinate;\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  fragColor = texture(sourceTexture, coordinate);\n}\n`\n    });\n\n    this.passRenderers = props.shaderPasses.map(shaderPass => new PassRenderer(device, shaderPass));\n  }\n\n  /** Destroys resources created by this ShaderPassRenderer */\n  destroy() {\n    for (const subPassRenderer of this.passRenderers) {\n      subPassRenderer.destroy();\n    }\n    this.swapFramebuffers.destroy();\n    this.clipSpace.destroy();\n  }\n\n  resize(width: number, height: number): void {\n    this.swapFramebuffers.resize({width, height});\n    // this.props.passes.forEach(pass => pass.resize(width, height));\n  }\n\n  renderToScreen(options: {sourceTexture: AsyncTexture; uniforms: any; bindings: any}): boolean {\n    // Run the shader passes and generate an output texture\n    const outputTexture = this.renderToTexture(options);\n    if (!outputTexture) {\n      // source texture not yet loaded\n      return false;\n    }\n\n    const renderPass = this.device.beginRenderPass({clearColor: [0, 0, 0, 1], clearDepth: 1});\n    this.clipSpace.setBindings({sourceTexture: outputTexture});\n    this.clipSpace.draw(renderPass);\n    renderPass.end();\n    return true;\n  }\n\n  /** Runs the shaderPasses in sequence on the sourceTexture and returns a texture with the results.\n   * @returns null if the the sourceTexture has not yet been loaded\n   */\n  renderToTexture(options: {\n    sourceTexture: AsyncTexture;\n    uniforms: any;\n    bindings: any;\n  }): Texture | null {\n    const {sourceTexture} = options;\n    if (!sourceTexture.isReady) {\n      return null;\n    }\n\n    this.textureModel.destroy();\n    this.textureModel = new BackgroundTextureModel(this.device, {\n      backgroundTexture: sourceTexture\n    });\n\n    // Clear the current texture before we begin\n    const clearTexturePass = this.device.beginRenderPass({\n      framebuffer: this.swapFramebuffers.current,\n      clearColor: [0, 0, 0, 1]\n    });\n    this.textureModel.draw(clearTexturePass);\n    clearTexturePass.end();\n\n    // const commandEncoder = this.device.createCommandEncoder();\n    // commandEncoder.copyTextureToTexture({\n    //   sourceTexture: sourceTexture.texture,\n    //   destinationTexture: this.swapFramebuffers.current.colorAttachments[0].texture\n    // });\n    // commandEncoder.finish();\n\n    let first = true;\n    for (const passRenderer of this.passRenderers) {\n      for (const subPassRenderer of passRenderer.subPassRenderers) {\n        if (!first) {\n          this.swapFramebuffers.swap();\n        }\n        first = false;\n\n        const swapBufferTexture = this.swapFramebuffers.current.colorAttachments[0].texture;\n\n        const bindings = {\n          sourceTexture: swapBufferTexture\n          // texSize: [sourceTextures.width, sourceTextures.height]\n        };\n\n        const renderPass = this.device.beginRenderPass({\n          framebuffer: this.swapFramebuffers.next,\n          clearColor: [0, 0, 0, 1],\n          clearDepth: 1\n        });\n        subPassRenderer.render({renderPass, bindings});\n        renderPass.end();\n      }\n    }\n\n    this.swapFramebuffers.swap();\n    const outputTexture = this.swapFramebuffers.current.colorAttachments[0].texture;\n    return outputTexture;\n  }\n}\n\n/** renders one ShaderPass */\nclass PassRenderer {\n  shaderPass: ShaderPass;\n  subPassRenderers: SubPassRenderer[];\n\n  constructor(device: Device, shaderPass: ShaderPass, props = {}) {\n    this.shaderPass = shaderPass;\n    // const id = `${shaderPass.name}-pass`;\n\n    const subPasses = shaderPass.passes || [];\n    // normalizePasses(gl, module, id, props);\n\n    this.subPassRenderers = subPasses.map(subPass => {\n      // const idn = `${id}-${subPasses.length + 1}`;\n      return new SubPassRenderer(device, shaderPass, subPass);\n    });\n  }\n\n  destroy() {\n    for (const subPassRenderer of this.subPassRenderers) {\n      subPassRenderer.destroy();\n    }\n  }\n}\n\n/** Renders one subpass of a ShaderPass */\nclass SubPassRenderer {\n  model: ClipSpace;\n  shaderPass: ShaderPass;\n  subPass: ShaderSubPass;\n\n  constructor(device: Device, shaderPass: ShaderPass, subPass: ShaderSubPass) {\n    this.shaderPass = shaderPass;\n    this.subPass = subPass;\n    const action =\n      subPass.action || (subPass.filter && 'filter') || (subPass.sampler && 'sample') || 'filter';\n    const fs = getFragmentShaderForRenderPass({\n      shaderPass,\n      action,\n      shadingLanguage: device.info.shadingLanguage\n    });\n\n    this.model = new ClipSpace(device, {\n      id: `${shaderPass.name}-subpass`,\n      source: fs,\n      fs,\n      modules: [shaderPass],\n      parameters: {\n        depthWriteEnabled: false,\n        depthCompare: 'always'\n      }\n    });\n  }\n\n  destroy() {\n    this.model.destroy();\n  }\n\n  render(options: {renderPass: RenderPass; bindings: any}): void {\n    const {renderPass, bindings} = options;\n\n    this.model.shaderInputs.setProps({\n      [this.shaderPass.name]: this.shaderPass.uniforms || {}\n    });\n    this.model.shaderInputs.setProps({\n      [this.shaderPass.name]: this.subPass.uniforms || {}\n    });\n    // this.model.setBindings(this.subPass.bindings || {});\n    this.model.setBindings(bindings || {});\n    this.model.draw(renderPass);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {BufferProps, FramebufferProps} from '@luma.gl/core';\nimport {Device, Resource, Buffer, Framebuffer, Texture} from '@luma.gl/core';\n\n/**\n * Helper class for working with repeated transformations / computations\n * Primarily intended for GPU buffers `Swap<Buffer>` or textures `Swap<Texture>`)\n * @note the two resources are expected to be structurally identical (same size, length, format, etc)\n * @note the two resources can be destroyed by calling `destroy()`\n */\nexport class Swap<T extends Resource<any>> {\n  /** The current resource - usually the source for renders or computations */\n  current: T;\n  /** The next resource - usually the target/destination for transforms / computations */\n  next: T;\n\n  constructor(props: {current: T; next: T}) {\n    this.current = props.current;\n    this.next = props.next;\n  }\n\n  /** Destroys the two managed resources */\n  destroy() {\n    this.current?.destroy();\n    this.next?.destroy();\n  }\n\n  /** Make the next resource into the current resource, and reuse the current resource as the next resource */\n  swap() {\n    const current = this.current;\n    this.current = this.next;\n    this.next = current;\n  }\n}\n\n/** Helper for managing double-buffered framebuffers */\nexport class SwapFramebuffers extends Swap<Framebuffer> {\n  constructor(device: Device, props: FramebufferProps) {\n    props = {...props};\n\n    let colorAttachments = props.colorAttachments?.map(colorAttachment =>\n      typeof colorAttachment !== 'string'\n        ? colorAttachment\n        : device.createTexture({\n            format: colorAttachment,\n            usage: Texture.COPY_DST | Texture.RENDER_ATTACHMENT\n          })\n    );\n\n    const current = device.createFramebuffer({...props, colorAttachments});\n\n    colorAttachments = props.colorAttachments?.map(colorAttachment =>\n      typeof colorAttachment !== 'string'\n        ? colorAttachment\n        : device.createTexture({\n            format: colorAttachment,\n            usage: Texture.COPY_DST | Texture.RENDER_ATTACHMENT\n          })\n    );\n\n    const next = device.createFramebuffer({...props, colorAttachments});\n\n    super({current, next});\n  }\n\n  /**\n   * Resizes the Framebuffers.\n   * @returns true if the size changed, otherwise exiting framebuffers were preserved\n   * @note any contents are not preserved!\n   */\n  resize(size: {width: number; height: number}): boolean {\n    if (size.width === this.current.width && size.height === this.current.height) {\n      return false;\n    }\n    const {current, next} = this;\n\n    this.current = current.clone(size);\n    current.destroy();\n\n    this.next = next.clone(size);\n    next.destroy();\n\n    return true;\n  }\n}\n\n/** Helper for managing double-buffered GPU buffers */\nexport class SwapBuffers extends Swap<Buffer> {\n  constructor(device: Device, props: BufferProps) {\n    super({current: device.createBuffer(props), next: device.createBuffer(props)});\n  }\n\n  /**\n   * Resizes the Buffers.\n   * @returns true if the size changed, otherwise exiting buffers were preserved.\n   * @note any contents are not preserved!\n   */\n  resize(props: {byteLength: number}) {\n    if (props.byteLength === this.current.byteLength) {\n      return false;\n    }\n\n    const {current, next} = this;\n\n    this.current = current.clone(props);\n    current.destroy();\n\n    this.next = next.clone(props);\n    next.destroy();\n\n    return true;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderPass} from '@luma.gl/shadertools';\n\n/**\n * Gets fragment shader source for a shader pass sub pass\n * @param options\n * @returns\n */\nexport function getFragmentShaderForRenderPass(options: {\n  shaderPass: ShaderPass;\n  action: 'filter' | 'sample';\n  shadingLanguage: 'wgsl' | 'glsl';\n}): string {\n  const {shaderPass, action, shadingLanguage} = options;\n  switch (action) {\n    case 'filter':\n      const filterFunc = `${shaderPass.name}_filterColor_ext`;\n      return shadingLanguage === 'wgsl'\n        ? getFilterShaderWGSL(filterFunc)\n        : getFilterShaderGLSL(filterFunc);\n\n    case 'sample':\n      const samplerFunc = `${shaderPass.name}_sampleColor`;\n      return shadingLanguage === 'wgsl'\n        ? getSamplerShaderWGSL(samplerFunc)\n        : getSamplerShaderGLSL(samplerFunc);\n\n    default:\n      throw new Error(`${shaderPass.name} no fragment shader generated for shader pass`);\n  }\n}\n\n/** Get a filtering WGSL fragment shader */\nfunction getFilterShaderWGSL(func: string) {\n  return /* wgsl */ `\\\n// Binding 0:1 is reserved for shader passes\n@group(0) @binding(0) var<uniform> brightnessContrast : brightnessContrastUniforms;\n@group(0) @binding(1) var texture: texture_2d<f32>;\n@group(0) @binding(2) var sampler: sampler;\n\nstruct FragmentInputs = {\n  @location(0) fragUV: vec2f,\n  @location(1) fragPosition: vec4f,\n  @location(2) fragCoordinate: vec4f\n};\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  let texSize = textureDimensions(texture, 0);\n  var fragColor = textureSample(texture, sampler, fragUV);\n  fragColor = ${func}(gl_FragColor, texSize, texCoord);\n  return fragColor;\n}\n`;\n}\n\n/** Get a sampling WGSL fragment shader */\nfunction getSamplerShaderWGSL(func: string) {\n  return /* wgsl */ `\\\n// Binding 0:1 is reserved for shader passes\n@group(0) @binding(0) var<uniform> brightnessContrast : brightnessContrastUniforms;\n@group(0) @binding(1) var texture: texture_2d<f32>;\n@group(0) @binding(2) var sampler: sampler;\n\nstruct FragmentInputs = {\n  @location(0) fragUV: vec2f,\n  @location(1) fragPosition: vec4f,\n  @location(2) fragCoordinate: vec4f\n};\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  let texSize = textureDimensions(texture, 0);\n  var fragColor = textureSample(texture, sampler, fragUV);\n  fragColor = ${func}(gl_FragColor, texSize, texCoord);\n  return fragColor;\n}\n`;\n}\n\n/** Get a filtering GLSL fragment shader */\nfunction getFilterShaderGLSL(func: string) {\n  return /* glsl */ `\\\n#version 300 es\n\nuniform sampler2D sourceTexture;\n\nin vec2 position;\nin vec2 coordinate;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  ivec2 iTexSize = textureSize(sourceTexture, 0);\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n\n  fragColor = texture(sourceTexture, texCoord);\n  fragColor = ${func}(fragColor, texSize, texCoord);\n}\n`;\n}\n\n/** Get a sampling GLSL fragment shader */\nfunction getSamplerShaderGLSL(func: string) {\n  return /* glsl */ `\\\n#version 300 es\n\nuniform sampler2D sourceTexture;\n\nin vec2 position;\nin vec2 coordinate;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  ivec2 iTexSize = textureSize(sourceTexture, 0);\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n\n  fragColor = ${func}(sourceTexture, texSize, texCoord);\n}\n`;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {DeviceFeature, ComputePipelineProps, Shader, Binding} from '@luma.gl/core';\nimport {\n  Device,\n  Buffer,\n  ComputePipeline,\n  ComputePass,\n  UniformStore,\n  log,\n  getTypedArrayFromDataType\n} from '@luma.gl/core';\nimport type {ShaderModule, PlatformInfo} from '@luma.gl/shadertools';\nimport {ShaderAssembler, getShaderLayoutFromWGSL} from '@luma.gl/shadertools';\nimport {TypedArray, isNumericArray} from '@math.gl/types';\nimport {ShaderInputs} from '../shader-inputs';\nimport {PipelineFactory} from '../factories/pipeline-factory';\nimport {ShaderFactory} from '../factories/shader-factory';\nimport {uid} from '../utils/uid';\n// import {getDebugTableForShaderLayout} from '../debug/debug-shader-layout';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\nexport type ComputationProps = Omit<ComputePipelineProps, 'shader'> & {\n  source?: string;\n\n  /** shadertool shader modules (added to shader code) */\n  modules?: ShaderModule[];\n  /** Shadertool module defines (configures shader code)*/\n  defines?: Record<string, string | number | boolean>;\n  // TODO - injections, hooks etc?\n\n  /** Shader inputs, used to generated uniform buffers and bindings */\n  shaderInputs?: ShaderInputs;\n\n  /** Bindings */\n  bindings?: Record<string, Binding>;\n\n  /** Show shader source in browser? */\n  debugShaders?: 'never' | 'errors' | 'warnings' | 'always';\n\n  /** Factory used to create a {@link ComputePipeline}. Defaults to {@link Device} default factory. */\n  pipelineFactory?: PipelineFactory;\n  /** Factory used to create a {@link Shader}. Defaults to {@link Device} default factory. */\n  shaderFactory?: ShaderFactory;\n  /** Shader assembler. Defaults to the ShaderAssembler.getShaderAssembler() */\n  shaderAssembler?: ShaderAssembler;\n};\n\n/**\n * v9 Model API\n * A model\n * - automatically reuses pipelines (programs) when possible\n * - automatically rebuilds pipelines if necessary to accommodate changed settings\n * shadertools integration\n * - accepts modules and performs shader transpilation\n */\nexport class Computation {\n  static defaultProps: Required<ComputationProps> = {\n    ...ComputePipeline.defaultProps,\n    id: 'unnamed',\n    handle: undefined,\n    userData: {},\n\n    source: '',\n    modules: [],\n    defines: {},\n\n    bindings: undefined!,\n    shaderInputs: undefined!,\n\n    pipelineFactory: undefined!,\n    shaderFactory: undefined!,\n    shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),\n\n    debugShaders: undefined!\n  };\n\n  readonly device: Device;\n  readonly id: string;\n\n  readonly pipelineFactory: PipelineFactory;\n  readonly shaderFactory: ShaderFactory;\n\n  userData: {[key: string]: any} = {};\n\n  /** Bindings (textures, samplers, uniform buffers) */\n  bindings: Record<string, Binding> = {};\n\n  /** The underlying GPU pipeline. */\n  pipeline: ComputePipeline;\n  /** Assembled compute shader source */\n  source: string;\n  /** the underlying compiled compute shader */\n  // @ts-ignore Set in function called from constructor\n  shader: Shader;\n\n  /** ShaderInputs instance */\n  shaderInputs: ShaderInputs;\n\n  // @ts-ignore Set in function called from constructor\n  _uniformStore: UniformStore;\n\n  _pipelineNeedsUpdate: string | false = 'newly created';\n\n  private _getModuleUniforms: (props?: Record<string, Record<string, any>>) => Record<string, any>;\n  private props: Required<ComputationProps>;\n\n  private _destroyed = false;\n\n  constructor(device: Device, props: ComputationProps) {\n    if (device.type !== 'webgpu') {\n      throw new Error('Computation is only supported in WebGPU');\n    }\n\n    this.props = {...Computation.defaultProps, ...props};\n    props = this.props;\n    this.id = props.id || uid('model');\n    this.device = device;\n\n    Object.assign(this.userData, props.userData);\n\n    // Setup shader module inputs\n    const moduleMap = Object.fromEntries(\n      this.props.modules?.map(module => [module.name, module]) || []\n    );\n    // @ts-ignore TODO - fix up typing?\n    this.shaderInputs = props.shaderInputs || new ShaderInputs(moduleMap);\n    this.setShaderInputs(this.shaderInputs);\n\n    // Support WGSL shader layout introspection\n    // TODO - Don't modify props!!\n    this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.props.source);\n\n    // Setup shader assembler\n    const platformInfo = getPlatformInfo(device);\n\n    // Extract modules from shader inputs if not supplied\n    const modules =\n      (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];\n\n    this.pipelineFactory =\n      props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);\n    this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);\n\n    const {source, getUniforms} = this.props.shaderAssembler.assembleWGSLShader({\n      platformInfo,\n      ...this.props,\n      modules\n    });\n\n    this.source = source;\n    // @ts-ignore\n    this._getModuleUniforms = getUniforms;\n\n    // Create the pipeline\n    // @note order is important\n    this.pipeline = this._updatePipeline();\n\n    // Apply any dynamic settings that will not trigger pipeline change\n    if (props.bindings) {\n      this.setBindings(props.bindings);\n    }\n\n    // Catch any access to non-standard props\n    Object.seal(this);\n  }\n\n  destroy(): void {\n    if (this._destroyed) return;\n    this.pipelineFactory.release(this.pipeline);\n    this.shaderFactory.release(this.shader);\n    this._uniformStore.destroy();\n    this._destroyed = true;\n  }\n\n  // Draw call\n\n  predraw() {\n    // Update uniform buffers if needed\n    this.updateShaderInputs();\n  }\n\n  dispatch(computePass: ComputePass, x: number, y?: number, z?: number): void {\n    try {\n      this._logDrawCallStart();\n\n      // Check if the pipeline is invalidated\n      // TODO - this is likely the worst place to do this from performance perspective. Perhaps add a predraw()?\n      this.pipeline = this._updatePipeline();\n\n      // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw\n      // Any caching needs to be done inside the pipeline functions\n      this.pipeline.setBindings(this.bindings);\n      computePass.setPipeline(this.pipeline);\n      // @ts-expect-error\n      computePass.setBindings([]);\n\n      computePass.dispatch(x, y, z);\n    } finally {\n      this._logDrawCallEnd();\n    }\n  }\n\n  // Update fixed fields (can trigger pipeline rebuild)\n\n  // Update dynamic fields\n\n  /**\n   * Updates the vertex count (used in draw calls)\n   * @note Any attributes with stepMode=vertex need to be at least this big\n   */\n  setVertexCount(vertexCount: number): void {\n    // this.vertexCount = vertexCount;\n  }\n\n  /**\n   * Updates the instance count (used in draw calls)\n   * @note Any attributes with stepMode=instance need to be at least this big\n   */\n  setInstanceCount(instanceCount: number): void {\n    // this.instanceCount = instanceCount;\n  }\n\n  setShaderInputs(shaderInputs: ShaderInputs): void {\n    this.shaderInputs = shaderInputs;\n    this._uniformStore = new UniformStore(this.shaderInputs.modules);\n    // Create uniform buffer bindings for all modules\n    for (const moduleName of Object.keys(this.shaderInputs.modules)) {\n      const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);\n      this.bindings[`${moduleName}Uniforms`] = uniformBuffer;\n    }\n  }\n\n  /**\n   * Updates shader module settings (which results in uniforms being set)\n   */\n  setShaderModuleProps(props: Record<string, any>): void {\n    const uniforms = this._getModuleUniforms(props);\n\n    // Extract textures & framebuffers set by the modules\n    // TODO better way to extract bindings\n    const keys = Object.keys(uniforms).filter(k => {\n      const uniform = uniforms[k];\n      return (\n        !isNumericArray(uniform) && typeof uniform !== 'number' && typeof uniform !== 'boolean'\n      );\n    });\n    const bindings: Record<string, Binding> = {};\n    for (const k of keys) {\n      bindings[k] = uniforms[k];\n      delete uniforms[k];\n    }\n  }\n\n  updateShaderInputs(): void {\n    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());\n  }\n\n  /**\n   * Sets bindings (textures, samplers, uniform buffers)\n   */\n  setBindings(bindings: Record<string, Binding>): void {\n    Object.assign(this.bindings, bindings);\n  }\n\n  _setPipelineNeedsUpdate(reason: string): void {\n    this._pipelineNeedsUpdate = this._pipelineNeedsUpdate || reason;\n  }\n\n  _updatePipeline(): ComputePipeline {\n    if (this._pipelineNeedsUpdate) {\n      let prevShader: Shader | null = null;\n      if (this.pipeline) {\n        log.log(\n          1,\n          `Model ${this.id}: Recreating pipeline because \"${this._pipelineNeedsUpdate}\".`\n        )();\n        prevShader = this.shader;\n      }\n\n      this._pipelineNeedsUpdate = false;\n\n      this.shader = this.shaderFactory.createShader({\n        id: `${this.id}-fragment`,\n        stage: 'compute',\n        source: this.source,\n        debugShaders: this.props.debugShaders\n      });\n\n      this.pipeline = this.pipelineFactory.createComputePipeline({\n        ...this.props,\n        shader: this.shader\n      });\n\n      if (prevShader) {\n        this.shaderFactory.release(prevShader);\n      }\n    }\n    return this.pipeline;\n  }\n\n  /** Throttle draw call logging */\n  _lastLogTime = 0;\n  _logOpen = false;\n\n  _logDrawCallStart(): void {\n    // IF level is 4 or higher, log every frame.\n    const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {\n      return;\n    }\n\n    this._lastLogTime = Date.now();\n    this._logOpen = true;\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.level <= 2})();\n  }\n\n  _logDrawCallEnd(): void {\n    if (this._logOpen) {\n      // const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.props.shaderLayout, this.id);\n\n      // log.table(logLevel, attributeTable)();\n      // log.table(logLevel, uniformTable)();\n      // log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();\n\n      const uniformTable = this.shaderInputs.getDebugTable();\n      log.table(LOG_DRAW_PRIORITY, uniformTable)();\n\n      log.groupEnd(LOG_DRAW_PRIORITY)();\n      this._logOpen = false;\n    }\n  }\n\n  protected _drawCount = 0;\n\n  // TODO - fix typing of luma data types\n  _getBufferOrConstantValues(attribute: Buffer | TypedArray, dataType: any): string {\n    const TypedArrayConstructor = getTypedArrayFromDataType(dataType);\n    const typedArray =\n      attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;\n    return typedArray.toString();\n  }\n}\n\n/** Create a shadertools platform info from the Device */\nexport function getPlatformInfo(device: Device): PlatformInfo {\n  return {\n    type: device.type,\n    shaderLanguage: device.info.shadingLanguage,\n    shaderLanguageVersion: device.info.shadingLanguageVersion as 100 | 300,\n    gpu: device.info.gpu,\n    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API\n    features: device.features as unknown as Set<DeviceFeature>\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumberArray4} from '@math.gl/types';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\n/** Default color for auto highlight, a cyan color */\nconst DEFAULT_HIGHLIGHT_COLOR: NumberArray4 = [0, 1, 1, 1];\n\nexport const INVALID_INDEX = -1;\n\n/**\n * Props for the picking module, which depending on mode renders picking colors or highlighted item.\n * When active, renders picking colors, assumed to be rendered to off-screen \"picking\" buffer.\n * When inactive, renders normal colors, with the exception of selected object which is rendered with highlight\n * can distinguish between 2^32 different objects in each of 2^32 different batches.\n */\nexport type PickingProps = {\n  /** Are we picking? I.e. rendering picking colors? */\n  isActive?: boolean;\n  /** Whether to use instance_index (built-in) or a custom application supplied index (usually from an attribute) */\n  indexMode?: 'instance' | 'custom';\n  /** Batch index (used when rendering multiple models to identify which model was picked), defaults to 0 */\n  batchIndex?: number;\n\n  /** Index of the highlighted batch, defaults to 0 */\n  highlightedBatchIndex?: number | null;\n  /** Set an index to highlight that item, or `null` to explicitly clear **/\n  highlightedObjectIndex?: number | null;\n  /** Color of visual highlight of \"selected\" item () */\n  highlightColor?: NumberArray4;\n};\n\n/**\n * Uniforms for the picking module, which renders picking colors and highlighted item.\n * When active, renders picking colors, assumed to be rendered to off-screen \"picking\" buffer.\n * When inactive, renders normal colors, with the exception of selected object which is rendered with highlight\n */\nexport type PickingUniforms = {\n  /**\n   * When true, renders picking colors. Set when rendering to off-screen \"picking\" buffer.\n   * When false, renders normal colors, with the exception of selected object which is rendered with highlight\n   */\n  isActive: boolean;\n  /** Set to true when picking an attribute value instead of object index */\n  indexMode: 0 | 1;\n  /** Index of batch currently being rendered */\n  batchIndex: number;\n\n  /** Do we have a highlighted item? */\n  isHighlightActive: boolean;\n  /** Color of visual highlight of \"selected\" item. Note: RGBA components must in the range 0-1 */\n  highlightColor: NumberArray4;\n  /** Indicates which batch to visually highlight an item in (defaults to 0) */\n  highlightedBatchIndex: number;\n  /** Indicates which index in the batch to highlight an item in */\n  highlightedObjectIndex: number;\n};\n\nexport type PickingBindings = {};\n\n// GLSL_UNIFORMS\n\nconst uniformTypes: Required<ShaderModule<PickingProps, PickingUniforms>>['uniformTypes'] = {\n  isActive: 'i32',\n  indexMode: 'i32',\n  batchIndex: 'i32',\n\n  isHighlightActive: 'i32',\n  highlightedBatchIndex: 'i32',\n  highlightedObjectIndex: 'i32',\n  highlightColor: 'vec4<f32>'\n};\n\nexport const GLSL_UNIFORMS = /* glsl */ `\\\nprecision highp float;\nprecision highp int;\n\nuniform pickingUniforms {\n  int isActive;\n  int indexMode;\n  int batchIndex;\n\n  int isHighlightActive;\n  int highlightedBatchIndex;\n  int highlightedObjectIndex;\n  vec4 highlightColor;\n} picking;\n`;\n\nexport const WGSL_UNIFORMS = /* wgsl */ `\\\nstruct pickingUniforms {\n  isActive: int32;\n  indexMode: int32;\n  batchIndex: int32;\n\n  isHighlightActive: int32;\n  highlightedBatchIndex: int32;\n  highlightedObjectIndex: int32;\n  highlightColor: vec4<f32>;\n} picking;\n`;\n\nfunction getUniforms(props: PickingProps = {}, prevUniforms?: PickingUniforms): PickingUniforms {\n  const uniforms = {...prevUniforms} as PickingUniforms;\n\n  // picking\n  if (props.isActive !== undefined) {\n    uniforms.isActive = Boolean(props.isActive);\n  }\n\n  switch (props.indexMode) {\n    case 'instance':\n      uniforms.indexMode = 0;\n      break;\n    case 'custom':\n      uniforms.indexMode = 1;\n      break;\n    case undefined:\n      // no change\n      break;\n  }\n\n  switch (props.highlightedObjectIndex) {\n    case undefined:\n      // Unless highlightedObjectColor explicitly null or set, do not update state\n      break;\n    case null:\n      // Clear highlight\n      uniforms.isHighlightActive = false;\n      uniforms.highlightedObjectIndex = INVALID_INDEX;\n      break;\n    default:\n      uniforms.isHighlightActive = true;\n      uniforms.highlightedObjectIndex = props.highlightedObjectIndex;\n  }\n\n  if (typeof props.highlightedBatchIndex === 'number') {\n    uniforms.highlightedBatchIndex = props.highlightedBatchIndex;\n  }\n\n  if (props.highlightColor) {\n    uniforms.highlightColor = props.highlightColor;\n  }\n\n  return uniforms;\n}\n\n/**\n * Provides support for color-based picking and highlighting.\n *\n * In particular, supports picking a specific instance in an instanced\n * draw call and highlighting an instance based on its picking color,\n * and correspondingly, supports picking and highlighting groups of\n * primitives with the same picking color in non-instanced draw-calls\n *\n * @note Color based picking has the significant advantage in that it can be added to any\n * existing shader without requiring any additional picking logic.\n */\nexport const pickingUniforms = {\n  props: {} as PickingProps,\n  uniforms: {} as PickingUniforms,\n\n  name: 'picking',\n\n  uniformTypes,\n  defaultUniforms: {\n    isActive: false,\n    indexMode: 0,\n    batchIndex: 0,\n    isHighlightActive: true,\n    highlightedBatchIndex: INVALID_INDEX,\n    highlightedObjectIndex: INVALID_INDEX,\n    highlightColor: DEFAULT_HIGHLIGHT_COLOR\n  },\n\n  getUniforms\n} as const satisfies ShaderModule<PickingProps, PickingUniforms, PickingBindings>;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Framebuffer} from '@luma.gl/core';\nimport {ShaderInputs} from '../../shader-inputs';\nimport {pickingUniforms, INVALID_INDEX} from './picking-uniforms';\n// import {picking} from './color-picking';\n\n/** Information about picked object */\nexport type PickInfo = {\n  batchIndex: number | null;\n  objectIndex: number | null;\n};\n\nexport type PickingManagerProps = {\n  /** Shader Inputs from models to pick */\n  shaderInputs?: ShaderInputs<{picking: typeof pickingUniforms.props}>;\n  /** Callback */\n  onObjectPicked?: (info: PickInfo) => void;\n};\n\n/**\n * Helper class for using the new picking module\n * @todo Port to WebGPU\n * @todo Support multiple models\n * @todo Switching picking module\n */\nexport class PickingManager {\n  device: Device;\n  props: Required<PickingManagerProps>;\n  /** Info from latest pick operation */\n  pickInfo: PickInfo = {batchIndex: null, objectIndex: null};\n  /** Framebuffer used for picking */\n  framebuffer: Framebuffer | null = null;\n\n  static defaultProps: Required<PickingManagerProps> = {\n    shaderInputs: undefined!,\n    onObjectPicked: () => {}\n  };\n\n  constructor(device: Device, props: PickingManagerProps) {\n    this.device = device;\n    this.props = {...PickingManager.defaultProps, ...props};\n  }\n\n  destroy() {\n    this.framebuffer?.destroy();\n  }\n\n  // TODO - Ask for a cached framebuffer? a Framebuffer factory?\n  getFramebuffer() {\n    if (!this.framebuffer) {\n      this.framebuffer = this.device.createFramebuffer({\n        colorAttachments: ['rgba8unorm', 'rg32sint'],\n        depthStencilAttachment: 'depth24plus'\n      });\n    }\n    return this.framebuffer;\n  }\n\n  /** Clear highlighted / picked object */\n  clearPickState() {\n    this.props.shaderInputs.setProps({picking: {highlightedObjectIndex: null}});\n  }\n\n  /** Prepare for rendering picking colors */\n  beginRenderPass() {\n    const framebuffer = this.getFramebuffer();\n    framebuffer.resize(this.device.getDefaultCanvasContext().getPixelSize());\n\n    this.props.shaderInputs?.setProps({picking: {isActive: true}});\n\n    const pickingPass = this.device.beginRenderPass({\n      framebuffer,\n      clearColors: [new Float32Array([0, 0, 0, 0]), new Int32Array([-1, -1, 0, 0])],\n      clearDepth: 1\n    });\n\n    return pickingPass;\n  }\n\n  getPickInfo(mousePosition: [number, number]): PickInfo | null {\n    const framebuffer = this.getFramebuffer();\n\n    // use the center pixel location in device pixel range\n    const [pickX, pickY] = this.getPickPosition(mousePosition);\n\n    // Read back\n    const pixelData = this.device.readPixelsToArrayWebGL(framebuffer, {\n      sourceX: pickX,\n      sourceY: pickY,\n      sourceWidth: 1,\n      sourceHeight: 1,\n      sourceAttachment: 1\n    });\n    if (!pixelData) {\n      return null;\n    }\n\n    const pickInfo: PickInfo = {\n      objectIndex: pixelData[0] === INVALID_INDEX ? null : pixelData[0],\n      batchIndex: pixelData[1] === INVALID_INDEX ? null : pixelData[1]\n    };\n\n    // Call callback if picked object has changed\n    if (\n      pickInfo.objectIndex !== this.pickInfo.objectIndex ||\n      pickInfo.batchIndex !== this.pickInfo.batchIndex\n    ) {\n      this.pickInfo = pickInfo;\n      this.props.onObjectPicked(pickInfo);\n      // console.log(`Object ${pickInfo.objectIndex} in batch ${pickInfo.batchIndex} was picked`)\n    }\n\n    this.props.shaderInputs?.setProps({\n      picking: {\n        isActive: false,\n        highlightedBatchIndex: pickInfo.batchIndex,\n        highlightedObjectIndex: pickInfo.objectIndex\n      }\n    });\n\n    return this.pickInfo;\n  }\n\n  /**\n   * Get pick position in device pixel range\n   * use the center pixel location in device pixel range\n   */\n  getPickPosition(mousePosition: number[]): [number, number] {\n    const devicePixels = this.device.getDefaultCanvasContext().cssToDevicePixels(mousePosition);\n    const pickX = devicePixels.x + Math.floor(devicePixels.width / 2);\n    const pickY = devicePixels.y + Math.floor(devicePixels.height / 2);\n    return [pickX, pickY];\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nimport type {PickingBindings, PickingProps, PickingUniforms} from './picking-uniforms';\nimport {pickingUniforms, GLSL_UNIFORMS, WGSL_UNIFORMS, INVALID_INDEX} from './picking-uniforms';\n\n// SHADERS\n\nconst source = /* wgsl */ `\\\n${WGSL_UNIFORMS}\n\nconst INDEX_PICKING_MODE_INSTANCE = 0;\nconst INDEX_PICKING_MODE_CUSTOM = 1;\nconst INDEX_PICKING_INVALID_INDEX = ${INVALID_INDEX}; // 2^32 - 1\n\nstruct indexPickingFragmentInputs = {\n  objectIndex: int32;\n};\n\nlet indexPickingFragmentInputs: indexPickingFragmentInputs;\n\n/**\n * Vertex shaders should call this function to set the object index.\n * If using instance or vertex mode, argument will be ignored, 0 can be supplied.\n */\nfn picking_setObjectIndex(objectIndex: int32) {\n  switch (picking.indexMode) {\n    case INDEX_PICKING_MODE_INSTANCE, default: {\n      picking_objectIndex = instance_index;\n    };\n    case INDEX_PICKING_MODE_CUSTOM: {\n      picking_objectIndex = objectIndex;\n    };\n  }\n}\n\n`;\n\nconst vs = /* glsl */ `\\\n${GLSL_UNIFORMS}\n\nconst int INDEX_PICKING_MODE_INSTANCE = 0;\nconst int INDEX_PICKING_MODE_CUSTOM = 1;\n\nconst int INDEX_PICKING_INVALID_INDEX = ${INVALID_INDEX}; // 2^32 - 1\n\nflat out int picking_objectIndex;\n\n/**\n * Vertex shaders should call this function to set the object index.\n * If using instance or vertex mode, argument will be ignored, 0 can be supplied.\n */\nvoid picking_setObjectIndex(int objectIndex) {\n  switch (picking.indexMode) {\n    case INDEX_PICKING_MODE_INSTANCE:\n      picking_objectIndex = gl_InstanceID;\n      break;\n    case INDEX_PICKING_MODE_CUSTOM:\n      picking_objectIndex = objectIndex;\n      break;\n  }\n}\n`;\n\nconst fs = /* glsl */ `\\\n${GLSL_UNIFORMS}\n\nconst int INDEX_PICKING_INVALID_INDEX = ${INVALID_INDEX}; // 2^32 - 1\n\nflat in int picking_objectIndex;\n\n/**\n * Check if this vertex is highlighted (part of the selected batch and object)\n */ \nbool picking_isFragmentHighlighted() {\n  return \n    bool(picking.isHighlightActive) &&\n    picking.highlightedBatchIndex == picking.batchIndex &&\n    picking.highlightedObjectIndex == picking_objectIndex\n    ;\n}\n\n/**\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (bool(picking.isActive)) {\n    return color;\n  }\n\n  // If we are not highlighted, return color as is\n  if (!picking_isFragmentHighlighted()) {\n    return color;\n  }\n   \n  // Blend in highlight color based on its alpha value\n  float highLightAlpha = picking.highlightColor.a;\n  float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n  float highLightRatio = highLightAlpha / blendedAlpha;\n\n  vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n  return vec4(blendedRGB, blendedAlpha);\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nivec4 picking_getPickingColor() {\n  // Assumes that colorAttachment0 is rg32int\n  // TODO? - we could render indices into a second color attachment and not mess with fragColor\n  return ivec4(picking_objectIndex, picking.batchIndex, 0u, 0u);  \n}\n\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_objectIndex == INDEX_PICKING_INVALID_INDEX) {\n      discard;\n    }\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 outColor = color;\n  outColor = picking_filterHighlightColor(outColor);\n  outColor = picking_filterPickingColor(outColor);\n  return outColor;\n}\n`;\n\n/**\n * Provides support for color-based picking and highlighting.\n *\n * In particular, supports picking a specific instance in an instanced\n * draw call and highlighting an instance based on its picking color,\n * and correspondingly, supports picking and highlighting groups of\n * primitives with the same picking color in non-instanced draw-calls\n *\n * @note Color based picking has the significant advantage in that it can be added to any\n * existing shader without requiring any additional picking logic.\n */\nexport const picking = {\n  ...pickingUniforms,\n  name: 'picking',\n  source,\n  vs,\n  fs\n} as const satisfies ShaderModule<PickingProps, PickingUniforms, PickingBindings>;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nimport type {PickingProps, PickingUniforms, PickingBindings} from './picking-uniforms';\nimport {pickingUniforms, GLSL_UNIFORMS, WGSL_UNIFORMS} from './picking-uniforms';\n\nconst source = /* wgsl */ `\\\n${WGSL_UNIFORMS}\n`;\n\nconst vs = /* glsl */ `\\\n${GLSL_UNIFORMS}\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setObjectIndex(uint objectIndex) {\n  if (bool(picking.isActive)) {\n    uint index = objectIndex;\n    if (picking.indexMode == PICKING_INDEX_MODE_INSTANCE) {\n      index = uint(gl_InstanceID);\n    }\n    picking_vRGBcolor_Avalid.r = float(index % 255) / 255.0;\n    picking_vRGBcolor_Avalid.g = float((index / 255) % 255) / 255.0;\n    picking_vRGBcolor_Avalid.b = float((index / 255 / 255) %255) / 255.0;\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n`;\n\nconst fs = /* glsl */ `\\\n${GLSL_UNIFORMS}\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n`;\n\n/**\n * Provides support for color-coding-based picking and highlighting.\n * In particular, supports picking a specific instance in an instanced\n * draw call and highlighting an instance based on its picking color,\n * and correspondingly, supports picking and highlighting groups of\n * primitives with the same picking color in non-instanced draw-calls\n */\nexport const picking = {\n  ...pickingUniforms,\n  name: 'picking',\n  source,\n  vs,\n  fs\n} as const satisfies ShaderModule<PickingProps, PickingUniforms, PickingBindings>;\n\n// function getUniforms(opts: PickingProps = {}, prevUniforms?: PickingUniforms): PickingUniforms {\n//   const uniforms = {} as PickingUniforms;\n\n//   if (opts.highlightedObjectColor === undefined) {\n//     // Unless highlightedObjectColor explicitly null or set, do not update state\n//   } else if (opts.highlightedObjectColor === null) {\n//     uniforms.isHighlightActive = false;\n//   } else {\n//     uniforms.isHighlightActive = true;\n//     const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);\n//     uniforms.highlightedObjectColor = highlightedObjectColor;\n//   }\n\n//   if (opts.highlightColor) {\n//     const color = Array.from(opts.highlightColor, x => x / 255);\n//     if (!Number.isFinite(color[3])) {\n//       color[3] = 1;\n//     }\n//     uniforms.highlightColor = color;\n//   }\n\n//   if (opts.isActive !== undefined) {\n//     uniforms.isActive = Boolean(opts.isActive);\n//     uniforms.isAttribute = Boolean(opts.isAttribute);\n//   }\n\n//   if (opts.useFloatColors !== undefined) {\n//     uniforms.useFloatColors = Boolean(opts.useFloatColors);\n//   }\n\n//   return uniforms;\n// }\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Framebuffer} from '@luma.gl/core';\nimport {picking} from '@luma.gl/shadertools';\nimport {ShaderInputs} from '../../shader-inputs';\nimport {NumberArray3} from '@math.gl/types';\n\n/**\n * Helper class for using the legacy picking module\n */\nexport class LegacyPickingManager {\n  device: Device;\n  framebuffer: Framebuffer | null = null;\n  shaderInputs: ShaderInputs<{picking: typeof picking.props}>;\n\n  constructor(device: Device, shaderInputs: ShaderInputs) {\n    this.device = device;\n    this.shaderInputs = shaderInputs as ShaderInputs<{picking: typeof picking.props}>;\n  }\n\n  destroy() {\n    this.framebuffer?.destroy();\n  }\n\n  getFramebuffer() {\n    if (!this.framebuffer) {\n      this.framebuffer = this.device.createFramebuffer({\n        colorAttachments: ['rgba8unorm'],\n        depthStencilAttachment: 'depth24plus'\n      });\n    }\n    return this.framebuffer;\n  }\n\n  /** Clear highlighted / picked object */\n  clearPickState() {\n    this.shaderInputs.setProps({picking: {highlightedObjectColor: null}});\n  }\n\n  /** Prepare for rendering picking colors */\n  beginRenderPass() {\n    const framebuffer = this.getFramebuffer();\n    framebuffer.resize(this.device.getCanvasContext().getPixelSize());\n\n    this.shaderInputs.setProps({picking: {isActive: true}});\n\n    const pickingPass = this.device.beginRenderPass({\n      framebuffer,\n      clearColor: [0, 0, 0, 0],\n      clearDepth: 1\n    });\n\n    return pickingPass;\n  }\n\n  updatePickState(mousePosition: [number, number]) {\n    const framebuffer = this.getFramebuffer();\n\n    // use the center pixel location in device pixel range\n    const [pickX, pickY] = this.getPickPosition(mousePosition);\n\n    // Read back\n    const color255 = this.device.readPixelsToArrayWebGL(framebuffer, {\n      sourceX: pickX,\n      sourceY: pickY,\n      sourceWidth: 1,\n      sourceHeight: 1\n    });\n    // console.log(color255);\n\n    // Check if we have\n    let highlightedObjectColor: NumberArray3 | null = [...color255].map(\n      x => x / 255\n    ) as NumberArray3;\n    const isHighlightActive =\n      highlightedObjectColor[0] + highlightedObjectColor[1] + highlightedObjectColor[2] > 0;\n\n    if (!isHighlightActive) {\n      highlightedObjectColor = null;\n    }\n\n    this.shaderInputs.setProps({\n      picking: {isActive: false, highlightedObjectColor}\n    });\n  }\n\n  /**\n   * Get pick position in device pixel range\n   * use the center pixel location in device pixel range\n   */\n  getPickPosition(mousePosition: number[]): [number, number] {\n    const devicePixels = this.device.getCanvasContext().cssToDevicePixels(mousePosition);\n    const pickX = devicePixels.x + Math.floor(devicePixels.width / 2);\n    const pickY = devicePixels.y + Math.floor(devicePixels.height / 2);\n    return [pickX, pickY];\n  }\n}\n"],
  "mappings": "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",
  "names": ["picking", "canvas", "import_core", "import_core", "import_shadertools", "import_core", "import_core", "import_core", "import_core", "module", "module", "source", "getUniforms", "vs", "fs", "import_core", "import_shadertools", "import_shadertools", "import_core", "import_core", "import_core", "import_shadertools", "import_core", "fs", "import_core", "import_shadertools", "import_types", "LOG_DRAW_PRIORITY", "LOG_DRAW_TIMEOUT", "module", "getPlatformInfo", "source", "getUniforms", "source", "vs", "fs", "picking"]
}
