import type { Texture, TextureProps, Sampler, TextureView, Device, Texture1DData, Texture2DData, Texture3DData, TextureArrayData, TextureCubeData, TextureCubeArrayData } from '@luma.gl/core';
export type AsyncTextureProps = Omit<TextureProps, 'data'> & AsyncTextureDataProps;
type AsyncTextureDataProps = AsyncTexture1DProps | AsyncTexture2DProps | AsyncTexture3DProps | AsyncTextureArrayProps | AsyncTextureCubeProps | AsyncTextureCubeArrayProps;
type AsyncTexture1DProps = {
    dimension: '1d';
    data: Promise<Texture1DData> | Texture1DData | null;
};
type AsyncTexture2DProps = {
    dimension?: '2d';
    data: Promise<Texture2DData> | Texture2DData | null;
};
type AsyncTexture3DProps = {
    dimension: '3d';
    data: Promise<Texture3DData> | Texture3DData | null;
};
type AsyncTextureArrayProps = {
    dimension: '2d-array';
    data: Promise<TextureArrayData> | TextureArrayData | null;
};
type AsyncTextureCubeProps = {
    dimension: 'cube';
    data: Promise<TextureCubeData> | TextureCubeData | null;
};
type AsyncTextureCubeArrayProps = {
    dimension: 'cube-array';
    data: Promise<TextureCubeArrayData> | TextureCubeArrayData | null;
};
/**
 * It is very convenient to be able to initialize textures with promises
 * This can add considerable complexity to the Texture class, and doesn't
 * fit with the immutable nature of WebGPU resources.
 * Instead, luma.gl offers async textures as a separate class.
 */
export declare class AsyncTexture {
    readonly device: Device;
    readonly id: string;
    texture: Texture;
    sampler: Sampler;
    view: TextureView;
    readonly ready: Promise<void>;
    isReady: boolean;
    destroyed: boolean;
    protected resolveReady: () => void;
    protected rejectReady: (error: Error) => void;
    get [Symbol.toStringTag](): string;
    toString(): string;
    constructor(device: Device, props: AsyncTextureProps);
    initAsync(props: AsyncTextureProps): Promise<void>;
    destroy(): void;
    /**
     * Textures are immutable and cannot be resized after creation,
     * but we can create a similar texture with the same parameters but a new size.
     * @note Does not copy contents of the texture
     * @todo Abort pending promise and create a texture with the new size?
     */
    resize(size: {
        width: number;
        height: number;
    }): boolean;
}
export {};
//# sourceMappingURL=async-texture.d.ts.map