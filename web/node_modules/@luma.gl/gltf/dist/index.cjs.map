{
  "version": 3,
  "sources": ["../src/index.ts", "../src/pbr/parse-pbr-material.ts", "../src/pbr/pbr-environment.ts", "../src/gltf/gltf-instantiator.ts", "../src/gltf/gltf-animator.ts", "../src/gltf/create-gltf-model.ts", "../src/gltf/gl-utils.ts", "../src/gltf/create-gltf-objects.ts"],
  "sourcesContent": ["// luma.gl, MIT license\n\nexport type {PBREnvironment} from './pbr/pbr-environment';\nexport type {ParsePBRMaterialOptions, ParsedPBRMaterial} from './pbr/parse-pbr-material';\nexport {parsePBRMaterial} from './pbr/parse-pbr-material';\nexport {loadPBREnvironment} from './pbr/pbr-environment';\n\n// glTF Scenegraph Instantiator\nexport {createScenegraphsFromGLTF} from './gltf/create-gltf-objects';\nexport {GLTFAnimator} from './gltf/gltf-animator';\n", "import type {Device, Texture, Parameters} from '@luma.gl/core';\nimport {log} from '@luma.gl/core';\nimport {PBREnvironment} from './pbr-environment';\nimport {PBRMaterialBindings, PBRMaterialUniforms, PBRProjectionProps} from '@luma.gl/shadertools';\n\n/* eslint-disable camelcase */\n\nexport type ParsePBRMaterialOptions = {\n  /** Debug PBR shader */\n  pbrDebug?: boolean;\n  /** Enable lights */\n  lights?: any;\n  /** Use tangents */\n  useTangents?: boolean;\n  /** provide an image based (texture cube) lighting environment */\n  imageBasedLightingEnvironment?: PBREnvironment;\n};\n\nexport type ParsedPBRMaterial = {\n  readonly defines: Record<string, number | boolean>;\n  readonly bindings: Partial<PBRMaterialBindings>;\n  readonly uniforms: Partial<PBRProjectionProps & PBRMaterialUniforms>;\n  readonly parameters: Parameters;\n  readonly glParameters: Record<string, any>;\n  /** List of all generated textures, makes it easy to destroy them later */\n  readonly generatedTextures: Texture[];\n};\n\n// NOTE: Modules other than `@luma.gl/webgl` should not import `GL` from\n// `@luma.gl/constants`. Locally we use `GLEnum` instead of `GL` to avoid\n// conflicts with the `babel-plugin-inline-webgl-constants` plugin.\n// eslint-disable-next-line no-shadow\nenum GLEnum {\n  FUNC_ADD = 0x8006,\n  ONE = 1,\n  SRC_ALPHA = 0x0302,\n  ONE_MINUS_SRC_ALPHA = 0x0303,\n  TEXTURE_MIN_FILTER = 0x2801,\n  LINEAR = 0x2601,\n  LINEAR_MIPMAP_NEAREST = 0x2701,\n  UNPACK_FLIP_Y_WEBGL = 0x9240\n}\n\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n */\nexport function parsePBRMaterial(\n  device: Device,\n  material,\n  attributes: Record<string, any>,\n  options: ParsePBRMaterialOptions\n): ParsedPBRMaterial {\n  const parsedMaterial: ParsedPBRMaterial = {\n    defines: {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    },\n    bindings: {},\n    uniforms: {\n      // TODO: find better values?\n      camera: [0, 0, 0], // Model should override\n\n      metallicRoughnessValues: [1, 1] // Default is 1 and 1\n    },\n    parameters: {},\n    glParameters: {},\n    generatedTextures: []\n  };\n\n  // TODO - always available\n  parsedMaterial.defines.USE_TEX_LOD = 1;\n\n  const {imageBasedLightingEnvironment} = options;\n  if (imageBasedLightingEnvironment) {\n    parsedMaterial.bindings.pbr_diffuseEnvSampler =\n      imageBasedLightingEnvironment.diffuseEnvSampler.texture;\n    parsedMaterial.bindings.pbr_specularEnvSampler =\n      imageBasedLightingEnvironment.specularEnvSampler.texture;\n    parsedMaterial.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.brdfLutTexture.texture;\n    parsedMaterial.uniforms.scaleIBLAmbient = [1, 1];\n  }\n\n  if (options?.pbrDebug) {\n    parsedMaterial.defines.PBR_DEBUG = 1;\n    // Override final color for reference app visualization of various parameters in the lighting equation.\n    parsedMaterial.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];\n    parsedMaterial.uniforms.scaleFGDSpec = [0, 0, 0, 0];\n  }\n\n  if (attributes.NORMAL) parsedMaterial.defines.HAS_NORMALS = 1;\n  if (attributes.TANGENT && options?.useTangents) parsedMaterial.defines.HAS_TANGENTS = 1;\n  if (attributes.TEXCOORD_0) parsedMaterial.defines.HAS_UV = 1;\n\n  if (options?.imageBasedLightingEnvironment) parsedMaterial.defines.USE_IBL = 1;\n  if (options?.lights) parsedMaterial.defines.USE_LIGHTS = 1;\n\n  if (material) {\n    parseMaterial(device, material, parsedMaterial);\n  }\n\n  return parsedMaterial;\n}\n\n/** Parse GLTF material record */\nfunction parseMaterial(device: Device, material, parsedMaterial: ParsedPBRMaterial): void {\n  parsedMaterial.uniforms.unlit = Boolean(material.unlit);\n\n  if (material.pbrMetallicRoughness) {\n    parsePbrMetallicRoughness(device, material.pbrMetallicRoughness, parsedMaterial);\n  }\n  if (material.normalTexture) {\n    addTexture(\n      device,\n      material.normalTexture,\n      'pbr_normalSampler',\n      'HAS_NORMALMAP',\n      parsedMaterial\n    );\n\n    const {scale = 1} = material.normalTexture;\n    parsedMaterial.uniforms.normalScale = scale;\n  }\n  if (material.occlusionTexture) {\n    addTexture(\n      device,\n      material.occlusionTexture,\n      'pbr_occlusionSampler',\n      'HAS_OCCLUSIONMAP',\n      parsedMaterial\n    );\n\n    const {strength = 1} = material.occlusionTexture;\n    parsedMaterial.uniforms.occlusionStrength = strength;\n  }\n  if (material.emissiveTexture) {\n    addTexture(\n      device,\n      material.emissiveTexture,\n      'pbr_emissiveSampler',\n      'HAS_EMISSIVEMAP',\n      parsedMaterial\n    );\n    parsedMaterial.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];\n  }\n\n  switch (material.alphaMode) {\n    case 'MASK':\n      const {alphaCutoff = 0.5} = material;\n      parsedMaterial.defines.ALPHA_CUTOFF = 1;\n      parsedMaterial.uniforms.alphaCutoff = alphaCutoff;\n      break;\n    case 'BLEND':\n      log.warn('glTF BLEND alphaMode might not work well because it requires mesh sorting')();\n\n      // WebGPU style parameters\n      parsedMaterial.parameters.blendColorOperation = 'add';\n      parsedMaterial.parameters.blendColorSrcFactor = 'src-alpha';\n      parsedMaterial.parameters.blendColorDstFactor = 'one-minus-src-alpha';\n\n      parsedMaterial.parameters.blendAlphaOperation = 'add';\n      parsedMaterial.parameters.blendAlphaSrcFactor = 'one';\n      parsedMaterial.parameters.blendAlphaDstFactor = 'one-minus-src-alpha';\n\n      // GL parameters\n      parsedMaterial.glParameters.blend = true;\n      parsedMaterial.glParameters.blendEquation = GLEnum.FUNC_ADD;\n      parsedMaterial.glParameters.blendFunc = [\n        GLEnum.SRC_ALPHA,\n        GLEnum.ONE_MINUS_SRC_ALPHA,\n        GLEnum.ONE,\n        GLEnum.ONE_MINUS_SRC_ALPHA\n      ];\n\n      break;\n  }\n}\n\n/** Parse GLTF material sub record */\nfunction parsePbrMetallicRoughness(\n  device: Device,\n  pbrMetallicRoughness,\n  parsedMaterial: ParsedPBRMaterial\n): void {\n  if (pbrMetallicRoughness.baseColorTexture) {\n    addTexture(\n      device,\n      pbrMetallicRoughness.baseColorTexture,\n      'pbr_baseColorSampler',\n      'HAS_BASECOLORMAP',\n      parsedMaterial\n    );\n  }\n  parsedMaterial.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n  if (pbrMetallicRoughness.metallicRoughnessTexture) {\n    addTexture(\n      device,\n      pbrMetallicRoughness.metallicRoughnessTexture,\n      'pbr_metallicRoughnessSampler',\n      'HAS_METALROUGHNESSMAP',\n      parsedMaterial\n    );\n  }\n  const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n  parsedMaterial.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];\n}\n\n/** Create a texture from a glTF texture/sampler/image combo and add it to bindings */\nfunction addTexture(\n  device: Device,\n  gltfTexture,\n  uniformName: string,\n  define = null,\n  parsedMaterial: ParsedPBRMaterial\n): void {\n  const parameters = gltfTexture?.texture?.sampler?.parameters || {};\n\n  const image = gltfTexture.texture.source.image;\n  let textureOptions;\n  let specialTextureParameters = {};\n  if (image.compressed) {\n    textureOptions = image;\n    specialTextureParameters = {\n      [GLEnum.TEXTURE_MIN_FILTER]:\n        image.data.length > 1 ? GLEnum.LINEAR_MIPMAP_NEAREST : GLEnum.LINEAR\n    };\n  } else {\n    // Texture2D accepts a promise that returns an image as data (Async Textures)\n    textureOptions = {data: image};\n  }\n\n  const texture: Texture = device.createTexture({\n    id: gltfTexture.uniformName || gltfTexture.id,\n    parameters: {\n      ...parameters,\n      ...specialTextureParameters\n    },\n    pixelStore: {\n      [GLEnum.UNPACK_FLIP_Y_WEBGL]: false\n    },\n    ...textureOptions\n  });\n  parsedMaterial.bindings[uniformName] = texture;\n  if (define) parsedMaterial.defines[define] = 1;\n  parsedMaterial.generatedTextures.push(texture);\n}\n\n/*\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n *\nexport class PBRMaterialParser {\n  readonly device: Device;\n\n  readonly defines: Record<string, number | boolean>;\n  readonly bindings: Record<string, Binding>;\n  readonly uniforms: Record<string, any>;\n  readonly parameters: Record<string, any>;\n\n  /** Hold on to generated textures, we destroy them in the destroy method *\n  readonly generatedTextures: Texture[];\n\n  constructor(device: Device, props: PBRMaterialParserProps) {\n    const {attributes, material, pbrDebug, imageBasedLightingEnvironment, lights, useTangents} =\n      props;\n    this.device = device;\n\n    this.defines = {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n\n    if (this.device.features.has('glsl-texture-lod')) {\n      this.defines.USE_TEX_LOD = 1;\n    }\n\n    this.uniforms = {\n      // TODO: find better values?\n      camera: [0, 0, 0], // Model should override\n\n      metallicRoughnessValues: [1, 1] // Default is 1 and 1\n    };\n\n    this.bindings = {};\n\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.bindings.pbr_diffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.bindings.pbr_specularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.scaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      // Override final color for reference app visualization\n      // of various parameters in the lighting equation.\n      this.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.scaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  /**\n   * Destroy all generated resources to release memory.\n   *\n  destroy(): void {\n    this.generatedTextures.forEach(texture => texture.destroy());\n  }\n\n  /** Add a define if the the value is non-nullish *\n  defineIfPresent(value: unknown, name: string): void {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n\n  /** Parse GLTF material record *\n  parseMaterial(material) {\n    this.uniforms.unlit = Boolean(material.unlit);\n\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n    if (material.normalTexture) {\n      this.addTexture(material.normalTexture, 'pbr_normalSampler', 'HAS_NORMALMAP');\n\n      const {scale = 1} = material.normalTexture;\n      this.uniforms.normalScale = scale;\n    }\n    if (material.occlusionTexture) {\n      this.addTexture(material.occlusionTexture, 'pbr_occlusionSampler', 'HAS_OCCLUSIONMAP');\n\n      const {strength = 1} = material.occlusionTexture;\n      this.uniforms.occlusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n      this.addTexture(material.emissiveTexture, 'pbr_emissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    if (material.alphaMode === 'MASK') {\n      const {alphaCutoff = 0.5} = material;\n      this.defines.ALPHA_CUTOFF = 1;\n      this.uniforms.alphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: GL.FUNC_ADD,\n        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA]\n      });\n    }\n  }\n\n  /** Parse GLTF material sub record *\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.baseColorTexture,\n        'pbr_baseColorSampler',\n        'HAS_BASECOLORMAP'\n      );\n    }\n    this.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.metallicRoughnessTexture,\n        'pbr_metallicRoughnessSampler',\n        'HAS_METALROUGHNESSMAP'\n      );\n    }\n    const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n    this.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n\n  /** Create a texture from a glTF texture/sampler/image combo and add it to bindings *\n  addTexture(gltfTexture, name, define = null) {\n    const parameters = gltfTexture?.texture?.sampler?.parameters || {};\n\n    const image = gltfTexture.texture.source.image;\n    let textureOptions;\n    let specialTextureParameters = {};\n    if (image.compressed) {\n      textureOptions = image;\n      specialTextureParameters = {\n        [GL.TEXTURE_MIN_FILTER]: image.data.length > 1 ? GL.LINEAR_MIPMAP_NEAREST : GL.LINEAR\n      };\n    } else {\n      // Texture2D accepts a promise that returns an image as data (Async Textures)\n      textureOptions = {data: image};\n    }\n\n    const texture: Texture = this.device.createTexture({\n      id: gltfTexture.name || gltfTexture.id,\n      parameters: {\n        ...parameters,\n        ...specialTextureParameters\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      ...textureOptions\n    });\n    this.bindings[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n}\n*/\n", "// luma.gl, MIT license\n\nimport {Device, SamplerProps} from '@luma.gl/core';\nimport {AsyncTexture} from '@luma.gl/engine';\nimport {loadImageTexture} from '@loaders.gl/textures';\n\n/** Environment textures for PBR module */\nexport type PBREnvironment = {\n  /** Bi-directional Reflectance Distribution Function (BRDF) lookup table */\n  brdfLutTexture: AsyncTexture;\n  diffuseEnvSampler: AsyncTexture;\n  specularEnvSampler: AsyncTexture;\n};\n\nexport type PBREnvironmentProps = {\n  brdfLutUrl: string;\n  getTexUrl: (name: string, dir: number, level: number) => string;\n  specularMipLevels?: number;\n};\n\n/** Loads textures for PBR environment */\nexport function loadPBREnvironment(device: Device, props: PBREnvironmentProps): PBREnvironment {\n  const brdfLutTexture = new AsyncTexture(device, {\n    id: 'brdfLUT',\n    sampler: {\n      wrapS: 'clamp-to-edge',\n      wrapT: 'clamp-to-edge',\n      minFilter: 'linear',\n      maxFilter: 'linear'\n    } as SamplerProps,\n    // Texture accepts a promise that returns an image as data (Async Textures)\n    data: loadImageTexture(props.brdfLutUrl)\n  });\n\n  const diffuseEnvSampler = makeCube(device, {\n    id: 'DiffuseEnvSampler',\n    getTextureForFace: dir => loadImageTexture(props.getTexUrl('diffuse', dir, 0)),\n    sampler: {\n      wrapS: 'clamp-to-edge',\n      wrapT: 'clamp-to-edge',\n      minFilter: 'linear',\n      maxFilter: 'linear'\n    } as SamplerProps\n  });\n\n  const specularEnvSampler = makeCube(device, {\n    id: 'SpecularEnvSampler',\n    getTextureForFace: (dir: number) => {\n      const imageArray = [];\n      for (let lod = 0; lod <= props.specularMipLevels - 1; lod++) {\n        imageArray.push(loadImageTexture(props.getTexUrl('specular', dir, lod)));\n      }\n      return imageArray;\n    },\n    sampler: {\n      wrapS: 'clamp-to-edge',\n      wrapT: 'clamp-to-edge',\n      minFilter: 'linear', // [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n      maxFilter: 'linear'\n    } as SamplerProps\n  });\n\n  return {\n    brdfLutTexture,\n    diffuseEnvSampler,\n    specularEnvSampler\n  };\n}\n\n// TODO put somewhere common\nconst FACES = [0, 1, 2, 3, 4, 5];\n\nfunction makeCube(\n  device: Device,\n  {\n    id,\n    getTextureForFace,\n    sampler\n  }: {\n    id: string;\n    getTextureForFace: (dir: number) => Promise<any> | Promise<any>[];\n    sampler: SamplerProps;\n  }\n): AsyncTexture {\n  const data = {};\n  FACES.forEach(face => {\n    data[String(face)] = getTextureForFace(face);\n  });\n  return new AsyncTexture(device, {\n    id,\n    dimension: 'cube',\n    mipmaps: false,\n    sampler,\n    // @ts-expect-error\n    data\n  });\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Buffer, PrimitiveTopology} from '@luma.gl/core';\nimport {Geometry, GeometryAttribute, GroupNode, ModelNode, ModelProps} from '@luma.gl/engine';\nimport {Matrix4} from '@math.gl/core';\n\nimport {GLTFAnimator} from './gltf-animator';\nimport {createGLTFModel} from './create-gltf-model';\nimport type {PBREnvironment} from '../pbr/pbr-environment';\nimport {convertGLDrawModeToTopology} from './gl-utils';\n\nexport type GLTFInstantiatorOptions = {\n  modelOptions?: Partial<ModelProps>;\n  pbrDebug?: boolean;\n  imageBasedLightingEnvironment?: PBREnvironment;\n  lights?: boolean;\n  useTangents?: boolean;\n};\n\nconst DEFAULT_OPTIONS: GLTFInstantiatorOptions = {\n  modelOptions: {},\n  pbrDebug: false,\n  imageBasedLightingEnvironment: null,\n  lights: true,\n  useTangents: false\n};\n\n/**\n * GLTF instantiator for luma.gl\n * Walks the parsed and resolved glTF structure and builds a luma.gl scenegraph\n */\nexport class GLTFInstantiator {\n  device: Device;\n  options: GLTFInstantiatorOptions;\n  gltf: any;\n\n  constructor(device: Device, options: GLTFInstantiatorOptions = {}) {\n    this.device = device;\n    this.options = {...DEFAULT_OPTIONS, ...options};\n  }\n\n  instantiate(gltf: any): GroupNode[] {\n    this.gltf = deepCopy(gltf);\n    const scenes = (this.gltf.scenes || []).map(scene => this.createScene(scene));\n    return scenes;\n  }\n\n  createAnimator(): GLTFAnimator {\n    if (Array.isArray(this.gltf.animations)) {\n      return new GLTFAnimator(this.gltf);\n    }\n\n    return null;\n  }\n\n  createScene(gltfScene: any): GroupNode {\n    const gltfNodes = gltfScene.nodes || [];\n    const nodes = gltfNodes.map(node => this.createNode(node));\n    const scene = new GroupNode({\n      id: gltfScene.name || gltfScene.id,\n      children: nodes\n    });\n    return scene;\n  }\n\n  createNode(gltfNode) {\n    if (!gltfNode._node) {\n      const gltfChildren = gltfNode.children || [];\n      const children = gltfChildren.map(child => this.createNode(child));\n\n      // Node can have children nodes and meshes at the same time\n      if (gltfNode.mesh) {\n        children.push(this.createMesh(gltfNode.mesh));\n      }\n\n      const node = new GroupNode({\n        id: gltfNode.name || gltfNode.id,\n        children\n      });\n\n      if (gltfNode.matrix) {\n        node.setMatrix(gltfNode.matrix);\n      } else {\n        node.matrix.identity();\n\n        if (gltfNode.translation) {\n          node.matrix.translate(gltfNode.translation);\n        }\n\n        if (gltfNode.rotation) {\n          const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);\n          node.matrix.multiplyRight(rotationMatrix);\n        }\n\n        if (gltfNode.scale) {\n          node.matrix.scale(gltfNode.scale);\n        }\n      }\n      gltfNode._node = node;\n    }\n\n    // Copy _node so that gltf-animator can access\n    const topLevelNode = this.gltf.nodes.find(node => node.id === gltfNode.id);\n    topLevelNode._node = gltfNode._node;\n\n    return gltfNode._node;\n  }\n\n  createMesh(gltfMesh): GroupNode {\n    // TODO: avoid changing the gltf\n    if (!gltfMesh._mesh) {\n      const gltfPrimitives = gltfMesh.primitives || [];\n      const primitives = gltfPrimitives.map((gltfPrimitive, i) =>\n        this.createPrimitive(gltfPrimitive, i, gltfMesh)\n      );\n      const mesh = new GroupNode({\n        id: gltfMesh.name || gltfMesh.id,\n        children: primitives\n      });\n      gltfMesh._mesh = mesh;\n    }\n\n    return gltfMesh._mesh;\n  }\n\n  createPrimitive(gltfPrimitive: any, i: number, gltfMesh): ModelNode {\n    const id = gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i}`;\n    const topology = convertGLDrawModeToTopology(gltfPrimitive.mode || 4);\n    const vertexCount = gltfPrimitive.indices\n      ? gltfPrimitive.indices.count\n      : this.getVertexCount(gltfPrimitive.attributes);\n\n    const modelNode = createGLTFModel(this.device, {\n      id,\n      geometry: this.createGeometry(id, gltfPrimitive, topology),\n      material: gltfPrimitive.material,\n      materialOptions: this.options,\n      modelOptions: this.options.modelOptions,\n      vertexCount\n    });\n\n    modelNode.bounds = [\n      gltfPrimitive.attributes.POSITION.min,\n      gltfPrimitive.attributes.POSITION.max\n    ];\n    // TODO this holds on to all the CPU side texture and attribute data\n    // modelNode.material =  gltfPrimitive.material;\n\n    return modelNode;\n  }\n\n  getVertexCount(attributes: any) {\n    throw new Error('getVertexCount not implemented');\n  }\n\n  createGeometry(id: string, gltfPrimitive: any, topology: PrimitiveTopology): Geometry {\n    const attributes = {};\n    for (const [attributeName, attribute] of Object.entries(gltfPrimitive.attributes)) {\n      const {components, size, value} = attribute as GeometryAttribute;\n\n      attributes[attributeName] = {size: size ?? components, value};\n    }\n\n    return new Geometry({\n      id,\n      topology,\n      indices: gltfPrimitive.indices.value,\n      attributes\n    });\n  }\n\n  createBuffer(attribute, usage: number): Buffer {\n    if (!attribute.bufferView) {\n      // Draco decoded files do not have a bufferView\n      attribute.bufferView = {};\n    }\n\n    const {bufferView} = attribute;\n    if (!bufferView.lumaBuffers) {\n      bufferView.lumaBuffers = {};\n    }\n\n    if (!bufferView.lumaBuffers[usage]) {\n      bufferView.lumaBuffers[usage] = this.device.createBuffer({\n        id: `from-${bufferView.id}`,\n        // Draco decoded files have attribute.value\n        data: bufferView.data || attribute.value\n      });\n    }\n\n    return bufferView.lumaBuffers[usage];\n  }\n\n  // TODO - create sampler in WebGL2\n  createSampler(gltfSampler) {\n    return gltfSampler;\n  }\n\n  // Helper methods (move to GLTFLoader.resolve...?)\n\n  needsPOT(): boolean {\n    // Has a wrapping mode (either wrapS or wrapT) equal to REPEAT or MIRRORED_REPEAT, or\n    // Has a minification filter (minFilter) that uses mipmapping\n    // (NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR,\n    // LINEAR_MIPMAP_NEAREST, or LINEAR_MIPMAP_LINEAR).\n    return false;\n  }\n}\n\n/** Deeply copies a JS data structure */\nfunction deepCopy(object: any): any {\n  // don't copy binary data\n  if (\n    ArrayBuffer.isView(object) ||\n    object instanceof ArrayBuffer ||\n    object instanceof ImageBitmap\n  ) {\n    return object;\n  }\n  if (Array.isArray(object)) {\n    return object.map(deepCopy);\n  }\n  if (object && typeof object === 'object') {\n    const result = {};\n    for (const key in object) {\n      result[key] = deepCopy(object[key]);\n    }\n    return result;\n  }\n  return object;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log} from '@luma.gl/core';\nimport {Matrix4, Quaternion} from '@math.gl/core';\n\n// TODO: import from loaders.gl?\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\ntype GLTFAnimationProps = {\n  name: string;\n  startTime?: number;\n  playing?: boolean;\n  speed?: number;\n  channels?: any;\n};\n\nclass GLTFAnimation {\n  name: string;\n  startTime: number = 0;\n  playing: boolean = true;\n  speed: number = 1;\n  channels: any = [];\n\n  constructor(props: GLTFAnimationProps) {\n    Object.assign(this, props);\n  }\n\n  animate(timeMs: number) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n\n    this.channels.forEach(({sampler, target, path}) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n}\n\nexport class GLTFAnimator {\n  animations: GLTFAnimation[];\n\n  constructor(gltf: any) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(({input, interpolation = 'LINEAR', output}) => ({\n        input: accessorToJsArray(gltf.accessors[input]),\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      }));\n      const channels = animation.channels.map(({sampler, target}) => ({\n        sampler: samplers[sampler],\n        target: gltf.nodes[target.node],\n        path: target.path\n      }));\n      return new GLTFAnimation({name, channels});\n    });\n  }\n\n  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */\n  animate(time: number): void {\n    this.setTime(time);\n  }\n\n  setTime(time: number): void {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n}\n\n//\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {buffer, byteOffset} = accessor.bufferView.data;\n\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\n// TODO: share with GLTFInstantiator\nconst helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nconst quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    quaternion.slerp({start, target: stop, ratio});\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio: t}) {\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] =\n      (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] +\n      (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 +\n      (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] +\n      (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, {input, interpolation, output}, target, path) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  // assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n\n        cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio});\n      }\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, RenderPipelineParameters, log} from '@luma.gl/core';\nimport {pbrMaterial, ShaderModule} from '@luma.gl/shadertools';\nimport {Geometry, Model, ModelNode, ModelProps} from '@luma.gl/engine';\nimport {ParsePBRMaterialOptions, parsePBRMaterial} from '../pbr/parse-pbr-material';\n\nconst SHADER = /* WGSL */ `\nlayout(0) positions: vec4; // in vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    in vec4 normals; // in vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n@vertex\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * positions;\n  }\n\n@fragment\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n`;\n\n// TODO rename attributes to POSITION/NORMAL etc\n// See gpu-geometry.ts: getAttributeBuffersFromGeometry()\nconst vs = /* glsl */ `\\\n#version 300 es\n\n  // in vec4 POSITION;\n  in vec4 positions;\n\n  #ifdef HAS_NORMALS\n    // in vec4 NORMAL;\n    in vec4 normals;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;\n  }\n`;\n\nconst fs = /* glsl */ `\\\n#version 300 es\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n`;\n\nexport type CreateGLTFModelOptions = {\n  id?: string;\n  vertexCount?: number;\n  geometry: Geometry;\n  material: any;\n  materialOptions: ParsePBRMaterialOptions;\n  modelOptions?: Partial<ModelProps>;\n};\n\nexport function createGLTFModel(device: Device, options: CreateGLTFModelOptions): ModelNode {\n  const {id, geometry, material, vertexCount, materialOptions, modelOptions} = options;\n\n  const parsedMaterial = parsePBRMaterial(device, material, geometry.attributes, materialOptions);\n  log.info(4, 'createGLTFModel defines: ', parsedMaterial.defines)();\n\n  // Calculate managedResources\n  // TODO: Implement resource management logic that will\n  // not deallocate resources/textures/buffers that are shared\n  const managedResources = [];\n  // managedResources.push(...parsedMaterial.generatedTextures);\n  // managedResources.push(...Object.values(attributes).map((attribute) => attribute.buffer));\n\n  const parameters: RenderPipelineParameters = {\n    depthWriteEnabled: true,\n    depthCompare: 'less',\n    depthFormat: 'depth24plus',\n    cullMode: 'back'\n  };\n\n  const modelProps: ModelProps = {\n    id,\n    source: SHADER,\n    vs,\n    fs,\n    geometry,\n    topology: geometry.topology,\n    vertexCount,\n    modules: [pbrMaterial as unknown as ShaderModule],\n    ...modelOptions,\n\n    defines: {...parsedMaterial.defines, ...modelOptions.defines},\n    parameters: {...parameters, ...parsedMaterial.parameters, ...modelOptions.parameters}\n  };\n\n  const model = new Model(device, modelProps);\n\n  const {camera, ...pbrMaterialProps} = {\n    ...parsedMaterial.uniforms,\n    ...modelOptions.uniforms,\n    ...parsedMaterial.bindings,\n    ...modelOptions.bindings\n  };\n\n  model.shaderInputs.setProps({pbrMaterial: pbrMaterialProps, pbrProjection: {camera}});\n  return new ModelNode({managedResources, model});\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {PrimitiveTopology} from '@luma.gl/core';\n\n// NOTE: Modules other than `@luma.gl/webgl` should not import `GL` from\n// `@luma.gl/constants`. Locally we use `GLEnum` instead of `GL` to avoid\n// conflicts with the `babel-plugin-inline-webgl-constants` plugin.\n// eslint-disable-next-line no-shadow\nexport enum GLEnum {\n  POINTS = 0x0,\n  LINES = 0x1,\n  LINE_LOOP = 0x2,\n  LINE_STRIP = 0x3,\n  TRIANGLES = 0x4,\n  TRIANGLE_STRIP = 0x5,\n  TRIANGLE_FAN = 0x6\n}\n\nexport function convertGLDrawModeToTopology(\n  drawMode:\n    | GLEnum.POINTS\n    | GLEnum.LINES\n    | GLEnum.LINE_STRIP\n    | GLEnum.LINE_LOOP\n    | GLEnum.TRIANGLES\n    | GLEnum.TRIANGLE_STRIP\n    | GLEnum.TRIANGLE_FAN\n): PrimitiveTopology {\n  // prettier-ignore\n  switch (drawMode) {\n    case GLEnum.POINTS: return 'point-list';\n    case GLEnum.LINES: return 'line-list';\n    case GLEnum.LINE_STRIP: return 'line-strip';\n    case GLEnum.TRIANGLES: return 'triangle-list';\n    case GLEnum.TRIANGLE_STRIP: return 'triangle-strip';\n    default: throw new Error(String(drawMode));\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device} from '@luma.gl/core';\nimport {GroupNode} from '@luma.gl/engine';\nimport {GLTFInstantiator, GLTFInstantiatorOptions} from './gltf-instantiator';\nimport {GLTFAnimator} from './gltf-animator';\n\nexport function createScenegraphsFromGLTF(\n  device: Device,\n  gltf: any,\n  options?: GLTFInstantiatorOptions\n): {\n  scenes: GroupNode[];\n  animator: GLTFAnimator;\n} {\n  const instantiator = new GLTFInstantiator(device, options);\n  const scenes = instantiator.instantiate(gltf);\n  const animator = instantiator.createAnimator();\n  return {scenes, animator};\n}\n"],
  "mappings": "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",
  "names": ["GLEnum", "import_engine", "import_core", "import_core", "import_core", "import_engine", "GLEnum"]
}
