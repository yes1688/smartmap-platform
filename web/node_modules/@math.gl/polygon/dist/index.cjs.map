{
  "version": 3,
  "sources": ["../src/index.ts", "../src/polygon.ts", "../src/polygon-utils.ts", "../src/earcut.ts", "../src/utils.ts", "../src/lineclip.ts", "../src/cut-by-grid.ts", "../src/cut-by-mercator-bounds.ts"],
  "sourcesContent": ["// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport {Polygon} from './polygon';\n\nexport {\n  getPolygonSignedArea,\n  getPolygonWindingDirection,\n  forEachSegmentInPolygon,\n  modifyPolygonWindingDirection,\n  WINDING\n} from './polygon-utils';\n\nexport {earcut} from './earcut';\n\nexport {clipPolygon, clipPolyline} from './lineclip';\n\nexport {cutPolygonByGrid, cutPolylineByGrid} from './cut-by-grid';\n\nexport {cutPolylineByMercatorBounds, cutPolygonByMercatorBounds} from './cut-by-mercator-bounds';\n\n/** @deprecated */\nexport {Polygon as _Polygon} from './polygon';\n", "// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable no-undef, no-console */\nimport {isArray} from '@math.gl/core';\nimport type {SegmentVisitorPoints} from './polygon-utils';\nimport type {NumericArray} from '@math.gl/core';\n\nimport {\n  getPolygonSignedArea,\n  forEachSegmentInPolygon,\n  modifyPolygonWindingDirection,\n  getPolygonSignedAreaPoints,\n  forEachSegmentInPolygonPoints,\n  modifyPolygonWindingDirectionPoints\n} from './polygon-utils';\n\nexport type PolygonOptions = {\n  start?: number;\n  end?: number;\n  size?: number;\n  isClosed?: boolean;\n};\n\nexport class Polygon {\n  points: NumericArray | number[][];\n  isFlatArray: boolean;\n  options: PolygonOptions;\n\n  constructor(points: NumericArray | number[][], options: PolygonOptions = {}) {\n    this.points = points;\n    this.isFlatArray = !isArray(points[0]);\n\n    this.options = {\n      start: options.start || 0,\n      end: options.end || points.length,\n      size: options.size || 2,\n      isClosed: options.isClosed\n    };\n\n    Object.freeze(this);\n  }\n\n  /**\n   * Returns signed area of the polygon.\n   * @returns Signed area of the polygon.\n   */\n  getSignedArea(): number {\n    if (this.isFlatArray) return getPolygonSignedArea(this.points as NumericArray, this.options);\n\n    return getPolygonSignedAreaPoints(this.points as number[][], this.options);\n  }\n\n  /**\n   * Returns absolute area of the polygon.\n   * @returns Absolute area of the polygon.\n   */\n  getArea(): number {\n    return Math.abs(this.getSignedArea());\n  }\n\n  /**\n   * Returns winding direction of the polygon.\n   * @returns Winding direction of the polygon. 1 is for clockwise, -1 for counterclockwise winding direction.\n   */\n  getWindingDirection(): number {\n    return Math.sign(this.getSignedArea());\n  }\n\n  /**\n   * Calls the visitor callback for each segment in the polygon.\n   * @param visitor A callback to call for each segment.\n   */\n  forEachSegment(visitor: SegmentVisitorPoints): void {\n    if (this.isFlatArray) {\n      forEachSegmentInPolygon(\n        this.points as NumericArray,\n        // eslint-disable-next-line max-params\n        (x1, y1, x2, y2, i1, i2) => {\n          // TODO @igorDykhta original visitor uses arrays for each point, but with flat arrays performance degrades if we allocate points for each segment\n          visitor([x1, y1], [x2, y2], i1, i2);\n        },\n        this.options\n      );\n    } else {\n      forEachSegmentInPolygonPoints(this.points as number[][], visitor, this.options);\n    }\n  }\n\n  /**\n   * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n   * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n   * @return Returns true if the winding direction was changed.\n   */\n  modifyWindingDirection(direction: number): boolean {\n    if (this.isFlatArray) {\n      return modifyPolygonWindingDirection(this.points as NumericArray, direction, this.options);\n    }\n    return modifyPolygonWindingDirectionPoints(this.points as number[][], direction, this.options);\n  }\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT and ISC\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\n\nimport {equals} from '@math.gl/core';\nimport type {NumericArray} from '@math.gl/core';\n\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n} as const;\n\n/** Polygon representation where each point is represented as a separate array of positions. */\ntype PointsArray = NumericArray[];\n\n/** Segment visitor callback type for polygons defined with flat arrays, */\ntype SegmentVisitorFlat = (\n  p1x: number,\n  p1y: number,\n  p2x: number,\n  p2y: number,\n  i1: number,\n  i2: number\n) => void;\n\n/** Segment visitor callback type for polygons defined with array of points. */\nexport type SegmentVisitorPoints = (\n  p1: NumericArray,\n  p2: NumericArray,\n  i1: number,\n  i2: number\n) => void;\n\nexport type Plane2D = 'xy' | 'yz' | 'xz';\n\n/** Parameters of a polygon. */\ntype PolygonParams = {\n  /**\n   * Start index of the polygon in the array of positions.\n   * @default `0`\n   */\n  start?: number;\n  /**\n   * End index of the polygon in the array of positions.\n   * @default number of positions\n   */\n  end?: number;\n  /**\n   * Size of a point, 2 (XZ) or 3 (XYZ). Affects only polygons stored in flat arrays.\n   * @default `2`\n   */\n  size?: number;\n  /**\n   * Indicates that the first point of the polygon is equal to the last point, and additional checks should be ommited.\n   */\n  isClosed?: boolean;\n  /**\n   * The 2D projection plane on which to calculate the area of a 3D polygon.\n   * @default `'xy'`\n   */\n  plane?: Plane2D;\n};\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points An array that represents points of the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirection(\n  points: NumericArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const windingDirection = getPolygonWindingDirection(points, options);\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirection(\n  points: NumericArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\n\nexport const DimIndex: Record<string, number> = {\n  x: 0,\n  y: 1,\n  z: 2\n} as const;\n\n/**\n * Returns signed area of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n * https://en.wikipedia.org/wiki/Shoelace_formula\n */\nexport function getPolygonSignedArea(points: NumericArray, options: PolygonParams = {}): number {\n  const {start = 0, end = points.length, plane = 'xy'} = options;\n  const dim = options.size || 2;\n  let area = 0;\n  const i0 = DimIndex[plane[0]];\n  const i1 = DimIndex[plane[1]];\n\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i + i0] - points[j + i0]) * (points[i + i1] + points[j + i1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls the visitor callback for each segment in the polygon.\n * @param points An array that represents points of the polygon\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygon(\n  points: NumericArray,\n  visitor: SegmentVisitorFlat,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, size = 2, isClosed} = options;\n\n  const numPoints = (end - start) / size;\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(\n      points[start + i * size],\n      points[start + i * size + 1],\n      points[start + (i + 1) * size],\n      points[start + (i + 1) * size + 1],\n      i,\n      i + 1\n    );\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx =\n    isClosed ||\n    (equals(points[start], points[endPointIndex]) &&\n      equals(points[start + 1], points[endPointIndex + 1]));\n\n  if (!isClosedEx) {\n    visitor(\n      points[endPointIndex],\n      points[endPointIndex + 1],\n      points[start],\n      points[start + 1],\n      numPoints - 1,\n      0\n    );\n  }\n}\n\nfunction reversePolygon(\n  points: NumericArray,\n  options: {start?: number; end?: number; size?: number}\n): void {\n  const {start = 0, end = points.length, size = 2} = options;\n\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points Array of points that represent the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirectionPoints(\n  points: PointsArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirectionPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\n\n/**\n * Returns signed area of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n */\nexport function getPolygonSignedAreaPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  // https://en.wikipedia.org/wiki/Shoelace_formula\n  const {start = 0, end = points.length, plane = 'xy'} = options;\n  let area = 0;\n  const i0 = DimIndex[plane[0]];\n  const i1 = DimIndex[plane[1]];\n\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][i0] - points[j][i0]) * (points[i][i1] + points[j][i1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls visitor callback for each segment in the polygon.\n * @param points Array of points that represent the polygon.\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygonPoints(\n  points: PointsArray,\n  visitor: SegmentVisitorPoints,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, isClosed} = options;\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT and ISC\n// Copyright (c) vis.gl contributors\n\n/*\n  Adapted from https://github.com/mapbox/earcut to allow passing in\n  of outline and hole areas using the `areas` parameter. As the\n  areas are calcuted as part of classifying the polygon rings\n  we can pass them in again to avoid recomputation\n\n  ISC License\n\n  Copyright (c) 2016, Mapbox\n\n  Permission to use, copy, modify, and/or distribute this software for any purpose\n  with or without fee is hereby granted, provided that the above copyright notice\n  and this permission notice appear in all copies.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n  THIS SOFTWARE.\n\n */\n\n// @ts-nocheck\n\n/* eslint-disable */\n\nimport type {NumericArray} from '@math.gl/core';\nimport {getPolygonSignedArea, DimIndex, Plane2D} from './polygon-utils';\n\n/**\n * Computes a triangulation of a polygon\n * @param positions a flat array of the vertex positions that define the polygon.\n * @param holeIndices an array of hole indices if any (e.g. [5, 8] for a 12-vertex input would mean one hole with vertices 5\u20137 and another with 8\u201311).\n * @param dim the number of elements in each vertex. Size `2` will interpret `positions` as `[x0, y0, x1, y1, ...]` and size `3` will interpret `positions` as `[x0, y0, z0, x1, y1, z1, ...]`. Default `2`.\n * @param areas areas of outer polygon and holes as computed by `getPolygonSignedArea()`. Can be optionally supplied to speed up triangulation\n * @returns array of indices into the `positions` array that describes the triangulation of the polygon\n * Adapted from https://github.com/mapbox/earcut\n */\nexport function earcut(\n  positions: NumericArray,\n  holeIndices?: NumericArray,\n  dim: number = 2,\n  areas?: NumericArray,\n  plane: Plane2D = 'xy'\n): number[] {\n  const hasHoles = holeIndices && holeIndices.length;\n  const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;\n  let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0], plane);\n  const triangles = [];\n\n  if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n  let invSize;\n  let maxX;\n  let maxY;\n  let minX;\n  let minY;\n  let x;\n  let y;\n\n  if (hasHoles) outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas, plane);\n\n  // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n  if (positions.length > 80 * dim) {\n    minX = maxX = positions[0];\n    minY = maxY = positions[1];\n\n    for (let i = dim; i < outerLen; i += dim) {\n      x = positions[i];\n      y = positions[i + 1];\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n    }\n\n    // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n    invSize = Math.max(maxX - minX, maxY - minY);\n    invSize = invSize !== 0 ? 32767 / invSize : 0;\n  }\n\n  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n  return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(\n  data: NumericArray,\n  start: number,\n  end: number,\n  dim: number,\n  clockwise: boolean,\n  area: number | undefined,\n  plane: Plane2D\n): Vertex {\n  let i;\n  let last;\n  if (area === undefined) {\n    area = getPolygonSignedArea(data, {start, end, size: dim, plane});\n  }\n\n  let i0 = DimIndex[plane[0]];\n  let i1 = DimIndex[plane[1]];\n  // Note that the signed area calculation in math.gl\n  // has the opposite sign to that which was originally\n  // present in earcut, thus the `< 0` is reversed\n  if (clockwise === area < 0) {\n    for (i = start; i < end; i += dim) last = insertNode(i, data[i + i0], data[i + i1], last);\n  } else {\n    for (i = end - dim; i >= start; i -= dim)\n      last = insertNode(i, data[i + i0], data[i + i1], last);\n  }\n\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n\n  return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end?) {\n  if (!start) return start;\n  if (!end) end = start;\n\n  let p = start;\n  let again;\n  do {\n    again = false;\n\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n\n  return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass?) {\n  if (!ear) return;\n\n  // interlink polygon nodes in z-order\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n  let stop = ear;\n  let prev;\n  let next;\n\n  // iterate through ears, slicing them one by one\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      // cut off the triangle\n      triangles.push((prev.i / dim) | 0);\n      triangles.push((ear.i / dim) | 0);\n      triangles.push((next.i / dim) | 0);\n\n      removeNode(ear);\n\n      // skipping the next vertex leads to less sliver triangles\n      ear = next.next;\n      stop = next.next;\n\n      continue;\n    }\n\n    ear = next;\n\n    // if we looped through the whole remaining polygon and can't find any more ears\n    if (ear === stop) {\n      // try filtering points and slicing again\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n        // if this didn't work, try curing all small self-intersections locally\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n        // as a last resort, try splitting the remaining polygon into two\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n\n      break;\n    }\n  }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  // now make sure we don't have other points inside the potential ear\n  const ax = a.x;\n  const bx = b.x;\n  const cx = c.x;\n  const ay = a.y;\n  const by = b.y;\n  const cy = c.y;\n\n  // triangle bbox; min & max are calculated like this for speed\n  const x0 = ax < bx ? (ax < cx ? ax : cx) : bx < cx ? bx : cx;\n  const y0 = ay < by ? (ay < cy ? ay : cy) : by < cy ? by : cy;\n  const x1 = ax > bx ? (ax > cx ? ax : cx) : bx > cx ? bx : cx;\n  const y1 = ay > by ? (ay > cy ? ay : cy) : by > cy ? by : cy;\n\n  let p = c.next;\n  while (p !== a) {\n    if (\n      p.x >= x0 &&\n      p.x <= x1 &&\n      p.y >= y0 &&\n      p.y <= y1 &&\n      pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n      area(p.prev, p, p.next) >= 0\n    )\n      return false;\n    p = p.next;\n  }\n\n  return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  const ax = a.x;\n  const bx = b.x;\n  const cx = c.x;\n  const ay = a.y;\n  const by = b.y;\n  const cy = c.y;\n\n  // triangle bbox; min & max are calculated like this for speed\n  const x0 = ax < bx ? (ax < cx ? ax : cx) : bx < cx ? bx : cx;\n  const y0 = ay < by ? (ay < cy ? ay : cy) : by < cy ? by : cy;\n  const x1 = ax > bx ? (ax > cx ? ax : cx) : bx > cx ? bx : cx;\n  const y1 = ay > by ? (ay > cy ? ay : cy) : by > cy ? by : cy;\n\n  // z-order range for the current triangle bbox;\n  const minZ = zOrder(x0, y0, minX, minY, invSize);\n  const maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n  let p = ear.prevZ;\n  let n = ear.nextZ;\n\n  // look for points inside the triangle in both directions\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (\n      p.x >= x0 &&\n      p.x <= x1 &&\n      p.y >= y0 &&\n      p.y <= y1 &&\n      p !== a &&\n      p !== c &&\n      pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n      area(p.prev, p, p.next) >= 0\n    )\n      return false;\n    p = p.prevZ;\n\n    if (\n      n.x >= x0 &&\n      n.x <= x1 &&\n      n.y >= y0 &&\n      n.y <= y1 &&\n      n !== a &&\n      n !== c &&\n      pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) &&\n      area(n.prev, n, n.next) >= 0\n    )\n      return false;\n    n = n.nextZ;\n  }\n\n  // look for remaining points in decreasing z-order\n  while (p && p.z >= minZ) {\n    if (\n      p.x >= x0 &&\n      p.x <= x1 &&\n      p.y >= y0 &&\n      p.y <= y1 &&\n      p !== a &&\n      p !== c &&\n      pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n      area(p.prev, p, p.next) >= 0\n    )\n      return false;\n    p = p.prevZ;\n  }\n\n  // look for remaining points in increasing z-order\n  while (n && n.z <= maxZ) {\n    if (\n      n.x >= x0 &&\n      n.x <= x1 &&\n      n.y >= y0 &&\n      n.y <= y1 &&\n      n !== a &&\n      n !== c &&\n      pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) &&\n      area(n.prev, n, n.next) >= 0\n    )\n      return false;\n    n = n.nextZ;\n  }\n\n  return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n  let p = start;\n  do {\n    const a = p.prev;\n    const b = p.next.next;\n\n    if (\n      !equals(a, b) &&\n      intersects(a, p, p.next, b) &&\n      locallyInside(a, b) &&\n      locallyInside(b, a)\n    ) {\n      triangles.push((a.i / dim) | 0);\n      triangles.push((p.i / dim) | 0);\n      triangles.push((b.i / dim) | 0);\n\n      // remove two nodes involved\n      removeNode(p);\n      removeNode(p.next);\n\n      p = start = b;\n    }\n    p = p.next;\n  } while (p !== start);\n\n  return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  // look for a valid diagonal that divides the polygon into two\n  let a = start;\n  do {\n    let b = a.next.next;\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        // split the polygon in two by the diagonal\n        let c = splitPolygon(a, b);\n\n        // filter colinear points around the cuts\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next);\n\n        // run earcut on each half\n        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n        return;\n      }\n      b = b.next;\n    }\n    a = a.next;\n  } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(\n  data: NumericArray,\n  holeIndices: NumericArray,\n  outerNode: Vertex,\n  dim: number,\n  areas: NumericArray | undefined,\n  plane: Plane2D\n): Vertex {\n  const queue = [];\n  let i;\n  let len;\n  let start;\n  let end;\n  let list;\n\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false, areas && areas[i + 1], plane);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n\n  queue.sort(compareX);\n\n  // process holes from left to right\n  for (i = 0; i < queue.length; i++) {\n    outerNode = eliminateHole(queue[i], outerNode);\n  }\n\n  return outerNode;\n}\n\nfunction compareX(a, b) {\n  return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n  const bridge = findHoleBridge(hole, outerNode);\n  if (!bridge) {\n    return outerNode;\n  }\n\n  const bridgeReverse = splitPolygon(bridge, hole);\n\n  // filter collinear points around the cuts\n  filterPoints(bridgeReverse, bridgeReverse.next);\n  return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode;\n  const hx = hole.x;\n  const hy = hole.y;\n  let qx = -Infinity;\n  let m;\n\n  // find a segment intersected by a ray from the hole's leftmost point to the left;\n  // segment's endpoint with lesser x will be potential connection point\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + ((hy - p.y) * (p.next.x - p.x)) / (p.next.y - p.y);\n      if (x <= hx && x > qx) {\n        qx = x;\n        m = p.x < p.next.x ? p : p.next;\n        if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n      }\n    }\n    p = p.next;\n  } while (p !== outerNode);\n\n  if (!m) return null;\n\n  // look for points inside the triangle of hole point, segment intersection and endpoint;\n  // if there are no points found, we have a valid connection;\n  // otherwise choose the point of the minimum angle with the ray as connection point\n\n  const stop = m;\n  const mx = m.x;\n  const my = m.y;\n  let tanMin = Infinity;\n  let tan;\n\n  p = m;\n\n  do {\n    if (\n      hx >= p.x &&\n      p.x >= mx &&\n      hx !== p.x &&\n      pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)\n    ) {\n      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n      if (\n        locallyInside(p, hole) &&\n        (tan < tanMin ||\n          (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))\n      ) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n\n    p = p.next;\n  } while (p !== stop);\n\n  return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n  do {\n    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n\n  sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n  let e;\n  let i;\n  let inSize = 1;\n  let numMerges;\n  let p;\n  let pSize;\n  let q;\n  let qSize;\n  let tail;\n\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n      qSize = inSize;\n\n      while (pSize > 0 || (qSize > 0 && q)) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n\n        if (tail) tail.nextZ = e;\n        else list = e;\n\n        e.prevZ = tail;\n        tail = e;\n      }\n\n      p = q;\n    }\n\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n\n  return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n  // coords are transformed into non-negative 15-bit integer range\n  x = ((x - minX) * invSize) | 0;\n  y = ((y - minY) * invSize) | 0;\n\n  x = (x | (x << 8)) & 0x00ff00ff;\n  x = (x | (x << 4)) & 0x0f0f0f0f;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y = (y | (y << 8)) & 0x00ff00ff;\n  y = (y | (y << 4)) & 0x0f0f0f0f;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n  let p = start;\n  let leftmost = start;\n  do {\n    if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n\n  return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (\n    (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n    (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n    (bx - px) * (cy - py) >= (cx - px) * (by - py)\n  );\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n  return (\n    a.next.i !== b.i &&\n    a.prev.i !== b.i &&\n    !intersectsPolygon(a, b) && // dones't intersect other edges\n    ((locallyInside(a, b) &&\n      locallyInside(b, a) &&\n      middleInside(a, b) && // locally visible\n      (area(a.prev, a, b.prev) || area(a, b.prev, b))) || // does not create opposite-facing sectors\n      (equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0))\n  ); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(area(p1, q1, p2));\n  const o2 = sign(area(p1, q1, q2));\n  const o3 = sign(area(p2, q2, p1));\n  const o4 = sign(area(p2, q2, q1));\n\n  if (o1 !== o2 && o3 !== o4) return true; // general case\n\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n  return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n  return (\n    q.x <= Math.max(p.x, r.x) &&\n    q.x >= Math.min(p.x, r.x) &&\n    q.y <= Math.max(p.y, r.y) &&\n    q.y >= Math.min(p.y, r.y)\n  );\n}\n\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n  let p = a;\n  do {\n    if (\n      p.i !== a.i &&\n      p.next.i !== a.i &&\n      p.i !== b.i &&\n      p.next.i !== b.i &&\n      intersects(p, p.next, a, b)\n    )\n      return true;\n    p = p.next;\n  } while (p !== a);\n\n  return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0\n    ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0\n    : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n  let p = a;\n  let inside = false;\n  const px = (a.x + b.x) / 2;\n  const py = (a.y + b.y) / 2;\n  do {\n    if (\n      p.y > py !== p.next.y > py &&\n      p.next.y !== p.y &&\n      px < ((p.next.x - p.x) * (py - p.y)) / (p.next.y - p.y) + p.x\n    )\n      inside = !inside;\n    p = p.next;\n  } while (p !== a);\n\n  return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n  const a2 = new Vertex(a.i, a.x, a.y);\n  const b2 = new Vertex(b.i, b.x, b.y);\n  const an = a.next;\n  const bp = b.prev;\n\n  a.next = b;\n  b.prev = a;\n\n  a2.next = an;\n  an.prev = a2;\n\n  b2.next = a2;\n  a2.prev = b2;\n\n  bp.next = b2;\n  b2.prev = bp;\n\n  return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n  const p = new Vertex(i, x, y);\n\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n  return p;\n}\n\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nclass Vertex {\n  // vertex index in coordinates array\n  i: number;\n\n  // vertex coordinates\n  x: number;\n  y: number;\n\n  // previous and next vertex nodes in a polygon ring\n  prev: Vertex = null;\n  next: Vertex = null;\n\n  // z-order curve value\n  z: number = 0;\n\n  // previous and next nodes in z-order\n  prevZ: Vertex = null;\n  nextZ: Vertex = null;\n\n  // indicates whether this is a steiner point\n  steiner: boolean = false;\n\n  constructor(i: number, x: number, y: number) {\n    this.i = i;\n    this.x = x;\n    this.y = y;\n  }\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumericArray} from '@math.gl/core';\n\nexport function push(target: number[], source: number[]): boolean {\n  const size = source.length;\n  const startIndex = target.length;\n\n  // dedupe, if source is the same point as the last vertex\n  if (startIndex > 0) {\n    let isDuplicate = true;\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n  return true;\n}\n\nexport function copy(target: number[], source: Readonly<NumericArray>): void {\n  const size = source.length;\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\n\nexport function getPointAtIndex(\n  positions: Readonly<NumericArray>,\n  index: number,\n  size: number,\n  offset: number,\n  out: number[] = []\n): number[] {\n  const startI = offset + index * size;\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n  return out;\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT and ISC\n// Copyright (c) vis.gl contributors\n\n/*\n  Adapted from https://github.com/mapbox/lineclip to work with flat arrays\n  and 3d positions\n\n  ISC License\n\n  Copyright (c) 2015, Mapbox\n\n  Permission to use, copy, modify, and/or distribute this software for any purpose\n  with or without fee is hereby granted, provided that the above copyright notice\n  and this permission notice appear in all copies.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n  THIS SOFTWARE.\n\n */\n\n/* eslint-disable max-statements, max-depth, complexity */\n\nimport {push, copy, getPointAtIndex} from './utils';\nimport type {NumericArray} from '@math.gl/core';\n\nexport type BoundingBox = [number, number, number, number];\n\n/**\n * Cohen-Sutherland line clipping algorithm, adapted to efficiently\n * handle polylines rather than just segments\n */\nexport function clipPolyline(\n  positions: Readonly<NumericArray>,\n  bbox: BoundingBox,\n  options?: {\n    size?: number;\n    startIndex?: number;\n    endIndex?: number;\n  }\n): number[][] {\n  const {size = 2, startIndex = 0, endIndex = positions.length} = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  const result: number[][] = [];\n  let part: number[] = [];\n  let a: number[];\n  let b: number[];\n  let codeA: number = -1;\n  let codeB: number;\n  let lastCode: number;\n\n  for (let i = 1; i < numPoints; i++) {\n    a = getPointAtIndex(positions, i - 1, size, startIndex, a);\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    if (codeA < 0) {\n      codeA = bitCode(a, bbox);\n    }\n    codeB = lastCode = bitCode(b, bbox);\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (!(codeA | codeB)) {\n        // accept\n        push(part, a);\n\n        if (codeB !== lastCode) {\n          // segment went outside\n          push(part, b);\n\n          if (i < numPoints - 1) {\n            // start a new line\n            result.push(part);\n            part = [];\n          }\n        } else if (i === numPoints - 1) {\n          push(part, b);\n        }\n        break;\n      } else if (codeA & codeB) {\n        // trivial reject\n        break;\n      } else if (codeA) {\n        // a outside, intersect with clip edge\n        intersect(a, b, codeA, bbox, a);\n        codeA = bitCode(a, bbox);\n      } else {\n        // b outside\n        intersect(a, b, codeB, bbox, b);\n        codeB = bitCode(b, bbox);\n      }\n    }\n\n    codeA = lastCode;\n  }\n\n  if (part.length) result.push(part);\n\n  return result;\n}\n\n/**\n * Sutherland-Hodgeman polygon clipping algorithm\n * polygon must be closed (first vertex == last vertex)\n */\nexport function clipPolygon(\n  positions: Readonly<NumericArray>,\n  bbox: BoundingBox,\n  options?: {\n    size?: number;\n    startIndex?: number;\n    endIndex?: number;\n  }\n): number[] {\n  const {size = 2, endIndex = positions.length} = options || {};\n  let {startIndex = 0} = options || {};\n  let numPoints = (endIndex - startIndex) / size;\n  let result: number[];\n  let p: number[];\n  let prev: number[];\n  let inside: boolean;\n  let prevInside: boolean;\n\n  // clip against each side of the clip rectangle\n  for (let edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = getPointAtIndex(positions, numPoints - 1, size, startIndex, prev);\n    prevInside = !(bitCode(prev, bbox) & edge);\n\n    for (let i = 0; i < numPoints; i++) {\n      p = getPointAtIndex(positions, i, size, startIndex, p);\n      inside = !(bitCode(p, bbox) & edge);\n\n      // if segment goes through the clip window, add an intersection\n      if (inside !== prevInside) push(result, intersect(prev, p, edge, bbox));\n\n      if (inside) push(result, p); // add a point if it's inside\n\n      copy(prev, p);\n      prevInside = inside;\n    }\n\n    // close loop\n    positions = result;\n    startIndex = 0;\n    numPoints = result.length / size;\n\n    if (!numPoints) break;\n  }\n\n  return result;\n}\n\n/** intersect a segment against one of the 4 lines that make up the bbox */\n\nexport function intersect(\n  a: number[],\n  b: number[],\n  edge: number,\n  bbox: BoundingBox,\n  out: number[] = []\n): number[] {\n  let t;\n  // Forces out[snapI] to be on the bbox edge\n  // Interpolation introduces precision issue which may cause lineclip to be\n  // stuck in an infinite loop\n  let snap: number;\n  if (edge & 8) {\n    // top\n    t = (bbox[3] - a[1]) / (b[1] - a[1]);\n    snap = 3;\n  } else if (edge & 4) {\n    // bottom\n    t = (bbox[1] - a[1]) / (b[1] - a[1]);\n    snap = 1;\n  } else if (edge & 2) {\n    // right\n    t = (bbox[2] - a[0]) / (b[0] - a[0]);\n    snap = 2;\n  } else if (edge & 1) {\n    // left\n    t = (bbox[0] - a[0]) / (b[0] - a[0]);\n    snap = 0;\n  } else {\n    return null;\n  }\n  for (let i = 0; i < a.length; i++) {\n    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];\n  }\n  return out;\n}\n\n/**\n * bit code reflects the point position relative to the bbox:\n *         left  mid  right\n *    top  1001  1000  1010\n *    mid  0001  0000  0010\n * bottom  0101  0100  0110\n */\nexport function bitCode(p: number[], bbox: BoundingBox): number {\n  let code = 0;\n\n  if (p[0] < bbox[0]) code |= 1;\n  // left\n  else if (p[0] > bbox[2]) code |= 2; // right\n\n  if (p[1] < bbox[1]) code |= 4;\n  // bottom\n  else if (p[1] > bbox[3]) code |= 8; // top\n\n  return code;\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\nimport {bitCode, intersect, BoundingBox} from './lineclip';\nimport {getPointAtIndex, copy, push} from './utils';\n\nimport type {NumericArray} from '@math.gl/core';\n\nexport type Polygon = {\n  positions: Readonly<NumericArray>;\n  holeIndices?: Readonly<NumericArray>;\n  edgeTypes?: Readonly<NumericArray>;\n};\n\nexport function cutPolylineByGrid(\n  positions: NumericArray,\n  options?: {\n    size?: number;\n    broken?: boolean;\n    gridResolution?: number;\n    gridOffset?: [number, number];\n    startIndex?: number;\n    endIndex?: number;\n  }\n): number[] | number[][] {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  let part: number[] = [];\n  const result: number[][] = [part];\n  const a: number[] = getPointAtIndex(positions, 0, size, startIndex);\n  let b: number[];\n  let codeB: number;\n  const cell: BoundingBox = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint: number[] = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      // find the intersection with the current cell\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n      push(part, scratchPoint);\n      // move to the next cell\n      copy(a, scratchPoint);\n\n      moveToNeighborCell(cell, gridResolution, codeB);\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\n\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\n/** Internal helper type during cutting, name TBD */\ntype PolygonCut = {\n  pos: Readonly<NumericArray>;\n  types: number[];\n  holes: Readonly<NumericArray>;\n};\n\n/** Internal helper type during cutting, name TBD */\ntype MutablePolygonCut = {\n  pos: number[];\n  types: number[];\n  holes: number[];\n};\n\n/**\n * Cuts a polygon by a pre-defined grid\n */\nexport function cutPolygonByGrid(\n  positions: Readonly<NumericArray>,\n  holeIndices: Readonly<NumericArray> | null = null,\n  options?: {\n    size?: number;\n    gridResolution?: number;\n    gridOffset?: [number, number];\n    edgeTypes?: boolean;\n  }\n): Polygon[] {\n  if (!positions.length) {\n    // input is empty\n    return [];\n  }\n  const {size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false} = options || {};\n  const result: Polygon[] = [];\n  const queue: PolygonCut[] = [\n    {\n      pos: positions,\n      types: edgeTypes ? (new Array(positions.length / size).fill(TYPE_BORDER) as number[]) : null,\n      holes: holeIndices || []\n    }\n  ];\n  const bbox: number[][] = [[], []];\n  // @ts-ignore\n  let cell: BoundingBox = [];\n\n  // Recursively bisect polygon until every part fit in a single grid cell\n  while (queue.length) {\n    const {pos, types, holes} = queue.shift();\n\n    // Get the bounding box of the outer polygon\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      // Split the outer ring at the boundary\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow: MutablePolygonCut = {pos: parts[0].pos, types: parts[0].types, holes: []};\n      const polygonHigh: MutablePolygonCut = {pos: parts[1].pos, types: parts[1].types, holes: []};\n      queue.push(polygonLow, polygonHigh);\n\n      // Split each hole at the boundary\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      // Polygon fits in a single cell, no more processing required\n      const polygon: Polygon = {positions: pos};\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n  return result;\n}\n\n// edgeTypes:\n// TYPE_BORDER - edge from the original polygon\n// TYPE_INSIDE - inside the original polygon\n// eslint-disable-next-line max-params\nfunction bisectPolygon(\n  positions: Readonly<NumericArray>,\n  edgeTypes: number[] | undefined,\n  size: number,\n  startIndex: number,\n  endIndex: number,\n  bbox: BoundingBox,\n  edge: number\n): {\n  pos: number[];\n  types?: number[];\n}[] {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow: number[] = [];\n  const resultHigh: number[] = [];\n  const typesLow: number[] = [];\n  const typesHigh: number[] = [];\n  const scratchPoint: number[] = [];\n\n  let p: number[];\n  let side: number;\n  let type: number;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    // if segment goes through the boundary, add an intersection\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [\n    lowPointCount ? {pos: resultLow, types: edgeTypes && typesLow} : null,\n    highPointCount ? {pos: resultHigh, types: edgeTypes && typesHigh} : null\n  ];\n}\n\nfunction getGridCell(\n  p: number[],\n  gridResolution: number,\n  gridOffset: [number, number],\n  out: number[]\n): BoundingBox {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom =\n    Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out as BoundingBox;\n}\n\nfunction moveToNeighborCell(cell: number[], gridResolution: number, edge: number): void {\n  if (edge & 8) {\n    // top\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    // bottom\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    // right\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    // left\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(\n  positions: Readonly<NumericArray>,\n  size: number,\n  endIndex: number,\n  out: number[][]\n): number[][] {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n\nfunction concatInPlace(arr1: number[], arr2: number[]): number[] {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n  return arr1;\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {cutPolylineByGrid, cutPolygonByGrid} from './cut-by-grid';\nimport {getPointAtIndex, push} from './utils';\nimport type {Polygon} from './cut-by-grid';\nimport type {NumericArray} from '@math.gl/core';\n\n// https://en.wikipedia.org/wiki/Web_Mercator_projection\nconst DEFAULT_MAX_LATITUDE = 85.051129;\n\n/** https://user-images.githubusercontent.com/2059298/78465769-938b7a00-76ae-11ea-9b95-1f4c26425ab9.png */\nexport function cutPolylineByMercatorBounds(\n  positions: Readonly<NumericArray>,\n  options?: {\n    size?: number;\n    startIndex?: number;\n    endIndex?: number;\n    normalize?: boolean;\n  }\n): number[][] {\n  const {size = 2, startIndex = 0, endIndex = positions.length, normalize = true} = options || {};\n\n  // Remap longitudes so that each segment takes the shorter path\n  const newPositions = positions.slice(startIndex, endIndex);\n  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);\n\n  const parts = cutPolylineByGrid(newPositions, {\n    size,\n    broken: true,\n    gridResolution: 360,\n    gridOffset: [-180, -180]\n  }) as number[][];\n\n  if (normalize) {\n    // Each part is guaranteed to be in a single copy of the world\n    // Map longitudes back to [-180, 180]\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part, size);\n    }\n  }\n  return parts;\n}\n\n/** https://user-images.githubusercontent.com/2059298/78465770-94241080-76ae-11ea-809a-6a8534dac1d9.png */\nexport function cutPolygonByMercatorBounds(\n  positions: Readonly<NumericArray>,\n  holeIndices: Readonly<NumericArray> | null = null,\n  options?: {\n    size?: number;\n    normalize?: boolean;\n    maxLatitude?: number;\n    edgeTypes?: boolean;\n  }\n): Polygon[] {\n  const {size = 2, normalize = true, edgeTypes = false} = options || {};\n  holeIndices = holeIndices || [];\n  const newPositions: number[] = [];\n  const newHoleIndices: number[] = [];\n  let srcStartIndex = 0;\n  let targetIndex = 0;\n\n  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {\n    // srcStartIndex/srcEndIndex define the ring in the original positions\n    const srcEndIndex = holeIndices[ringIndex] || positions.length;\n    // targetStartIndex/targetIndex define the ring in newPositions\n    const targetStartIndex = targetIndex;\n\n    // In case the ring contains a pole (e.g. Antarctica), we'll have to insert vertices\n    // The insertion point is defined by the vertex closest to the pole\n    // Split the the ring by the insertion point when copying to newPositions\n    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);\n    for (let i = splitIndex; i < srcEndIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n    for (let i = srcStartIndex; i < splitIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    // Remap longitudes so that each segment takes the shorter path\n    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);\n\n    // Handle the case when the ring contains a pole\n    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options?.maxLatitude);\n\n    srcStartIndex = srcEndIndex;\n    newHoleIndices[ringIndex] = targetIndex;\n  }\n  newHoleIndices.pop();\n\n  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {\n    size,\n    gridResolution: 360,\n    gridOffset: [-180, -180],\n    edgeTypes\n  });\n\n  if (normalize) {\n    // Each part is guaranteed to be in a single copy of the world\n    // Map longitudes back to [-180, 180]\n    for (const part of parts) {\n      // @ts-expect-error (mutates readonly array) May mutate newPositions, which is created by us\n      shiftLongitudesIntoRange(part.positions, size);\n    }\n  }\n  return parts;\n}\n\n/* Helpers */\n\n// See comments for insertPoleVertices\nfunction findSplitIndex(\n  positions: Readonly<NumericArray>,\n  size: number,\n  startIndex: number,\n  endIndex: number\n): number {\n  let maxLat = -1;\n  let pointIndex = -1;\n  for (let i = startIndex + 1; i < endIndex; i += size) {\n    const lat = Math.abs(positions[i]);\n    if (lat > maxLat) {\n      maxLat = lat;\n      pointIndex = i - 1;\n    }\n  }\n  return pointIndex;\n}\n\n// https://user-images.githubusercontent.com/2059298/78857483-5987e400-79de-11ea-98fc-0631287a8431.png\n//\n// If the polygon contains a pole, to tesselate it correctly, we need to insert the edge\n// of map into the polygon. This requires adding two vertices that represent the pole, by\n// drawing a perpendicular line to the Mercator map edge from a selected vertex on the ring.\n//\n// We select the insertion position carefully so that the inserted line segments do not\n// intersect with the ring itself. This is ensured by findSplitIndex, which returns the\n// vertex closest to the pole.\nfunction insertPoleVertices(\n  positions: number[],\n  size: number,\n  startIndex: number,\n  endIndex: number,\n  maxLatitude: number = DEFAULT_MAX_LATITUDE\n): void {\n  // Check if the ring contains a pole\n  const firstLng = positions[startIndex];\n  const lastLng = positions[endIndex - size];\n  if (Math.abs(firstLng - lastLng) > 180) {\n    // The ring does not make a round trip\n    // Add the nearest pole to the vertices so that the polygon tesselates correctly\n    const p = getPointAtIndex(positions, 0, size, startIndex);\n    // Copy the first vertex to the world of the last vertex\n    p[0] += Math.round((lastLng - firstLng) / 360) * 360;\n    push(positions, p);\n    // Project the copied vertex to the edge of the map\n    p[1] = Math.sign(p[1]) * maxLatitude;\n    push(positions, p);\n    // Project the first vertex to the edge of the map\n    p[0] = firstLng;\n    push(positions, p);\n  }\n}\n\nfunction wrapLongitudesForShortestPath(\n  positions: NumericArray,\n  size: number,\n  startIndex: number,\n  endIndex: number\n): void {\n  let prevLng: number = positions[0];\n  let lng: number;\n  for (let i = startIndex; i < endIndex; i += size) {\n    lng = positions[i];\n    const delta = lng - prevLng;\n    if (delta > 180 || delta < -180) {\n      lng -= Math.round(delta / 360) * 360;\n    }\n    positions[i] = prevLng = lng;\n  }\n}\n\nfunction shiftLongitudesIntoRange(positions: NumericArray, size: number): void {\n  let refLng: number;\n  const pointCount = positions.length / size;\n\n  // Find a longitude that is not on the edge of a world\n  // Which we will use to determine which world copy it is\n  for (let i = 0; i < pointCount; i++) {\n    refLng = positions[i * size];\n    if ((refLng + 180) % 360 !== 0) {\n      break;\n    }\n  }\n\n  const delta = -Math.round(refLng / 360) * 360;\n  if (delta === 0) {\n    return;\n  }\n  for (let i = 0; i < pointCount; i++) {\n    positions[i * size] += delta;\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_core", "area", "area", "equals"]
}
