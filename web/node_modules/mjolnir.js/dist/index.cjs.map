{
  "version": 3,
  "sources": ["../src/index.ts", "../src/hammerjs/input/input-consts.ts", "../src/hammerjs/recognizer/recognizer-state.ts", "../src/hammerjs/touchaction/touchaction-Consts.ts", "../src/hammerjs/touchaction/clean-touch-actions.ts", "../src/hammerjs/touchaction/touchaction.ts", "../src/hammerjs/utils/split-str.ts", "../src/hammerjs/utils/event-listeners.ts", "../src/hammerjs/utils/get-window-for-element.ts", "../src/hammerjs/utils/has-parent.ts", "../src/hammerjs/input/get-center.ts", "../src/hammerjs/input/simple-clone-input-data.ts", "../src/hammerjs/input/get-distance.ts", "../src/hammerjs/input/get-angle.ts", "../src/hammerjs/input/get-direction.ts", "../src/hammerjs/input/get-delta-xy.ts", "../src/hammerjs/input/get-velocity.ts", "../src/hammerjs/input/get-scale.ts", "../src/hammerjs/input/get-rotation.ts", "../src/hammerjs/input/compute-interval-input-data.ts", "../src/hammerjs/input/compute-input-data.ts", "../src/hammerjs/input/input-handler.ts", "../src/hammerjs/input/input.ts", "../src/hammerjs/inputs/pointerevent.ts", "../src/hammerjs/utils/prefixed.ts", "../src/hammerjs/manager.ts", "../src/hammerjs/utils/unique-id.ts", "../src/hammerjs/recognizer/state-str.ts", "../src/hammerjs/recognizer/recognizer.ts", "../src/hammerjs/recognizers/attribute.ts", "../src/hammerjs/recognizers/tap.ts", "../src/hammerjs/recognizers/pan.ts", "../src/hammerjs/recognizers/swipe.ts", "../src/hammerjs/recognizers/pinch.ts", "../src/hammerjs/recognizers/rotate.ts", "../src/hammerjs/recognizers/press.ts", "../src/inputs/input.ts", "../src/utils/globals.ts", "../src/inputs/wheel-input.ts", "../src/inputs/move-input.ts", "../src/inputs/key-input.ts", "../src/inputs/contextmenu-input.ts", "../src/utils/event-utils.ts", "../src/utils/event-registrar.ts", "../src/event-manager.ts"],
  "sourcesContent": ["// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport {EventManager} from './event-manager';\nexport {\n  Recognizer,\n  Pan,\n  Rotate,\n  Pinch,\n  Swipe,\n  Press,\n  Tap,\n  InputDirection,\n  InputEvent\n} from './hammerjs/index';\n\n// types\nexport type {EventManagerOptions, RecognizerTuple} from './event-manager';\nexport type {\n  MjolnirEvent,\n  MjolnirGestureEvent,\n  MjolnirKeyEvent,\n  MjolnirWheelEvent,\n  MjolnirPointerEvent\n} from './types';\n\nexport type {\n  PanRecognizerOptions,\n  RotateRecognizerOptions,\n  PinchRecognizerOptions,\n  SwipeRecognizerOptions,\n  PressRecognizerOptions,\n  TapRecognizerOptions\n} from './hammerjs/index';\n", "export const MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nexport const COMPUTE_INTERVAL = 25;\n\nexport enum InputEvent {\n  Start = 1,\n  Move = 2,\n  End = 4,\n  Cancel = 8\n}\n\nexport enum InputDirection {\n  None = 0,\n  Left = 1,\n  Right = 2,\n  Up = 4,\n  Down = 8,\n  Horizontal = 3,\n  Vertical = 12,\n  All = 15\n}\n", "export enum RecognizerState {\n  Possible = 1,\n  Began = 2,\n  Changed = 4,\n  Ended = 8,\n  Recognized = 8, // eslint-disable-line\n  Cancelled = 16,\n  Failed = 32\n}\n", "// magical touchAction value\nexport const TOUCH_ACTION_COMPUTE = 'compute';\nexport const TOUCH_ACTION_AUTO = 'auto';\nexport const TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nexport const TOUCH_ACTION_NONE = 'none';\nexport const TOUCH_ACTION_PAN_X = 'pan-x';\nexport const TOUCH_ACTION_PAN_Y = 'pan-y';\n", "import {\n  TOUCH_ACTION_NONE,\n  TOUCH_ACTION_PAN_X,\n  TOUCH_ACTION_PAN_Y,\n  TOUCH_ACTION_MANIPULATION,\n  TOUCH_ACTION_AUTO\n} from './touchaction-Consts';\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @returns valid touchAction\n */\nexport default function cleanTouchActions(actions: string): string {\n  // none\n  if (actions.includes(TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  const hasPanX = actions.includes(TOUCH_ACTION_PAN_X);\n  const hasPanY = actions.includes(TOUCH_ACTION_PAN_Y);\n\n  // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  // pan-x OR pan-y\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  }\n\n  // manipulation\n  if (actions.includes(TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n", "import {TOUCH_ACTION_COMPUTE} from './touchaction-Consts';\nimport cleanTouchActions from './clean-touch-actions';\n\nimport type {Manager} from '../manager';\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n */\nexport class TouchAction {\n  manager: Manager;\n  actions: string = '';\n\n  constructor(manager: Manager, value: string) {\n    this.manager = manager;\n    this.set(value);\n  }\n\n  /**\n   * set the touchAction value on the element or enable the polyfill\n   */\n  set(value: string) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (this.manager.element) {\n      this.manager.element.style.touchAction = value;\n      this.actions = value;\n    }\n  }\n\n  /**\n   * just re-set the touchAction value\n   */\n  update() {\n    this.set(this.manager.options.touchAction);\n  }\n\n  /**\n   * compute the value for the touchAction property based on the recognizer's settings\n   */\n  compute(): string {\n    let actions: string[] = [];\n    for (const recognizer of this.manager.recognizers) {\n      if (recognizer.options.enable) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    }\n    return cleanTouchActions(actions.join(' '));\n  }\n}\n", "/**\n * split string on whitespace\n * @returns {Array} words\n */\nexport function splitStr(str: string): string[] {\n  return str.trim().split(/\\s+/g);\n}\n", "import {splitStr} from './split-str';\n\n/**\n * addEventListener with multiple events at once\n */\nexport function addEventListeners(\n  target: EventTarget | null,\n  types: string,\n  handler: EventListener\n) {\n  if (!target) {\n    return;\n  }\n  for (const type of splitStr(types)) {\n    target.addEventListener(type, handler, false);\n  }\n}\n\n/**\n * removeEventListener with multiple events at once\n */\nexport function removeEventListeners(\n  target: EventTarget | null,\n  types: string,\n  handler: EventListener\n) {\n  if (!target) {\n    return;\n  }\n  for (const type of splitStr(types)) {\n    target.removeEventListener(type, handler, false);\n  }\n}\n", "/**\n * get the window object of an element\n */\nexport function getWindowForElement(element: HTMLElement): Window | null {\n  const doc = element.ownerDocument || (element as unknown as Document);\n  return doc.defaultView;\n}\n", "/**\n * find if a node is in the given parent\n */\nexport default function hasParent(node: HTMLElement, parent: HTMLElement): boolean {\n  let ancestor: Node | null = node;\n  while (ancestor) {\n    if (ancestor === parent) {\n      return true;\n    }\n    ancestor = ancestor.parentNode;\n  }\n  return false;\n}\n", "import type {Point, PointerEventLike} from './types';\n\n/**\n * get the center of all the pointers\n */\nexport function getCenter(pointers: PointerEventLike[]): Point {\n  const pointersLength = pointers.length;\n\n  // no need to loop when only one touch\n  if (pointersLength === 1) {\n    return {\n      x: Math.round(pointers[0].clientX),\n      y: Math.round(pointers[0].clientY)\n    };\n  }\n\n  let x = 0;\n  let y = 0;\n  let i = 0;\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: Math.round(x / pointersLength),\n    y: Math.round(y / pointersLength)\n  };\n}\n", "import {getCenter} from './get-center';\nimport type {RawInput, PointerEventLike, SimpleInput} from './types';\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n */\nexport function simpleCloneInputData(input: RawInput): SimpleInput {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  const pointers: PointerEventLike[] = [];\n  let i = 0;\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: Math.round(input.pointers[i].clientX),\n      clientY: Math.round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: Date.now(),\n    pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n", "import type {Point, PointerEventLike} from './types';\n\n/**\n * calculate the absolute distance between two points\n * @returns distance\n */\nexport function getPointDistance(p1: Point, p2: Point): number {\n  const x = p2.x - p1.x;\n  const y = p2.y - p1.y;\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * calculate the absolute distance between two pointer events\n * @returns distance\n */\nexport function getEventDistance(p1: PointerEventLike, p2: PointerEventLike): number {\n  const x = p2.clientX - p1.clientX;\n  const y = p2.clientY - p1.clientY;\n  return Math.sqrt(x * x + y * y);\n}\n", "import {Point, PointerEventLike} from './types';\n\n/**\n * calculate the angle between two coordinates\n * @returns angle in degrees\n */\nexport function getPointAngle(p1: Point, p2: Point) {\n  const x: number = p2.x - p1.x;\n  const y: number = p2.y - p1.y;\n  return (Math.atan2(y, x) * 180) / Math.PI;\n}\n\n/**\n * calculate the angle between two pointer events\n * @returns angle in degrees\n */\nexport function getEventAngle(p1: PointerEventLike, p2: PointerEventLike) {\n  const x: number = p2.clientX - p1.clientX;\n  const y: number = p2.clientY - p1.clientY;\n  return (Math.atan2(y, x) * 180) / Math.PI;\n}\n", "import {InputDirection} from './input-consts';\n\n/**\n * get the direction between two points\n * @returns direction\n */\nexport function getDirection(dx: number, dy: number): InputDirection {\n  if (dx === dy) {\n    return InputDirection.None;\n  }\n\n  if (Math.abs(dx) >= Math.abs(dy)) {\n    return dx < 0 ? InputDirection.Left : InputDirection.Right;\n  }\n  return dy < 0 ? InputDirection.Up : InputDirection.Down;\n}\n", "import {InputEvent} from './input-consts';\nimport type {RawInput, Session} from './types';\n\n/** Populates input.deltaX, input.deltaY */\nexport function computeDeltaXY(\n  session: Session,\n  input: RawInput\n): {\n  deltaX: number;\n  deltaY: number;\n} {\n  // getCenter is called before computeDeltaXY\n  const center = input.center!;\n  let offset = session.offsetDelta;\n  let prevDelta = session.prevDelta;\n  const prevInput = session.prevInput;\n\n  if (input.eventType === InputEvent.Start || prevInput?.eventType === InputEvent.End) {\n    prevDelta = session.prevDelta = {\n      x: prevInput?.deltaX || 0,\n      y: prevInput?.deltaY || 0\n    };\n\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  return {\n    deltaX: prevDelta!.x + (center.x - offset!.x),\n    deltaY: prevDelta!.y + (center.y - offset!.y)\n  };\n}\n", "import type {Vector} from './types';\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n */\nexport function getVelocity(deltaTime: number, x: number, y: number): Vector {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n", "import {getEventDistance} from './get-distance';\nimport type {PointerEventLike} from './types';\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n */\nexport function getScale(start: PointerEventLike[], end: PointerEventLike[]): number {\n  return getEventDistance(end[0], end[1]) / getEventDistance(start[0], start[1]);\n}\n", "import {getEventAngle} from './get-angle';\nimport {PointerEventLike} from './types';\n\n/**\n * calculate the rotation degrees between two pointer sets\n * @returns rotation in degrees\n */\nexport function getRotation(start: PointerEventLike[], end: PointerEventLike[]): number {\n  return getEventAngle(end[1], end[0]) - getEventAngle(start[1], start[0]);\n}\n", "import {InputEvent, COMPUTE_INTERVAL} from './input-consts';\nimport {getVelocity} from './get-velocity';\nimport {getDirection} from './get-direction';\n\nimport type {Session, HammerInput} from './types';\n\n/**\n * velocity is calculated every x ms\n */\nexport function computeIntervalInputData(session: Session, input: HammerInput) {\n  const last = session.lastInterval || input;\n  const deltaTime = input.timeStamp - last.timeStamp;\n  let velocity;\n  let velocityX;\n  let velocityY;\n  let direction;\n\n  if (\n    input.eventType !== InputEvent.Cancel &&\n    (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)\n  ) {\n    const deltaX = input.deltaX - last.deltaX;\n    const deltaY = input.deltaY - last.deltaY;\n\n    const v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = Math.abs(v.x) > Math.abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n", "import hasParent from '../utils/has-parent';\nimport {simpleCloneInputData} from './simple-clone-input-data';\nimport {getCenter} from './get-center';\nimport {getPointDistance} from './get-distance';\nimport {getPointAngle} from './get-angle';\nimport {getDirection} from './get-direction';\nimport {computeDeltaXY} from './get-delta-xy';\nimport {getVelocity} from './get-velocity';\nimport {getScale} from './get-scale';\nimport {getRotation} from './get-rotation';\nimport {computeIntervalInputData} from './compute-interval-input-data';\n\nimport type {Manager} from '../manager';\nimport type {RawInput, HammerInput} from './types';\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n */\nexport function computeInputData(manager: Manager, input: RawInput): HammerInput {\n  const {session} = manager;\n  const {pointers} = input;\n  const {length: pointersLength} = pointers;\n\n  // store the first input to calculate the distance and direction\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  }\n\n  // to compute scale and rotation we need to store the multiple touches\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  const {firstInput, firstMultiple} = session;\n  const offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n  const center = (input.center = getCenter(pointers));\n  input.timeStamp = Date.now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n  input.angle = getPointAngle(offsetCenter, center);\n  input.distance = getPointDistance(offsetCenter, center);\n\n  const {deltaX, deltaY} = computeDeltaXY(session, input);\n  input.deltaX = deltaX;\n  input.deltaY = deltaY;\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n  const overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity =\n    Math.abs(overallVelocity.x) > Math.abs(overallVelocity.y)\n      ? overallVelocity.x\n      : overallVelocity.y;\n\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n  input.maxPointers = !session.prevInput\n    ? input.pointers.length\n    : input.pointers.length > session.prevInput.maxPointers\n      ? input.pointers.length\n      : session.prevInput.maxPointers;\n\n  // find the correct target\n  let target = manager.element!;\n  if (hasParent(input.srcEvent.target as HTMLElement, target)) {\n    target = input.srcEvent.target as HTMLElement;\n  }\n  input.target = target;\n\n  computeIntervalInputData(session, input as HammerInput);\n\n  // All the optional fields have been populated\n  return input as HammerInput;\n}\n", "import {InputEvent} from './input-consts';\nimport {computeInputData} from './compute-input-data';\n\nimport type {Manager} from '../manager';\nimport type {RawInput} from './types';\n\n/**\n * handle input events\n */\nexport function inputHandler(manager: Manager, eventType: InputEvent, input: RawInput) {\n  const pointersLen = input.pointers.length;\n  const changedPointersLen = input.changedPointers.length;\n  const isFirst = eventType & InputEvent.Start && pointersLen - changedPointersLen === 0;\n  const isFinal =\n    eventType & (InputEvent.End | InputEvent.Cancel) && pointersLen - changedPointersLen === 0;\n\n  input.isFirst = Boolean(isFirst);\n  input.isFinal = Boolean(isFinal);\n\n  if (isFirst) {\n    manager.session = {};\n  }\n\n  // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n  input.eventType = eventType;\n\n  // compute scale, rotation etc\n  const processedInput = computeInputData(manager, input);\n\n  // emit secret event\n  manager.emit('hammer.input', processedInput);\n\n  manager.recognize(processedInput);\n  manager.session.prevInput = processedInput;\n}\n", "import {addEventListeners, removeEventListeners} from '../utils/event-listeners';\nimport {getWindowForElement} from '../utils/get-window-for-element';\nimport {inputHandler} from './input-handler';\n\nimport {InputEvent} from './input-consts';\nimport type {RawInput} from './types';\nimport type {Manager} from '../manager';\n\n/**\n * create new input type manager\n */\nexport abstract class Input {\n  manager: Manager;\n  element: HTMLElement;\n  target: EventTarget;\n\n  evEl: string = '';\n  evWin: string = '';\n  evTarget: string = '';\n\n  constructor(manager: Manager) {\n    this.manager = manager;\n    this.element = manager.element!;\n    this.target = manager.options.inputTarget || manager.element!;\n  }\n\n  /** smaller wrapper around the handler, for the scope and the enabled state of the manager,\n   * so when disabled the input events are completely bypassed.\n   */\n  protected domHandler = (ev: Event) => {\n    if (this.manager.options.enable) {\n      this.handler(ev);\n    }\n  };\n\n  protected callback(eventType: InputEvent, input: RawInput) {\n    inputHandler(this.manager, eventType, input);\n  }\n\n  /**\n   * should handle the inputEvent data and trigger the callback\n   */\n  abstract handler(ev: Event): void;\n\n  // eslint-disable @typescript-eslint/unbound-method\n  /**\n   * bind the events\n   */\n  init() {\n    addEventListeners(this.element, this.evEl, this.domHandler);\n    addEventListeners(this.target, this.evTarget, this.domHandler);\n    addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  }\n\n  /**\n   * unbind the events\n   */\n  destroy() {\n    removeEventListeners(this.element, this.evEl, this.domHandler);\n    removeEventListeners(this.target, this.evTarget, this.domHandler);\n    removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  }\n  // eslint-enable @typescript-eslint/unbound-method\n}\n", "import {InputEvent} from '../input/input-consts';\nimport {Input} from '../input/input';\nimport type {Manager} from '../manager';\n\nconst POINTER_INPUT_MAP = {\n  pointerdown: InputEvent.Start,\n  pointermove: InputEvent.Move,\n  pointerup: InputEvent.End,\n  pointercancel: InputEvent.Cancel,\n  pointerout: InputEvent.Cancel\n} as const;\n\nconst POINTER_ELEMENT_EVENTS = 'pointerdown';\nconst POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n/**\n * Pointer events input\n */\nexport class PointerEventInput extends Input {\n  store: PointerEvent[];\n\n  constructor(manager: Manager) {\n    super(manager);\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    this.store = this.manager.session.pointerEvents = [];\n    this.init();\n  }\n\n  /**\n   * handle mouse events\n   */\n  handler(ev: PointerEvent) {\n    const {store} = this;\n    let removePointer = false;\n\n    // @ts-ignore\n    const eventType = POINTER_INPUT_MAP[ev.type];\n    const pointerType = ev.pointerType;\n\n    const isTouch = pointerType === 'touch';\n\n    // get index of the event in the store\n    let storeIndex = store.findIndex((e) => e.pointerId === ev.pointerId);\n\n    // start and mouse must be down\n    if (eventType & InputEvent.Start && (ev.buttons || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (InputEvent.End | InputEvent.Cancel)) {\n      removePointer = true;\n    }\n\n    // it not found, so the pointer hasn't been down (so it's probably a hover)\n    if (storeIndex < 0) {\n      return;\n    }\n\n    // update the event in the store\n    store[storeIndex] = ev;\n\n    this.callback(eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      eventType,\n      pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  }\n}\n", "const VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n\n/**\n * get the prefixed property\n * @returns prefixed property name\n */\nexport function prefixed(obj: Record<string, any>, property: string): string | undefined {\n  const camelProp = property[0].toUpperCase() + property.slice(1);\n\n  for (const prefix of VENDOR_PREFIXES) {\n    const prop = prefix ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n  }\n  return undefined;\n}\n", "import {TouchAction} from './touchaction/touchaction';\nimport {PointerEventInput} from './inputs/pointerevent';\nimport {splitStr} from './utils/split-str';\nimport {prefixed} from './utils/prefixed';\nimport {RecognizerState} from './recognizer/recognizer-state';\n\nimport type {Input} from './input/input';\nimport type {Recognizer} from './recognizer/recognizer';\nimport type {Session, HammerInput} from './input/types';\n\nconst STOP = 1;\nconst FORCED_STOP = 2;\n\nexport type ManagerOptions = {\n  /**\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @default compute\n   */\n  touchAction?: string;\n\n  /**\n   * @default true\n   */\n  enable?: boolean;\n\n  /**\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @default null\n   */\n  inputTarget?: null | EventTarget;\n\n  /**\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   */\n  cssProps?: Partial<CSSStyleDeclaration>;\n};\n\nexport type HammerEvent = HammerInput & {\n  type: string;\n  preventDefault: () => void;\n};\nexport type EventHandler = (event: HammerEvent) => void;\n\nconst defaultOptions: Required<ManagerOptions> = {\n  touchAction: 'compute',\n  enable: true,\n  inputTarget: null,\n  cssProps: {\n    /**\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     */\n    userSelect: 'none',\n    /**\n     * (Webkit) Disable default dragging behavior\n     */\n    // @ts-ignore\n    userDrag: 'none',\n    /**\n     * (iOS only) Disables the default callout shown when you touch and hold a touch target.\n     * When you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     */\n    // @ts-ignore\n    touchCallout: 'none',\n    /**\n     * (iOS only) Sets the color of the highlight that appears over a link while it's being tapped.\n     */\n    // @ts-ignore\n    tapHighlightColor: 'rgba(0,0,0,0)'\n  }\n};\n\n/**\n * Manager\n */\nexport class Manager {\n  options: Required<ManagerOptions>;\n\n  element: HTMLElement | null;\n  touchAction: TouchAction;\n  oldCssProps: {[prop: string]: any};\n  session: Session;\n  recognizers: Recognizer[];\n  input: Input;\n  handlers: {[event: string]: EventHandler[]};\n\n  constructor(element: HTMLElement, options: ManagerOptions) {\n    this.options = {\n      ...defaultOptions,\n      ...options,\n      cssProps: {...defaultOptions.cssProps, ...options.cssProps},\n      inputTarget: options.inputTarget || element\n    };\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = new PointerEventInput(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    this.toggleCssProps(true);\n  }\n\n  /**\n   * set options\n   */\n  set(options: Partial<ManagerOptions>) {\n    Object.assign(this.options, options);\n\n    // Options that need a little more setup\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n    return this;\n  }\n\n  /**\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   */\n  stop(force?: boolean) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  }\n\n  /**\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   */\n  recognize(inputData: HammerInput) {\n    const {session} = this;\n    if (session.stopped) {\n      return;\n    }\n\n    // run the touch-action polyfill\n    if (this.session.prevented) {\n      inputData.srcEvent.preventDefault();\n    }\n\n    let recognizer;\n    const {recognizers} = this;\n\n    // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n    let {curRecognizer} = session;\n\n    // reset when the last recognizer is recognized\n    // or when we're in a new session\n    if (!curRecognizer || (curRecognizer && curRecognizer.state & RecognizerState.Recognized)) {\n      curRecognizer = session.curRecognizer = null;\n    }\n\n    let i = 0;\n    while (i < recognizers.length) {\n      recognizer = recognizers[i];\n\n      // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n      if (\n        session.stopped !== FORCED_STOP && // 1\n        (!curRecognizer ||\n          recognizer === curRecognizer || // 2\n          recognizer.canRecognizeWith(curRecognizer))\n      ) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      }\n\n      // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n      if (\n        !curRecognizer &&\n        recognizer.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended)\n      ) {\n        curRecognizer = session.curRecognizer = recognizer;\n      }\n      i++;\n    }\n  }\n\n  /**\n   * get a recognizer by its event name.\n   */\n  get(recognizerName: string): Recognizer | null {\n    const {recognizers} = this;\n    for (let i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizerName) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   */\n  add(recognizer: Recognizer | Recognizer[]) {\n    if (Array.isArray(recognizer)) {\n      for (const item of recognizer) {\n        this.add(item);\n      }\n      return this;\n    }\n\n    // remove existing\n    const existing = this.get(recognizer.options.event);\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n\n    this.touchAction.update();\n    return recognizer;\n  }\n\n  /**\n   * remove a recognizer by name or instance\n   */\n  remove(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.remove(item);\n      }\n      return this;\n    }\n\n    const recognizer =\n      typeof recognizerOrName === 'string' ? this.get(recognizerOrName) : recognizerOrName;\n\n    // let's make sure this recognizer exists\n    if (recognizer) {\n      const {recognizers} = this;\n      const index = recognizers.indexOf(recognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * bind event\n   */\n  on(events: string, handler: EventHandler) {\n    if (!events || !handler) {\n      return;\n    }\n    const {handlers} = this;\n    for (const event of splitStr(events)) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    }\n  }\n\n  /**\n   * unbind event, leave hander blank to remove all handlers\n   */\n  off(events: string, handler?: EventHandler) {\n    if (!events) {\n      return;\n    }\n\n    const {handlers} = this;\n    for (const event of splitStr(events)) {\n      if (!handler) {\n        delete handlers[event];\n      } else if (handlers[event]) {\n        handlers[event].splice(handlers[event].indexOf(handler), 1);\n      }\n    }\n  }\n\n  /**\n   * emit event to the listeners\n   */\n  emit(event: string, data: HammerInput) {\n    // no handlers, so skip it all\n    const handlers = this.handlers[event] && this.handlers[event].slice();\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    const evt = data as HammerEvent;\n    evt.type = event;\n    evt.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    let i = 0;\n    while (i < handlers.length) {\n      handlers[i](evt);\n      i++;\n    }\n  }\n\n  /**\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n  destroy() {\n    this.toggleCssProps(false);\n\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  }\n\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   */\n  private toggleCssProps(add: boolean) {\n    const {element} = this;\n    if (!element) {\n      return;\n    }\n    for (const [name, value] of Object.entries(this.options.cssProps)) {\n      const prop = prefixed(element.style, name) as any;\n      if (add) {\n        this.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value as any;\n      } else {\n        element.style[prop] = this.oldCssProps[prop] || '';\n      }\n    }\n    if (!add) {\n      this.oldCssProps = {};\n    }\n  }\n}\n", "/**\n * get a unique id\n */\nlet _uniqueId = 1;\nexport function uniqueId(): number {\n  return _uniqueId++;\n}\n", "import {RecognizerState} from './recognizer-state';\n\n/**\n * get a usable string, used as event postfix\n */\nexport function stateStr(state: RecognizerState) {\n  if (state & RecognizerState.Cancelled) {\n    return 'cancel';\n  } else if (state & RecognizerState.Ended) {\n    return 'end';\n  } else if (state & RecognizerState.Changed) {\n    return 'move';\n  } else if (state & RecognizerState.Began) {\n    return 'start';\n  }\n  return '';\n}\n", "import {RecognizerState} from './recognizer-state';\nimport {uniqueId} from '../utils/unique-id';\nimport {stateStr} from './state-str';\n\nimport type {Manager} from '../manager';\nimport type {HammerInput} from '../input/types';\n\nexport type RecognizerOptions = {\n  /** Name of the event */\n  event: string;\n  /** Enable this recognizer */\n  enable: boolean;\n};\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n */\nexport abstract class Recognizer<OptionsT extends RecognizerOptions = any> {\n  id: number;\n  state: RecognizerState;\n  manager!: Manager;\n\n  readonly options: OptionsT;\n\n  protected simultaneous: {[id: string]: Recognizer};\n  protected requireFail: Recognizer[];\n\n  constructor(options: OptionsT) {\n    this.options = options;\n\n    this.id = uniqueId();\n\n    this.state = RecognizerState.Possible;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  /**\n   * set options\n   */\n  set(options: Partial<OptionsT>) {\n    Object.assign(this.options, options);\n\n    // also update the touchAction, in case something changed about the directions/enabled state\n    this.manager.touchAction.update();\n    return this;\n  }\n\n  /**\n   * recognize simultaneous with an other recognizer.\n   */\n  recognizeWith(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.recognizeWith(item);\n      }\n      return this;\n    }\n\n    let otherRecognizer: Recognizer | null;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n      if (!otherRecognizer) {\n        throw new Error(`Cannot find recognizer ${recognizerOrName}`);\n      }\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    const {simultaneous} = this;\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  }\n\n  /**\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   */\n  dropRecognizeWith(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.dropRecognizeWith(item);\n      }\n      return this;\n    }\n\n    let otherRecognizer: Recognizer | null;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    if (otherRecognizer) {\n      delete this.simultaneous[otherRecognizer.id];\n    }\n    return this;\n  }\n\n  /**\n   * recognizer can only run when an other is failing\n   */\n  requireFailure(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.requireFailure(item);\n      }\n      return this;\n    }\n\n    let otherRecognizer: Recognizer | null;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n      if (!otherRecognizer) {\n        throw new Error(`Cannot find recognizer ${recognizerOrName}`);\n      }\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    const {requireFail} = this;\n    if (requireFail.indexOf(otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  }\n\n  /**\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   */\n  dropRequireFailure(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.dropRequireFailure(item);\n      }\n      return this;\n    }\n\n    let otherRecognizer: Recognizer | null;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    if (otherRecognizer) {\n      const index = this.requireFail.indexOf(otherRecognizer);\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * has require failures boolean\n   */\n  hasRequireFailures(): boolean {\n    return Boolean(this.requireFail.find((recognier) => recognier.options.enable));\n  }\n\n  /**\n   * if the recognizer can recognize simultaneous with an other recognizer\n   */\n  canRecognizeWith(otherRecognizer: Recognizer): boolean {\n    return Boolean(this.simultaneous[otherRecognizer.id]);\n  }\n\n  /**\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   */\n  protected emit(input?: HammerInput) {\n    // Some recognizers override emit() with their own logic\n    if (!input) return;\n\n    const {state} = this;\n\n    // 'panstart' and 'panmove'\n    if (state < RecognizerState.Ended) {\n      this.manager.emit(this.options.event + stateStr(state), input);\n    }\n\n    // simple 'eventName' events\n    this.manager.emit(this.options.event, input);\n\n    // additional event(panleft, panright, pinchin, pinchout...)\n    if (input.additionalEvent) {\n      this.manager.emit(input.additionalEvent, input);\n    }\n\n    // panend and pancancel\n    if (state >= RecognizerState.Ended) {\n      this.manager.emit(this.options.event + stateStr(state), input);\n    }\n  }\n\n  /**\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   */\n  protected tryEmit(input?: HammerInput) {\n    if (this.canEmit()) {\n      this.emit(input);\n    } else {\n      // it's failing anyway\n      this.state = RecognizerState.Failed;\n    }\n  }\n\n  /**\n   * can we emit?\n   */\n  protected canEmit(): boolean {\n    let i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (RecognizerState.Failed | RecognizerState.Possible))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  }\n\n  /**\n   * update the recognizer\n   */\n  recognize(inputData: HammerInput) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    const inputDataClone = {...inputData};\n\n    // is is enabled and allow recognizing?\n    if (!this.options.enable) {\n      this.reset();\n      this.state = RecognizerState.Failed;\n      return;\n    }\n\n    // reset when we've reached the end\n    if (\n      this.state &\n      (RecognizerState.Recognized | RecognizerState.Cancelled | RecognizerState.Failed)\n    ) {\n      this.state = RecognizerState.Possible;\n    }\n\n    this.state = this.process(inputDataClone);\n\n    // the recognizer has recognized a gesture\n    // so trigger an event\n    if (\n      this.state &\n      (RecognizerState.Began |\n        RecognizerState.Changed |\n        RecognizerState.Ended |\n        RecognizerState.Cancelled)\n    ) {\n      this.tryEmit(inputDataClone);\n    }\n  }\n\n  /**\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   */\n\n  abstract process(inputData: HammerInput): RecognizerState;\n\n  /**\n   * return the preferred touch-action\n   */\n  abstract getTouchAction(): string[];\n\n  /**\n   * return the event names that are emitted by this recognizer\n   */\n  getEventNames(): string[] {\n    return [this.options.event];\n  }\n\n  /**\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   */\n  reset(): void {}\n}\n", "import {Recognizer, RecognizerOptions} from '../recognizer/recognizer';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport {InputEvent} from '../input/input-consts';\nimport type {HammerInput} from '../input/types';\n\ntype AttrRecognizerOptions = RecognizerOptions & {\n  pointers: number;\n};\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n */\nexport abstract class AttrRecognizer<\n  OptionsT extends AttrRecognizerOptions\n> extends Recognizer<OptionsT> {\n  /**\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   */\n  attrTest(input: HammerInput): boolean {\n    const optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  }\n\n  /**\n   * Process the input and return the state for the recognizer\n   */\n  process(input: HammerInput) {\n    const {state} = this;\n    const {eventType} = input;\n\n    const isRecognized = state & (RecognizerState.Began | RecognizerState.Changed);\n    const isValid = this.attrTest(input);\n\n    // on cancel input and we've recognized before, return STATE_CANCELLED\n    if (isRecognized && (eventType & InputEvent.Cancel || !isValid)) {\n      return state | RecognizerState.Cancelled;\n    } else if (isRecognized || isValid) {\n      if (eventType & InputEvent.End) {\n        return state | RecognizerState.Ended;\n      } else if (!(state & RecognizerState.Began)) {\n        return RecognizerState.Began;\n      }\n      return state | RecognizerState.Changed;\n    }\n    return RecognizerState.Failed;\n  }\n}\n", "/* global setTimeout, clearTimeout */\nimport {Recognizer} from '../recognizer/recognizer';\nimport {TOUCH_ACTION_MANIPULATION} from '../touchaction/touchaction-Consts';\nimport {InputEvent} from '../input/input-consts';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport {getPointDistance} from '../input/get-distance';\nimport type {Point, HammerInput} from '../input/types';\n\nexport type TapRecognizerOptions = {\n  /** Name of the event.\n   * @default 'tap'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required pointers.\n   * @default 1\n   */\n  pointers?: number;\n  /** Required number of taps in succession.\n   * @default 1\n   */\n  taps?: number;\n  /** Maximum time in ms between multiple taps.\n   * @default 300\n   */\n  interval?: number;\n  /** Maximum press time in ms.\n   * @default 250\n   */\n  time?: number;\n  /** While doing a tap some small movement is allowed.\n   * @default 9\n   */\n  threshold?: number;\n  /** The maximum position difference between multiple taps.\n   * @default 10\n   */\n  posThreshold?: number;\n};\n\n/**\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n */\nexport class TapRecognizer extends Recognizer<Required<TapRecognizerOptions>> {\n  /** previous time for tap counting */\n  private pTime: number | null = null;\n  /** previous center for tap counting */\n  private pCenter: Point | null = null;\n\n  private _timer: any = null;\n  private _input: HammerInput | null = null;\n\n  private count: number = 0;\n\n  constructor(options: TapRecognizerOptions = {}) {\n    super({\n      enable: true,\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      time: 250,\n      threshold: 9,\n      posThreshold: 10,\n      ...options\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  }\n\n  process(input: HammerInput) {\n    const {options} = this;\n\n    const validPointers = input.pointers.length === options.pointers;\n    const validMovement = input.distance < options.threshold;\n    const validTouchTime = input.deltaTime < options.time;\n\n    this.reset();\n\n    if (input.eventType & InputEvent.Start && this.count === 0) {\n      return this.failTimeout();\n    }\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== InputEvent.End) {\n        return this.failTimeout();\n      }\n\n      const validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      const validMultiTap =\n        !this.pCenter || getPointDistance(this.pCenter, input.center) < options.posThreshold;\n\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input;\n\n      // if tap count matches we have recognized it,\n      // else it has began recognizing...\n      const tapCount = this.count % options.taps;\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return RecognizerState.Recognized;\n        }\n        this._timer = setTimeout(() => {\n          this.state = RecognizerState.Recognized;\n          this.tryEmit(this._input!);\n        }, options.interval);\n        return RecognizerState.Began;\n      }\n    }\n    return RecognizerState.Failed;\n  }\n\n  failTimeout() {\n    this._timer = setTimeout(() => {\n      this.state = RecognizerState.Failed;\n    }, this.options.interval);\n    return RecognizerState.Failed;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit(input: HammerInput) {\n    if (this.state === RecognizerState.Recognized) {\n      input.tapCount = this.count;\n      this.manager.emit(this.options.event, input);\n    }\n  }\n}\n", "import {AttrRecognizer} from './attribute';\nimport {InputDirection} from '../input/input-consts';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport {TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y} from '../touchaction/touchaction-Consts';\nimport type {HammerInput} from '../input/types';\n\nexport type PanRecognizerOptions = {\n  /** Name of the event.\n   * @default 'pan'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required number of pointers. 0 for all pointers.\n   * @default 1\n   */\n  pointers?: number;\n  /** Required direction of panning.\n   * @default InputDirection.All\n   */\n  direction?: InputDirection;\n  /** Minimal pan distance required before recognizing.\n   * @default 10\n   */\n  threshold?: number;\n};\n\nconst EVENT_NAMES = ['', 'start', 'move', 'end', 'cancel', 'up', 'down', 'left', 'right'] as const;\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n */\nexport class PanRecognizer extends AttrRecognizer<Required<PanRecognizerOptions>> {\n  pX: number | null;\n  pY: number | null;\n\n  constructor(options: PanRecognizerOptions = {}) {\n    super({\n      enable: true,\n      pointers: 1,\n      event: 'pan',\n      threshold: 10,\n      direction: InputDirection.All,\n      ...options\n    });\n    this.pX = null;\n    this.pY = null;\n  }\n\n  getTouchAction(): string[] {\n    const {\n      options: {direction}\n    } = this;\n    const actions: string[] = [];\n    if (direction & InputDirection.Horizontal) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n    if (direction & InputDirection.Vertical) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n    return actions;\n  }\n\n  getEventNames(): string[] {\n    return EVENT_NAMES.map((suffix) => this.options.event + suffix);\n  }\n\n  directionTest(input: HammerInput): boolean {\n    const {options} = this;\n    let hasMoved = true;\n    let {distance} = input;\n    let {direction} = input;\n    const x = input.deltaX;\n    const y = input.deltaY;\n\n    // lock to axis?\n    if (!(direction & options.direction)) {\n      if (options.direction & InputDirection.Horizontal) {\n        direction =\n          x === 0 ? InputDirection.None : x < 0 ? InputDirection.Left : InputDirection.Right;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? InputDirection.None : y < 0 ? InputDirection.Up : InputDirection.Down;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && Boolean(direction & options.direction);\n  }\n\n  attrTest(input: HammerInput): boolean {\n    return (\n      super.attrTest(input) &&\n      (Boolean(this.state & RecognizerState.Began) ||\n        (!(this.state & RecognizerState.Began) && this.directionTest(input)))\n    );\n  }\n\n  emit(input: HammerInput) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n\n    const direction = InputDirection[input.direction].toLowerCase();\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n    super.emit(input);\n  }\n}\n", "import {AttrRecognizer} from './attribute';\nimport {InputDirection, InputEvent} from '../input/input-consts';\nimport {PanRecognizer} from './pan';\nimport type {HammerInput} from '../input/types';\n\nexport type SwipeRecognizerOptions = {\n  /** Name of the event.\n   * @default 'swipe'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required number of pointers.\n   * @default 1\n   */\n  pointers?: number;\n  /** Direction of the panning.\n   * @default InputDirection.All\n   */\n  direction?: InputDirection;\n  /** Minimal distance required before recognizing.\n   * @default 10\n   */\n  threshold?: number;\n  /** Minimal velocity required before recognizing, in px/ms\n   * @default 0.3\n   */\n  velocity?: number;\n};\n\nconst EVENT_NAMES = ['', 'up', 'down', 'left', 'right'] as const;\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n */\nexport class SwipeRecognizer extends AttrRecognizer<Required<SwipeRecognizerOptions>> {\n  constructor(options: SwipeRecognizerOptions = {}) {\n    super({\n      enable: true,\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: InputDirection.All,\n      pointers: 1,\n      ...options\n    });\n  }\n\n  getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  }\n\n  getEventNames(): string[] {\n    return EVENT_NAMES.map((suffix) => this.options.event + suffix);\n  }\n\n  attrTest(input: HammerInput): boolean {\n    const {direction} = this.options;\n    let velocity = 0;\n\n    if (direction & InputDirection.All) {\n      velocity = input.overallVelocity;\n    } else if (direction & InputDirection.Horizontal) {\n      velocity = input.overallVelocityX;\n    } else if (direction & InputDirection.Vertical) {\n      velocity = input.overallVelocityY;\n    }\n\n    return (\n      super.attrTest(input) &&\n      Boolean(direction & input.offsetDirection) &&\n      input.distance > this.options.threshold &&\n      input.maxPointers === this.options.pointers &&\n      Math.abs(velocity) > this.options.velocity &&\n      Boolean(input.eventType & InputEvent.End)\n    );\n  }\n\n  emit(input: HammerInput) {\n    const direction = InputDirection[input.offsetDirection].toLowerCase();\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  }\n}\n", "import {AttrRecognizer} from './attribute';\nimport {TOUCH_ACTION_NONE} from '../touchaction/touchaction-Consts';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport type {HammerInput} from '../input/types';\n\nexport type PinchRecognizerOptions = {\n  /** Name of the event.\n   * @default 'pinch'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required number of pointers, with a minimum of 2.\n   * @default 2\n   */\n  pointers?: number;\n  /** Minimal scale before recognizing.\n   * @default 0\n   */\n  threshold?: number;\n};\n\nconst EVENT_NAMES = ['', 'start', 'move', 'end', 'cancel', 'in', 'out'] as const;\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n */\nexport class PinchRecognizer extends AttrRecognizer<Required<PinchRecognizerOptions>> {\n  constructor(options: PinchRecognizerOptions = {}) {\n    super({\n      enable: true,\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2,\n      ...options\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  }\n\n  getEventNames(): string[] {\n    return EVENT_NAMES.map((suffix) => this.options.event + suffix);\n  }\n\n  attrTest(input: HammerInput): boolean {\n    return (\n      super.attrTest(input) &&\n      (Math.abs(input.scale - 1) > this.options.threshold ||\n        Boolean(this.state & RecognizerState.Began))\n    );\n  }\n\n  emit(input: HammerInput) {\n    if (input.scale !== 1) {\n      const inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n    super.emit(input);\n  }\n}\n", "import {AttrRecognizer} from './attribute';\nimport {TOUCH_ACTION_NONE} from '../touchaction/touchaction-Consts';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport type {HammerInput} from '../input/types';\n\nexport type RotateRecognizerOptions = {\n  /** Name of the event.\n   * @default 'rotate'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required number of pointers, with a minimum of 2.\n   * @default 2\n   */\n  pointers?: number;\n  /** Minimal rotation before recognizing.\n   * @default 0\n   */\n  threshold?: number;\n};\n\nconst EVENT_NAMES = ['', 'start', 'move', 'end', 'cancel'] as const;\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n */\nexport class RotateRecognizer extends AttrRecognizer<Required<RotateRecognizerOptions>> {\n  constructor(options: RotateRecognizerOptions = {}) {\n    super({\n      enable: true,\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2,\n      ...options\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  }\n\n  getEventNames(): string[] {\n    return EVENT_NAMES.map((suffix) => this.options.event + suffix);\n  }\n\n  attrTest(input: HammerInput): boolean {\n    return (\n      super.attrTest(input) &&\n      (Math.abs(input.rotation) > this.options.threshold ||\n        Boolean(this.state & RecognizerState.Began))\n    );\n  }\n}\n", "/* global setTimeout, clearTimeout */\nimport {Recognizer} from '../recognizer/recognizer';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport {TOUCH_ACTION_AUTO} from '../touchaction/touchaction-Consts';\nimport {InputEvent} from '../input/input-consts';\nimport {HammerInput} from '../input/types';\n\nexport type PressRecognizerOptions = {\n  /** Name of the event.\n   * @default 'press'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required number of pointers.\n   * @default 1\n   */\n  pointers?: number;\n  /** Minimal press time in ms.\n   * @default 251\n   */\n  time?: number;\n  /** Minimal movement that is allowed while pressing.\n   * @default 9\n   */\n  threshold?: number;\n};\n\nconst EVENT_NAMES = ['', 'up'] as const;\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n */\nexport class PressRecognizer extends Recognizer<Required<PressRecognizerOptions>> {\n  private _timer: any = null;\n  private _input: HammerInput | null = null;\n\n  constructor(options: PressRecognizerOptions = {}) {\n    super({\n      enable: true,\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      threshold: 9,\n      ...options\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  }\n\n  getEventNames(): string[] {\n    return EVENT_NAMES.map((suffix) => this.options.event + suffix);\n  }\n\n  process(input: HammerInput) {\n    const {options} = this;\n    const validPointers = input.pointers.length === options.pointers;\n    const validMovement = input.distance < options.threshold;\n    const validTime = input.deltaTime > options.time;\n\n    this._input = input;\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (\n      !validMovement ||\n      !validPointers ||\n      (input.eventType & (InputEvent.End | InputEvent.Cancel) && !validTime)\n    ) {\n      this.reset();\n    } else if (input.eventType & InputEvent.Start) {\n      this.reset();\n      this._timer = setTimeout(() => {\n        this.state = RecognizerState.Recognized;\n        this.tryEmit();\n      }, options.time);\n    } else if (input.eventType & InputEvent.End) {\n      return RecognizerState.Recognized;\n    }\n    return RecognizerState.Failed;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit(input?: HammerInput) {\n    if (this.state !== RecognizerState.Recognized) {\n      return;\n    }\n\n    if (input && input.eventType & InputEvent.End) {\n      this.manager.emit(`${this.options.event}up`, input);\n    } else {\n      this._input!.timeStamp = Date.now();\n      this.manager.emit(this.options.event, this._input!);\n    }\n  }\n}\n", "// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {MjolnirEventRaw} from '../types';\n\nexport interface InputOptions {\n  enable?: boolean;\n}\n\nexport class Input<EventType extends MjolnirEventRaw, Options extends InputOptions> {\n  element: HTMLElement;\n  options: Options;\n  callback: (e: EventType) => void;\n\n  constructor(element: HTMLElement, callback: (e: EventType) => void, options: Options) {\n    this.element = element;\n    this.callback = callback;\n    this.options = options;\n  }\n}\n", "// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global'\n\n/* global window, global, document, navigator */\nexport const userAgent =\n  typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';\n\nconst window_ = typeof window !== 'undefined' ? window : global;\nconst global_ = typeof global !== 'undefined' ? global : window;\nconst document_ = typeof document !== 'undefined' ? document : {};\n\nexport {window_ as window, global_ as global, document_ as document};\n", "// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {MjolnirWheelEventRaw} from '../types';\nimport {Input, InputOptions} from './input';\n\nimport {userAgent} from '../utils/globals';\n\nconst firefox = userAgent.indexOf('firefox') !== -1;\n\n// Constants for normalizing input delta\nconst WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;\nconst WHEEL_DELTA_PER_LINE = 40;\n// Slow down zoom if shift key is held for more precise zooming\nconst SHIFT_MULTIPLIER = 0.25;\n\nexport class WheelInput extends Input<MjolnirWheelEventRaw, Required<InputOptions>> {\n  constructor(\n    element: HTMLElement,\n    callback: (event: MjolnirWheelEventRaw) => void,\n    options: InputOptions\n  ) {\n    super(element, callback, {enable: true, ...options});\n\n    element.addEventListener('wheel', this.handleEvent, {passive: false});\n  }\n\n  destroy() {\n    this.element.removeEventListener('wheel', this.handleEvent);\n  }\n\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType: string, enabled: boolean) {\n    if (eventType === 'wheel') {\n      this.options.enable = enabled;\n    }\n  }\n\n  /* eslint-disable complexity, max-statements */\n  handleEvent = (event: WheelEvent) => {\n    if (!this.options.enable) {\n      return;\n    }\n\n    let value = event.deltaY;\n    if (globalThis.WheelEvent) {\n      // Firefox doubles the values on retina screens...\n      if (firefox && event.deltaMode === globalThis.WheelEvent.DOM_DELTA_PIXEL) {\n        value /= globalThis.devicePixelRatio;\n      }\n      if (event.deltaMode === globalThis.WheelEvent.DOM_DELTA_LINE) {\n        value *= WHEEL_DELTA_PER_LINE;\n      }\n    }\n\n    if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {\n      // This one is definitely a mouse wheel event.\n      // Normalize this value to match trackpad.\n      value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);\n    }\n\n    if (event.shiftKey && value) {\n      value = value * SHIFT_MULTIPLIER;\n    }\n\n    this.callback({\n      type: 'wheel',\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      delta: -value,\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target as HTMLElement\n    });\n  };\n}\n", "// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {MjolnirPointerEventRaw} from '../types';\nimport {Input, InputOptions} from './input';\n\nconst MOUSE_EVENTS = [\n  'mousedown',\n  'mousemove',\n  'mouseup',\n  'mouseover',\n  'mouseout',\n  'mouseleave'\n] as const;\n\ntype MoveEventType = 'pointermove' | 'pointerover' | 'pointerout' | 'pointerenter' | 'pointerleave';\n\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nexport class MoveInput extends Input<MjolnirPointerEventRaw, Required<InputOptions>> {\n  pressed: boolean;\n  enableMoveEvent: boolean;\n  enableEnterEvent: boolean;\n  enableLeaveEvent: boolean;\n  enableOutEvent: boolean;\n  enableOverEvent: boolean;\n\n  constructor(\n    element: HTMLElement,\n    callback: (event: MjolnirPointerEventRaw) => void,\n    options: InputOptions\n  ) {\n    super(element, callback, {enable: true, ...options});\n\n    this.pressed = false;\n    const {enable} = this.options;\n\n    this.enableMoveEvent = enable;\n    this.enableLeaveEvent = enable;\n    this.enableEnterEvent = enable;\n    this.enableOutEvent = enable;\n    this.enableOverEvent = enable;\n\n    MOUSE_EVENTS.forEach((event) => element.addEventListener(event, this.handleEvent));\n  }\n\n  destroy() {\n    MOUSE_EVENTS.forEach((event) => this.element.removeEventListener(event, this.handleEvent));\n  }\n\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType: string, enabled: boolean) {\n    switch (eventType) {\n      case 'pointermove':\n        this.enableMoveEvent = enabled;\n        break;\n      case 'pointerover':\n        this.enableOverEvent = enabled;\n        break;\n      case 'pointerout':\n        this.enableOutEvent = enabled;\n        break;\n      case 'pointerenter':\n        this.enableEnterEvent = enabled;\n        break;\n      case 'pointerleave':\n        this.enableLeaveEvent = enabled;\n        break;\n      default:\n      // ignore\n    }\n  }\n\n  handleEvent = (event: MouseEvent) => {\n    this.handleOverEvent(event);\n    this.handleOutEvent(event);\n    this.handleEnterEvent(event);\n    this.handleLeaveEvent(event);\n    this.handleMoveEvent(event);\n  };\n\n  handleOverEvent(event: MouseEvent) {\n    if (this.enableOverEvent && event.type === 'mouseover') {\n      this._emit('pointerover', event);\n    }\n  }\n\n  handleOutEvent(event: MouseEvent) {\n    if (this.enableOutEvent && event.type === 'mouseout') {\n      this._emit('pointerout', event);\n    }\n  }\n\n  handleEnterEvent(event: MouseEvent) {\n    if (this.enableEnterEvent && event.type === 'mouseenter') {\n      this._emit('pointerenter', event);\n    }\n  }\n\n  handleLeaveEvent(event: MouseEvent) {\n    if (this.enableLeaveEvent && event.type === 'mouseleave') {\n      this._emit('pointerleave', event);\n    }\n  }\n\n  handleMoveEvent(event: MouseEvent) {\n    if (this.enableMoveEvent) {\n      switch (event.type) {\n        case 'mousedown':\n          if (event.button >= 0) {\n            // Button is down\n            this.pressed = true;\n          }\n          break;\n        case 'mousemove':\n          // Move events use `bottons` to track the button being pressed\n          if (event.buttons === 0) {\n            // Button is not down\n            this.pressed = false;\n          }\n          if (!this.pressed) {\n            // Drag events are emitted by hammer already\n            // we just need to emit the move event on hover\n            this._emit('pointermove', event);\n          }\n          break;\n        case 'mouseup':\n          this.pressed = false;\n          break;\n        default:\n      }\n    }\n  }\n\n  _emit(type: MoveEventType, event: MouseEvent) {\n    this.callback({\n      type,\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target as HTMLElement\n    });\n  }\n}\n", "// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {MjolnirKeyEventRaw} from '../types';\nimport {Input, InputOptions} from './input';\n\nconst KEY_EVENTS = ['keydown', 'keyup'] as const;\n\ntype KeyInputOptions = InputOptions & {\n  tabIndex?: number;\n};\n\nexport class KeyInput extends Input<MjolnirKeyEventRaw, Required<KeyInputOptions>> {\n  enableDownEvent: boolean;\n  enableUpEvent: boolean;\n\n  constructor(\n    element: HTMLElement,\n    callback: (event: MjolnirKeyEventRaw) => void,\n    options: KeyInputOptions\n  ) {\n    super(element, callback, {enable: true, tabIndex: 0, ...options});\n\n    this.enableDownEvent = this.options.enable;\n    this.enableUpEvent = this.options.enable;\n\n    element.tabIndex = this.options.tabIndex;\n    element.style.outline = 'none';\n    KEY_EVENTS.forEach((event) => element.addEventListener(event, this.handleEvent));\n  }\n\n  destroy() {\n    KEY_EVENTS.forEach((event) => this.element.removeEventListener(event, this.handleEvent));\n  }\n\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType: string, enabled: boolean) {\n    if (eventType === 'keydown') {\n      this.enableDownEvent = enabled;\n    }\n    if (eventType === 'keyup') {\n      this.enableUpEvent = enabled;\n    }\n  }\n\n  handleEvent = (event: KeyboardEvent) => {\n    // Ignore if focused on text input\n    const targetElement = (event.target || event.srcElement) as HTMLElement;\n    if (\n      (targetElement.tagName === 'INPUT' && (targetElement as HTMLInputElement).type === 'text') ||\n      targetElement.tagName === 'TEXTAREA'\n    ) {\n      return;\n    }\n\n    if (this.enableDownEvent && event.type === 'keydown') {\n      this.callback({\n        type: 'keydown',\n        srcEvent: event,\n        key: event.key,\n        target: event.target as HTMLElement\n      });\n    }\n\n    if (this.enableUpEvent && event.type === 'keyup') {\n      this.callback({\n        type: 'keyup',\n        srcEvent: event,\n        key: event.key,\n        target: event.target as HTMLElement\n      });\n    }\n  };\n}\n", "// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {MjolnirPointerEventRaw} from '../types';\nimport {Input, InputOptions} from './input';\n\nexport class ContextmenuInput extends Input<MjolnirPointerEventRaw, InputOptions> {\n  constructor(\n    element: HTMLElement,\n    callback: (event: MjolnirPointerEventRaw) => void,\n    options: InputOptions\n  ) {\n    super(element, callback, options);\n\n    element.addEventListener('contextmenu', this.handleEvent);\n  }\n\n  destroy() {\n    this.element.removeEventListener('contextmenu', this.handleEvent);\n  }\n\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType: string, enabled: boolean) {\n    if (eventType === 'contextmenu') {\n      this.options.enable = enabled;\n    }\n  }\n\n  handleEvent = (event: MouseEvent) => {\n    if (!this.options.enable) {\n      return;\n    }\n\n    this.callback({\n      type: 'contextmenu',\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target as HTMLElement\n    });\n  };\n}\n", "// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {MjolnirEventRaw, Point} from '../types';\nimport type {HammerEvent} from '../hammerjs/index';\n\n/* Constants */\nconst DOWN_EVENT = 1;\nconst MOVE_EVENT = 2;\nconst UP_EVENT = 4;\nconst MOUSE_EVENTS = {\n  pointerdown: DOWN_EVENT,\n  pointermove: MOVE_EVENT,\n  pointerup: UP_EVENT,\n  mousedown: DOWN_EVENT,\n  mousemove: MOVE_EVENT,\n  mouseup: UP_EVENT\n};\n\n// MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\nconst MOUSE_EVENT_BUTTON_LEFT = 0;\nconst MOUSE_EVENT_BUTTON_MIDDLE = 1;\nconst MOUSE_EVENT_BUTTON_RIGHT = 2;\n// MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\nconst MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;\nconst MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;\nconst MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;\n\n/**\n * Extract the involved mouse button\n */\nexport function whichButtons(event: MjolnirEventRaw): {\n  leftButton: boolean;\n  middleButton: boolean;\n  rightButton: boolean;\n} | null {\n  const eventType = MOUSE_EVENTS[event.srcEvent.type];\n  if (!eventType) {\n    // Not a mouse evet\n    return null;\n  }\n\n  const {buttons, button} = event.srcEvent as PointerEvent;\n  let leftButton = false;\n  let middleButton = false;\n  let rightButton = false;\n\n  if (eventType === MOVE_EVENT) {\n    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);\n    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);\n    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);\n  } else {\n    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;\n    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;\n    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;\n  }\n\n  return {leftButton, middleButton, rightButton};\n}\n\n/**\n * Calculate event position relative to the root element\n */\nexport function getOffsetPosition(\n  event: MjolnirEventRaw,\n  rootElement: HTMLElement\n): {\n  center: Point;\n  offsetCenter: Point;\n} | null {\n  const center = (event as HammerEvent).center;\n\n  // `center` is a hammer.js event property\n  if (!center) {\n    // Not a gestural event\n    return null;\n  }\n\n  const rect = rootElement.getBoundingClientRect();\n\n  // Fix scale for map affected by a CSS transform.\n  // See https://stackoverflow.com/a/26893663/3528533\n  const scaleX = rect.width / rootElement.offsetWidth || 1;\n  const scaleY = rect.height / rootElement.offsetHeight || 1;\n\n  // Calculate center relative to the root element\n  const offsetCenter = {\n    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,\n    y: (center.y - rect.top - rootElement.clientTop) / scaleY\n  };\n\n  return {center, offsetCenter};\n}\n", "// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {EventManager} from '../event-manager';\nimport {whichButtons, getOffsetPosition} from './event-utils';\nimport type {\n  MjolnirEventRaw,\n  MjolnirEventWrapper,\n  MjolnirEvent,\n  MjolnirEventHandler\n} from '../types';\n\nexport type HandlerOptions = {\n  /** Optional element from which the event is originated from.\n   * @default 'root'\n   */\n  srcElement?: 'root' | HTMLElement;\n  /** Handler with higher priority will be called first.\n   * Handler with the same priority will be called in the order of registration.\n   * @default 0\n   */\n  priority?: number;\n};\n\ntype EventHandler = {\n  type: string;\n  handler: (event: MjolnirEvent) => void;\n  once?: boolean;\n  passive?: boolean;\n  srcElement: 'root' | HTMLElement;\n  priority: number;\n};\n\nconst DEFAULT_OPTIONS: Required<HandlerOptions> = {\n  srcElement: 'root',\n  priority: 0\n};\n\nexport class EventRegistrar {\n  eventManager: EventManager;\n  recognizerName: string;\n  handlers: EventHandler[];\n  handlersByElement: Map<'root' | HTMLElement, EventHandler[]>;\n  _active: boolean;\n\n  constructor(eventManager: EventManager, recognizerName: string) {\n    this.eventManager = eventManager;\n    this.recognizerName = recognizerName;\n    this.handlers = [];\n    // Element -> handler map\n    this.handlersByElement = new Map();\n\n    this._active = false;\n  }\n\n  // Returns true if there are no non-passive handlers\n  isEmpty(): boolean {\n    return !this._active;\n  }\n\n  add(\n    type: string,\n    handler: MjolnirEventHandler,\n    options?: HandlerOptions,\n    once: boolean = false,\n    passive: boolean = false\n  ) {\n    const {handlers, handlersByElement} = this;\n    const opts: Required<HandlerOptions> = {...DEFAULT_OPTIONS, ...options};\n\n    let entries = handlersByElement.get(opts.srcElement);\n    if (!entries) {\n      entries = [];\n      handlersByElement.set(opts.srcElement, entries);\n    }\n    const entry: EventHandler = {\n      type,\n      handler,\n      srcElement: opts.srcElement,\n      priority: opts.priority\n    };\n    if (once) {\n      entry.once = true;\n    }\n    if (passive) {\n      entry.passive = true;\n    }\n    handlers.push(entry);\n    this._active = this._active || !entry.passive;\n\n    // Sort handlers by descending priority\n    // Handlers with the same priority are excuted in the order of registration\n    let insertPosition = entries.length - 1;\n    while (insertPosition >= 0) {\n      if (entries[insertPosition].priority >= entry.priority) {\n        break;\n      }\n      insertPosition--;\n    }\n    entries.splice(insertPosition + 1, 0, entry);\n  }\n\n  remove(type: string, handler: MjolnirEventHandler) {\n    const {handlers, handlersByElement} = this;\n\n    for (let i = handlers.length - 1; i >= 0; i--) {\n      const entry = handlers[i];\n\n      if (entry.type === type && entry.handler === handler) {\n        handlers.splice(i, 1);\n        const entries = handlersByElement.get(entry.srcElement)!;\n        entries.splice(entries.indexOf(entry), 1);\n        if (entries.length === 0) {\n          handlersByElement.delete(entry.srcElement);\n        }\n      }\n    }\n    this._active = handlers.some((entry) => !entry.passive);\n  }\n\n  /**\n   * Handles hammerjs event\n   */\n  handleEvent = (event: MjolnirEventRaw) => {\n    if (this.isEmpty()) {\n      return;\n    }\n\n    const mjolnirEvent = this._normalizeEvent(event);\n    let target = event.srcEvent.target as HTMLElement;\n\n    while (target && target !== mjolnirEvent.rootElement) {\n      this._emit(mjolnirEvent, target);\n      if (mjolnirEvent.handled) {\n        return;\n      }\n      target = target.parentNode as HTMLElement;\n    }\n    this._emit(mjolnirEvent, 'root');\n  };\n\n  /**\n   * Invoke handlers on a particular element\n   */\n  _emit<T extends MjolnirEventRaw>(\n    event: MjolnirEventWrapper<T>,\n    srcElement: 'root' | HTMLElement\n  ) {\n    const entries = this.handlersByElement.get(srcElement);\n\n    if (entries) {\n      let immediatePropagationStopped = false;\n\n      // Prevents the current event from bubbling up\n      const stopPropagation = () => {\n        event.handled = true;\n      };\n      // Prevent any remaining listeners from being called\n      const stopImmediatePropagation = () => {\n        event.handled = true;\n        immediatePropagationStopped = true;\n      };\n      const entriesToRemove: EventHandler[] = [];\n\n      for (let i = 0; i < entries.length; i++) {\n        const {type, handler, once} = entries[i];\n        // @ts-ignore\n        handler({\n          ...event,\n          type,\n          stopPropagation,\n          stopImmediatePropagation\n        });\n        if (once) {\n          entriesToRemove.push(entries[i]);\n        }\n        if (immediatePropagationStopped) {\n          break;\n        }\n      }\n\n      for (let i = 0; i < entriesToRemove.length; i++) {\n        const {type, handler} = entriesToRemove[i];\n        this.remove(type, handler);\n      }\n    }\n  }\n\n  /**\n   * Normalizes hammerjs and custom events to have predictable fields.\n   */\n  _normalizeEvent<T extends MjolnirEventRaw>(event: T): MjolnirEventWrapper<T> {\n    const rootElement = this.eventManager.getElement();\n\n    // @ts-ignore\n    return {\n      ...event,\n      ...whichButtons(event),\n      ...getOffsetPosition(event, rootElement!),\n      preventDefault: () => {\n        event.srcEvent.preventDefault();\n      },\n      stopImmediatePropagation: null,\n      stopPropagation: null,\n      handled: false,\n      rootElement\n    };\n  }\n}\n", "// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Manager as HammerManager, Recognizer} from './hammerjs/index';\nimport type {\n  MjolnirEventRaw,\n  MjolnirEvent,\n  MjolnirEventHandler,\n  MjolnirEventHandlers\n} from './types';\n\nimport {WheelInput} from './inputs/wheel-input';\nimport {MoveInput} from './inputs/move-input';\nimport {KeyInput} from './inputs/key-input';\nimport {ContextmenuInput} from './inputs/contextmenu-input';\n\nimport {EventRegistrar, HandlerOptions} from './utils/event-registrar';\n\ntype RecognizerConstructor = {new (options: any): Recognizer};\n\ntype RecognizerTupleNormalized = {\n  recognizer: Recognizer;\n  /** Allow another gesture to be recognized simultaneously with this one.\n   * For example an interaction can trigger pinch and rotate at the same time. */\n  recognizeWith?: string[];\n  /** Another recognizer is mutually exclusive with this one.\n   * For example an interaction could be singletap or doubletap; pan-horizontal or pan-vertical; but never both. */\n  requireFailure?: string[];\n};\n\nexport type RecognizerTuple =\n  | Recognizer\n  | RecognizerConstructor\n  | RecognizerTupleNormalized\n  /** hammer.js/mjolnir.js@2 style */\n  | [\n      recognizer: RecognizerConstructor,\n      options?: any,\n      /** Allow another gesture to be recognized simultaneously with this one.\n       * For example an interaction can trigger pinch and rotate at the same time. */\n      recognizeWith?: string | string[],\n      /** Another recognizer is mutually exclusive with this one.\n       * For example an interaction could be singletap or doubletap; pan-horizontal or pan-vertical; but never both. */\n      requireFailure?: string | string[]\n    ];\n\nexport type EventManagerOptions = {\n  /** Event listeners */\n  events?: MjolnirEventHandlers;\n  /** Gesture recognizers */\n  recognizers?: RecognizerTuple[];\n  /** Touch action to set on the target element.\n   * Use 'compute' to automatically set as the least restrictive value to support the recognizers.\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action\n   * @default 'compute'\n   */\n  touchAction?: 'none' | 'compute' | 'manipulation' | 'pan-x' | 'pan-y' | 'pan-x pan-y';\n  /** Tab index of the target element */\n  tabIndex?: number;\n  /**\n   * Optional CSS properties to be applied to the target element.\n   */\n  cssProps?: Partial<CSSStyleDeclaration>;\n};\n\nfunction normalizeRecognizer(item: RecognizerTuple): RecognizerTupleNormalized {\n  if ('recognizer' in item) {\n    return item;\n  }\n  let recognizer: Recognizer;\n  const itemArray = Array.isArray(item) ? [...item] : [item];\n  if (typeof itemArray[0] === 'function') {\n    // Backward compatibility: v2 / hammerjs style\n    const RecognizerType = itemArray.shift();\n    const options = itemArray.shift() || {};\n    recognizer = new RecognizerType(options);\n  } else {\n    recognizer = itemArray.shift();\n  }\n  return {\n    recognizer,\n    recognizeWith: typeof itemArray[0] === 'string' ? [itemArray[0]] : itemArray[0],\n    requireFailure: typeof itemArray[1] === 'string' ? [itemArray[1]] : itemArray[1]\n  };\n}\n\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport class EventManager {\n  private element: HTMLElement | null;\n  private manager: HammerManager;\n  private options: Required<EventManagerOptions>;\n  private events: Map<string, EventRegistrar>;\n\n  // Custom handlers\n  private wheelInput: WheelInput;\n  private moveInput: MoveInput;\n  private contextmenuInput: ContextmenuInput;\n  private keyInput: KeyInput;\n\n  constructor(element: HTMLElement | null = null, options: EventManagerOptions = {}) {\n    this.options = {\n      recognizers: [],\n      events: {},\n      touchAction: 'compute',\n      tabIndex: 0,\n      cssProps: {},\n      ...options\n    };\n    this.events = new Map();\n    this.element = element;\n\n    if (!element) return;\n\n    this.manager = new HammerManager(element, this.options);\n    for (const item of this.options.recognizers) {\n      const {recognizer, recognizeWith, requireFailure} = normalizeRecognizer(item);\n      this.manager.add(recognizer);\n      if (recognizeWith) {\n        recognizer.recognizeWith(recognizeWith);\n      }\n      if (requireFailure) {\n        recognizer.requireFailure(requireFailure);\n      }\n    }\n\n    this.manager.on('hammer.input', this._onBasicInput);\n\n    // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    });\n\n    // Register all passed events.\n    this.on(this.options.events);\n  }\n\n  getElement(): HTMLElement | null {\n    return this.element;\n  }\n\n  // Tear down internal event management implementations.\n  destroy(): void {\n    // manager etc. cannot exist if there is no element\n    if (!this.element) return;\n\n    this.wheelInput.destroy();\n    this.moveInput.destroy();\n    this.keyInput.destroy();\n    this.contextmenuInput.destroy();\n    this.manager.destroy();\n  }\n\n  /** Register multiple event handlers */\n  on(events: MjolnirEventHandlers, opts?: HandlerOptions): void;\n  on<EventT extends MjolnirEvent>(\n    event: EventT['type'],\n    handler: (ev: EventT) => void,\n    opts?: HandlerOptions\n  ): void;\n\n  /** Register an event handler function to be called on `event` */\n  on(event: any, handler: any, opts?: any) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n\n  /** Register an event handler function to be called on `event`, then remove it */\n  once(events: MjolnirEventHandlers, opts?: HandlerOptions): void;\n  once<EventT extends MjolnirEvent>(\n    event: EventT['type'],\n    handler: (ev: EventT) => void,\n    opts?: HandlerOptions\n  ): void;\n\n  once(event: any, handler: any, opts?: any) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n\n  /** Register an event handler function to be called on `event`\n   * This handler does not ask the event to be recognized at all times.\n   * Instead, it only \"intercepts\" the event if some other handler is getting it.\n   */\n  watch(events: MjolnirEventHandlers, opts?: HandlerOptions): void;\n  watch<EventT extends MjolnirEvent>(\n    event: EventT['type'],\n    handler: (ev: EventT) => void,\n    opts?: HandlerOptions\n  ): void;\n\n  watch(event: any, handler: any, opts?: any) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n\n  /**\n   * Deregister a previously-registered event handler.\n   */\n  off(events: MjolnirEventHandlers): void;\n  off<EventT extends MjolnirEvent>(event: EventT['type'], handler: (ev: EventT) => void): void;\n\n  off(event: any, handler?: any) {\n    this._removeEventHandler(event, handler);\n  }\n\n  /*\n   * Enable/disable recognizer for the given event\n   */\n  private _toggleRecognizer(name: string, enabled: boolean): void {\n    const {manager} = this;\n    if (!manager) {\n      return;\n    }\n    const recognizer = manager.get(name);\n    if (recognizer) {\n      recognizer.set({enable: enabled});\n      manager.touchAction.update();\n    }\n    this.wheelInput?.enableEventType(name, enabled);\n    this.moveInput?.enableEventType(name, enabled);\n    this.keyInput?.enableEventType(name, enabled);\n    this.contextmenuInput?.enableEventType(name, enabled);\n  }\n\n  /**\n   * Process the event registration for a single event + handler.\n   */\n  private _addEventHandler(\n    event: string | MjolnirEventHandlers,\n    handler: MjolnirEventHandler,\n    opts?: HandlerOptions,\n    once?: boolean,\n    passive?: boolean\n  ) {\n    if (typeof event !== 'string') {\n      // @ts-ignore\n      opts = handler;\n      // If `event` is a map, call `on()` for each entry.\n      for (const [eventName, eventHandler] of Object.entries(event)) {\n        this._addEventHandler(eventName, eventHandler, opts, once, passive);\n      }\n      return;\n    }\n\n    const {manager, events} = this;\n    if (!manager) return;\n\n    let eventRegistrar = events.get(event);\n    if (!eventRegistrar) {\n      // Enable recognizer for this event.\n      const recognizerName = this._getRecognizerName(event) || event;\n\n      eventRegistrar = new EventRegistrar(this, recognizerName);\n      events.set(event, eventRegistrar);\n      // Listen to the event\n      if (manager) {\n        manager.on(event, eventRegistrar.handleEvent);\n      }\n    }\n    eventRegistrar.add(event, handler, opts, once, passive);\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n  private _removeEventHandler(event: string | MjolnirEventHandlers, handler?: MjolnirEventHandler) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const [eventName, eventHandler] of Object.entries(event)) {\n        this._removeEventHandler(eventName, eventHandler);\n      }\n      return;\n    }\n\n    const {events} = this;\n\n    const eventRegistrar = events.get(event);\n\n    if (!eventRegistrar) {\n      return;\n    }\n\n    eventRegistrar.remove(event, handler!);\n\n    if (eventRegistrar.isEmpty()) {\n      const {recognizerName} = eventRegistrar;\n      // Disable recognizer if no more handlers are attached to its events\n      let isRecognizerUsed = false;\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n\n  private _getRecognizerName(event: string): string | undefined {\n    return this.manager.recognizers.find((recognizer) => {\n      return recognizer.getEventNames().includes(event);\n    })?.options.event;\n  }\n\n  /**\n   * Handle basic events using the 'hammer.input' Hammer.js API:\n   * Before running Recognizers, Hammer emits a 'hammer.input' event\n   * with the basic event info. This function emits all basic events\n   * aliased to the \"class\" of event received.\n   * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n   */\n  private _onBasicInput = (event: MjolnirEventRaw) => {\n    this.manager.emit(event.srcEvent.type, event as any);\n  };\n\n  /**\n   * Handle events not supported by Hammer.js,\n   * and pipe back out through same (Hammer) channel used by other events.\n   */\n  private _onOtherEvent = (event: MjolnirEventRaw) => {\n    // console.log('onotherevent', event.type, event)\n    this.manager.emit(event.type, event as any);\n  };\n}\n"],
  "mappings": "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",
  "names": ["InputEvent", "InputDirection", "RecognizerState", "EVENT_NAMES", "EVENT_NAMES", "EVENT_NAMES", "EVENT_NAMES", "Input", "Input", "Input", "Input", "Input", "MOUSE_EVENTS"]
}
