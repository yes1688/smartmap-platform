(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod2, secondTarget) => (__copyProps(target, mod2, "default"), secondTarget && __copyProps(secondTarget, mod2, "default"));
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

  // external-global-plugin:@deck.gl/core
  var require_core = __commonJS({
    "external-global-plugin:@deck.gl/core"(exports, module) {
      module.exports = globalThis.deck;
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    MapboxOverlay: () => MapboxOverlay
  });

  // ../core/bundle/peer-dependency.ts
  var peer_dependency_exports = {};
  var import_core = __toESM(require_core(), 1);
  __reExport(peer_dependency_exports, __toESM(require_core(), 1));
  if (!import_core.Layer) {
    throw new Error("@deck.gl/core is not found");
  }

  // bundle.ts
  __reExport(bundle_exports, peer_dependency_exports);

  // src/mapbox-overlay.ts
  var import_core4 = __toESM(require_core(), 1);

  // src/deck-utils.ts
  var import_core2 = __toESM(require_core(), 1);

  // ../../node_modules/@math.gl/web-mercator/dist/assert.js
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || "@math.gl/web-mercator: assertion failed.");
    }
  }

  // ../../node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js
  var PI = Math.PI;
  var PI_4 = PI / 4;
  var DEGREES_TO_RADIANS = PI / 180;
  var RADIANS_TO_DEGREES = 180 / PI;
  var TILE_SIZE = 512;
  var EARTH_CIRCUMFERENCE = 4003e4;
  function lngLatToWorld(lngLat) {
    const [lng, lat] = lngLat;
    assert(Number.isFinite(lng));
    assert(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
    const lambda2 = lng * DEGREES_TO_RADIANS;
    const phi2 = lat * DEGREES_TO_RADIANS;
    const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);
    const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
    return [x, y];
  }
  function unitsPerMeter(latitude) {
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
    return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
  }

  // ../../node_modules/@math.gl/web-mercator/dist/get-bounds.js
  var DEGREES_TO_RADIANS2 = Math.PI / 180;

  // src/deck-utils.ts
  var TILE_SIZE2 = 512;
  var DEGREES_TO_RADIANS3 = Math.PI / 180;
  function getDeckInstance({
    map,
    gl,
    deck
  }) {
    if (map.__deck) {
      return map.__deck;
    }
    const customRender = deck?.props._customRender;
    const onLoad = deck?.props.onLoad;
    const deckProps = {
      ...deck?.props,
      _customRender: () => {
        map.triggerRepaint();
        customRender?.("");
      }
    };
    deckProps.parameters = { ...getDefaultParameters(map, true), ...deckProps.parameters };
    deckProps.views ||= getDefaultView(map);
    let deckInstance;
    if (!deck || deck.props.gl === gl) {
      Object.assign(deckProps, {
        gl,
        width: null,
        height: null,
        touchAction: "unset",
        viewState: getViewState(map)
      });
      if (deck?.isInitialized) {
        watchMapMove(deck, map);
      } else {
        deckProps.onLoad = () => {
          onLoad?.();
          watchMapMove(deckInstance, map);
        };
      }
    }
    if (deck) {
      deckInstance = deck;
      deck.setProps(deckProps);
      deck.userData.isExternal = true;
    } else {
      deckInstance = new import_core2.Deck(deckProps);
      map.on("remove", () => {
        removeDeckInstance(map);
      });
    }
    deckInstance.userData.mapboxLayers = /* @__PURE__ */ new Set();
    map.__deck = deckInstance;
    map.on("render", () => {
      if (deckInstance.isInitialized)
        afterRender(deckInstance, map);
    });
    return deckInstance;
  }
  function watchMapMove(deck, map) {
    const _handleMapMove = () => {
      if (deck.isInitialized) {
        onMapMove(deck, map);
      } else {
        map.off("move", _handleMapMove);
      }
    };
    map.on("move", _handleMapMove);
  }
  function removeDeckInstance(map) {
    map.__deck?.finalize();
    map.__deck = null;
  }
  function getDefaultParameters(map, interleaved) {
    const result = interleaved ? {
      depthWriteEnabled: true,
      depthCompare: "less-equal",
      depthBias: 0,
      blend: true,
      blendColorSrcFactor: "src-alpha",
      blendColorDstFactor: "one-minus-src-alpha",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one-minus-src-alpha",
      blendColorOperation: "add",
      blendAlphaOperation: "add"
    } : {};
    if (getProjection(map) === "globe") {
      result.cullMode = "back";
    }
    return result;
  }
  function addLayer(deck, layer) {
    deck.userData.mapboxLayers.add(layer);
    updateLayers(deck);
  }
  function removeLayer(deck, layer) {
    deck.userData.mapboxLayers.delete(layer);
    updateLayers(deck);
  }
  function updateLayer(deck, layer) {
    updateLayers(deck);
  }
  function drawLayer(deck, map, layer, renderParameters) {
    let { currentViewport } = deck.userData;
    let clearStack = false;
    if (!currentViewport) {
      currentViewport = getViewport(deck, map, renderParameters);
      deck.userData.currentViewport = currentViewport;
      clearStack = true;
    }
    if (!deck.isInitialized) {
      return;
    }
    deck._drawLayers("mapbox-repaint", {
      viewports: [currentViewport],
      layerFilter: (params) => (!deck.props.layerFilter || deck.props.layerFilter(params)) && (layer.id === params.layer.id || params.layer.props.operation.includes("terrain")),
      clearStack,
      clearCanvas: false
    });
  }
  function getProjection(map) {
    const projection = map.getProjection?.();
    const type = (
      // maplibre projection spec
      projection?.type || // mapbox projection spec
      projection?.name
    );
    if (type === "globe") {
      return "globe";
    }
    if (type && type !== "mercator") {
      throw new Error("Unsupported projection");
    }
    return "mercator";
  }
  function getDefaultView(map) {
    if (getProjection(map) === "globe") {
      return new import_core2._GlobeView({ id: "mapbox" });
    }
    return new import_core2.MapView({ id: "mapbox" });
  }
  function getViewState(map) {
    const { lng, lat } = map.getCenter();
    const viewState = {
      // Longitude returned by getCenter can be outside of [-180, 180] when zooming near the anti meridian
      // https://github.com/visgl/deck.gl/issues/6894
      longitude: (lng + 540) % 360 - 180,
      latitude: lat,
      zoom: map.getZoom(),
      bearing: map.getBearing(),
      pitch: map.getPitch(),
      padding: map.getPadding(),
      repeat: map.getRenderWorldCopies()
    };
    if (map.getTerrain?.()) {
      centerCameraOnTerrain(map, viewState);
    }
    return viewState;
  }
  function centerCameraOnTerrain(map, viewState) {
    if (map.getFreeCameraOptions) {
      const { position } = map.getFreeCameraOptions();
      if (!position || position.z === void 0) {
        return;
      }
      const height = map.transform.height;
      const { longitude, latitude, pitch } = viewState;
      const cameraX = position.x * TILE_SIZE2;
      const cameraY = (1 - position.y) * TILE_SIZE2;
      const cameraZ = position.z * TILE_SIZE2;
      const center = lngLatToWorld([longitude, latitude]);
      const dx = cameraX - center[0];
      const dy = cameraY - center[1];
      const cameraToCenterDistanceGround = Math.sqrt(dx * dx + dy * dy);
      const pitchRadians = pitch * DEGREES_TO_RADIANS3;
      const altitudePixels = 1.5 * height;
      const scale = pitchRadians < 1e-3 ? (
        // Pitch angle too small to deduce the look at point, assume elevation is 0
        altitudePixels * Math.cos(pitchRadians) / cameraZ
      ) : altitudePixels * Math.sin(pitchRadians) / cameraToCenterDistanceGround;
      viewState.zoom = Math.log2(scale);
      const cameraZFromSurface = altitudePixels * Math.cos(pitchRadians) / scale;
      const surfaceElevation = cameraZ - cameraZFromSurface;
      viewState.position = [0, 0, surfaceElevation / unitsPerMeter(latitude)];
    } else if (typeof map.transform.elevation === "number") {
      viewState.position = [0, 0, map.transform.elevation];
    }
  }
  function getViewport(deck, map, renderParameters) {
    const viewState = getViewState(map);
    const view = getDefaultView(map);
    if (renderParameters) {
      view.props.nearZMultiplier = 0.2;
    }
    const nearZ = renderParameters?.nearZ ?? map.transform._nearZ;
    const farZ = renderParameters?.farZ ?? map.transform._farZ;
    if (Number.isFinite(nearZ)) {
      viewState.nearZ = nearZ / map.transform.height;
      viewState.farZ = farZ / map.transform.height;
    }
    return view.makeViewport({
      width: deck.width,
      height: deck.height,
      viewState
    });
  }
  function afterRender(deck, map) {
    const { mapboxLayers, isExternal } = deck.userData;
    if (isExternal) {
      const mapboxLayerIds = Array.from(mapboxLayers, (layer) => layer.id);
      const deckLayers = (0, import_core2._flatten)(deck.props.layers, Boolean);
      const hasNonMapboxLayers = deckLayers.some(
        (layer) => layer && !mapboxLayerIds.includes(layer.id)
      );
      let viewports = deck.getViewports();
      const mapboxViewportIdx = viewports.findIndex((vp) => vp.id === "mapbox");
      const hasNonMapboxViews = viewports.length > 1 || mapboxViewportIdx < 0;
      if (hasNonMapboxLayers || hasNonMapboxViews) {
        if (mapboxViewportIdx >= 0) {
          viewports = viewports.slice();
          viewports[mapboxViewportIdx] = getViewport(deck, map);
        }
        deck._drawLayers("mapbox-repaint", {
          viewports,
          layerFilter: (params) => (!deck.props.layerFilter || deck.props.layerFilter(params)) && (params.viewport.id !== "mapbox" || !mapboxLayerIds.includes(params.layer.id)),
          clearCanvas: false
        });
      }
    }
    deck.userData.currentViewport = null;
  }
  function onMapMove(deck, map) {
    deck.setProps({
      viewState: getViewState(map)
    });
    deck.needsRedraw({ clearRedrawFlags: true });
  }
  function updateLayers(deck) {
    if (deck.userData.isExternal) {
      return;
    }
    const layers = [];
    deck.userData.mapboxLayers.forEach((deckLayer) => {
      const LayerType = deckLayer.props.type;
      const layer = new LayerType(deckLayer.props);
      layers.push(layer);
    });
    deck.setProps({ layers });
  }

  // src/mapbox-overlay.ts
  var import_core5 = __toESM(require_core(), 1);

  // src/resolve-layers.ts
  var import_core3 = __toESM(require_core(), 1);

  // src/mapbox-layer.ts
  var MapboxLayer = class {
    /* eslint-disable no-this-before-super */
    constructor(props) {
      if (!props.id) {
        throw new Error("Layer must have an unique id");
      }
      this.id = props.id;
      this.type = "custom";
      this.renderingMode = props.renderingMode || "3d";
      this.slot = props.slot;
      this.map = null;
      this.deck = null;
      this.props = props;
    }
    /* Mapbox custom layer methods */
    onAdd(map, gl) {
      this.map = map;
      this.deck = getDeckInstance({ map, gl, deck: this.props.deck });
      addLayer(this.deck, this);
    }
    onRemove() {
      if (this.deck) {
        removeLayer(this.deck, this);
      }
    }
    setProps(props) {
      Object.assign(this.props, props, { id: this.id });
      if (this.deck) {
        updateLayer(this.deck, this);
      }
    }
    render(gl, renderParameters) {
      drawLayer(this.deck, this.map, this, renderParameters);
    }
  };

  // src/resolve-layers.ts
  var UNDEFINED_BEFORE_ID = "__UNDEFINED__";
  function resolveLayers(map, deck, oldLayers, newLayers) {
    if (!map || !deck || !map.style || !map.style._loaded) {
      return;
    }
    const layers = (0, import_core3._flatten)(newLayers, Boolean);
    if (oldLayers !== newLayers) {
      const prevLayers = (0, import_core3._flatten)(oldLayers, Boolean);
      const prevLayerIds = new Set(prevLayers.map((l) => l.id));
      for (const layer of layers) {
        prevLayerIds.delete(layer.id);
      }
      for (const id of prevLayerIds) {
        if (map.getLayer(id)) {
          map.removeLayer(id);
        }
      }
    }
    for (const layer of layers) {
      const mapboxLayer = map.getLayer(layer.id);
      if (mapboxLayer) {
        const layerInstance = mapboxLayer.implementation || mapboxLayer;
        layerInstance.setProps(layer.props);
      } else {
        map.addLayer(
          new MapboxLayer({
            id: layer.id,
            deck,
            // @ts-expect-error slot is not defined in LayerProps
            slot: layer.props.slot
          }),
          // @ts-expect-error beforeId is not defined in LayerProps
          layer.props.beforeId
        );
      }
    }
    const mapLayers = map.style._order;
    const layerGroups = {};
    for (const layer of layers) {
      let { beforeId } = layer.props;
      if (!beforeId || !mapLayers.includes(beforeId)) {
        beforeId = UNDEFINED_BEFORE_ID;
      }
      layerGroups[beforeId] = layerGroups[beforeId] || [];
      layerGroups[beforeId].push(layer.id);
    }
    for (const beforeId in layerGroups) {
      const layerGroup = layerGroups[beforeId];
      let lastLayerIndex = beforeId === UNDEFINED_BEFORE_ID ? mapLayers.length : mapLayers.indexOf(beforeId);
      let lastLayerId = beforeId === UNDEFINED_BEFORE_ID ? void 0 : beforeId;
      for (let i = layerGroup.length - 1; i >= 0; i--) {
        const layerId = layerGroup[i];
        const layerIndex = mapLayers.indexOf(layerId);
        if (layerIndex !== lastLayerIndex - 1) {
          map.moveLayer(layerId, lastLayerId);
          if (layerIndex > lastLayerIndex) {
            lastLayerIndex++;
          }
        }
        lastLayerIndex--;
        lastLayerId = layerId;
      }
    }
  }

  // src/mapbox-overlay.ts
  var MapboxOverlay = class {
    constructor(props) {
      this._handleStyleChange = () => {
        resolveLayers(this._map, this._deck, this._props.layers, this._props.layers);
      };
      this._updateContainerSize = () => {
        if (this._map && this._container) {
          const { clientWidth, clientHeight } = this._map.getContainer();
          Object.assign(this._container.style, {
            width: `${clientWidth}px`,
            height: `${clientHeight}px`
          });
        }
      };
      this._updateViewState = () => {
        const deck = this._deck;
        const map = this._map;
        if (deck && map) {
          deck.setProps({
            views: this._props.views || getDefaultView(map),
            viewState: getViewState(map)
          });
          if (deck.isInitialized) {
            deck.redraw();
          }
        }
      };
      // eslint-disable-next-line complexity
      this._handleMouseEvent = (event) => {
        const deck = this._deck;
        if (!deck || !deck.isInitialized) {
          return;
        }
        const mockEvent = {
          type: event.type,
          offsetCenter: event.point,
          srcEvent: event
        };
        const lastDown = this._lastMouseDownPoint;
        if (!event.point && lastDown) {
          mockEvent.deltaX = event.originalEvent.clientX - lastDown.clientX;
          mockEvent.deltaY = event.originalEvent.clientY - lastDown.clientY;
          mockEvent.offsetCenter = {
            x: lastDown.x + mockEvent.deltaX,
            y: lastDown.y + mockEvent.deltaY
          };
        }
        switch (mockEvent.type) {
          case "mousedown":
            deck._onPointerDown(mockEvent);
            this._lastMouseDownPoint = {
              ...event.point,
              clientX: event.originalEvent.clientX,
              clientY: event.originalEvent.clientY
            };
            break;
          case "dragstart":
            mockEvent.type = "panstart";
            deck._onEvent(mockEvent);
            break;
          case "drag":
            mockEvent.type = "panmove";
            deck._onEvent(mockEvent);
            break;
          case "dragend":
            mockEvent.type = "panend";
            deck._onEvent(mockEvent);
            break;
          case "click":
            mockEvent.tapCount = 1;
            deck._onEvent(mockEvent);
            break;
          case "dblclick":
            mockEvent.type = "click";
            mockEvent.tapCount = 2;
            deck._onEvent(mockEvent);
            break;
          case "mousemove":
            mockEvent.type = "pointermove";
            deck._onPointerMove(mockEvent);
            break;
          case "mouseout":
            mockEvent.type = "pointerleave";
            deck._onPointerMove(mockEvent);
            break;
          default:
            return;
        }
      };
      const { interleaved = false, ...otherProps } = props;
      this._interleaved = interleaved;
      this._props = otherProps;
    }
    /** Update (partial) props of the underlying Deck instance. */
    setProps(props) {
      if (this._interleaved && props.layers) {
        resolveLayers(this._map, this._deck, this._props.layers, props.layers);
      }
      Object.assign(this._props, props);
      if (this._deck && this._map) {
        this._deck.setProps({
          ...this._props,
          parameters: {
            ...getDefaultParameters(this._map, this._interleaved),
            ...this._props.parameters
          }
        });
      }
    }
    // The local Map type is for internal typecheck only. It does not necesarily satisefy mapbox/maplibre types at runtime.
    // Do not restrict the argument type here to avoid type conflict.
    /** Called when the control is added to a map */
    onAdd(map) {
      this._map = map;
      return this._interleaved ? this._onAddInterleaved(map) : this._onAddOverlaid(map);
    }
    _onAddOverlaid(map) {
      const container = document.createElement("div");
      Object.assign(container.style, {
        position: "absolute",
        left: 0,
        top: 0,
        textAlign: "initial",
        pointerEvents: "none"
      });
      this._container = container;
      this._deck = new import_core4.Deck({
        ...this._props,
        parent: container,
        parameters: { ...getDefaultParameters(map, false), ...this._props.parameters },
        views: this._props.views || getDefaultView(map),
        viewState: getViewState(map)
      });
      map.on("resize", this._updateContainerSize);
      map.on("render", this._updateViewState);
      map.on("mousedown", this._handleMouseEvent);
      map.on("dragstart", this._handleMouseEvent);
      map.on("drag", this._handleMouseEvent);
      map.on("dragend", this._handleMouseEvent);
      map.on("mousemove", this._handleMouseEvent);
      map.on("mouseout", this._handleMouseEvent);
      map.on("click", this._handleMouseEvent);
      map.on("dblclick", this._handleMouseEvent);
      this._updateContainerSize();
      return container;
    }
    _onAddInterleaved(map) {
      const gl = map.painter.context.gl;
      if (gl instanceof WebGLRenderingContext) {
        import_core5.log.warn(
          "Incompatible basemap library. See: https://deck.gl/docs/api-reference/mapbox/overview#compatibility"
        )();
      }
      this._deck = getDeckInstance({
        map,
        gl,
        deck: new import_core4.Deck({
          ...this._props,
          gl
        })
      });
      map.on("styledata", this._handleStyleChange);
      resolveLayers(map, this._deck, [], this._props.layers);
      return document.createElement("div");
    }
    /** Called when the control is removed from a map */
    onRemove() {
      const map = this._map;
      if (map) {
        if (this._interleaved) {
          this._onRemoveInterleaved(map);
        } else {
          this._onRemoveOverlaid(map);
        }
      }
      this._deck = void 0;
      this._map = void 0;
      this._container = void 0;
    }
    _onRemoveOverlaid(map) {
      map.off("resize", this._updateContainerSize);
      map.off("render", this._updateViewState);
      map.off("mousedown", this._handleMouseEvent);
      map.off("dragstart", this._handleMouseEvent);
      map.off("drag", this._handleMouseEvent);
      map.off("dragend", this._handleMouseEvent);
      map.off("mousemove", this._handleMouseEvent);
      map.off("mouseout", this._handleMouseEvent);
      map.off("click", this._handleMouseEvent);
      map.off("dblclick", this._handleMouseEvent);
      this._deck?.finalize();
    }
    _onRemoveInterleaved(map) {
      map.off("styledata", this._handleStyleChange);
      resolveLayers(map, this._deck, this._props.layers, []);
      removeDeckInstance(map);
    }
    getDefaultPosition() {
      return "top-left";
    }
    /** Forwards the Deck.pickObject method */
    pickObject(params) {
      (0, import_core4.assert)(this._deck);
      return this._deck.pickObject(params);
    }
    /** Forwards the Deck.pickMultipleObjects method */
    pickMultipleObjects(params) {
      (0, import_core4.assert)(this._deck);
      return this._deck.pickMultipleObjects(params);
    }
    /** Forwards the Deck.pickObjects method */
    pickObjects(params) {
      (0, import_core4.assert)(this._deck);
      return this._deck.pickObjects(params);
    }
    /** Remove from map and releases all resources */
    finalize() {
      if (this._map) {
        this._map.removeControl(this);
      }
    }
    /** If interleaved: true, returns base map's canvas, otherwise forwards the Deck.getCanvas method. */
    getCanvas() {
      if (!this._map) {
        return null;
      }
      return this._interleaved ? this._map.getCanvas() : this._deck.getCanvas();
    }
  };
  return __toCommonJS(bundle_exports);
})();
      return __exports__;
      });
