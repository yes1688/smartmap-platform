declare const _default: "\nin vec4 fillColors;\nin vec4 lineColors;\nin vec3 pickingColors;\n\nout vec4 vColor;\n\nstruct PolygonProps {\n  vec3 positions;\n  vec3 positions64Low;\n  vec3 normal;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\n    return normalize(vector * project.commonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n  vec3 pos = props.positions;\n  vec3 pos64Low = props.positions64Low;\n  vec3 normal = props.normal;\n  vec4 colors = solidPolygon.isWireframe ? lineColors : fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.pickingColor = pickingColors;\n\n  if (solidPolygon.extruded) {\n    pos.z += props.elevations * solidPolygon.elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (solidPolygon.extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(normal);\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n    vColor = vec4(lightColor, colors.a * layer.opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * layer.opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
export default _default;
//# sourceMappingURL=solid-polygon-layer-vertex-main.glsl.d.ts.map